[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/combined/index.js",
    "content": "import GuiRender from \"../gui/index\";\r\nimport ModelRender from \"../model/index\";\r\nimport SkinRender from \"../skin/index\";\r\nimport Render from \"../renderBase\";\r\nimport EntityRender from \"../entity\";\r\n\r\n/**\r\n * A renderer-wrapper to combine the individual aspects of renderers into a single scene, e.g. render a player and a block at once\r\n */\r\nclass CombinedRender extends Render {\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     */\r\n    constructor(options, element) {\r\n        super(options, {}, element);\r\n\r\n        this.renderType = \"CombinedRender\";\r\n    }\r\n\r\n    /**\r\n     * Initializes the renderer - This has to be called before {@link render}\r\n     * @param {Render[]} renders Array of render objects\r\n     */\r\n    init(renders) {\r\n        let combinedRender = this;\r\n\r\n        super.initScene(function () {\r\n            combinedRender.element.dispatchEvent(new CustomEvent(\"combinedRender\", {detail: {renders: renders}}));\r\n        }, true);\r\n\r\n\r\n        for (let i = 0; i < renders.length; i++) {\r\n            attachTo(renders[i], combinedRender);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Starts rendering - This has to be called after {@link init}\r\n     */\r\n    render() {\r\n        this._animate();\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nfunction attachTo(self, target) {\r\n    console.log(\"Attaching \" + self.constructor.name + \" to \" + target.constructor.name);\r\n\r\n    self._scene = target._scene;\r\n    self._camera = target._camera;\r\n    // self._renderer = target._renderer;\r\n    // self._composer = target._composer;\r\n    // self._canvas = target._canvas;\r\n    self.attached = true;\r\n}\r\n\r\nCombinedRender.prototype.constructor = CombinedRender;\r\n\r\nCombinedRender.GuiRender = GuiRender;\r\nCombinedRender.ModelRender = ModelRender;\r\nCombinedRender.SkinRender = SkinRender;\r\n\r\nif(typeof window !== \"undefined\") {\r\n    window.CombinedRender = CombinedRender;\r\n\r\n// Add the other render classes here, because adding them as separate scripts bugs out THREE.js\r\n    window.GuiRender = GuiRender;\r\n    window.ModelRender = ModelRender;\r\n    window.SkinRender = SkinRender;\r\n}\r\nif (typeof global !== \"undefined\") {\r\n    global.CombinedRender = CombinedRender;\r\n\r\n    global.GuiRender = GuiRender;\r\n    global.ModelRender = ModelRender;\r\n    global.SkinRender = SkinRender;\r\n}\r\n\r\nexport default CombinedRender;\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/combined/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "function",
    "name": "attachTo",
    "memberof": "src/combined/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/combined/index.js~attachTo",
    "access": "public",
    "export": false,
    "importPath": "minerender",
    "importStyle": null,
    "description": "",
    "lineNumber": 50,
    "ignore": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      },
      {
        "name": "target",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 50,
    "kind": "class",
    "name": "CombinedRender",
    "memberof": "src/combined/index.js",
    "static": true,
    "longname": "src/combined/index.js~CombinedRender",
    "access": "public",
    "export": true,
    "importPath": "minerender",
    "importStyle": "CombinedRender",
    "description": "A renderer-wrapper to combine the individual aspects of renderers into a single scene, e.g. render a player and a block at once",
    "lineNumber": 10,
    "interface": false,
    "extends": [
      "src/renderBase.js~Render"
    ]
  },
  {
    "__docId__": 51,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/combined/index.js~CombinedRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/combined/index.js~CombinedRender#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 16,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options for this renderer, see {@link defaultOptions}"
      },
      {
        "nullable": null,
        "types": [
          "HTMLElement"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "document.body",
        "defaultRaw": "document.body",
        "name": "element",
        "description": "DOM Element to attach the renderer to - defaults to document.body"
      }
    ]
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "renderType",
    "memberof": "src/combined/index.js~CombinedRender",
    "static": false,
    "longname": "src/combined/index.js~CombinedRender#renderType",
    "access": "public",
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "method",
    "name": "init",
    "memberof": "src/combined/index.js~CombinedRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/combined/index.js~CombinedRender#init",
    "access": "public",
    "description": "Initializes the renderer - This has to be called before {@link render}",
    "lineNumber": 26,
    "params": [
      {
        "nullable": null,
        "types": [
          "Render[]"
        ],
        "spread": false,
        "optional": false,
        "name": "renders",
        "description": "Array of render objects"
      }
    ],
    "return": null
  },
  {
    "__docId__": 54,
    "kind": "method",
    "name": "render",
    "memberof": "src/combined/index.js~CombinedRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/combined/index.js~CombinedRender#render",
    "access": "public",
    "description": "Starts rendering - This has to be called after {@link init}",
    "lineNumber": 42,
    "params": [],
    "return": null
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/entity/index.js",
    "content": "import * as THREE from \"three\";\r\nimport * as $ from 'jquery';\r\nimport merge from 'deepmerge'\r\nimport Render, { defaultOptions } from \"../renderBase\";\r\nimport { loadTextureAsBase64, scaleUv, DEFAULT_ROOT, loadJsonFromPath, loadBlockState, loadTextureMeta } from \"../functions\";\r\nimport GuiRender from \"../gui\";\r\n\r\n\r\nconst FACE_ORDER = [\"left\", \"right\", \"top\", \"bottom\", \"front\", \"back\"];\r\n\r\n\r\n/**\r\n * @see defaultOptions\r\n * @property {string} [assetRoot=DEFAULT_ROOT] root to get asset files from\r\n */\r\nlet defOptions = {\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 35,\r\n        y: 25,\r\n        z: 20,\r\n        target: [0, 16, 0]\r\n    },\r\n    assetRoot: DEFAULT_ROOT\r\n};\r\n\r\n/**\r\n * A renderer for Minecraft entities\r\n */\r\nclass EntityRender extends Render {\r\n\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {string} [options.assetRoot=DEFAULT_ROOT] root to get asset files from\r\n     *\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, element) {\r\n        super(options, defOptions, element);\r\n\r\n        this.renderType = \"EntityRender\";\r\n\r\n        this.entities = [];\r\n        this.attached = false;\r\n    }\r\n\r\n\r\n    render(entities, cb) {\r\n        let entityRender = this;\r\n\r\n        if (!entityRender.attached && !entityRender._scene) {// Don't init scene if attached, since we already have an available scene\r\n            super.initScene(function () {\r\n                entityRender.element.dispatchEvent(new CustomEvent(\"entityRender\", {detail: {entities: entityRender.entities}}));\r\n            });\r\n        } else {\r\n            console.log(\"[EntityRender] is attached - skipping scene init\");\r\n        }\r\n\r\n        let promises = [];\r\n        for (let i = 0; i < entities.length; i++) {\r\n            promises.push(new Promise((resolve) => {\r\n                let entity = entities[i];\r\n                console.log(entity)\r\n\r\n                if (typeof entity !== \"object\") {\r\n                    entity = {\r\n                        model: entity,\r\n                        texture: entity,\r\n                        textureScale: 1\r\n                    }\r\n                }\r\n\r\n                if (!entity.textureScale) entity.textureScale = 1;\r\n\r\n                getEntityModel(entity.model)\r\n                    .then(modelData => mergeParents(modelData))\r\n                    .then((mergedModel) => {\r\n                        console.log(\"Merged:\")\r\n                        console.log(mergedModel)\r\n                        loadTextureAsBase64(entityRender.options.assetRoot, \"minecraft\", \"/entity/\", entity.texture).then((texture) => {\r\n                            new THREE.TextureLoader().load(texture, function (textureData) {\r\n                                textureData.magFilter = THREE.NearestFilter;\r\n                                textureData.minFilter = THREE.NearestFilter;\r\n                                textureData.anisotropy = 0;\r\n                                textureData.needsUpdate = true;\r\n\r\n                                renderEntity(entityRender, mergedModel, textureData, entity.textureScale).then((renderedEntity) => {\r\n                                    entityRender.addToScene(renderedEntity);\r\n                                    entityRender.entities.push(renderedEntity);\r\n                                    resolve();\r\n                                })\r\n                            });\r\n                        }).catch(() => {\r\n                            console.warn(\"Missing texture for entity \" + entity.texture);\r\n                        })\r\n                    }).catch(() => {\r\n                    console.warn(\"No model file found for entity \" + entity.model);\r\n                })\r\n            }))\r\n        }\r\n\r\n        Promise.all(promises).then(() => {\r\n            if (typeof cb === \"function\") cb();\r\n        })\r\n    }\r\n\r\n\r\n}\r\n\r\nfunction renderEntity(entityRender, modelData, texture, textureScale) {\r\n    console.log(modelData)\r\n    return new Promise((resolve) => {\r\n        let entityGroup = new THREE.Object3D();\r\n        for (let g in modelData.groups) {\r\n            if (modelData.groups.hasOwnProperty(g)) {\r\n                let group = modelData.groups[g];\r\n\r\n                let cubeGroup = new THREE.Object3D();\r\n                cubeGroup.name = group.name;\r\n\r\n                if (group.pivot) {\r\n                    cubeGroup.applyMatrix(new THREE.Matrix4().makeTranslation(group.pivot[0], group.pivot[1], group.pivot[2]));\r\n                }\r\n                if (group.pos) {// There's a pos tag and I have absolutely no idea why the f* it's even there, since it just messes up everything\r\n                    // cubeGroup.applyMatrix(new THREE.Matrix4().makeTranslation(group.pos[0], group.pos[1], group.pos[2]))\r\n                }\r\n                if (group.rotation && group.rotation.length === 3) {\r\n                    cubeGroup.rotation.x = group.rotation[0];\r\n                    cubeGroup.rotation.y = group.rotation[1];\r\n                    cubeGroup.rotation.z = group.rotation[2];\r\n                }\r\n\r\n\r\n                for (let i = 0; i < group.cubes.length; i++) {\r\n                    let cube = group.cubes[i];\r\n\r\n                    let cubeContainer = new THREE.Object3D();\r\n                    cubeContainer.applyMatrix(new THREE.Matrix4().makeTranslation(cube.origin[0], cube.origin[1], -cube.origin[2]));\r\n                    if (group.pivot)\r\n                        cubeContainer.applyMatrix(new THREE.Matrix4().makeTranslation(-group.pivot[0], -group.pivot[1], -group.pivot[2]));\r\n\r\n\r\n                    let cubeMesh = createCube(cube.size[0], cube.size[1], cube.size[2], group.name + \"_\" + i, cube.uv, 0x000000, texture, cube.mirror || group.mirror, textureScale);\r\n\r\n\r\n                    cubeMesh.translateOnAxis(new THREE.Vector3(0, 0, 1), cube.size[2]);\r\n                    // Center the cube\r\n                    cubeMesh.applyMatrix(new THREE.Matrix4().makeTranslation(cube.size[0] / 2, cube.size[1] / 2, -cube.size[2] / 2));\r\n\r\n                    cubeContainer.add(cubeMesh);\r\n\r\n                    if (entityRender.options.showOutlines) {\r\n                        let geo = new THREE.WireframeGeometry(cubeMesh.geometry);\r\n                        let mat = new THREE.LineBasicMaterial({color: 0x000000, linewidth: 2});\r\n                        let line = new THREE.LineSegments(geo, mat);\r\n                        line.name = cubeMesh.name + \"_outline\";\r\n\r\n                        line.position.x = cubeMesh.position.x;\r\n                        line.position.y = cubeMesh.position.y;\r\n                        line.position.z = cubeMesh.position.z;\r\n\r\n                        line.rotation.x = cubeMesh.rotation.x;\r\n                        line.rotation.y = cubeMesh.rotation.y;\r\n                        line.rotation.z = cubeMesh.rotation.z;\r\n\r\n                        line.scale.set(1.01, 1.01, 1.01);\r\n\r\n                        cubeContainer.add(line);\r\n\r\n                        let box = new THREE.BoxHelper(cubeMesh, 0xff0000);\r\n                        cubeContainer.add(box);\r\n                    }\r\n\r\n\r\n                    cubeGroup.add(cubeContainer);\r\n                }\r\n\r\n                entityGroup.add(cubeGroup);\r\n            }\r\n        }\r\n\r\n        resolve(entityGroup);\r\n    })\r\n}\r\n\r\n\r\nlet createCube = function (width, height, depth, name, uv, color, texture, mirror, textureScale) {\r\n    let geometry = new THREE.BoxGeometry(width, height, depth);\r\n    let material;\r\n    if (texture) {\r\n        material = new THREE.MeshBasicMaterial({\r\n            map: texture,\r\n            side: THREE.DoubleSide,\r\n            transparent: true,\r\n            alphaTest: 0.5\r\n        });\r\n    } else {\r\n        material = new THREE.MeshBasicMaterial({\r\n            color: color,\r\n            wireframe: true\r\n        });\r\n    }\r\n\r\n    if (texture) {\r\n        applyCubeTextureToGeometry(geometry, texture, uv, mirror, textureScale);\r\n    }\r\n\r\n\r\n    let cube = new THREE.Mesh(geometry, material);\r\n    cube.name = name;\r\n    cube.receiveShadow = true;\r\n\r\n    return cube;\r\n};\r\n\r\nlet applyCubeTextureToGeometry = function (geometry, texture, uv, mirror, textureScale) {\r\n    let w = texture.image.width;\r\n    let h = texture.image.height;\r\n\r\n    geometry.computeBoundingBox();\r\n    geometry.faceVertexUvs[0] = [];\r\n    let faceUvs = [];\r\n    for (let i = 0; i < 6; i++) {\r\n        let tx1 = uv[FACE_ORDER[i]][0] * textureScale;\r\n        let ty1 = h - uv[FACE_ORDER[i]][1] * textureScale;\r\n        let tx2 = uv[FACE_ORDER[i]][2] * textureScale;\r\n        let ty2 = h - uv[FACE_ORDER[i]][3] * textureScale;\r\n\r\n\r\n        let flipY = false;\r\n        let flipX = false;\r\n\r\n        if (mirror) {\r\n            flipX = true;\r\n        }\r\n        if (FACE_ORDER[i] === \"front\" || FACE_ORDER[i] === \"left\" || FACE_ORDER[i] === \"right\") flipY = true;\r\n\r\n        tx1 /= w;\r\n        ty1 /= h;\r\n        tx2 /= w;\r\n        ty2 /= h;\r\n\r\n        faceUvs[i] = [\r\n            new THREE.Vector2(tx1, ty2),\r\n            new THREE.Vector2(tx1, ty1),\r\n            new THREE.Vector2(tx2, ty1),\r\n            new THREE.Vector2(tx2, ty2)\r\n        ];\r\n\r\n        let temp;\r\n        if (flipY) {\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[2];\r\n            faceUvs[i][1] = temp[3];\r\n            faceUvs[i][2] = temp[0];\r\n            faceUvs[i][3] = temp[1]\r\n        }\r\n        if (flipX) {//flip x\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[3];\r\n            faceUvs[i][1] = temp[2];\r\n            faceUvs[i][2] = temp[1];\r\n            faceUvs[i][3] = temp[0]\r\n        }\r\n\r\n    }\r\n\r\n    let j = 0;\r\n    for (let i = 0; i < faceUvs.length; i++) {\r\n        geometry.faceVertexUvs[0][j] = [faceUvs[i][0], faceUvs[i][1], faceUvs[i][3]];\r\n        geometry.faceVertexUvs[0][j + 1] = [faceUvs[i][1], faceUvs[i][2], faceUvs[i][3]];\r\n        j += 2;\r\n    }\r\n    geometry.uvsNeedUpdate = true;\r\n};\r\n\r\n\r\nfunction getEntityModel(entity) {\r\n    return new Promise((resolve, reject) => {\r\n        $.ajax(\"https://minerender.org/res/models/entities/\" + entity + \".json\")\r\n            .done((data) => {\r\n                resolve(data);\r\n            })\r\n            .fail(() => {\r\n                reject();\r\n            })\r\n    })\r\n}\r\n\r\nconst overwriteMerge = (destinationArray, sourceArray, options) => {\r\n    return sourceArray;\r\n};\r\n\r\nlet mergeParents = function (model) {\r\n    return new Promise((resolve, reject) => {\r\n        mergeParents_(model, [], resolve, reject);\r\n    });\r\n};\r\nlet mergeParents_ = function (model, stack, resolve, reject) {\r\n    console.log(stack)\r\n\r\n    stack.push(model);\r\n\r\n    if (!model.hasOwnProperty(\"parent\")) {// already at the highest parent\r\n        stack.reverse();\r\n        let merged = {};\r\n        for (let i = 0; i < stack.length; i++) {\r\n            console.log(i)\r\n            merged = merge(merged, stack[i], {arrayMerge: overwriteMerge});\r\n            console.log(merged)\r\n        }\r\n\r\n        resolve(merged);\r\n        return;\r\n    }\r\n\r\n    let parent = model[\"parent\"];\r\n    delete model[\"parent\"];// remove the child's parent so it will be replaced by the parent's parent\r\n\r\n    getEntityModel(parent).then((parentData) => {\r\n        // let mergedModel = Object.assign({}, model, parentData);\r\n        mergeParents_(parentData, stack, resolve, reject);\r\n    })\r\n\r\n\r\n};\r\n\r\nif (typeof window !== \"undefined\")\r\n    window.EntityRender = EntityRender;\r\nif (typeof global !== \"undefined\")\r\n    global.EntityRender = EntityRender;\r\n\r\nexport default EntityRender;",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/entity/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "FACE_ORDER",
    "memberof": "src/entity/index.js",
    "static": true,
    "longname": "src/entity/index.js~FACE_ORDER",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "defOptions",
    "memberof": "src/entity/index.js",
    "static": true,
    "longname": "src/entity/index.js~defOptions",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": "",
    "see": [
      "defaultOptions"
    ],
    "lineNumber": 16,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT_ROOT",
        "defaultRaw": "DEFAULT_ROOT",
        "name": "assetRoot",
        "description": "root to get asset files from"
      }
    ],
    "type": {
      "types": [
        "{\"camera\": *, \"assetRoot\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "function",
    "name": "renderEntity",
    "memberof": "src/entity/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/entity/index.js~renderEntity",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [
      {
        "name": "entityRender",
        "types": [
          "*"
        ]
      },
      {
        "name": "modelData",
        "types": [
          "*"
        ]
      },
      {
        "name": "texture",
        "types": [
          "*"
        ]
      },
      {
        "name": "textureScale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "function",
    "name": "createCube",
    "memberof": "src/entity/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/entity/index.js~createCube",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 189,
    "undocument": true,
    "params": [
      {
        "name": "width",
        "types": [
          "*"
        ]
      },
      {
        "name": "height",
        "types": [
          "*"
        ]
      },
      {
        "name": "depth",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "uv",
        "types": [
          "*"
        ]
      },
      {
        "name": "color",
        "types": [
          "*"
        ]
      },
      {
        "name": "texture",
        "types": [
          "*"
        ]
      },
      {
        "name": "mirror",
        "types": [
          "*"
        ]
      },
      {
        "name": "textureScale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "function",
    "name": "applyCubeTextureToGeometry",
    "memberof": "src/entity/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/entity/index.js~applyCubeTextureToGeometry",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 218,
    "undocument": true,
    "params": [
      {
        "name": "geometry",
        "types": [
          "*"
        ]
      },
      {
        "name": "texture",
        "types": [
          "*"
        ]
      },
      {
        "name": "uv",
        "types": [
          "*"
        ]
      },
      {
        "name": "mirror",
        "types": [
          "*"
        ]
      },
      {
        "name": "textureScale",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "function",
    "name": "getEntityModel",
    "memberof": "src/entity/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/entity/index.js~getEntityModel",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 280,
    "undocument": true,
    "params": [
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 62,
    "kind": "function",
    "name": "overwriteMerge",
    "memberof": "src/entity/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/entity/index.js~overwriteMerge",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 292,
    "undocument": true,
    "params": [
      {
        "name": "destinationArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "sourceArray",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 63,
    "kind": "function",
    "name": "mergeParents",
    "memberof": "src/entity/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/entity/index.js~mergeParents",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 296,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 64,
    "kind": "function",
    "name": "mergeParents_",
    "memberof": "src/entity/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/entity/index.js~mergeParents_",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 301,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "stack",
        "types": [
          "*"
        ]
      },
      {
        "name": "resolve",
        "types": [
          "*"
        ]
      },
      {
        "name": "reject",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 65,
    "kind": "class",
    "name": "EntityRender",
    "memberof": "src/entity/index.js",
    "static": true,
    "longname": "src/entity/index.js~EntityRender",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/entity/index.js",
    "importStyle": "EntityRender",
    "description": "A renderer for Minecraft entities",
    "lineNumber": 30,
    "interface": false,
    "extends": [
      "src/renderBase.js~Render"
    ]
  },
  {
    "__docId__": 66,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/entity/index.js~EntityRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/entity/index.js~EntityRender#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 40,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options for this renderer, see {@link defaultOptions}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT_ROOT",
        "defaultRaw": "DEFAULT_ROOT",
        "name": "options.assetRoot",
        "description": "root to get asset files from"
      },
      {
        "nullable": null,
        "types": [
          "HTMLElement"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "document.body",
        "defaultRaw": "document.body",
        "name": "element",
        "description": "DOM Element to attach the renderer to - defaults to document.body"
      }
    ]
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "renderType",
    "memberof": "src/entity/index.js~EntityRender",
    "static": false,
    "longname": "src/entity/index.js~EntityRender#renderType",
    "access": "public",
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "entities",
    "memberof": "src/entity/index.js~EntityRender",
    "static": false,
    "longname": "src/entity/index.js~EntityRender#entities",
    "access": "public",
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "member",
    "name": "attached",
    "memberof": "src/entity/index.js~EntityRender",
    "static": false,
    "longname": "src/entity/index.js~EntityRender#attached",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "method",
    "name": "render",
    "memberof": "src/entity/index.js~EntityRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/entity/index.js~EntityRender#render",
    "access": "public",
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "entities",
        "types": [
          "*"
        ]
      },
      {
        "name": "cb",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 71,
    "kind": "file",
    "name": "src/functions.js",
    "content": "/**\r\n * Default asset root\r\n * @type {string}\r\n */\r\nexport const DEFAULT_ROOT = \"https://assets.mcasset.cloud/1.13\";\r\n/**\r\n * Texture cache\r\n * @type {Object.<string,string>}\r\n */\r\nconst textureCache = {};\r\n/**\r\n * Texture callbacks\r\n * @type {Object.<string,function[]>}\r\n */\r\nconst textureCallbacks = {};\r\n\r\n/**\r\n * Model cache\r\n * @type {Object.<string,string>}\r\n */\r\nconst modelCache = {};\r\n/**\r\n * Model callbacks\r\n * @type {Object.<string,function[]>}\r\n */\r\nconst modelCallbacks = {};\r\n\r\n\r\n/**\r\n * Loads a Mincraft texture an returns it as Base64\r\n *\r\n * @param {string} root Asset root, see {@link DEFAULT_ROOT}\r\n * @param {string} namespace Namespace, usually 'minecraft'\r\n * @param {string} dir Directory of the texture\r\n * @param {string} name Name of the texture\r\n * @returns {Promise<string>}\r\n */\r\nexport function loadTextureAsBase64(root, namespace, dir, name) {\r\n    return new Promise((resolve, reject) => {\r\n        loadTexture(root, namespace, dir, name, resolve, reject);\r\n    })\r\n};\r\n\r\n/**\r\n * Load a texture as base64 - shouldn't be used directly\r\n * @see loadTextureAsBase64\r\n * @ignore\r\n */\r\nfunction loadTexture(root, namespace, dir, name, resolve, reject, forceLoad) {\r\n    let path = \"/assets/\" + namespace + \"/textures\" + dir + name + \".png\";\r\n\r\n    if (textureCache.hasOwnProperty(path)) {\r\n        if (textureCache[path] === \"__invalid\") {\r\n            reject();\r\n            return;\r\n        }\r\n        resolve(textureCache[path]);\r\n        return;\r\n    }\r\n\r\n    if (!textureCallbacks.hasOwnProperty(path) || textureCallbacks[path].length === 0 || forceLoad) {\r\n        // https://gist.github.com/oliyh/db3d1a582aefe6d8fee9 / https://stackoverflow.com/questions/20035615/using-raw-image-data-from-ajax-request-for-data-uri\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open('GET', root + path, true);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.onloadend = function () {\r\n            if (xhr.status === 200) {\r\n                let arr = new Uint8Array(xhr.response || xhr.responseText);\r\n                let raw = String.fromCharCode.apply(null, arr);\r\n                let b64 = btoa(raw);\r\n                let dataURL = \"data:image/png;base64,\" + b64;\r\n\r\n                textureCache[path] = dataURL;\r\n\r\n                if (textureCallbacks.hasOwnProperty(path)) {\r\n                    while (textureCallbacks[path].length > 0) {\r\n                        let cb = textureCallbacks[path].shift(0);\r\n                        cb[0](dataURL);\r\n                    }\r\n                }\r\n            } else {\r\n                if (DEFAULT_ROOT === root) {\r\n                    textureCache[path] = \"__invalid\";\r\n\r\n                    if (textureCallbacks.hasOwnProperty(path)) {\r\n                        while (textureCallbacks[path].length > 0) {\r\n                            let cb = textureCallbacks[path].shift(0);\r\n                            cb[1]();\r\n                        }\r\n                    }\r\n                } else {\r\n                    loadTexture(DEFAULT_ROOT, namespace, dir, name, resolve, reject, true)\r\n                }\r\n            }\r\n        };\r\n        xhr.send();\r\n\r\n        // init array\r\n        if (!textureCallbacks.hasOwnProperty(path))\r\n            textureCallbacks[path] = [];\r\n    }\r\n\r\n    // add the promise callback\r\n    textureCallbacks[path].push([resolve, reject]);\r\n}\r\n\r\n\r\n/**\r\n * Loads a blockstate file and returns the contained JSON\r\n * @param {string} state Name of the blockstate\r\n * @param {string} assetRoot Asset root, see {@link DEFAULT_ROOT}\r\n * @returns {Promise<object>}\r\n */\r\nexport function loadBlockState(state, assetRoot) {\r\n    return loadJsonFromPath(assetRoot, \"/assets/minecraft/blockstates/\" + state + \".json\")\r\n};\r\n\r\nexport function loadTextureMeta(texture, assetRoot) {\r\n    return loadJsonFromPath(assetRoot, \"/assets/minecraft/textures/block/\" + texture + \".png.mcmeta\")\r\n}\r\n\r\n/**\r\n * Loads a model file and returns the contained JSON\r\n * @param {string} root Asset root, see {@link DEFAULT_ROOT}\r\n * @param {string} path Path to the model file\r\n * @returns {Promise<object>}\r\n */\r\nexport function loadJsonFromPath(root, path) {\r\n    return new Promise((resolve, reject) => {\r\n        loadJsonFromPath_(root, path, resolve, reject);\r\n    })\r\n}\r\n\r\n/**\r\n * Load a model - shouldn't used directly\r\n * @see loadJsonFromPath\r\n * @ignore\r\n */\r\nexport function loadJsonFromPath_(root, path, resolve, reject, forceLoad) {\r\n    if (modelCache.hasOwnProperty(path)) {\r\n        if (modelCache[path] === \"__invalid\") {\r\n            reject();\r\n            return;\r\n        }\r\n        resolve(Object.assign({}, modelCache[path]));\r\n        return;\r\n    }\r\n\r\n    if (!modelCallbacks.hasOwnProperty(path) || modelCallbacks[path].length === 0 || forceLoad) {\r\n        console.log(root + path)\r\n        fetch(root + path, {\r\n            mode: \"cors\",\r\n            redirect: \"follow\"\r\n        })\r\n            .then(response => response.json())\r\n            .then(data => {\r\n                console.log(\"json data:\", data);\r\n                modelCache[path] = data;\r\n\r\n                if (modelCallbacks.hasOwnProperty(path)) {\r\n                    while (modelCallbacks[path].length > 0) {\r\n                        let dataCopy = Object.assign({}, data);\r\n                        let cb = modelCallbacks[path].shift(0);\r\n                        cb[0](dataCopy);\r\n                    }\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                console.warn(err);\r\n                if (DEFAULT_ROOT === root) {\r\n                    modelCache[path] = \"__invalid\";\r\n\r\n                    if (modelCallbacks.hasOwnProperty(path)) {\r\n                        while (modelCallbacks[path].length > 0) {\r\n                            let cb = modelCallbacks[path].shift(0);\r\n                            cb[1]();\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Try again with default root\r\n                    loadJsonFromPath_(DEFAULT_ROOT, path, resolve, reject, true);\r\n                }\r\n            });\r\n\r\n        if (!modelCallbacks.hasOwnProperty(path))\r\n            modelCallbacks[path] = [];\r\n    }\r\n\r\n    modelCallbacks[path].push([resolve, reject]);\r\n}\r\n\r\n/**\r\n * Scales UV values\r\n * @param {number} uv UV value\r\n * @param {number} size\r\n * @param {number} [scale=16]\r\n * @returns {number}\r\n */\r\nexport function scaleUv(uv, size, scale) {\r\n    if (uv === 0) return 0;\r\n    return size / (scale || 16) * uv;\r\n}\r\n\r\n\r\n// https://gist.github.com/remy/784508\r\nexport function trimCanvas(c) {\r\n    let ctx = c.getContext('2d'),\r\n        copy = document.createElement('canvas').getContext('2d'),\r\n        pixels = ctx.getImageData(0, 0, c.width, c.height),\r\n        l = pixels.data.length,\r\n        i,\r\n        bound = {\r\n            top: null,\r\n            left: null,\r\n            right: null,\r\n            bottom: null\r\n        },\r\n        x, y;\r\n\r\n    for (i = 0; i < l; i += 4) {\r\n        if (pixels.data[i + 3] !== 0) {\r\n            x = (i / 4) % c.width;\r\n            y = ~~((i / 4) / c.width);\r\n\r\n            if (bound.top === null) {\r\n                bound.top = y;\r\n            }\r\n\r\n            if (bound.left === null) {\r\n                bound.left = x;\r\n            } else if (x < bound.left) {\r\n                bound.left = x;\r\n            }\r\n\r\n            if (bound.right === null) {\r\n                bound.right = x;\r\n            } else if (bound.right < x) {\r\n                bound.right = x;\r\n            }\r\n\r\n            if (bound.bottom === null) {\r\n                bound.bottom = y;\r\n            } else if (bound.bottom < y) {\r\n                bound.bottom = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    let trimHeight = bound.bottom - bound.top,\r\n        trimWidth = bound.right - bound.left,\r\n        trimmed = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);\r\n\r\n    copy.canvas.width = trimWidth;\r\n    copy.canvas.height = trimHeight;\r\n    copy.putImageData(trimmed, 0, 0);\r\n\r\n    // open new window with trimmed image:\r\n    return copy.canvas;\r\n}",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/functions.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 72,
    "kind": "variable",
    "name": "DEFAULT_ROOT",
    "memberof": "src/functions.js",
    "static": true,
    "longname": "src/functions.js~DEFAULT_ROOT",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{DEFAULT_ROOT}",
    "description": "Default asset root",
    "lineNumber": 5,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "variable",
    "name": "textureCache",
    "memberof": "src/functions.js",
    "static": true,
    "longname": "src/functions.js~textureCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/functions.js",
    "importStyle": null,
    "description": "Texture cache",
    "lineNumber": 10,
    "type": {
      "nullable": null,
      "types": [
        "Object.<string,string>"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 74,
    "kind": "variable",
    "name": "textureCallbacks",
    "memberof": "src/functions.js",
    "static": true,
    "longname": "src/functions.js~textureCallbacks",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/functions.js",
    "importStyle": null,
    "description": "Texture callbacks",
    "lineNumber": 15,
    "type": {
      "nullable": null,
      "types": [
        "Object.<string,function[]>"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 75,
    "kind": "variable",
    "name": "modelCache",
    "memberof": "src/functions.js",
    "static": true,
    "longname": "src/functions.js~modelCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/functions.js",
    "importStyle": null,
    "description": "Model cache",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Object.<string,string>"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 76,
    "kind": "variable",
    "name": "modelCallbacks",
    "memberof": "src/functions.js",
    "static": true,
    "longname": "src/functions.js~modelCallbacks",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/functions.js",
    "importStyle": null,
    "description": "Model callbacks",
    "lineNumber": 26,
    "type": {
      "nullable": null,
      "types": [
        "Object.<string,function[]>"
      ],
      "spread": false,
      "description": null
    },
    "ignore": true
  },
  {
    "__docId__": 77,
    "kind": "function",
    "name": "loadTextureAsBase64",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~loadTextureAsBase64",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{loadTextureAsBase64}",
    "description": "Loads a Mincraft texture an returns it as Base64",
    "lineNumber": 38,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<string>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "root",
        "description": "Asset root, see {@link DEFAULT_ROOT}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "namespace",
        "description": "Namespace, usually 'minecraft'"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dir",
        "description": "Directory of the texture"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "Name of the texture"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<string>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 78,
    "kind": "function",
    "name": "loadTexture",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~loadTexture",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/functions.js",
    "importStyle": null,
    "description": "Load a texture as base64 - shouldn't be used directly",
    "see": [
      "loadTextureAsBase64"
    ],
    "lineNumber": 49,
    "ignore": true,
    "params": [
      {
        "name": "root",
        "types": [
          "*"
        ]
      },
      {
        "name": "namespace",
        "types": [
          "*"
        ]
      },
      {
        "name": "dir",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "resolve",
        "types": [
          "*"
        ]
      },
      {
        "name": "reject",
        "types": [
          "*"
        ]
      },
      {
        "name": "forceLoad",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 79,
    "kind": "function",
    "name": "loadBlockState",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~loadBlockState",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{loadBlockState}",
    "description": "Loads a blockstate file and returns the contained JSON",
    "lineNumber": 114,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<object>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "state",
        "description": "Name of the blockstate"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "assetRoot",
        "description": "Asset root, see {@link DEFAULT_ROOT}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 80,
    "kind": "function",
    "name": "loadTextureMeta",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~loadTextureMeta",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{loadTextureMeta}",
    "description": null,
    "lineNumber": 118,
    "undocument": true,
    "params": [
      {
        "name": "texture",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "function",
    "name": "loadJsonFromPath",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~loadJsonFromPath",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{loadJsonFromPath}",
    "description": "Loads a model file and returns the contained JSON",
    "lineNumber": 128,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<object>}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "root",
        "description": "Asset root, see {@link DEFAULT_ROOT}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "path",
        "description": "Path to the model file"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<object>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 82,
    "kind": "function",
    "name": "loadJsonFromPath_",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~loadJsonFromPath_",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{loadJsonFromPath_}",
    "description": "Load a model - shouldn't used directly",
    "see": [
      "loadJsonFromPath"
    ],
    "lineNumber": 139,
    "ignore": true,
    "params": [
      {
        "name": "root",
        "types": [
          "*"
        ]
      },
      {
        "name": "path",
        "types": [
          "*"
        ]
      },
      {
        "name": "resolve",
        "types": [
          "*"
        ]
      },
      {
        "name": "reject",
        "types": [
          "*"
        ]
      },
      {
        "name": "forceLoad",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 83,
    "kind": "function",
    "name": "scaleUv",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~scaleUv",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{scaleUv}",
    "description": "Scales UV values",
    "lineNumber": 199,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "uv",
        "description": "UV value"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "size",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "16",
        "defaultRaw": 16,
        "name": "scale",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 84,
    "kind": "function",
    "name": "trimCanvas",
    "memberof": "src/functions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/functions.js~trimCanvas",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/functions.js",
    "importStyle": "{trimCanvas}",
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "params": [
      {
        "name": "c",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "file",
    "name": "src/gui/guiHelper.js",
    "content": "import guiPositions from \"./guiPositions\";\r\n\r\n/**\r\n * Helper functions for GUI creation\r\n */\r\nconst guiHelper = {\r\n    addPos: function (arr1, arr2, a) {\r\n        if (arr1.length === 2 && arr2.length === 2) {\r\n            if (!a || a === \"xy\") {\r\n                return [arr1[0] + arr2[0], arr1[1] + arr2[1]];\r\n            }\r\n            if (a === \"x\") {\r\n                return [arr1[0] + arr2[0], arr1[1]];\r\n            }\r\n            if (a === \"y\") {\r\n                return [arr1[0], arr1[1] + arr2[1]];\r\n            }\r\n        }\r\n    },\r\n    subtractPos: function (arr1, arr2, a) {\r\n        if (arr1.length === 2 && arr2.length === 2) {\r\n            if (!a || a === \"xy\") {\r\n                return [arr1[0] - arr2[0], arr1[1] - arr2[1]];\r\n            }\r\n            if (a === \"x\") {\r\n                return [arr1[0] - arr2[0], arr1[1]];\r\n            }\r\n            if (a === \"y\") {\r\n                return [arr1[0], arr1[1] - arr2[1]];\r\n            }\r\n        }\r\n    },\r\n    multiplyPos: function (arr1, n, a) {\r\n        if (arr1.length === 2) {\r\n            if (!a || a === \"xy\") {\r\n                return [arr1[0] * n, arr1[1] * n];\r\n            }\r\n            if (a === \"x\") {\r\n                return [arr1[0] * n, arr1[1]];\r\n            }\r\n            if (a === \"y\") {\r\n                return [arr1[0], arr1[1] * n];\r\n            }\r\n        }\r\n    },\r\n\r\n    inventorySlot: function (n, origin, offset, rowSize) {\r\n        if (!rowSize) rowSize = 9;\r\n        let row, col;\r\n\r\n        if (n instanceof Array) {\r\n            row = n[1];\r\n            col = n[0];\r\n        } else {\r\n            row = Math.floor(n / rowSize);\r\n            col = n % rowSize;\r\n        }\r\n\r\n        let x = origin[0] + (col * offset[0]);\r\n        let y = origin[1] + (row * offset[1]);\r\n\r\n        return [x, y];\r\n    },\r\n    recipe: function (recipeData, textureMap) {\r\n\r\n        let renderData = [];\r\n        renderData.push({\r\n            name: \"base\",\r\n            texture: \"/gui/container/crafting_table\",\r\n            layer: 0,\r\n            uv: guiPositions.container.crafting_table.uv,\r\n            pos: [0, 0]\r\n        });\r\n\r\n        if (recipeData.type === \"crafting_shaped\") {\r\n            let pattern = recipeData.pattern;\r\n            for (let l = 0; l < pattern.length; l++) {\r\n                let line = pattern[l];\r\n                for (let c = 0; c < line.length; c++) {\r\n                    let char = line[c];\r\n                    if (char === ' ') continue;\r\n                    if (!recipeData.key.hasOwnProperty(char)) {\r\n                        console.warn(\"Missing recipe key \" + char);\r\n                        continue;\r\n                    }\r\n\r\n                    let slot = this.inventorySlot([c, l], guiPositions.container.crafting_table.left_origin, guiPositions.container.crafting_table.item_offset, 3);\r\n                    let item = recipeData.key[char].item;\r\n                    let itemSplit = item.split(\":\");\r\n                    let itemNamespace = itemSplit[0];\r\n                    let itemName = itemSplit[1];\r\n\r\n                    if (textureMap.hasOwnProperty(itemName)) {\r\n                        itemName = textureMap[itemName];\r\n                    } else {\r\n                        itemName = \"/item/\" + itemName;\r\n                    }\r\n\r\n                    renderData.push({\r\n                        name: item,\r\n                        texture: itemName,\r\n                        layer: 1,\r\n                        pos: slot\r\n                    });\r\n                }\r\n            }\r\n        } else if (recipeData.type === \"crafting_shapeless\") {\r\n            for (let i = 0; i < recipeData.ingredients.length; i++) {\r\n                let ingredient = recipeData.ingredients[i];\r\n\r\n                let slot = this.inventorySlot(i, guiPositions.container.crafting_table.left_origin, guiPositions.container.crafting_table.item_offset, 3);\r\n                let item = ingredient.item;\r\n                let itemSplit = item.split(\":\");\r\n                let itemNamespace = itemSplit[0];\r\n                let itemName = itemSplit[1];\r\n\r\n                if (textureMap.hasOwnProperty(itemName)) {\r\n                    itemName = textureMap[itemName];\r\n                } else {\r\n                    itemName = \"/item/\" + itemName;\r\n                }\r\n\r\n                renderData.push({\r\n                    name: item,\r\n                    texture: itemName,\r\n                    layer: 1,\r\n                    pos: slot\r\n                });\r\n            }\r\n        }\r\n\r\n        let resultItem = recipeData.result.item;\r\n        let itemSplit = resultItem.split(\":\");\r\n        let itemNamespace = itemSplit[0];\r\n        let itemName = itemSplit[1];\r\n        if (textureMap.hasOwnProperty(itemName)) {\r\n            itemName = textureMap[itemName];\r\n        } else {\r\n            itemName = \"/item/\" + itemName;\r\n        }\r\n\r\n        renderData.push({\r\n            name: resultItem,\r\n            texture: itemName,\r\n            layer: 1,\r\n            pos: guiPositions.container.crafting_table.right_origin\r\n        });\r\n\r\n\r\n        return renderData;\r\n    }\r\n};\r\n\r\nexport default guiHelper;",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/gui/guiHelper.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 86,
    "kind": "variable",
    "name": "guiHelper",
    "memberof": "src/gui/guiHelper.js",
    "static": true,
    "longname": "src/gui/guiHelper.js~guiHelper",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/gui/guiHelper.js",
    "importStyle": "guiHelper",
    "description": "Helper functions for GUI creation",
    "lineNumber": 6,
    "type": {
      "types": [
        "{\"addPos\": *, \"subtractPos\": *, \"multiplyPos\": *, \"inventorySlot\": *, \"recipe\": *}"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "file",
    "name": "src/gui/guiPositions.js",
    "content": "/**\r\n * Definition of positions/UV mappings ov Minecraft GUI assets\r\n */\r\nconst guiPositions = {\r\n    bars: {\r\n        pink_empty: {\r\n            uv: [0, 0, 182, 5]\r\n        },\r\n        pink_full: {\r\n            uv: [0, 5, 182, 10]\r\n        },\r\n        cyan_empty: {\r\n            uv: [0, 10, 182, 15]\r\n        },\r\n        cyan_full: {\r\n            uv: [0, 15, 182, 20]\r\n        },\r\n        orange_empty: {\r\n            uv: [0, 20, 182, 25]\r\n        },\r\n        orange_full: {\r\n            uv: [0, 25, 182, 30]\r\n        },\r\n        green_empty: {\r\n            uv: [0, 30, 182, 35]\r\n        },\r\n        green_full: {\r\n            uv: [0, 35, 182, 40]\r\n        },\r\n        yellow_empty: {\r\n            uv: [0, 40, 182, 45]\r\n        },\r\n        yellow_full: {\r\n            uv: [0, 45, 182, 50]\r\n        },\r\n        purple_empty: {\r\n            uv: [0, 50, 182, 55]\r\n        },\r\n        purple_full: {\r\n            uv: [0, 55, 182, 60]\r\n        },\r\n        white_empty: {\r\n            uv: [0, 60, 182, 65]\r\n        },\r\n        white_full: {\r\n            uv: [0, 65, 182, 70]\r\n        }\r\n    },\r\n    book: {\r\n        base: {\r\n            uv: [0, 0, 192, 192],// 192 is actually bigger than the book background, but that's the coordinates MC itself uses\r\n        },\r\n        button_next: {\r\n            uv: [0, 192, 23, 205],\r\n            pos: [120, 156]\r\n        },\r\n        button_next_hover: {\r\n            uv: [23, 192, 46, 205],\r\n            pos: [120, 156]\r\n        },\r\n        button_prev: {\r\n            uv: [0, 205, 23, 218],\r\n            pos: [38, 156]\r\n        },\r\n        button_prev_hover: {\r\n            uv: [23, 205, 46, 218],\r\n            pos: [38, 156]\r\n        }\r\n    },\r\n    container: {\r\n        generic_54: {\r\n            uv: [0, 0, 176, 222],\r\n            top_origin: [8, 18],\r\n            item_offset: [18, 18]\r\n        },\r\n        crafting_table: {\r\n            uv: [0, 0, 176, 166],\r\n            left_origin: [30, 17],\r\n            right_origin: [124, 35],\r\n            item_offset: [18, 18]\r\n        }\r\n    }\r\n};\r\n\r\nexport default guiPositions;",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/gui/guiPositions.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 88,
    "kind": "variable",
    "name": "guiPositions",
    "memberof": "src/gui/guiPositions.js",
    "static": true,
    "longname": "src/gui/guiPositions.js~guiPositions",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/gui/guiPositions.js",
    "importStyle": "guiPositions",
    "description": "Definition of positions/UV mappings ov Minecraft GUI assets",
    "lineNumber": 4,
    "type": {
      "types": [
        "{\"bars\": *, \"book\": *, \"container\": *}"
      ]
    }
  },
  {
    "__docId__": 89,
    "kind": "file",
    "name": "src/gui/index.js",
    "content": "import * as THREE from \"three\";\r\nimport Render, { defaultOptions } from \"../renderBase\";\r\nimport { loadTextureAsBase64, DEFAULT_ROOT } from \"../functions\";\r\nimport guiPositions from \"./guiPositions\";\r\nimport guiHelper from \"./guiHelper\";\r\nimport ModelRender from \"../model\";\r\n\r\n/**\r\n * @see defaultOptions\r\n * @property {string} [assetRoot=DEFAULT_ROOT] root to get asset files from\r\n */\r\nlet defOptions = {\r\n    controls: {\r\n        enabled: true,\r\n        zoom: true,\r\n        rotate: false,\r\n        pan: true\r\n    },\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 0,\r\n        y: 0,\r\n        z: 50,\r\n        target: [0, 0, 0]\r\n    },\r\n    assetRoot: DEFAULT_ROOT\r\n};\r\n\r\n/**\r\n * A renderer for Minecraft GUIs\r\n */\r\nclass GuiRender extends Render {\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {string} [options.assetRoot=DEFAULT_ROOT] root to get asset files from\r\n     *\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, element) {\r\n        super(options, defOptions, element);\r\n\r\n        this.renderType = \"GuiRender\";\r\n\r\n        this.gui = null;\r\n        this.attached = false;\r\n    }\r\n\r\n    /**\r\n     * Does the actual rendering\r\n     *\r\n     * @param {(string[]|Object[])} layers Array of GUI layers - either strings or objects\r\n     * @param {string} layers[].texture path to the layer's texture (starting at assets/minecraft/textures/), e.g. '/items/apple'\r\n     * @param {number} [layers[].textureScale=1] scale of the given texture, can be used to get different sized textures aligned proerly\r\n     * @param {number[]} [layers[].uv] [x1,y1,x2,y2] array UV mapping of the texture\r\n     * @param {number[]} [layers[].pos=[0,0]] [x,y] array position of the layer\r\n     *\r\n     * @param {function} [cb] Callback when rendering finished\r\n     */\r\n    render(layers, cb) {\r\n        let guiRender = this;\r\n\r\n        if (!guiRender.attached && !guiRender._scene) {// Don't init scene if attached, since we already have an available scene\r\n            super.initScene(function () {\r\n                guiRender.element.dispatchEvent(new CustomEvent(\"guiRender\", {detail: {gui: guiRender.gui}}));\r\n            });\r\n\r\n            guiRender._controls.target.set(0, 0, 0);\r\n            guiRender._camera.lookAt(new THREE.Vector3(0, 0, 0));\r\n        } else {\r\n            console.log(\"[GuiRender] is attached - skipping scene init\");\r\n        }\r\n\r\n        let promises = [];\r\n        for (let i = 0; i < layers.length; i++) {\r\n            promises.push(new Promise((resolve, reject) => {\r\n                let layer = layers[i];\r\n                if (typeof layer === \"string\") {\r\n                    layer = {\r\n                        texture: layer\r\n                    }\r\n                }\r\n                if (!layer.textureScale) layer.textureScale = 1;\r\n\r\n                loadTextureAsBase64(guiRender.options.assetRoot, \"minecraft\", \"\", layer.texture).then((url) => {\r\n                    let imgDone = function (url) {\r\n                        let texture = new THREE.TextureLoader().load(url, function () {\r\n                            texture.magFilter = THREE.NearestFilter;\r\n                            texture.minFilter = THREE.NearestFilter;\r\n                            texture.anisotropy = 0;\r\n                            texture.needsUpdate = true;\r\n\r\n                            let material = new THREE.MeshBasicMaterial({\r\n                                map: texture,\r\n                                transparent: true,\r\n                                side: THREE.DoubleSide,\r\n                                alphaTest: 0.5\r\n                            });\r\n\r\n                            material.userData.layer = layer;\r\n\r\n                            resolve(material);\r\n                        })\r\n                    };\r\n\r\n                    if (!layer.uv) {\r\n                        imgDone(url);\r\n                    } else {\r\n                        layer.uv = [\r\n                            layer.uv[0] * layer.textureScale,\r\n                            layer.uv[1] * layer.textureScale,\r\n                            layer.uv[2] * layer.textureScale,\r\n                            layer.uv[3] * layer.textureScale\r\n                        ];\r\n\r\n                        let img = new Image();\r\n                        img.onload = function () {\r\n                            let canvas = document.createElement(\"canvas\");\r\n                            canvas.width = layer.uv[2] - layer.uv[0];\r\n                            canvas.height = layer.uv[3] - layer.uv[1];\r\n                            let context = canvas.getContext(\"2d\");\r\n                            context.drawImage(img, layer.uv[0], layer.uv[1], layer.uv[2] - layer.uv[0], layer.uv[3] - layer.uv[1], 0, 0, layer.uv[2] - layer.uv[0], layer.uv[3] - layer.uv[1]);\r\n\r\n                            imgDone(canvas.toDataURL(\"image/png\"));\r\n                        };\r\n                        img.crossOrigin = \"anonymous\";\r\n                        img.src = url;\r\n                    }\r\n                });\r\n            }));\r\n        }\r\n\r\n        Promise.all(promises).then((materials) => {\r\n            let planeGroup = new THREE.Object3D();\r\n\r\n            let w = 0, h = 0;\r\n            for (let i = 0; i < materials.length; i++) {\r\n                let material = materials[i];\r\n\r\n                let width = material.map.image.width;\r\n                let height = material.map.image.height;\r\n\r\n\r\n                let uv = material.userData.layer.uv;\r\n                if (!uv) {\r\n                    // default to full image size if uv isn't set\r\n                    uv = [0, 0, width, height];\r\n                }\r\n                // uv = [\r\n                //     uv[0]/4,\r\n                //     uv[1]/4,\r\n                //     uv[2]/4,\r\n                //     uv[3]/4\r\n                // ];\r\n\r\n                let uvW = (uv[2] - uv[0]) / material.userData.layer.textureScale;\r\n                let uvH = (uv[3] - uv[1]) / material.userData.layer.textureScale;\r\n\r\n                if (uvW > w) w = uvW;\r\n                if (uvH > h) h = uvH;\r\n\r\n                let geometry = new THREE.PlaneGeometry(uvW, uvH);\r\n                let plane = new THREE.Mesh(geometry, material);\r\n                plane.name = material.userData.layer.texture.toLowerCase() + (material.userData.layer.name ? \"_\" + material.userData.layer.name.toLowerCase() : \"\");\r\n                plane.position.set(0, 0, 0);\r\n\r\n                plane.applyMatrix(new THREE.Matrix4().makeTranslation(uvW / 2, uvH / 2, 0));\r\n\r\n                if (material.userData.layer.pos) {\r\n                    plane.applyMatrix(new THREE.Matrix4().makeTranslation(material.userData.layer.pos[0], -uvH - material.userData.layer.pos[1], 0));\r\n                } else {\r\n                    plane.applyMatrix(new THREE.Matrix4().makeTranslation(0, -uvH, 0));\r\n                }\r\n\r\n                if (material.userData.layer.layer) {\r\n                    plane.layers.set(material.userData.layer.layer);\r\n                    guiRender._camera.layers.enable(material.userData.layer.layer);\r\n                }\r\n\r\n\r\n                planeGroup.add(plane);\r\n\r\n\r\n                if (guiRender.options.showOutlines) {\r\n                    let box = new THREE.BoxHelper(plane, 0xff0000);\r\n                    planeGroup.add(box);\r\n\r\n                    if (material.userData.layer.layer) {\r\n                        box.layers.set(material.userData.layer.layer);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            planeGroup.applyMatrix(new THREE.Matrix4().makeTranslation(-w / 2, h / 2, 0));\r\n            guiRender.addToScene(planeGroup);\r\n\r\n            guiRender.gui = planeGroup;\r\n\r\n            if (!guiRender.attached) {\r\n                guiRender._camera.position.set(0, 0, Math.max(w, h));\r\n                // https://stackoverflow.com/a/11278936\r\n                guiRender._camera.fov = 2 * Math.atan(Math.max(w, h) / (2 * Math.max(w, h))) * (180 / Math.PI);\r\n                guiRender._camera.updateProjectionMatrix();\r\n            }\r\n\r\n            if (typeof cb === \"function\") cb();\r\n        });\r\n    };\r\n}\r\n\r\nGuiRender.Positions = guiPositions;\r\nGuiRender.Helper = guiHelper;\r\n\r\nif (typeof window !== \"undefined\")\r\n    window.GuiRender = GuiRender;\r\nif (typeof global !== \"undefined\")\r\n    global.GuiRender = GuiRender;\r\n\r\n\r\nexport default GuiRender;",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/gui/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 90,
    "kind": "variable",
    "name": "defOptions",
    "memberof": "src/gui/index.js",
    "static": true,
    "longname": "src/gui/index.js~defOptions",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/gui/index.js",
    "importStyle": null,
    "description": "",
    "see": [
      "defaultOptions"
    ],
    "lineNumber": 12,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT_ROOT",
        "defaultRaw": "DEFAULT_ROOT",
        "name": "assetRoot",
        "description": "root to get asset files from"
      }
    ],
    "type": {
      "types": [
        "{\"controls\": *, \"camera\": *, \"assetRoot\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 91,
    "kind": "class",
    "name": "GuiRender",
    "memberof": "src/gui/index.js",
    "static": true,
    "longname": "src/gui/index.js~GuiRender",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/gui/index.js",
    "importStyle": "GuiRender",
    "description": "A renderer for Minecraft GUIs",
    "lineNumber": 32,
    "interface": false,
    "extends": [
      "src/renderBase.js~Render"
    ]
  },
  {
    "__docId__": 92,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/gui/index.js~GuiRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/gui/index.js~GuiRender#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 41,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options for this renderer, see {@link defaultOptions}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT_ROOT",
        "defaultRaw": "DEFAULT_ROOT",
        "name": "options.assetRoot",
        "description": "root to get asset files from"
      },
      {
        "nullable": null,
        "types": [
          "HTMLElement"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "document.body",
        "defaultRaw": "document.body",
        "name": "element",
        "description": "DOM Element to attach the renderer to - defaults to document.body"
      }
    ]
  },
  {
    "__docId__": 93,
    "kind": "member",
    "name": "renderType",
    "memberof": "src/gui/index.js~GuiRender",
    "static": false,
    "longname": "src/gui/index.js~GuiRender#renderType",
    "access": "public",
    "description": null,
    "lineNumber": 44,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "member",
    "name": "gui",
    "memberof": "src/gui/index.js~GuiRender",
    "static": false,
    "longname": "src/gui/index.js~GuiRender#gui",
    "access": "public",
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "attached",
    "memberof": "src/gui/index.js~GuiRender",
    "static": false,
    "longname": "src/gui/index.js~GuiRender#attached",
    "access": "public",
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "method",
    "name": "render",
    "memberof": "src/gui/index.js~GuiRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/gui/index.js~GuiRender#render",
    "access": "public",
    "description": "Does the actual rendering",
    "lineNumber": 61,
    "params": [
      {
        "nullable": null,
        "types": [
          "string[]",
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "layers",
        "description": "Array of GUI layers - either strings or objects"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "layers[].texture",
        "description": "path to the layer's texture (starting at assets/minecraft/textures/), e.g. '/items/apple'"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "layers[].textureScale",
        "description": "scale of the given texture, can be used to get different sized textures aligned proerly"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "layers[].uv",
        "description": "[x1,y1,x2,y2] array UV mapping of the texture"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0]",
        "defaultRaw": [
          0,
          0
        ],
        "name": "layers[].pos",
        "description": "[x,y] array position of the layer"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "cb",
        "description": "Callback when rendering finished"
      }
    ],
    "return": null
  },
  {
    "__docId__": 97,
    "kind": "file",
    "name": "src/lib/merge.js",
    "content": "",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/lib/merge.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 98,
    "kind": "file",
    "name": "src/lib/OrbitControls.js",
    "content": "import * as THREE from \"three\";\r\n\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\r\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\r\n\r\nexport default function OrbitControls( object, domElement ) {\r\n\r\n    this.object = object;\r\n\r\n    this.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the object orbits around\r\n    this.target = new THREE.Vector3();\r\n\r\n    // How far you can dolly in and out ( PerspectiveCamera only )\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // How far you can zoom in and out ( OrthographicCamera only )\r\n    this.minZoom = 0;\r\n    this.maxZoom = Infinity;\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // How far you can orbit horizontally, upper and lower limits.\r\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n    this.minAzimuthAngle = - Infinity; // radians\r\n    this.maxAzimuthAngle = Infinity; // radians\r\n\r\n    // Set to true to enable damping (inertia)\r\n    // If damping is enabled, you must call controls.update() in your animation loop\r\n    this.enableDamping = false;\r\n    this.dampingFactor = 0.25;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n    // Set to false to disable zooming\r\n    this.enableZoom = true;\r\n    this.zoomSpeed = 1.0;\r\n\r\n    // Set to false to disable rotating\r\n    this.enableRotate = true;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to false to disable panning\r\n    this.enablePan = true;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // Set to false to disable use of the keys\r\n    this.enableKeys = true;\r\n\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    // Mouse buttons\r\n    this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\r\n\r\n    // for reset\r\n    this.target0 = this.target.clone();\r\n    this.position0 = this.object.position.clone();\r\n    this.zoom0 = this.object.zoom;\r\n\r\n    //\r\n    // public methods\r\n    //\r\n\r\n    this.getPolarAngle = function () {\r\n\r\n        return spherical.phi;\r\n\r\n    };\r\n\r\n    this.getAzimuthalAngle = function () {\r\n\r\n        return spherical.theta;\r\n\r\n    };\r\n\r\n    this.saveState = function () {\r\n\r\n        scope.target0.copy( scope.target );\r\n        scope.position0.copy( scope.object.position );\r\n        scope.zoom0 = scope.object.zoom;\r\n\r\n    };\r\n\r\n    this.reset = function () {\r\n\r\n        scope.target.copy( scope.target0 );\r\n        scope.object.position.copy( scope.position0 );\r\n        scope.object.zoom = scope.zoom0;\r\n\r\n        scope.object.updateProjectionMatrix();\r\n        scope.dispatchEvent( changeEvent );\r\n\r\n        scope.update();\r\n\r\n        state = STATE.NONE;\r\n\r\n    };\r\n\r\n    // this method is exposed, but perhaps it would be better if we can make it private...\r\n    this.update = function () {\r\n\r\n        var offset = new THREE.Vector3();\r\n\r\n        // so camera.up is the orbit axis\r\n        var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\r\n        var quatInverse = quat.clone().inverse();\r\n\r\n        var lastPosition = new THREE.Vector3();\r\n        var lastQuaternion = new THREE.Quaternion();\r\n\r\n        return function update() {\r\n\r\n            var position = scope.object.position;\r\n\r\n            offset.copy( position ).sub( scope.target );\r\n\r\n            // rotate offset to \"y-axis-is-up\" space\r\n            offset.applyQuaternion( quat );\r\n\r\n            // angle from z-axis around y-axis\r\n            spherical.setFromVector3( offset );\r\n\r\n            if ( scope.autoRotate && state === STATE.NONE ) {\r\n\r\n                rotateLeft( getAutoRotationAngle() );\r\n\r\n            }\r\n\r\n            spherical.theta += sphericalDelta.theta;\r\n            spherical.phi += sphericalDelta.phi;\r\n\r\n            // restrict theta to be between desired limits\r\n            spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\r\n\r\n            // restrict phi to be between desired limits\r\n            spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\r\n\r\n            spherical.makeSafe();\r\n\r\n\r\n            spherical.radius *= scale;\r\n\r\n            // restrict radius to be between desired limits\r\n            spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\r\n\r\n            // move target to panned location\r\n            scope.target.add( panOffset );\r\n\r\n            offset.setFromSpherical( spherical );\r\n\r\n            // rotate offset back to \"camera-up-vector-is-up\" space\r\n            offset.applyQuaternion( quatInverse );\r\n\r\n            position.copy( scope.target ).add( offset );\r\n\r\n            scope.object.lookAt( scope.target );\r\n\r\n            if ( scope.enableDamping === true ) {\r\n\r\n                sphericalDelta.theta *= ( 1 - scope.dampingFactor );\r\n                sphericalDelta.phi *= ( 1 - scope.dampingFactor );\r\n\r\n            } else {\r\n\r\n                sphericalDelta.set( 0, 0, 0 );\r\n\r\n            }\r\n\r\n            scale = 1;\r\n            panOffset.set( 0, 0, 0 );\r\n\r\n            // update condition is:\r\n            // min(camera displacement, camera rotation in radians)^2 > EPS\r\n            // using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n            if ( zoomChanged ||\r\n                lastPosition.distanceToSquared( scope.object.position ) > EPS ||\r\n                8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\r\n\r\n                scope.dispatchEvent( changeEvent );\r\n\r\n                lastPosition.copy( scope.object.position );\r\n                lastQuaternion.copy( scope.object.quaternion );\r\n                zoomChanged = false;\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            return false;\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    this.dispose = function () {\r\n\r\n        scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\r\n        scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n        scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\r\n\r\n        scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\r\n        scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\r\n        scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\r\n\r\n        document.removeEventListener( 'mousemove', onMouseMove, false );\r\n        document.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        window.removeEventListener( 'keydown', onKeyDown, false );\r\n\r\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n\r\n    };\r\n\r\n    //\r\n    // internals\r\n    //\r\n\r\n    var scope = this;\r\n\r\n    var changeEvent = { type: 'change' };\r\n    var startEvent = { type: 'start' };\r\n    var endEvent = { type: 'end' };\r\n\r\n    var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\r\n\r\n    var state = STATE.NONE;\r\n\r\n    var EPS = 0.000001;\r\n\r\n    // current position in spherical coordinates\r\n    var spherical = new THREE.Spherical();\r\n    var sphericalDelta = new THREE.Spherical();\r\n\r\n    var scale = 1;\r\n    var panOffset = new THREE.Vector3();\r\n    var zoomChanged = false;\r\n\r\n    var rotateStart = new THREE.Vector2();\r\n    var rotateEnd = new THREE.Vector2();\r\n    var rotateDelta = new THREE.Vector2();\r\n\r\n    var panStart = new THREE.Vector2();\r\n    var panEnd = new THREE.Vector2();\r\n    var panDelta = new THREE.Vector2();\r\n\r\n    var dollyStart = new THREE.Vector2();\r\n    var dollyEnd = new THREE.Vector2();\r\n    var dollyDelta = new THREE.Vector2();\r\n\r\n    function getAutoRotationAngle() {\r\n\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n    }\r\n\r\n    function getZoomScale() {\r\n\r\n        return Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n    }\r\n\r\n    function rotateLeft( angle ) {\r\n\r\n        sphericalDelta.theta -= angle;\r\n\r\n    }\r\n\r\n    function rotateUp( angle ) {\r\n\r\n        sphericalDelta.phi -= angle;\r\n\r\n    }\r\n\r\n    var panLeft = function () {\r\n\r\n        var v = new THREE.Vector3();\r\n\r\n        return function panLeft( distance, objectMatrix ) {\r\n\r\n            v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n            v.multiplyScalar( - distance );\r\n\r\n            panOffset.add( v );\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    var panUp = function () {\r\n\r\n        var v = new THREE.Vector3();\r\n\r\n        return function panUp( distance, objectMatrix ) {\r\n\r\n            v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\r\n            v.multiplyScalar( distance );\r\n\r\n            panOffset.add( v );\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    // deltaX and deltaY are in pixels; right and down are positive\r\n    var pan = function () {\r\n\r\n        var offset = new THREE.Vector3();\r\n\r\n        return function pan( deltaX, deltaY ) {\r\n\r\n            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n            if ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\r\n                // perspective\r\n                var position = scope.object.position;\r\n                offset.copy( position ).sub( scope.target );\r\n                var targetDistance = offset.length();\r\n\r\n                // half of the fov is center to top of screen\r\n                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n                // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n                panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\r\n                panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\r\n\r\n            } else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\r\n                // orthographic\r\n                panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\r\n                panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\r\n\r\n            } else {\r\n\r\n                // camera neither orthographic nor perspective\r\n                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n                scope.enablePan = false;\r\n\r\n            }\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    function dollyIn( dollyScale ) {\r\n\r\n        if ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\r\n            scale /= dollyScale;\r\n\r\n        } else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\r\n            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n\r\n        } else {\r\n\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n            scope.enableZoom = false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function dollyOut( dollyScale ) {\r\n\r\n        if ( scope.object instanceof THREE.PerspectiveCamera ) {\r\n\r\n            scale *= dollyScale;\r\n\r\n        } else if ( scope.object instanceof THREE.OrthographicCamera ) {\r\n\r\n            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n\r\n        } else {\r\n\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n            scope.enableZoom = false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //\r\n    // event callbacks - update the object state\r\n    //\r\n\r\n    function handleMouseDownRotate( event ) {\r\n\r\n        //console.log( 'handleMouseDownRotate' );\r\n\r\n        rotateStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseDownDolly( event ) {\r\n\r\n        //console.log( 'handleMouseDownDolly' );\r\n\r\n        dollyStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseDownPan( event ) {\r\n\r\n        //console.log( 'handleMouseDownPan' );\r\n\r\n        panStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseMoveRotate( event ) {\r\n\r\n        //console.log( 'handleMouseMoveRotate' );\r\n\r\n        rotateEnd.set( event.clientX, event.clientY );\r\n        rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        // rotating across whole screen goes 360 degrees around\r\n        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n        rotateStart.copy( rotateEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseMoveDolly( event ) {\r\n\r\n        //console.log( 'handleMouseMoveDolly' );\r\n\r\n        dollyEnd.set( event.clientX, event.clientY );\r\n\r\n        dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n        if ( dollyDelta.y > 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        } else if ( dollyDelta.y < 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        }\r\n\r\n        dollyStart.copy( dollyEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseMovePan( event ) {\r\n\r\n        //console.log( 'handleMouseMovePan' );\r\n\r\n        panEnd.set( event.clientX, event.clientY );\r\n\r\n        panDelta.subVectors( panEnd, panStart );\r\n\r\n        pan( panDelta.x, panDelta.y );\r\n\r\n        panStart.copy( panEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseUp( event ) {\r\n\r\n        // console.log( 'handleMouseUp' );\r\n\r\n    }\r\n\r\n    function handleMouseWheel( event ) {\r\n\r\n        // console.log( 'handleMouseWheel' );\r\n\r\n        if ( event.deltaY < 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        } else if ( event.deltaY > 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        }\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleKeyDown( event ) {\r\n\r\n        //console.log( 'handleKeyDown' );\r\n\r\n        switch ( event.keyCode ) {\r\n\r\n            case scope.keys.UP:\r\n                pan( 0, scope.keyPanSpeed );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.BOTTOM:\r\n                pan( 0, - scope.keyPanSpeed );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.LEFT:\r\n                pan( scope.keyPanSpeed, 0 );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.RIGHT:\r\n                pan( - scope.keyPanSpeed, 0 );\r\n                scope.update();\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function handleTouchStartRotate( event ) {\r\n\r\n        //console.log( 'handleTouchStartRotate' );\r\n\r\n        rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n    }\r\n\r\n    function handleTouchStartDolly( event ) {\r\n\r\n        //console.log( 'handleTouchStartDolly' );\r\n\r\n        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        dollyStart.set( 0, distance );\r\n\r\n    }\r\n\r\n    function handleTouchStartPan( event ) {\r\n\r\n        //console.log( 'handleTouchStartPan' );\r\n\r\n        panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n    }\r\n\r\n    function handleTouchMoveRotate( event ) {\r\n\r\n        //console.log( 'handleTouchMoveRotate' );\r\n\r\n        rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n        rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        // rotating across whole screen goes 360 degrees around\r\n        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n        rotateStart.copy( rotateEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchMoveDolly( event ) {\r\n\r\n        //console.log( 'handleTouchMoveDolly' );\r\n\r\n        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        dollyEnd.set( 0, distance );\r\n\r\n        dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n        if ( dollyDelta.y > 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        } else if ( dollyDelta.y < 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        }\r\n\r\n        dollyStart.copy( dollyEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchMovePan( event ) {\r\n\r\n        //console.log( 'handleTouchMovePan' );\r\n\r\n        panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n        panDelta.subVectors( panEnd, panStart );\r\n\r\n        pan( panDelta.x, panDelta.y );\r\n\r\n        panStart.copy( panEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchEnd( event ) {\r\n\r\n        //console.log( 'handleTouchEnd' );\r\n\r\n    }\r\n\r\n    //\r\n    // event handlers - FSM: listen for events and reset state\r\n    //\r\n\r\n    function onMouseDown( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        switch ( event.button ) {\r\n\r\n            case scope.mouseButtons.ORBIT:\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleMouseDownRotate( event );\r\n\r\n                state = STATE.ROTATE;\r\n\r\n                break;\r\n\r\n            case scope.mouseButtons.ZOOM:\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleMouseDownDolly( event );\r\n\r\n                state = STATE.DOLLY;\r\n\r\n                break;\r\n\r\n            case scope.mouseButtons.PAN:\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleMouseDownPan( event );\r\n\r\n                state = STATE.PAN;\r\n\r\n                break;\r\n\r\n        }\r\n\r\n        if ( state !== STATE.NONE ) {\r\n\r\n            document.addEventListener( 'mousemove', onMouseMove, false );\r\n            document.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n            scope.dispatchEvent( startEvent );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onMouseMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        switch ( state ) {\r\n\r\n            case STATE.ROTATE:\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleMouseMoveRotate( event );\r\n\r\n                break;\r\n\r\n            case STATE.DOLLY:\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleMouseMoveDolly( event );\r\n\r\n                break;\r\n\r\n            case STATE.PAN:\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleMouseMovePan( event );\r\n\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onMouseUp( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        handleMouseUp( event );\r\n\r\n        document.removeEventListener( 'mousemove', onMouseMove, false );\r\n        document.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        scope.dispatchEvent( endEvent );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onMouseWheel( event ) {\r\n\r\n        if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        handleMouseWheel( event );\r\n\r\n        scope.dispatchEvent( startEvent ); // not sure why these are here...\r\n        scope.dispatchEvent( endEvent );\r\n\r\n    }\r\n\r\n    function onKeyDown( event ) {\r\n\r\n        if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\r\n\r\n        handleKeyDown( event );\r\n\r\n    }\r\n\r\n    function onTouchStart( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1:\t// one-fingered touch: rotate\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleTouchStartRotate( event );\r\n\r\n                state = STATE.TOUCH_ROTATE;\r\n\r\n                break;\r\n\r\n            case 2:\t// two-fingered touch: dolly\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleTouchStartDolly( event );\r\n\r\n                state = STATE.TOUCH_DOLLY;\r\n\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleTouchStartPan( event );\r\n\r\n                state = STATE.TOUCH_PAN;\r\n\r\n                break;\r\n\r\n            default:\r\n\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n        if ( state !== STATE.NONE ) {\r\n\r\n            scope.dispatchEvent( startEvent );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onTouchMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1: // one-fingered touch: rotate\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n                if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\r\n\r\n                handleTouchMoveRotate( event );\r\n\r\n                break;\r\n\r\n            case 2: // two-fingered touch: dolly\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n                if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\r\n\r\n                handleTouchMoveDolly( event );\r\n\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n\r\n                if ( scope.enablePan === false ) return;\r\n                if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\r\n\r\n                handleTouchMovePan( event );\r\n\r\n                break;\r\n\r\n            default:\r\n\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onTouchEnd( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        handleTouchEnd( event );\r\n\r\n        scope.dispatchEvent( endEvent );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onContextMenu( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n    }\r\n\r\n    //\r\n\r\n    scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\r\n\r\n    scope.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n    scope.domElement.addEventListener( 'wheel', onMouseWheel, false );\r\n\r\n    scope.domElement.addEventListener( 'touchstart', onTouchStart, false );\r\n    scope.domElement.addEventListener( 'touchend', onTouchEnd, false );\r\n    scope.domElement.addEventListener( 'touchmove', onTouchMove, false );\r\n\r\n    window.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n    // force an update at start\r\n\r\n    this.update();\r\n\r\n};\r\n\r\nOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\r\nOrbitControls.prototype.constructor = OrbitControls;\r\n\r\nObject.defineProperties( OrbitControls.prototype, {\r\n\r\n    center: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .center has been renamed to .target' );\r\n            return this.target;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    // backward compatibility\r\n\r\n    noZoom: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n            return ! this.enableZoom;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n            this.enableZoom = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noRotate: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n            return ! this.enableRotate;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n            this.enableRotate = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noPan: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n            return ! this.enablePan;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n            this.enablePan = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noKeys: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n            return ! this.enableKeys;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n            this.enableKeys = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    staticMoving: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n            return ! this.enableDamping;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n            this.enableDamping = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    dynamicDampingFactor: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n            return this.dampingFactor;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n            this.dampingFactor = value;\r\n\r\n        }\r\n\r\n    }\r\n\r\n} );",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/lib/OrbitControls.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 99,
    "kind": "function",
    "name": "OrbitControls",
    "memberof": "src/lib/OrbitControls.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/OrbitControls.js~OrbitControls",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/lib/OrbitControls.js",
    "importStyle": "OrbitControls",
    "description": "",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@author",
        "tagValue": "qiao / https://github.com/qiao"
      },
      {
        "tagName": "@author",
        "tagValue": "mrdoob / http://mrdoob.com"
      },
      {
        "tagName": "@author",
        "tagValue": "alteredq / http://alteredqualia.com/"
      },
      {
        "tagName": "@author",
        "tagValue": "WestLangley / http://github.com/WestLangley"
      },
      {
        "tagName": "@author",
        "tagValue": "erich666 / http://erichaines.com"
      }
    ],
    "params": [
      {
        "name": "object",
        "types": [
          "*"
        ]
      },
      {
        "name": "domElement",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 100,
    "kind": "file",
    "name": "src/model/index.js",
    "content": "import * as THREE from \"three\";\r\n\r\nrequire(\"three-instanced-mesh\")(THREE);\r\nimport * as $ from 'jquery';\r\nimport merge from 'deepmerge'\r\nimport Render, { defaultOptions, deepDisposeMesh, mergeCubeMeshes } from \"../renderBase\";\r\nimport { loadTextureAsBase64, scaleUv, DEFAULT_ROOT, loadJsonFromPath, loadBlockState, loadTextureMeta } from \"../functions\";\r\nimport ModelConverter from \"./modelConverter\";\r\nimport * as md5 from \"md5\";\r\n\r\nimport { parseModel, loadAndMergeModel, loadModelTexture, modelCacheKey, toRadians, deleteObjectProperties, loadTextures } from \"./modelFunctions\";\r\n\r\nimport work from 'webworkify-webpack';\r\nimport SkinRender from \"../skin\";\r\nconst ModelWorker = require.resolve(\"./ModelWorker.js\");\r\n\r\n\r\nString.prototype.replaceAll = function (search, replacement) {\r\n    let target = this;\r\n    return target.replace(new RegExp(search, 'g'), replacement);\r\n};\r\n\r\nconst colors = [\r\n    0xFF0000,\r\n    0x00FFFF,\r\n    0x0000FF,\r\n    0x000080,\r\n    0xFF00FF,\r\n    0x800080,\r\n    0x808000,\r\n    0x00FF00,\r\n    0x008000,\r\n    0xFFFF00,\r\n    0x800000,\r\n    0x008080,\r\n];\r\n\r\nconst FACE_ORDER = [\"east\", \"west\", \"up\", \"down\", \"south\", \"north\"];\r\nconst TINTS = [\"lightgreen\"];\r\n\r\nconst mergedModelCache = {};\r\nconst loadedTextureCache = {};\r\nconst modelInstances = {};\r\n\r\nconst textureCache = {};\r\nconst canvasCache = {};\r\nconst materialCache = {};\r\nconst geometryCache = {};\r\nconst instanceCache = {};\r\n\r\nconst animatedTextures = [];\r\n\r\n/**\r\n * @see defaultOptions\r\n * @property {string} type alternative way to specify the model type (block/item)\r\n * @property {boolean} [centerCubes=false] center the cube's rotation point\r\n * @property {string} [assetRoot=DEFAULT_ROOT] root to get asset files from\r\n */\r\nlet defOptions = {\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 35,\r\n        y: 25,\r\n        z: 20,\r\n        target: [0, 0, 0]\r\n    },\r\n    type: \"block\",\r\n    centerCubes: false,\r\n    assetRoot: DEFAULT_ROOT,\r\n    useWebWorkers: false\r\n};\r\n\r\n/**\r\n * A renderer for Minecraft models, i.e. blocks & items\r\n */\r\nclass ModelRender extends Render {\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {string} [options.assetRoot=DEFAULT_ROOT] root to get asset files from\r\n     *\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, element) {\r\n        super(options, defOptions, element);\r\n\r\n        this.renderType = \"ModelRender\";\r\n\r\n        this.models = [];\r\n        this.attached = false;\r\n    }\r\n\r\n    /**\r\n     * Does the actual rendering\r\n     * @param {(string[]|Object[])} models Array of models to render - Either strings in the format <block|item>/<model name> or objects\r\n     * @param {string} [models[].type=block] either 'block' or 'item'\r\n     * @param {string} models[].model if 'type' is given, just the block/item name otherwise '<block|item>/<model name>'\r\n     * @param {number[]} [models[].offset] [x,y,z] array of the offset\r\n     * @param {number[]} [models[].rotation] [x,y,z] array of the rotation\r\n     * @param {string} [models[].blockstate] name of a blockstate to be used to determine the models (only for blocks)\r\n     * @param {string} [models[].variant=normal] if 'blockstate' is given, the block variant to use\r\n     * @param {function} [cb] Callback when rendering finished\r\n     */\r\n    render(models, cb) {\r\n        let modelRender = this;\r\n\r\n        if (!modelRender.attached && !modelRender._scene) {// Don't init scene if attached, since we already have an available scene\r\n            super.initScene(function () {\r\n                // Animate textures\r\n                for (let i = 0; i < animatedTextures.length; i++) {\r\n                    animatedTextures[i]();\r\n                }\r\n\r\n                modelRender.element.dispatchEvent(new CustomEvent(\"modelRender\", {detail: {models: modelRender.models}}));\r\n            });\r\n        } else {\r\n            console.log(\"[ModelRender] is attached - skipping scene init\");\r\n        }\r\n\r\n        let parsedModelList = [];\r\n\r\n        parseModels(modelRender, models, parsedModelList)\r\n            .then(() => loadAndMergeModels(modelRender, parsedModelList))\r\n            .then(() => loadModelTextures(modelRender, parsedModelList))\r\n            .then(() => doModelRender(modelRender, parsedModelList))\r\n            .then((renderedModels) => {\r\n                console.timeEnd(\"doModelRender\");\r\n                console.debug(renderedModels)\r\n                if (typeof cb === \"function\") cb();\r\n            })\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction parseModels(modelRender, models, parsedModelList) {\r\n    console.time(\"parseModels\");\r\n    console.log(\"Parsing Models...\");\r\n    let parsePromises = [];\r\n    for (let i = 0; i < models.length; i++) {\r\n        let model = models[i];\r\n\r\n        // parsePromises.push(parseModel(model, model, parsedModelList, modelRender.options.assetRoot))\r\n        parsePromises.push(new Promise(resolve => {\r\n            if(modelRender.options.useWebWorkers) {\r\n                let w = work(ModelWorker);\r\n                w.addEventListener('message', event => {\r\n                    parsedModelList.push(...event.data.parsedModelList);\r\n                    resolve();\r\n                });\r\n                w.postMessage({\r\n                    func: \"parseModel\",\r\n                    model: model,\r\n                    modelOptions: model,\r\n                    parsedModelList: parsedModelList,\r\n                    assetRoot: modelRender.options.assetRoot\r\n                })\r\n            }else{\r\n                parseModel(model, model, parsedModelList, modelRender.options.assetRoot).then(()=>{\r\n                    resolve();\r\n                })\r\n            }\r\n        }))\r\n\r\n    }\r\n\r\n    return Promise.all(parsePromises);\r\n}\r\n\r\n\r\nfunction loadAndMergeModels(modelRender, parsedModelList) {\r\n    console.timeEnd(\"parseModels\");\r\n    console.time(\"loadAndMergeModels\");\r\n\r\n    let jsonPromises = [];\r\n\r\n    console.log(\"Loading Model JSON data & merging...\");\r\n    let uniqueModels = {};\r\n    for (let i = 0; i < parsedModelList.length; i++) {\r\n        let cacheKey = modelCacheKey(parsedModelList[i]);\r\n        modelInstances[cacheKey] = (modelInstances[cacheKey] || 0) + 1;\r\n        uniqueModels[cacheKey] = parsedModelList[i];\r\n    }\r\n    let uniqueModelList = Object.values(uniqueModels);\r\n    console.debug(uniqueModelList.length + \" unique models\");\r\n    for (let i = 0; i < uniqueModelList.length; i++) {\r\n        jsonPromises.push(new Promise(resolve => {\r\n            let model = uniqueModelList[i];\r\n            let cacheKey = modelCacheKey(model);\r\n            console.debug(\"loadAndMerge \" + cacheKey);\r\n\r\n\r\n\r\n            if (mergedModelCache.hasOwnProperty(cacheKey)) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if(modelRender.options.useWebWorkers) {\r\n                let w = work(ModelWorker);\r\n                w.addEventListener('message', event => {\r\n                    mergedModelCache[cacheKey] = event.data.mergedModel;\r\n                    resolve();\r\n                });\r\n                w.postMessage({\r\n                    func: \"loadAndMergeModel\",\r\n                    model: model,\r\n                    assetRoot: modelRender.options.assetRoot\r\n                });\r\n            }else{\r\n                loadAndMergeModel(model,modelRender.options.assetRoot).then((mergedModel)=>{\r\n                    mergedModelCache[cacheKey] = mergedModel;\r\n                    resolve();\r\n                })\r\n            }\r\n        }))\r\n    }\r\n\r\n    return Promise.all(jsonPromises);\r\n}\r\n\r\nfunction loadModelTextures(modelRender, parsedModelList) {\r\n    console.timeEnd(\"loadAndMergeModels\");\r\n    console.time(\"loadModelTextures\");\r\n\r\n    let texturePromises = [];\r\n\r\n    console.log(\"Loading Textures...\");\r\n    let uniqueModels = {};\r\n    for (let i = 0; i < parsedModelList.length; i++) {\r\n        uniqueModels[modelCacheKey(parsedModelList[i])] = parsedModelList[i];\r\n    }\r\n    let uniqueModelList = Object.values(uniqueModels);\r\n    console.debug(uniqueModelList.length + \" unique models\");\r\n    for (let i = 0; i < uniqueModelList.length; i++) {\r\n        texturePromises.push(new Promise(resolve => {\r\n            let model = uniqueModelList[i];\r\n            let cacheKey = modelCacheKey(model);\r\n            console.debug(\"loadTexture \" + cacheKey);\r\n            let mergedModel = mergedModelCache[cacheKey];\r\n\r\n            if (loadedTextureCache.hasOwnProperty(cacheKey)) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if (!mergedModel) {\r\n                console.warn(\"Missing merged model\");\r\n                console.warn(model.name);\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if (!mergedModel.textures) {\r\n                console.warn(\"The model doesn't have any textures!\");\r\n                console.warn(\"Please make sure you're using the proper file.\");\r\n                console.warn(model.name);\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if(modelRender.options.useWebWorkers) {\r\n                let w = work(ModelWorker);\r\n                w.addEventListener('message', event => {\r\n                    loadedTextureCache[cacheKey] = event.data.textures;\r\n                    resolve();\r\n                });\r\n                w.postMessage({\r\n                    func: \"loadTextures\",\r\n                    textures: mergedModel.textures,\r\n                    assetRoot: modelRender.options.assetRoot\r\n                });\r\n            }else{\r\n                loadTextures(mergedModel.textures, modelRender.options.assetRoot).then((textures)=>{\r\n                    loadedTextureCache[cacheKey] = textures;\r\n                    resolve();\r\n                })\r\n            }\r\n        }))\r\n    }\r\n\r\n\r\n    return Promise.all(texturePromises);\r\n}\r\n\r\nfunction doModelRender(modelRender, parsedModelList) {\r\n    console.timeEnd(\"loadModelTextures\");\r\n    console.time(\"doModelRender\");\r\n\r\n    console.log(\"Rendering Models...\");\r\n\r\n    let renderPromises = [];\r\n\r\n    for (let i = 0; i < parsedModelList.length; i++) {\r\n        renderPromises.push(new Promise(resolve => {\r\n            let model = parsedModelList[i];\r\n\r\n            let mergedModel = mergedModelCache[modelCacheKey(model)];\r\n            let textures = loadedTextureCache[modelCacheKey(model)];\r\n\r\n            let offset = model.offset || [0, 0, 0];\r\n            let rotation = model.rotation || [0, 0, 0];\r\n            let scale = model.scale || [1, 1, 1];\r\n\r\n            if (model.options.hasOwnProperty(\"display\")) {\r\n                if (mergedModel.hasOwnProperty(\"display\")) {\r\n                    if (mergedModel.display.hasOwnProperty(model.options.display)) {\r\n                        let displayData = mergedModel.display[model.options.display];\r\n\r\n                        if (displayData.hasOwnProperty(\"translation\")) {\r\n                            offset = [offset[0] + displayData.translation[0], offset[1] + displayData.translation[1], offset[2] + displayData.translation[2]];\r\n                        }\r\n                        if (displayData.hasOwnProperty(\"rotation\")) {\r\n                            rotation = [rotation[0] + displayData.rotation[0], rotation[1] + displayData.rotation[1], rotation[2] + displayData.rotation[2]];\r\n                        }\r\n                        if (displayData.hasOwnProperty(\"scale\")) {\r\n                            scale = [displayData.scale[0], displayData.scale[1], displayData.scale[2]];\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            renderModel(modelRender, mergedModel, textures, mergedModel.textures, model.type, model.name, model.variant, offset, rotation, scale).then((renderedModel) => {\r\n\r\n                if (renderedModel.firstInstance) {\r\n                    let container = new THREE.Object3D();\r\n                    container.add(renderedModel.mesh);\r\n\r\n                    modelRender.models.push(container);\r\n                    modelRender.addToScene(container);\r\n                }\r\n\r\n                resolve(renderedModel);\r\n            })\r\n        }))\r\n    }\r\n\r\n    return Promise.all(renderPromises);\r\n}\r\n\r\n\r\nlet renderModel = function (modelRender, model, textures, textureNames, type, name, variant, offset, rotation, scale) {\r\n    return new Promise((resolve) => {\r\n        if (model.hasOwnProperty(\"elements\")) {// block OR item with block parent\r\n            let modelKey = modelCacheKey({type: type, name: name, variant: variant});\r\n            let instanceCount = modelInstances[modelKey];\r\n\r\n            let applyModelTransforms = function (mesh, instanceIndex) {\r\n                mesh.userData.modelType = type;\r\n                mesh.userData.modelName = name;\r\n\r\n                let _v3o = new THREE.Vector3();\r\n                let _v3s = new THREE.Vector3();\r\n                let _q = new THREE.Quaternion();\r\n\r\n                if (rotation) {\r\n                    mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(rotation[0]), toRadians(Math.abs(rotation[0]) > 0 ? rotation[1] : -rotation[1]), toRadians(rotation[2]))));\r\n                }\r\n                if (offset) {\r\n                    mesh.setPositionAt(instanceIndex, _v3o.set(offset[0], offset[1], offset[2]));\r\n                }\r\n                if (scale) {\r\n                    mesh.setScaleAt(instanceIndex, _v3s.set(scale[0], scale[1], scale[2]));\r\n                }\r\n\r\n                mesh.needsUpdate();\r\n\r\n                // mesh.position = _v3o;\r\n                // Object.defineProperty(mesh.position,\"x\",{\r\n                //     get:function () {\r\n                //         return this._x||0;\r\n                //     },\r\n                //     set:function (x) {\r\n                //         this._x=x;\r\n                //         mesh.setPositionAt(instanceIndex, _v3o.set(x, this.y, this.z));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.position,\"y\",{\r\n                //     get:function () {\r\n                //         return this._y||0;\r\n                //     },\r\n                //     set:function (y) {\r\n                //         this._y=y;\r\n                //         mesh.setPositionAt(instanceIndex, _v3o.set(this.x, y, this.z));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.position,\"z\",{\r\n                //     get:function () {\r\n                //         return this._z||0;\r\n                //     },\r\n                //     set:function (z) {\r\n                //         this._z=z;\r\n                //         mesh.setPositionAt(instanceIndex, _v3o.set(this.x, this.y, z));\r\n                //     }\r\n                // })\r\n                //\r\n                // mesh.rotation = new THREE.Euler(toRadians(rotation[0]), toRadians(Math.abs(rotation[0]) > 0 ? rotation[1] : -rotation[1]), toRadians(rotation[2]));\r\n                // Object.defineProperty(mesh.rotation,\"x\",{\r\n                //     get:function () {\r\n                //         return this._x||0;\r\n                //     },\r\n                //     set:function (x) {\r\n                //         this._x=x;\r\n                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(x), toRadians(this.y), toRadians(this.z))));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.rotation,\"y\",{\r\n                //     get:function () {\r\n                //         return this._y||0;\r\n                //     },\r\n                //     set:function (y) {\r\n                //         this._y=y;\r\n                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(this.x), toRadians(y), toRadians(this.z))));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.rotation,\"z\",{\r\n                //     get:function () {\r\n                //         return this._z||0;\r\n                //     },\r\n                //     set:function (z) {\r\n                //         this._z=z;\r\n                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(this.x), toRadians(this.y), toRadians(z))));\r\n                //     }\r\n                // });\r\n                //\r\n                // mesh.scale = _v3s;\r\n\r\n                resolve({\r\n                    mesh: mesh,\r\n                    firstInstance: instanceIndex === 0\r\n                });\r\n            };\r\n\r\n            let finalizeCubeModel = function (geometry, materials) {\r\n                geometry.translate(-8, -8, -8);\r\n\r\n\r\n                let cachedInstance;\r\n\r\n                if (!instanceCache.hasOwnProperty(modelKey)) {\r\n                    console.debug(\"Caching new model instance \" + modelKey + \" (with \" + instanceCount + \" instances)\");\r\n                    let newInstance = new THREE.InstancedMesh(\r\n                        geometry,\r\n                        materials,\r\n                        instanceCount,\r\n                        false,\r\n                        false,\r\n                        false);\r\n                    cachedInstance = {\r\n                        instance: newInstance,\r\n                        index: 0\r\n                    };\r\n                    instanceCache[modelKey] = cachedInstance;\r\n                    let _v3o = new THREE.Vector3();\r\n                    let _v3s = new THREE.Vector3(1, 1, 1);\r\n                    let _q = new THREE.Quaternion();\r\n\r\n                    for (let i = 0; i < instanceCount; i++) {\r\n\r\n                        newInstance.setQuaternionAt(i, _q);\r\n                        newInstance.setPositionAt(i, _v3o);\r\n                        newInstance.setScaleAt(i, _v3s);\r\n\r\n                    }\r\n                } else {\r\n                    console.debug(\"Using cached instance (\" + modelKey + \")\");\r\n                    cachedInstance = instanceCache[modelKey];\r\n\r\n                }\r\n\r\n                applyModelTransforms(cachedInstance.instance, cachedInstance.index++);\r\n            };\r\n\r\n            if (instanceCache.hasOwnProperty(modelKey)) {\r\n                console.debug(\"Using cached model instance (\" + modelKey + \")\");\r\n                let cachedInstance = instanceCache[modelKey];\r\n                applyModelTransforms(cachedInstance.instance, cachedInstance.index++);\r\n                return;\r\n            }\r\n\r\n            // Render the elements\r\n            let promises = [];\r\n            for (let i = 0; i < model.elements.length; i++) {\r\n                let element = model.elements[i];\r\n\r\n                // // From net.minecraft.client.renderer.block.model.BlockPart.java#47 - https://yeleha.co/2JcqSr4\r\n                let fallbackFaces = {\r\n                    down: {\r\n                        uv: [element.from[0], 16 - element.to[2], element.to[0], 16 - element.from[2]],\r\n                        texture: \"#down\"\r\n                    },\r\n                    up: {\r\n                        uv: [element.from[0], element.from[2], element.to[0], element.to[2]],\r\n                        texture: \"#up\"\r\n                    },\r\n                    north: {\r\n                        uv: [16 - element.to[0], 16 - element.to[1], 16 - element.from[0], 16 - element.from[1]],\r\n                        texture: \"#north\"\r\n                    },\r\n                    south: {\r\n                        uv: [element.from[0], 16 - element.to[1], element.to[0], 16 - element.from[1]],\r\n                        texture: \"#south\"\r\n                    },\r\n                    west: {\r\n                        uv: [element.from[2], 16 - element.to[1], element.to[2], 16 - element.from[2]],\r\n                        texture: \"#west\"\r\n                    },\r\n                    east: {\r\n                        uv: [16 - element.to[2], 16 - element.to[1], 16 - element.from[2], 16 - element.from[1]],\r\n                        texture: \"#east\"\r\n                    }\r\n                };\r\n\r\n                promises.push(new Promise((resolve) => {\r\n                    let baseName =name.replaceAll(\" \", \"_\").replaceAll(\"-\", \"_\").toLowerCase() + \"_\" + (element.__comment ? element.__comment.replaceAll(\" \", \"_\").replaceAll(\"-\", \"_\").toLowerCase() + \"_\" : \"\");\r\n                    createCube(element.to[0] - element.from[0], element.to[1] - element.from[1], element.to[2] - element.from[2],\r\n                        baseName + Date.now(),\r\n                        element.faces, fallbackFaces, textures, textureNames, modelRender.options.assetRoot, baseName)\r\n                        .then((cube) => {\r\n                            cube.applyMatrix(new THREE.Matrix4().makeTranslation((element.to[0] - element.from[0]) / 2, (element.to[1] - element.from[1]) / 2, (element.to[2] - element.from[2]) / 2));\r\n                            cube.applyMatrix(new THREE.Matrix4().makeTranslation(element.from[0], element.from[1], element.from[2]));\r\n\r\n                            if (element.rotation) {\r\n                                rotateAboutPoint(cube,\r\n                                    new THREE.Vector3(element.rotation.origin[0], element.rotation.origin[1], element.rotation.origin[2]),\r\n                                    new THREE.Vector3(element.rotation.axis === \"x\" ? 1 : 0, element.rotation.axis === \"y\" ? 1 : 0, element.rotation.axis === \"z\" ? 1 : 0),\r\n                                    toRadians(element.rotation.angle));\r\n                            }\r\n\r\n                            resolve(cube);\r\n                        })\r\n                }));\r\n\r\n\r\n            }\r\n\r\n            Promise.all(promises).then((cubes) => {\r\n                let mergedCubes = mergeCubeMeshes(cubes, true);\r\n                mergedCubes.sourceSize = cubes.length;\r\n                finalizeCubeModel(mergedCubes.geometry, mergedCubes.materials, cubes.length);\r\n                for (let i = 0; i < cubes.length; i++) {\r\n                    deepDisposeMesh(cubes[i], true);\r\n                }\r\n            })\r\n        } else {// 2d item\r\n            createPlane(name + \"_\" + Date.now(), textures).then((plane) => {\r\n                if (offset) {\r\n                    plane.applyMatrix(new THREE.Matrix4().makeTranslation(offset[0], offset[1], offset[2]))\r\n                }\r\n                if (rotation) {\r\n                    plane.rotation.set(toRadians(rotation[0]), toRadians(Math.abs(rotation[0]) > 0 ? rotation[1] : -rotation[1]), toRadians(rotation[2]));\r\n                }\r\n                if (scale) {\r\n                    plane.scale.set(scale[0], scale[1], scale[2]);\r\n                }\r\n\r\n                resolve({\r\n                    mesh: plane,\r\n                    firstInstance: true\r\n                });\r\n            })\r\n        }\r\n    })\r\n};\r\n\r\nlet createDot = function (c) {\r\n    let dotGeometry = new THREE.Geometry();\r\n    dotGeometry.vertices.push(new THREE.Vector3());\r\n    let dotMaterial = new THREE.PointsMaterial({size: 5, sizeAttenuation: false, color: c});\r\n    return new THREE.Points(dotGeometry, dotMaterial);\r\n};\r\n\r\nlet createPlane = function (name, textures) {\r\n    return new Promise((resolve) => {\r\n\r\n        let materialLoaded = function (material, width, height) {\r\n            let geometry = new THREE.PlaneGeometry(width, height);\r\n            let plane = new THREE.Mesh(geometry, material);\r\n            plane.name = name;\r\n            plane.receiveShadow = true;\r\n\r\n            resolve(plane);\r\n        };\r\n\r\n        if (textures) {\r\n            let w = 0, h = 0;\r\n            let promises = [];\r\n            for (let t in textures) {\r\n                if (textures.hasOwnProperty(t)) {\r\n                    promises.push(new Promise((resolve) => {\r\n                        let img = new Image();\r\n                        img.onload = function () {\r\n                            if (img.width > w) w = img.width;\r\n                            if (img.height > h) h = img.height;\r\n                            resolve(img);\r\n                        };\r\n                        img.src = textures[t];\r\n                    }))\r\n                }\r\n            }\r\n            Promise.all(promises).then((images) => {\r\n                let canvas = document.createElement(\"canvas\");\r\n                canvas.width = w;\r\n                canvas.height = h;\r\n                let context = canvas.getContext(\"2d\");\r\n\r\n                for (let i = 0; i < images.length; i++) {\r\n                    let img = images[i];\r\n                    context.drawImage(img, 0, 0);\r\n                }\r\n\r\n                let data = canvas.toDataURL(\"image/png\");\r\n                let hash = md5(data);\r\n\r\n                if (materialCache.hasOwnProperty(hash)) {// Use material from cache\r\n                    console.debug(\"Using cached Material (\" + hash + \")\");\r\n                    materialLoaded(materialCache[hash], w, h);\r\n                    return;\r\n                }\r\n\r\n                let textureLoaded = function (texture) {\r\n                    let material = new THREE.MeshBasicMaterial({\r\n                        map: texture,\r\n                        transparent: true,\r\n                        side: THREE.DoubleSide,\r\n                        alphaTest: 0.5,\r\n                        name: name\r\n                    });\r\n\r\n                    // Add material to cache\r\n                    console.debug(\"Caching Material \" + hash);\r\n                    materialCache[hash] = material;\r\n\r\n                    materialLoaded(material, w, h);\r\n                };\r\n\r\n                if (textureCache.hasOwnProperty(hash)) {// Use texture to cache\r\n                    console.debug(\"Using cached Texture (\" + hash + \")\");\r\n                    textureLoaded(textureCache[hash]);\r\n                    return;\r\n                }\r\n\r\n                console.debug(\"Pre-Caching Texture \" + hash);\r\n                textureCache[hash] = new THREE.TextureLoader().load(data, function (texture) {\r\n                    texture.magFilter = THREE.NearestFilter;\r\n                    texture.minFilter = THREE.NearestFilter;\r\n                    texture.anisotropy = 0;\r\n                    texture.needsUpdate = true;\r\n\r\n                    console.debug(\"Caching Texture \" + hash);\r\n                    // Add texture to cache\r\n                    textureCache[hash] = texture;\r\n\r\n                    textureLoaded(texture);\r\n                });\r\n            });\r\n        }\r\n\r\n    })\r\n};\r\n\r\n\r\n/// From https://github.com/InventivetalentDev/SkinRender/blob/master/js/render/skin.js#L353\r\nlet createCube = function (width, height, depth, name, faces, fallbackFaces, textures, textureNames, assetRoot, baseName) {\r\n    return new Promise((resolve) => {\r\n        let geometryKey = width + \"_\" + height + \"_\" + depth;\r\n        let geometry;\r\n        if (geometryCache.hasOwnProperty(geometryKey)) {\r\n            console.debug(\"Using cached Geometry (\" + geometryKey + \")\");\r\n            geometry = geometryCache[geometryKey];\r\n        } else {\r\n            geometry = new THREE.BoxGeometry(width, height, depth);\r\n            console.debug(\"Caching Geometry \" + geometryKey);\r\n            geometryCache[geometryKey] = geometry;\r\n        }\r\n\r\n        let materialsLoaded = function (materials) {\r\n            let cube = new THREE.Mesh(geometry, materials);\r\n            cube.name = name;\r\n            cube.receiveShadow = true;\r\n\r\n            resolve(cube);\r\n        };\r\n        if (textures) {\r\n            let promises = [];\r\n            for (let i = 0; i < 6; i++) {\r\n                promises.push(new Promise((resolve) => {\r\n                    let f = FACE_ORDER[i];\r\n                    if (!faces.hasOwnProperty(f)) {\r\n                        // console.warn(\"Missing face: \" + f + \" in model \" + name);\r\n                        resolve(null);\r\n                        return;\r\n                    }\r\n                    let face = faces[f];\r\n                    let textureRef = face.texture.substr(1);\r\n                    if (!textures.hasOwnProperty(textureRef)) {\r\n                        console.warn(\"Missing texture '\" + textureRef + \"' for face \" + f + \" in model \" + name);\r\n                        resolve(null);\r\n                        return;\r\n                    }\r\n\r\n                    let canvasKey = textureRef + \"_\" + f + \"_\" + baseName;\r\n\r\n                    let processImgToCanvasData = (img)=>{\r\n                        let uv = face.uv;\r\n                        if (!uv) {\r\n                            // console.warn(\"Missing UV mapping for face \" + f + \" in model \" + name + \". Using defaults\");\r\n                            uv = fallbackFaces[f].uv;\r\n                        }\r\n\r\n                        // Scale the uv values to match the image width, so we can support resource packs with higher-resolution textures\r\n                        uv = [\r\n                            scaleUv(uv[0], img.width),\r\n                            scaleUv(uv[1], img.height),\r\n                            scaleUv(uv[2], img.width),\r\n                            scaleUv(uv[3], img.height)\r\n                        ];\r\n\r\n\r\n                        let canvas = document.createElement(\"canvas\");\r\n                        canvas.width = Math.abs(uv[2] - uv[0]);\r\n                        canvas.height = Math.abs(uv[3] - uv[1]);\r\n\r\n                        let context = canvas.getContext(\"2d\");\r\n                        context.drawImage(img, Math.min(uv[0], uv[2]), Math.min(uv[1], uv[3]), canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);\r\n\r\n                        if (face.hasOwnProperty(\"tintindex\")) {\r\n                            context.fillStyle = TINTS[face.tintindex];\r\n                            context.globalCompositeOperation = 'multiply';\r\n                            context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n                            context.globalAlpha = 1;\r\n                            context.globalCompositeOperation = 'destination-in';\r\n                            context.drawImage(img, Math.min(uv[0], uv[2]), Math.min(uv[1], uv[3]), canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);\r\n\r\n                            // context.globalAlpha = 0.5;\r\n                            // context.beginPath();\r\n                            // context.fillStyle = \"green\";\r\n                            // context.rect(0, 0, uv[2] - uv[0], uv[3] - uv[1]);\r\n                            // context.fill();\r\n                            // context.globalAlpha = 1.0;\r\n                        }\r\n\r\n                        let canvasData = context.getImageData(0, 0, canvas.width, canvas.height).data;\r\n                        let hasTransparency = false;\r\n                        for (let i = 3; i < (canvas.width * canvas.height); i += 4) {\r\n                            if (canvasData[i] < 255) {\r\n                                hasTransparency = true;\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        let dataUrl =  canvas.toDataURL(\"image/png\");\r\n                        let dataHash = md5(dataUrl);\r\n\r\n                        let d = {\r\n                            data: canvasData,\r\n                            dataUrl: dataUrl,\r\n                            dataUrlHash: dataHash,\r\n                            hasTransparency: hasTransparency,\r\n                            width: canvas.width,\r\n                            height: canvas.height\r\n                        };\r\n                        console.debug(\"Caching new canvas (\"+canvasKey+\"/\"+dataHash+\")\")\r\n                        canvasCache[canvasKey] = d;\r\n                        return d;\r\n                    };\r\n\r\n                    let loadTextureFromCanvas = (canvas)=>{\r\n\r\n\r\n                        let loadTextureDefault = function (canvas) {\r\n                            let data = canvas.dataUrl;\r\n                            let hash =canvas.dataUrlHash;\r\n                            let hasTransparency = canvas.hasTransparency;\r\n\r\n                            if (materialCache.hasOwnProperty(hash)) {// Use material from cache\r\n                                console.debug(\"Using cached Material (\" + hash + \")\");\r\n                                resolve(materialCache[hash]);\r\n                                return;\r\n                            }\r\n\r\n                            let textureLoaded = function (texture) {\r\n                                let n = textureNames[textureRef];\r\n                                if (n.startsWith(\"#\")) {\r\n                                    n = textureNames[name.substr(1)];\r\n                                }\r\n\r\n                                let material = new THREE.MeshBasicMaterial({\r\n                                    map: texture,\r\n                                    transparent: hasTransparency,\r\n                                    side: hasTransparency ? THREE.DoubleSide : THREE.FrontSide,\r\n                                    alphaTest: 0.5,\r\n                                    name: f + \"_\" + textureRef + \"_\" + n\r\n                                });\r\n\r\n                                // Add material to cache\r\n                                console.debug(\"Caching Material \" + hash);\r\n                                materialCache[hash] = material;\r\n\r\n                                resolve(material);\r\n                            };\r\n\r\n                            if (textureCache.hasOwnProperty(hash)) {// Use texture from cache\r\n                                console.debug(\"Using cached Texture (\" + hash + \")\");\r\n                                textureLoaded(textureCache[hash]);\r\n                                return;\r\n                            }\r\n\r\n                            console.debug(\"Pre-Caching Texture \" + hash);\r\n                            textureCache[hash] = new THREE.TextureLoader().load(data, function (texture) {\r\n                                texture.magFilter = THREE.NearestFilter;\r\n                                texture.minFilter = THREE.NearestFilter;\r\n                                texture.anisotropy = 0;\r\n                                texture.needsUpdate = true;\r\n\r\n                                if (face.hasOwnProperty(\"rotation\")) {\r\n                                    texture.center.x = .5;\r\n                                    texture.center.y = .5;\r\n                                    texture.rotation = toRadians(face.rotation);\r\n                                }\r\n\r\n                                console.debug(\"Caching Texture \" + hash);\r\n                                // Add texture to cache\r\n                                textureCache[hash] = texture;\r\n\r\n                                textureLoaded(texture);\r\n                            });\r\n                        };\r\n\r\n                        let loadTextureWithMeta = function (canvas, meta) {\r\n                            let hasTransparency = canvas.hasTransparency;\r\n                            let frametime = 1;\r\n                            if (meta.hasOwnProperty(\"animation\")) {\r\n                                if (meta.animation.hasOwnProperty(\"frametime\")) {\r\n                                    frametime = meta.animation.frametime;\r\n                                }\r\n                            }\r\n\r\n                            let parts = Math.floor(canvas.height / canvas.width);\r\n\r\n                            let promises1 = [];\r\n                            for (let i = 0; i < parts; i++) {\r\n                                promises1.push(new Promise((resolve) => {\r\n                                    let canvas1 = document.createElement(\"canvas\");\r\n                                    canvas1.width = canvas.width;\r\n                                    canvas1.height = canvas.width;\r\n                                    let context1 = canvas1.getContext(\"2d\");\r\n                                    context1.drawImage(canvas, 0, i * canvas.width, canvas.width, canvas.width, 0, 0, canvas.width, canvas.width);\r\n\r\n                                    let data = canvas1.toDataURL(\"image/png\");\r\n                                    let hash = md5(data);\r\n\r\n                                    if (textureCache.hasOwnProperty(hash)) {// Use texture to cache\r\n                                        console.debug(\"Using cached Texture (\" + hash + \")\");\r\n                                        resolve(textureCache[hash]);\r\n                                        return;\r\n                                    }\r\n\r\n                                    console.debug(\"Pre-Caching Texture \" + hash);\r\n                                    textureCache[hash] = new THREE.TextureLoader().load(data, function (texture) {\r\n                                        texture.magFilter = THREE.NearestFilter;\r\n                                        texture.minFilter = THREE.NearestFilter;\r\n                                        texture.anisotropy = 0;\r\n                                        texture.needsUpdate = true;\r\n\r\n                                        console.debug(\"Caching Texture \" + hash);\r\n                                        // add texture to cache\r\n                                        textureCache[hash] = texture;\r\n\r\n                                        resolve(texture);\r\n                                    });\r\n                                }));\r\n                            }\r\n\r\n                            Promise.all(promises1).then((textures) => {\r\n\r\n                                // Don't cache this material, since it's animated\r\n                                let material = new THREE.MeshBasicMaterial({\r\n                                    map: textures[0],\r\n                                    transparent: hasTransparency,\r\n                                    side: hasTransparency ? THREE.DoubleSide : THREE.FrontSide,\r\n                                    alphaTest: 0.5\r\n                                });\r\n\r\n                                let frameCounter = 0;\r\n                                let textureIndex = 0;\r\n                                animatedTextures.push(() => {// called on render\r\n                                    if (frameCounter >= frametime) {\r\n                                        frameCounter = 0;\r\n\r\n                                        // Set new texture\r\n                                        material.map = textures[textureIndex];\r\n\r\n                                        textureIndex++;\r\n                                    }\r\n                                    if (textureIndex >= textures.length) {\r\n                                        textureIndex = 0;\r\n                                    }\r\n                                    frameCounter += 0.1;// game ticks TODO: figure out the proper value for this\r\n                                })\r\n\r\n                                resolve(material);\r\n                            });\r\n                        };\r\n\r\n                        if ((canvas.height > canvas.width) && (canvas.height % canvas.width === 0)) {// Taking a guess that this is an animated texture\r\n                            let name = textureNames[textureRef];\r\n                            if (name.startsWith(\"#\")) {\r\n                                name = textureNames[name.substr(1)];\r\n                            }\r\n                            if (name.indexOf(\"/\") !== -1) {\r\n                                name = name.substr(name.indexOf(\"/\") + 1);\r\n                            }\r\n                            loadTextureMeta(name, assetRoot).then((meta) => {\r\n                                loadTextureWithMeta(canvas, meta);\r\n                            }).catch(() => {// Guessed wrong :shrug:\r\n                                loadTextureDefault(canvas);\r\n                            })\r\n                        } else {\r\n                            loadTextureDefault(canvas);\r\n                        }\r\n                    };\r\n\r\n\r\n                    if (canvasCache.hasOwnProperty(canvasKey)) {\r\n                        let cachedCanvas = canvasCache[canvasKey];\r\n\r\n                        if (cachedCanvas.hasOwnProperty(\"img\")) {\r\n                            console.debug(\"Waiting for canvas image that's already loading (\"+canvasKey+\")\")\r\n                           let img= cachedCanvas.img;\r\n                           img.waitingForCanvas.push(function (canvas) {\r\n                               loadTextureFromCanvas(canvas);\r\n                           });\r\n                        } else {\r\n                            console.debug(\"Using cached canvas (\" + canvasKey + \")\")\r\n                            loadTextureFromCanvas(canvasCache[canvasKey]);\r\n                        }\r\n                    } else {\r\n                        let img = new Image();\r\n                        img.onerror = function (err) {\r\n                            console.warn(err);\r\n                            resolve(null);\r\n                        };\r\n                        img.waitingForCanvas = [];\r\n                        img.onload = function () {\r\n                            let canvasData = processImgToCanvasData(img);\r\n                            loadTextureFromCanvas(canvasData);\r\n\r\n                            for (let c = 0; c < img.waitingForCanvas.length; c++) {\r\n                                img.waitingForCanvas[c](canvasData);\r\n                            }\r\n                        };\r\n                        console.debug(\"Pre-caching canvas (\" + canvasKey + \")\");\r\n                        canvasCache[canvasKey] = {\r\n                            img: img\r\n                        };\r\n                        img.src = textures[textureRef];\r\n                    }\r\n                }));\r\n            }\r\n            Promise.all(promises).then(materials => materialsLoaded(materials))\r\n        } else {\r\n            let materials = [];\r\n            for (let i = 0; i < 6; i++) {\r\n                materials.push(new THREE.MeshBasicMaterial({\r\n                    color: colors[i + 2],\r\n                    wireframe: true\r\n                }))\r\n            }\r\n            materialsLoaded(materials);\r\n        }\r\n\r\n        // if (textures) {\r\n        //     applyCubeTextureToGeometry(geometry, texture, uv, width, height, depth);\r\n        // }\r\n\r\n\r\n    })\r\n};\r\n\r\n/// https://stackoverflow.com/questions/42812861/three-js-pivot-point/42866733#42866733\r\n// obj - your object (THREE.Object3D or derived)\r\n// point - the point of rotation (THREE.Vector3)\r\n// axis - the axis of rotation (normalized THREE.Vector3)\r\n// theta - radian value of rotation\r\nfunction rotateAboutPoint(obj, point, axis, theta) {\r\n    obj.position.sub(point); // remove the offset\r\n    obj.position.applyAxisAngle(axis, theta); // rotate the POSITION\r\n    obj.position.add(point); // re-add the offset\r\n\r\n    obj.rotateOnAxis(axis, theta); // rotate the OBJECT\r\n}\r\n\r\nModelRender.cache = {\r\n    loadedTextures: loadedTextureCache,\r\n    mergedModels: mergedModelCache,\r\n    instanceCount: modelInstances,\r\n\r\n    texture: textureCache,\r\n    canvas: canvasCache,\r\n    material: materialCache,\r\n    geometry: geometryCache,\r\n    instances: instanceCache,\r\n\r\n\r\n    resetInstances: function () {\r\n        deleteObjectProperties(modelInstances);\r\n        deleteObjectProperties(instanceCache);\r\n    },\r\n    clearAll: function () {\r\n        deleteObjectProperties(loadedTextureCache);\r\n        deleteObjectProperties(mergedModelCache);\r\n        deleteObjectProperties(modelInstances);\r\n        deleteObjectProperties(textureCache);\r\n        deleteObjectProperties(materialCache);\r\n        deleteObjectProperties(geometryCache);\r\n        deleteObjectProperties(instanceCache);\r\n    }\r\n};\r\nModelRender.ModelConverter = ModelConverter;\r\n\r\nif (typeof window !== \"undefined\") {\r\n    window.ModelRender = ModelRender;\r\n    window.ModelConverter = ModelConverter;\r\n}\r\nif (typeof global !== \"undefined\")\r\n    global.ModelRender = ModelRender;\r\n\r\nexport default ModelRender;\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/model/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 101,
    "kind": "variable",
    "name": "ModelWorker",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~ModelWorker",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 102,
    "kind": "function",
    "name": "replaceAll",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~replaceAll",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "search",
        "types": [
          "*"
        ]
      },
      {
        "name": "replacement",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 103,
    "kind": "variable",
    "name": "colors",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~colors",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "number[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 104,
    "kind": "variable",
    "name": "FACE_ORDER",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~FACE_ORDER",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 105,
    "kind": "variable",
    "name": "TINTS",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~TINTS",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 106,
    "kind": "variable",
    "name": "mergedModelCache",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~mergedModelCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 107,
    "kind": "variable",
    "name": "loadedTextureCache",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~loadedTextureCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 108,
    "kind": "variable",
    "name": "modelInstances",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~modelInstances",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 109,
    "kind": "variable",
    "name": "textureCache",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~textureCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "variable",
    "name": "canvasCache",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~canvasCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 46,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 111,
    "kind": "variable",
    "name": "materialCache",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~materialCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 112,
    "kind": "variable",
    "name": "geometryCache",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~geometryCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 113,
    "kind": "variable",
    "name": "instanceCache",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~instanceCache",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 49,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 114,
    "kind": "variable",
    "name": "animatedTextures",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~animatedTextures",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 51,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 115,
    "kind": "variable",
    "name": "defOptions",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~defOptions",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": "",
    "see": [
      "defaultOptions"
    ],
    "lineNumber": 59,
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "alternative way to specify the model type (block/item)"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "centerCubes",
        "description": "center the cube's rotation point"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT_ROOT",
        "defaultRaw": "DEFAULT_ROOT",
        "name": "assetRoot",
        "description": "root to get asset files from"
      }
    ],
    "type": {
      "types": [
        "{\"camera\": *, \"type\": string, \"centerCubes\": *, \"assetRoot\": *, \"useWebWorkers\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 116,
    "kind": "function",
    "name": "parseModels",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~parseModels",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "params": [
      {
        "name": "modelRender",
        "types": [
          "*"
        ]
      },
      {
        "name": "models",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsedModelList",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 117,
    "kind": "function",
    "name": "loadAndMergeModels",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~loadAndMergeModels",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "params": [
      {
        "name": "modelRender",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsedModelList",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 118,
    "kind": "function",
    "name": "loadModelTextures",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~loadModelTextures",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [
      {
        "name": "modelRender",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsedModelList",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 119,
    "kind": "function",
    "name": "doModelRender",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~doModelRender",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "modelRender",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsedModelList",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 120,
    "kind": "function",
    "name": "renderModel",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~renderModel",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "params": [
      {
        "name": "modelRender",
        "types": [
          "*"
        ]
      },
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "textures",
        "types": [
          "*"
        ]
      },
      {
        "name": "textureNames",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "variant",
        "types": [
          "*"
        ]
      },
      {
        "name": "offset",
        "types": [
          "*"
        ]
      },
      {
        "name": "rotation",
        "types": [
          "*"
        ]
      },
      {
        "name": "scale",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 121,
    "kind": "function",
    "name": "createDot",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~createDot",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 570,
    "undocument": true,
    "params": [
      {
        "name": "c",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 122,
    "kind": "function",
    "name": "createPlane",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~createPlane",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 577,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "textures",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 123,
    "kind": "function",
    "name": "createCube",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~createCube",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 668,
    "undocument": true,
    "params": [
      {
        "name": "width",
        "types": [
          "*"
        ]
      },
      {
        "name": "height",
        "types": [
          "*"
        ]
      },
      {
        "name": "depth",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "faces",
        "types": [
          "*"
        ]
      },
      {
        "name": "fallbackFaces",
        "types": [
          "*"
        ]
      },
      {
        "name": "textures",
        "types": [
          "*"
        ]
      },
      {
        "name": "textureNames",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      },
      {
        "name": "baseName",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 124,
    "kind": "function",
    "name": "rotateAboutPoint",
    "memberof": "src/model/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/index.js~rotateAboutPoint",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 991,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "point",
        "types": [
          "*"
        ]
      },
      {
        "name": "axis",
        "types": [
          "*"
        ]
      },
      {
        "name": "theta",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 125,
    "kind": "class",
    "name": "ModelRender",
    "memberof": "src/model/index.js",
    "static": true,
    "longname": "src/model/index.js~ModelRender",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/index.js",
    "importStyle": "ModelRender",
    "description": "A renderer for Minecraft models, i.e. blocks & items",
    "lineNumber": 76,
    "interface": false,
    "extends": [
      "src/renderBase.js~Render"
    ]
  },
  {
    "__docId__": 126,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/model/index.js~ModelRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/model/index.js~ModelRender#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 85,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options for this renderer, see {@link defaultOptions}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "DEFAULT_ROOT",
        "defaultRaw": "DEFAULT_ROOT",
        "name": "options.assetRoot",
        "description": "root to get asset files from"
      },
      {
        "nullable": null,
        "types": [
          "HTMLElement"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "document.body",
        "defaultRaw": "document.body",
        "name": "element",
        "description": "DOM Element to attach the renderer to - defaults to document.body"
      }
    ]
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "renderType",
    "memberof": "src/model/index.js~ModelRender",
    "static": false,
    "longname": "src/model/index.js~ModelRender#renderType",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "models",
    "memberof": "src/model/index.js~ModelRender",
    "static": false,
    "longname": "src/model/index.js~ModelRender#models",
    "access": "public",
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "attached",
    "memberof": "src/model/index.js~ModelRender",
    "static": false,
    "longname": "src/model/index.js~ModelRender#attached",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 130,
    "kind": "method",
    "name": "render",
    "memberof": "src/model/index.js~ModelRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/model/index.js~ModelRender#render",
    "access": "public",
    "description": "Does the actual rendering",
    "lineNumber": 105,
    "params": [
      {
        "nullable": null,
        "types": [
          "string[]",
          "Object[]"
        ],
        "spread": false,
        "optional": false,
        "name": "models",
        "description": "Array of models to render - Either strings in the format <block|item>/<model name> or objects"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "block",
        "defaultRaw": "block",
        "name": "models[].type",
        "description": "either 'block' or 'item'"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "models[].model",
        "description": "if 'type' is given, just the block/item name otherwise '<block|item>/<model name>'"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "models[].offset",
        "description": "[x,y,z] array of the offset"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "models[].rotation",
        "description": "[x,y,z] array of the rotation"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "models[].blockstate",
        "description": "name of a blockstate to be used to determine the models (only for blocks)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "normal",
        "defaultRaw": "normal",
        "name": "models[].variant",
        "description": "if 'blockstate' is given, the block variant to use"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "cb",
        "description": "Callback when rendering finished"
      }
    ],
    "return": null
  },
  {
    "__docId__": 131,
    "kind": "file",
    "name": "src/model/modelConverter.js",
    "content": "import * as pako from \"pako\";\r\nimport * as NBT from \"prismarine-nbt\";\r\nimport SkinRender from \"../skin/index\";\r\nimport { loadBlockState } from \"../functions\";\r\n\r\n/**\r\n * Helper to convert multi-block structures to models used by {@link ModelRender}\r\n * @constructor\r\n */\r\nfunction ModelConverter() {\r\n}\r\n\r\n/**\r\n * Converts a {@link https://minecraft.gamepedia.com/Structure_block_file_format|Minecraft structure file} to models\r\n * @param {object} structure structure file info\r\n * @param {string} structure.url URL to a structure file\r\n * @param {(Blob|File)} structure.file uploaded file\r\n * @param {(Uint8Array|ArrayBuffer)} structure.raw Raw NBT data\r\n * @param cb\r\n */\r\nModelConverter.prototype.structureToModels = function (structure, cb) {\r\n    loadNBT(structure).then((rawNbt) => {\r\n        NBT.parse(rawNbt, (err, data) => {\r\n            if (err) {\r\n                console.warn(\"Error while parsing NBT data\");\r\n                console.warn(err);\r\n                return;\r\n            }\r\n\r\n            if (!PRODUCTION) {\r\n                console.log(\"NBT Data:\")\r\n                console.log(data);\r\n            }\r\n\r\n            parseStructureData(data).then((data) => {\r\n                cb(data);\r\n            })\r\n        })\r\n    })\r\n};\r\n\r\n\r\n/**\r\n * Converts a Minecraft schematic file to models\r\n * @param {object} schematic structure file info\r\n * @param {string} schematic.url URL to a structure file\r\n * @param {(Blob|File)} schematic.file uploaded file\r\n * @param {(Uint8Array|ArrayBuffer)} schematic.raw Raw NBT data\r\n * @param cb\r\n */\r\nModelConverter.prototype.schematicToModels = function (schematic, cb) {\r\n    loadNBT(schematic).then(rawNbt => {\r\n        NBT.parse(rawNbt, (err, data) => {\r\n            if (err) {\r\n                console.warn(\"Error while parsing NBT data\");\r\n                console.warn(err);\r\n                return;\r\n            }\r\n\r\n            if (!PRODUCTION) {\r\n                console.log(\"NBT Data:\")\r\n                console.log(data);\r\n            }\r\n\r\n            let xhr = new XMLHttpRequest();\r\n            xhr.open('GET', \"https://minerender.org/res/idsToNames.json\", true);\r\n            xhr.onloadend = function () {\r\n                if (xhr.status === 200) {\r\n                    console.log(xhr.response || xhr.responseText);\r\n\r\n                    let idsToNames = JSON.parse(xhr.response || xhr.responseText);\r\n                    parseSchematicData(data, idsToNames).then(data => cb(data));\r\n                }\r\n            };\r\n            xhr.send();\r\n\r\n        })\r\n    })\r\n};\r\n\r\n\r\nfunction loadNBT(source) {\r\n    return new Promise((resolve, reject) => {\r\n        if (source.file) {\r\n            let reader = new FileReader();\r\n            reader.onload = function () {\r\n                let arrayBuffer = this.result;\r\n                let array = new Uint8Array(arrayBuffer);\r\n\r\n                resolve(array);\r\n            }\r\n            reader.readAsArrayBuffer(source.file);\r\n        } else if (source.url) {\r\n            let xhr = new XMLHttpRequest();\r\n            xhr.open('GET', source.url, true);\r\n            xhr.responseType = 'arraybuffer';\r\n            xhr.onloadend = function () {\r\n                if (xhr.status === 200) {\r\n                    let array = new Uint8Array(xhr.response || xhr.responseText);\r\n\r\n                    resolve(array);\r\n                }\r\n            };\r\n            xhr.send();\r\n        } else if (source.raw) {\r\n            if (source.raw instanceof Uint8Array) {\r\n                resolve(source.raw)\r\n            } else {\r\n                resolve(new Uint8Array(source.raw));\r\n            }\r\n        } else {\r\n            reject();\r\n        }\r\n    })\r\n}\r\n\r\nfunction parseStructureData(data, paletteIndex) {\r\n    return new Promise((resolve, reject) => {\r\n        if (data.type === \"compound\") {\r\n            if (data.value.hasOwnProperty(\"blocks\") && (data.value.hasOwnProperty(\"palette\") || data.value.hasOwnProperty(\"palettes\"))) {\r\n                let originalPalette;\r\n                if (data.value.hasOwnProperty(\"palette\")) {\r\n                    originalPalette = data.value[\"palette\"].value.value;\r\n                } else {\r\n                    if (typeof paletteIndex === \"undefined\") paletteIndex = 0;\r\n                    if (paletteIndex >= data.value[\"palettes\"].value.value.length || !data.value[\"palettes\"].value.value[paletteIndex]) {\r\n                        console.warn(\"Specified palette index (\" + paletteIndex + \") is outside of available palettes (\" + data.value[\"palettes\"].value.value.length + \")\")\r\n                        return;\r\n                    }\r\n                    originalPalette = data.value[\"palettes\"].value.value[paletteIndex].value;\r\n                }\r\n\r\n\r\n                // Simplify palette\r\n                let palette = [];\r\n                for (let i = 0; i < originalPalette.length; i++) {\r\n                    palette.push(originalPalette[i]);\r\n                }\r\n\r\n                let arr = [];\r\n\r\n                // Iterate blocks\r\n                let blocks = data.value.blocks.value.value;\r\n                for (let i = 0; i < blocks.length; i++) {\r\n                    let blockType = palette[blocks[i].state.value].Name.value;\r\n                    if (blockType === \"minecraft:air\") {\r\n                        // No need to add air\r\n                        continue;\r\n                    }\r\n                    let shortBlockType = blockType.substr(\"minecraft:\".length);\r\n\r\n                    let pos = blocks[i].pos.value.value;\r\n\r\n                    let multipartConditions = {};\r\n\r\n                    let variantString = \"\";\r\n                    if (palette[blocks[i].state.value].hasOwnProperty(\"Properties\")) {\r\n                        let strs = [];\r\n                        for (let p in  palette[blocks[i].state.value].Properties.value) {\r\n                            if (palette[blocks[i].state.value].Properties.value.hasOwnProperty(p)) {\r\n                                let prop = palette[blocks[i].state.value].Properties.value[p];\r\n\r\n                                strs.push(p + \"=\" + prop.value);\r\n\r\n                                multipartConditions[p] = prop.value;\r\n                            }\r\n                        }\r\n\r\n                        // Make sure the variants are sorted properly, or it won't match the game files\r\n                        strs.sort();\r\n\r\n                        for (let i = 0; i < strs.length; i++) {\r\n                            variantString += \",\" + strs[i];\r\n                        }\r\n\r\n                        variantString = variantString.substr(1);\r\n                    }\r\n\r\n                    if (specialVariants.hasOwnProperty(shortBlockType)) {\r\n                        shortBlockType = specialVariants[shortBlockType](palette[blocks[i].state.value].Properties.value);\r\n                        variantString = \"\";\r\n                    }\r\n\r\n                    let block = {\r\n                        blockstate: shortBlockType,\r\n                        variant: variantString,\r\n                        multipart: multipartConditions,\r\n                        offset: [pos[0] * 16, pos[1] * 16, pos[2] * 16]\r\n                    };\r\n                    arr.push(block)\r\n                }\r\n\r\n                resolve(arr);\r\n            } else {\r\n                console.warn(\"Invalid NBT - Missing blocks/palette(s)\");\r\n                reject();\r\n            }\r\n        } else {\r\n            console.warn(\"Invalid NBT - Root tag should be compound\");\r\n            reject();\r\n        }\r\n    })\r\n}\r\n\r\nfunction parseSchematicData(data, idToNameMap) {\r\n    return new Promise((resolve, reject) => {\r\n        let width = data.value.Width.value;\r\n        let height = data.value.Height.value;\r\n        let length = data.value.Length.value;\r\n\r\n        let infoAt = function (x, y, z) {\r\n            let index = (y * length + z) * width + x;\r\n            return {\r\n                id: data.value.Blocks.value[index] & 0xff,\r\n                data: data.value.Data.value[index]\r\n            }\r\n        };\r\n\r\n        let convertLegacy = function (id, data) {\r\n            let mapped = idToNameMap.blocks[id + \":\" + data];\r\n            if (!mapped) {\r\n                console.warn(\"Missing legacy mapping for \" + id + \":\" + data);\r\n                return \"minecraft:air\";\r\n            }\r\n            return mapped;\r\n        };\r\n\r\n        let arr = [];\r\n\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                for (let z = 0; z < length; z++) {\r\n                    let info = infoAt(x, y, z);\r\n                    let convertedInfo = convertLegacy(info.id, info.data);\r\n\r\n                    let infoSplit = convertedInfo.replace(\"minecraft:\", \"\").replace(\"]\", \"\").split(\"[\");\r\n                    let shortName = infoSplit[0];\r\n                    let variantString = infoSplit[1] || \"\";\r\n\r\n                    if (shortName === \"air\") continue;\r\n\r\n                    if (variantString !== \"\") {\r\n                        variantString = variantString.split(\",\").sort().join(\",\");\r\n                    }\r\n\r\n                    arr.push({\r\n                        blockstate: shortName,\r\n                        variant: variantString,\r\n                        offset: [x * 16, y * 16, z * 16]\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        resolve(arr);\r\n    })\r\n}\r\n\r\nlet specialVariants = {\r\n    \"stained_glass\": function (properties) {\r\n        return properties.color.value + \"_stained_glass\";\r\n    },\r\n    \"planks\": function (properties) {\r\n        return properties.variant.value + \"_planks\";\r\n    }\r\n};\r\n\r\n\r\nModelConverter.prototype.constructor = ModelConverter;\r\n\r\nwindow.ModelConverter = ModelConverter;\r\n\r\nexport default ModelConverter;\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/model/modelConverter.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 132,
    "kind": "function",
    "name": "structureToModels",
    "memberof": "src/model/modelConverter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelConverter.js~structureToModels",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/modelConverter.js",
    "importStyle": null,
    "description": "Converts a {@link https://minecraft.gamepedia.com/Structure_block_file_format|Minecraft structure file} to models",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "structure",
        "description": "structure file info"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "structure.url",
        "description": "URL to a structure file"
      },
      {
        "nullable": null,
        "types": [
          "Blob",
          "File"
        ],
        "spread": false,
        "optional": false,
        "name": "structure.file",
        "description": "uploaded file"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array",
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "structure.raw",
        "description": "Raw NBT data"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cb",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 133,
    "kind": "function",
    "name": "schematicToModels",
    "memberof": "src/model/modelConverter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelConverter.js~schematicToModels",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/modelConverter.js",
    "importStyle": null,
    "description": "Converts a Minecraft schematic file to models",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "schematic",
        "description": "structure file info"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "schematic.url",
        "description": "URL to a structure file"
      },
      {
        "nullable": null,
        "types": [
          "Blob",
          "File"
        ],
        "spread": false,
        "optional": false,
        "name": "schematic.file",
        "description": "uploaded file"
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array",
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "schematic.raw",
        "description": "Raw NBT data"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cb",
        "description": ""
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 134,
    "kind": "function",
    "name": "loadNBT",
    "memberof": "src/model/modelConverter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelConverter.js~loadNBT",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/modelConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 82,
    "undocument": true,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 135,
    "kind": "function",
    "name": "parseStructureData",
    "memberof": "src/model/modelConverter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelConverter.js~parseStructureData",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/modelConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 117,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "paletteIndex",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 136,
    "kind": "function",
    "name": "parseSchematicData",
    "memberof": "src/model/modelConverter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelConverter.js~parseSchematicData",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/modelConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 205,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "idToNameMap",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 137,
    "kind": "variable",
    "name": "specialVariants",
    "memberof": "src/model/modelConverter.js",
    "static": true,
    "longname": "src/model/modelConverter.js~specialVariants",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/modelConverter.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 259,
    "undocument": true,
    "type": {
      "types": [
        "{\"stained_glass\": *, \"planks\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 138,
    "kind": "function",
    "name": "ModelConverter",
    "memberof": "src/model/modelConverter.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelConverter.js~ModelConverter",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelConverter.js",
    "importStyle": "ModelConverter",
    "description": "Helper to convert multi-block structures to models used by {@link ModelRender}",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [],
    "return": null
  },
  {
    "__docId__": 139,
    "kind": "file",
    "name": "src/model/modelFunctions.js",
    "content": "import { loadBlockState, loadJsonFromPath, loadTextureAsBase64 } from \"../functions\";\r\nimport merge from \"deepmerge\";\r\n\r\nexport function parseModel(model, modelOptions, parsedModelList, assetRoot) {\r\n    return new Promise(resolve => {\r\n        let type = \"block\";\r\n        let offset;\r\n        let rotation;\r\n        let scale;\r\n\r\n        if (typeof model === \"string\") {\r\n            let parsed = parseModelType(model);\r\n            model = parsed.model;\r\n            type = parsed.type;\r\n\r\n            parsedModelList.push({\r\n                name: model,\r\n                type: type,\r\n                options: modelOptions\r\n            });\r\n            resolve(parsedModelList);\r\n        } else if (typeof model === \"object\") {\r\n            if (model.hasOwnProperty(\"offset\")) {\r\n                offset = model[\"offset\"];\r\n            }\r\n            if (model.hasOwnProperty(\"rotation\")) {\r\n                rotation = model[\"rotation\"];\r\n            }\r\n            if (model.hasOwnProperty(\"scale\")) {\r\n                scale = model[\"scale\"];\r\n            }\r\n\r\n            if (model.hasOwnProperty(\"model\")) {\r\n                if (model.hasOwnProperty(\"type\")) {\r\n                    type = model[\"type\"];\r\n                    model = model[\"model\"];\r\n                } else {\r\n                    let parsed = parseModelType(model[\"model\"]);\r\n                    model = parsed.model;\r\n                    type = parsed.type;\r\n                }\r\n\r\n                parsedModelList.push({\r\n                    name: model,\r\n                    type: type,\r\n                    offset: offset,\r\n                    rotation: rotation,\r\n                    scale: scale,\r\n                    options: modelOptions\r\n                });\r\n                resolve(parsedModelList);\r\n            } else if (model.hasOwnProperty(\"blockstate\")) {\r\n                type = \"block\";\r\n\r\n                loadBlockState(model.blockstate, assetRoot).then((blockstate) => {\r\n                    if (blockstate.hasOwnProperty(\"variants\")) {\r\n\r\n                        if (model.hasOwnProperty(\"variant\")) {\r\n                            let variantKey = findMatchingVariant(blockstate.variants, model.variant);\r\n                            if (variantKey === null) {\r\n                                console.warn(\"Missing variant key for \" + model.blockstate + \": \" + model.variant);\r\n                                console.warn(blockstate.variants);\r\n                                resolve(null);\r\n                                return;\r\n                            }\r\n                            let variant = blockstate.variants[variantKey];\r\n                            if (!variant) {\r\n                                console.warn(\"Missing variant for \" + model.blockstate + \": \" + model.variant);\r\n                                resolve(null);\r\n                                return;\r\n                            }\r\n\r\n                            let variants = [];\r\n                            if (!Array.isArray(variant)) {\r\n                                variants = [variant];\r\n                            } else {\r\n                                variants = variant;\r\n                            }\r\n\r\n                            rotation = [0, 0, 0];\r\n\r\n                            let v = variants[Math.floor(Math.random() * variants.length)];\r\n                            if (variant.hasOwnProperty(\"x\")) {\r\n                                rotation[0] = v.x;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"y\")) {\r\n                                rotation[1] = v.y;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                rotation[2] = v.z;\r\n                            }\r\n                            let parsed = parseModelType(v.model);\r\n                            parsedModelList.push({\r\n                                name: parsed.model,\r\n                                type: \"block\",\r\n                                variant: model.variant,\r\n                                offset: offset,\r\n                                rotation: rotation,\r\n                                scale: scale,\r\n                                options: modelOptions\r\n                            });\r\n                            resolve(parsedModelList);\r\n                        } else {\r\n                            let variant;\r\n                            if (blockstate.variants.hasOwnProperty(\"normal\")) {\r\n                                variant = blockstate.variants.normal;\r\n                            } else if (blockstate.variants.hasOwnProperty(\"\")) {\r\n                                variant = blockstate.variants[\"\"];\r\n                            } else {\r\n                                variant = blockstate.variants[Object.keys(blockstate.variants)[0]]\r\n                            }\r\n\r\n                            let variants = [];\r\n                            if (!Array.isArray(variant)) {\r\n                                variants = [variant];\r\n                            } else {\r\n                                variants = variant;\r\n                            }\r\n\r\n                            rotation = [0, 0, 0];\r\n\r\n                            let v = variants[Math.floor(Math.random() * variants.length)];\r\n                            if (variant.hasOwnProperty(\"x\")) {\r\n                                rotation[0] = v.x;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"y\")) {\r\n                                rotation[1] = v.y;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                rotation[2] = v.z;\r\n                            }\r\n                            let parsed = parseModelType(v.model);\r\n                            parsedModelList.push({\r\n                                name: parsed.model,\r\n                                type: \"block\",\r\n                                variant: model.variant,\r\n                                offset: offset,\r\n                                rotation: rotation,\r\n                                scale: scale,\r\n                                options: modelOptions\r\n                            })\r\n                            resolve(parsedModelList);\r\n                        }\r\n                    } else if (blockstate.hasOwnProperty(\"multipart\")) {\r\n                        for (let j = 0; j < blockstate.multipart.length; j++) {\r\n                            let cond = blockstate.multipart[j];\r\n                            let apply = cond.apply;\r\n                            let when = cond.when;\r\n\r\n                            rotation = [0, 0, 0];\r\n\r\n                            if (!when) {\r\n                                if (apply.hasOwnProperty(\"x\")) {\r\n                                    rotation[0] = apply.x;\r\n                                }\r\n                                if (apply.hasOwnProperty(\"y\")) {\r\n                                    rotation[1] = apply.y;\r\n                                }\r\n                                if (apply.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                    rotation[2] = apply.z;\r\n                                }\r\n                                let parsed = parseModelType(apply.model);\r\n                                parsedModelList.push({\r\n                                    name: parsed.model,\r\n                                    type: \"block\",\r\n                                    offset: offset,\r\n                                    rotation: rotation,\r\n                                    scale: scale,\r\n                                    options: modelOptions\r\n                                });\r\n                            } else if (model.hasOwnProperty(\"multipart\")) {\r\n                                let multipartConditions = model.multipart;\r\n\r\n                                let applies = false;\r\n                                if (when.hasOwnProperty(\"OR\")) {\r\n                                    for (let k = 0; k < when.OR.length; k++) {\r\n                                        if (applies) break;\r\n                                        for (let c in when.OR[k]) {\r\n                                            if (applies) break;\r\n                                            if (when.OR[k].hasOwnProperty(c)) {\r\n                                                let expected = when.OR[k][c];\r\n                                                let expectedArray = expected.split(\"|\");\r\n\r\n                                                let given = multipartConditions[c];\r\n                                                for (let k = 0; k < expectedArray.length; k++) {\r\n                                                    if (expectedArray[k] === given) {\r\n                                                        applies = true;\r\n                                                        break;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    for (let c in when) {// this SHOULD be a single case, but iterating makes it a bit easier\r\n                                        if (applies) break;\r\n                                        if (when.hasOwnProperty(c)) {\r\n                                            let expected = String(when[c]);\r\n                                            let expectedArray = expected.split(\"|\");\r\n\r\n                                            let given = multipartConditions[c];\r\n                                            for (let k = 0; k < expectedArray.length; k++) {\r\n                                                if (expectedArray[k] === given) {\r\n                                                    applies = true;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (applies) {\r\n                                    if (apply.hasOwnProperty(\"x\")) {\r\n                                        rotation[0] = apply.x;\r\n                                    }\r\n                                    if (apply.hasOwnProperty(\"y\")) {\r\n                                        rotation[1] = apply.y;\r\n                                    }\r\n                                    if (apply.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                        rotation[2] = apply.z;\r\n                                    }\r\n                                    let parsed = parseModelType(apply.model);\r\n                                    parsedModelList.push({\r\n                                        name: parsed.model,\r\n                                        type: \"block\",\r\n                                        offset: offset,\r\n                                        rotation: rotation,\r\n                                        scale: scale,\r\n                                        options: modelOptions\r\n                                    })\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        resolve(parsedModelList);\r\n                    }\r\n                }).catch(()=>{\r\n                    resolve(parsedModelList);\r\n                })\r\n            }\r\n\r\n        }\r\n    })\r\n}\r\n\r\nexport function loadAndMergeModel(model, assetRoot) {\r\n    return loadModel(model.name, model.type, assetRoot)\r\n        .then(modelData => mergeParents(modelData, model.name, assetRoot));\r\n}\r\n\r\n\r\n\r\n// Utils\r\n\r\nexport function modelCacheKey(model) {\r\n    return model.type + \"__\" + model.name /*+ \"[\" + (model.variant || \"default\") + \"]\"*/;\r\n}\r\n\r\nexport function findMatchingVariant(variants, selector) {\r\n    if (!Array.isArray(variants)) variants = Object.keys(variants);\r\n\r\n    if (!selector || selector === \"\" || selector.length === 0) return \"\";\r\n    let selectorObj = variantStringToObject(selector);\r\n    for (let i = 0; i < variants.length; i++) {\r\n        let variantObj = variantStringToObject(variants[i]);\r\n\r\n        let matches = true;\r\n        for (let k in selectorObj) {\r\n            if (selectorObj.hasOwnProperty(k)) {\r\n                if (variantObj.hasOwnProperty(k)) {\r\n                    if (selectorObj[k] !== variantObj[k]) {\r\n                        matches = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (matches) return variants[i];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function variantStringToObject(str) {\r\n    let split = str.split(\",\");\r\n    let obj = {};\r\n    for (let i = 0; i < split.length; i++) {\r\n        let spl = split[i];\r\n        let split1 = spl.split(\"=\");\r\n        obj[split1[0]] = split1[1];\r\n    }\r\n    return obj;\r\n}\r\n\r\nexport function parseModelType(string) {\r\n    if (string.startsWith(\"block/\")) {\r\n        // if (type === \"item\") {\r\n        //     throw new Error(\"Tried to mix block/item models\");\r\n        // }\r\n        return {\r\n            type: \"block\",\r\n            model: string.substr(\"block/\".length)\r\n        }\r\n    } else if (string.startsWith(\"item/\")) {\r\n        // if (type === \"block\") {\r\n        //     throw new Error(\"Tried to mix item/block models\");\r\n        // }\r\n        return {\r\n            type: \"item\",\r\n            model: string.substr(\"item/\".length)\r\n        }\r\n    }\r\n    return {\r\n        type: \"block\",\r\n        model: \"string\"\r\n    }\r\n}\r\n\r\nexport function loadModel(model, type/* block OR item */, assetRoot) {\r\n    return new Promise((resolve, reject) => {\r\n        if (typeof model === \"string\") {\r\n            if (model.startsWith(\"{\") && model.endsWith(\"}\")) {// JSON string\r\n                resolve(JSON.parse(model));\r\n            } else if (model.startsWith(\"http\")) {// URL\r\n                fetch(model, {\r\n                    mode: \"cors\",\r\n                    redirect: \"follow\"\r\n                })\r\n                    .then(response => response.json())\r\n                    .then(data => {\r\n                        console.log(\"model data:\", data);\r\n                        resolve(data);\r\n                    })\r\n            } else {// model name -> use local data\r\n                loadJsonFromPath(assetRoot, \"/assets/minecraft/models/\" + (type || \"block\") + \"/\" + model + \".json\").then((data) => {\r\n                    resolve(data);\r\n                })\r\n            }\r\n        } else if (typeof model === \"object\") {// JSON object\r\n            resolve(model);\r\n        } else {\r\n            console.warn(\"Invalid model\");\r\n            reject();\r\n        }\r\n    });\r\n};\r\n\r\nexport function loadTextures(textureNames, assetRoot) {\r\n    return new Promise((resolve) => {\r\n        let promises = [];\r\n        let filteredNames = [];\r\n\r\n        let names = Object.keys(textureNames);\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            let texture = textureNames[name];\r\n            if (texture.startsWith(\"#\")) {// reference to another texture, no need to load\r\n                continue;\r\n            }\r\n            filteredNames.push(name);\r\n            promises.push(loadTextureAsBase64(assetRoot, \"minecraft\", \"/\", texture));\r\n        }\r\n        Promise.all(promises).then((textures) => {\r\n            let mappedTextures = {};\r\n            for (let i = 0; i < textures.length; i++) {\r\n                mappedTextures[filteredNames[i]] = textures[i];\r\n            }\r\n\r\n            // Fill in the referenced textures\r\n            for (let i = 0; i < names.length; i++) {\r\n                let name = names[i];\r\n                if (!mappedTextures.hasOwnProperty(name) && textureNames.hasOwnProperty(name)) {\r\n                    let ref = textureNames[name].substr(1);\r\n                    mappedTextures[name] = mappedTextures[ref];\r\n                }\r\n            }\r\n\r\n            resolve(mappedTextures);\r\n        });\r\n    })\r\n};\r\n\r\n\r\nexport function mergeParents(model, modelName, assetRoot) {\r\n    return new Promise((resolve, reject) => {\r\n        mergeParents_(model, modelName, [], [], assetRoot, resolve, reject);\r\n    });\r\n};\r\nlet mergeParents_ = function (model, name, stack, hierarchy, assetRoot, resolve, reject) {\r\n    stack.push(model);\r\n\r\n    if (!model.hasOwnProperty(\"parent\") || model[\"parent\"] === \"builtin/generated\" || model[\"parent\"] === \"builtin/entity\") {// already at the highest parent OR we reach the builtin parent which seems to be the hardcoded stuff that's not in the json files\r\n        let merged = {};\r\n        for (let i = stack.length - 1; i >= 0; i--) {\r\n            merged = merge(merged, stack[i]);\r\n        }\r\n\r\n        hierarchy.unshift(name);\r\n        merged.hierarchy = hierarchy;\r\n        resolve(merged);\r\n        return;\r\n    }\r\n\r\n    let parent = model[\"parent\"];\r\n    delete model[\"parent\"];// remove the child's parent so it will be replaced by the parent's parent\r\n    hierarchy.push(parent);\r\n\r\n    loadJsonFromPath(assetRoot, \"/assets/minecraft/models/\" + parent + \".json\").then((parentData) => {\r\n        let mergedModel = Object.assign({}, model, parentData);\r\n        mergeParents_(mergedModel, name, stack, hierarchy, assetRoot, resolve, reject);\r\n    }).catch(reject);\r\n\r\n};\r\n\r\nexport function toRadians(angle) {\r\n    return angle * (Math.PI / 180);\r\n}\r\n\r\nexport function deleteObjectProperties(obj) {\r\n    Object.keys(obj).forEach(function (key) {\r\n        delete obj[key];\r\n    });\r\n}\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/model/modelFunctions.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 140,
    "kind": "function",
    "name": "parseModel",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~parseModel",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{parseModel}",
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "modelOptions",
        "types": [
          "*"
        ]
      },
      {
        "name": "parsedModelList",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 141,
    "kind": "function",
    "name": "loadAndMergeModel",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~loadAndMergeModel",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{loadAndMergeModel}",
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 142,
    "kind": "function",
    "name": "modelCacheKey",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~modelCacheKey",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{modelCacheKey}",
    "description": null,
    "lineNumber": 255,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 143,
    "kind": "function",
    "name": "findMatchingVariant",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~findMatchingVariant",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{findMatchingVariant}",
    "description": null,
    "lineNumber": 259,
    "undocument": true,
    "params": [
      {
        "name": "variants",
        "types": [
          "*"
        ]
      },
      {
        "name": "selector",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 144,
    "kind": "function",
    "name": "variantStringToObject",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~variantStringToObject",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{variantStringToObject}",
    "description": null,
    "lineNumber": 285,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 145,
    "kind": "function",
    "name": "parseModelType",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~parseModelType",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{parseModelType}",
    "description": null,
    "lineNumber": 296,
    "undocument": true,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"type\": string, \"model\": string}"
      ]
    }
  },
  {
    "__docId__": 146,
    "kind": "function",
    "name": "loadModel",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~loadModel",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{loadModel}",
    "description": null,
    "lineNumber": 320,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "function",
    "name": "loadTextures",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~loadTextures",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{loadTextures}",
    "description": null,
    "lineNumber": 349,
    "undocument": true,
    "params": [
      {
        "name": "textureNames",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 148,
    "kind": "function",
    "name": "mergeParents",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~mergeParents",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{mergeParents}",
    "description": null,
    "lineNumber": 385,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "modelName",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 149,
    "kind": "function",
    "name": "mergeParents_",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~mergeParents_",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 390,
    "undocument": true,
    "params": [
      {
        "name": "model",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "stack",
        "types": [
          "*"
        ]
      },
      {
        "name": "hierarchy",
        "types": [
          "*"
        ]
      },
      {
        "name": "assetRoot",
        "types": [
          "*"
        ]
      },
      {
        "name": "resolve",
        "types": [
          "*"
        ]
      },
      {
        "name": "reject",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 150,
    "kind": "function",
    "name": "toRadians",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~toRadians",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{toRadians}",
    "description": null,
    "lineNumber": 416,
    "undocument": true,
    "params": [
      {
        "name": "angle",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 151,
    "kind": "function",
    "name": "deleteObjectProperties",
    "memberof": "src/model/modelFunctions.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/modelFunctions.js~deleteObjectProperties",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/modelFunctions.js",
    "importStyle": "{deleteObjectProperties}",
    "description": null,
    "lineNumber": 420,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 152,
    "kind": "file",
    "name": "src/model/ModelWorker.js",
    "content": "import { parseModel, loadAndMergeModel,  modelCacheKey, loadTextures } from \"./modelFunctions\";\r\n\r\nexport default function worker(self) {\r\n    console.debug(\"New Worker!\")\r\n    self.addEventListener(\"message\", event => {\r\n        let msg = event.data;\r\n\r\n        if (msg.func === \"parseModel\") {\r\n            parseModel(msg.model, msg.modelOptions, [], msg.assetRoot).then((parsedModelList) => {\r\n                self.postMessage({msg: \"done\",parsedModelList:parsedModelList})\r\n                close();\r\n            })\r\n        } else if (msg.func === \"loadAndMergeModel\") {\r\n            loadAndMergeModel(msg.model, msg.assetRoot).then((mergedModel) => {\r\n                self.postMessage({msg: \"done\",mergedModel:mergedModel});\r\n                close();\r\n            })\r\n        } else if (msg.func === \"loadTextures\") {\r\n            loadTextures(msg.textures, msg.assetRoot).then((textures) => {\r\n                self.postMessage({msg: \"done\",textures:textures});\r\n                close();\r\n            })\r\n        } else {\r\n            console.warn(\"Unknown function '\" + msg.func + \"' for ModelWorker\");\r\n            console.warn(msg);\r\n            close();\r\n        }\r\n    })\r\n};\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/model/ModelWorker.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 153,
    "kind": "function",
    "name": "worker",
    "memberof": "src/model/ModelWorker.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/model/ModelWorker.js~worker",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/model/ModelWorker.js",
    "importStyle": "worker",
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "self",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 154,
    "kind": "file",
    "name": "src/renderBase.js",
    "content": "import OrbitControls from \"./lib/OrbitControls\";\r\nimport { SSAARenderPass, OBJExporter, GLTFExporter, PLYExporter } from \"threejs-ext\";\r\nimport EffectComposer, { ShaderPass, CopyShader } from \"@johh/three-effectcomposer\";\r\nimport * as THREE from \"three\";\r\nimport OnScreen from \"onscreen\";\r\nimport * as $ from \"jquery\";\r\nimport { trimCanvas, DEFAULT_ROOT } from \"./functions\";\r\n\r\n/**\r\n * @property {boolean} showAxes                 Debugging - Show the scene's axes\r\n * @property {boolean} showOutlines             Debugging - Show bounding boxes\r\n * @property {boolean} showGrid                 Debugging - Show coordinate grid\r\n *\r\n * @property {object} controls                  Controls settings\r\n * @property {boolean} [controls.enabled=true]  Toggle controls\r\n * @property {boolean} [controls.zoom=true]     Toggle zoom\r\n * @property {boolean} [controls.rotate=true]   Toggle rotation\r\n * @property {boolean} [controls.pan=true]      Toggle panning\r\n *\r\n * @property {object} camera                    Camera settings\r\n * @property {string} [camera.type=perspective] Camera type\r\n * @property {number} camera.x                  Camera X-position\r\n * @property {number} camera.y                  Camera Y-Position\r\n * @property {number} camera.z                  Camera Z-Position\r\n * @property {number[]} camera.target           [x,y,z] array where the camera should look\r\n */\r\nexport const defaultOptions = {\r\n    showAxes: false,\r\n    showGrid: false,\r\n    autoResize: false,\r\n    controls: {\r\n        enabled: true,\r\n        zoom: true,\r\n        rotate: true,\r\n        pan: true,\r\n        keys: true\r\n    },\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 20,\r\n        y: 35,\r\n        z: 20,\r\n        target: [0, 0, 0]\r\n    },\r\n    canvas: {\r\n        width: undefined,\r\n        height: undefined\r\n    },\r\n    pauseHidden: true,\r\n    forceContext: false,\r\n    sendStats: true\r\n};\r\n\r\n/**\r\n * Base class for all Renders\r\n */\r\nexport default class Render {\r\n\r\n    /**\r\n     * @param {object} options The options for this renderer, see {@link defaultOptions}\r\n     * @param {object} defOptions Additional default options, provided by the individual renders\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, defOptions, element) {\r\n        /**\r\n         * DOM Element to attach the renderer to\r\n         * @type {HTMLElement}\r\n         */\r\n        this.element = element || document.body;\r\n        /**\r\n         * Combined options\r\n         * @type {{} & defaultOptions & defOptions & options}\r\n         */\r\n        this.options = Object.assign({}, defaultOptions, defOptions, options);\r\n\r\n        this.renderType = \"_Base_\";\r\n    }\r\n\r\n    /**\r\n     * @param {boolean} [trim=false] whether to trim transparent pixels\r\n     * @param {string} [mime=image/png] mime type of the image\r\n     * @returns {string} The content of the renderer's canvas as a Base64 encoded image\r\n     */\r\n    toImage(trim, mime) {\r\n        if (!mime) mime = \"image/png\";\r\n        if (this._renderer) {\r\n            if (!trim) {\r\n                return this._renderer.domElement.toDataURL(mime);\r\n            } else {\r\n                // Clone the canvas onto a 2d context, so we can trim it properly\r\n                let newCanvas = document.createElement('canvas');\r\n                let context = newCanvas.getContext('2d');\r\n\r\n                newCanvas.width = this._renderer.domElement.width;\r\n                newCanvas.height = this._renderer.domElement.height;\r\n\r\n                context.drawImage(this._renderer.domElement, 0, 0);\r\n\r\n                let trimmed = trimCanvas(newCanvas);\r\n                return trimmed.toDataURL(mime);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Export the current scene content in the .obj format (only geometries, no textures)\r\n     * @returns {string} the .obj file content\r\n     */\r\n    toObj() {\r\n        if (this._scene) {\r\n            let exporter = new OBJExporter();\r\n            return exporter.parse(this._scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Export the current scene content in the .gltf format (geometries + textures)\r\n     * @returns {Promise<any>} a promise which resolves with the .gltf file content\r\n     */\r\n    toGLTF(exportOptions) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this._scene) {\r\n                let exporter = new GLTFExporter();\r\n                exporter.parse(this._scene, (gltf) => {\r\n                    resolve(gltf);\r\n                }, exportOptions)\r\n            } else {\r\n                reject();\r\n            }\r\n        })\r\n    }\r\n\r\n    toPLY(exportOptions) {\r\n        if (this._scene) {\r\n            let exporter = new PLYExporter();\r\n            return exporter.parse(this._scene, exportOptions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the scene\r\n     * @param renderCb\r\n     * @param doNotAnimate\r\n     * @protected\r\n     */\r\n    initScene(renderCb, doNotAnimate) {\r\n        let renderObj = this;\r\n\r\n        console.log(\" \");\r\n        console.log('%c       ', 'font-size: 100px; background: url(https://minerender.org/img/minerender.svg) no-repeat;');\r\n        console.log(\"MineRender/\" + (renderObj.renderType || renderObj.constructor.name) + \"/\" + VERSION);\r\n        console.log((PRODUCTION ? \"PRODUCTION\" : \"DEVELOPMENT\") + \" build\");\r\n        console.log(\"Built @ \" + BUILD_DATE);\r\n        console.log(\" \");\r\n\r\n        if (renderObj.options.sendStats) {\r\n            // Send stats\r\n\r\n            let iframe = false;\r\n            try {\r\n                iframe = window.self !== window.top;\r\n            } catch (e) {\r\n                return true;\r\n            }\r\n            let hostname;\r\n            try{\r\n                hostname = new URL(iframe ? document.referrer : window.location).hostname;\r\n            }catch (e) {\r\n                console.warn(\"Failed to get hostname\");\r\n            }\r\n\r\n            $.post({\r\n                url: \"https://minerender.org/stats.php\",\r\n                data: {\r\n                    action: \"init\",\r\n                    type: renderObj.renderType,\r\n                    host: hostname,\r\n                    source: (iframe ? \"iframe\" : \"javascript\")\r\n                }\r\n            });\r\n        }\r\n\r\n        // Scene INIT\r\n        let scene = new THREE.Scene();\r\n        renderObj._scene = scene;\r\n        let camera;\r\n        if (renderObj.options.camera.type === \"orthographic\") {\r\n            camera = new THREE.OrthographicCamera((renderObj.options.canvas.width || window.innerWidth) / -2, (renderObj.options.canvas.width || window.innerWidth) / 2, (renderObj.options.canvas.height || window.innerHeight) / 2, (renderObj.options.canvas.height || window.innerHeight) / -2, 1, 1000);\r\n        } else {\r\n            camera = new THREE.PerspectiveCamera(75, (renderObj.options.canvas.width || window.innerWidth) / (renderObj.options.canvas.height || window.innerHeight), 5, 1000);\r\n        }\r\n        renderObj._camera = camera;\r\n\r\n        if (renderObj.options.camera.zoom) {\r\n            camera.zoom = renderObj.options.camera.zoom;\r\n        }\r\n\r\n        let renderer = new THREE.WebGLRenderer({alpha: true, antialias: true, preserveDrawingBuffer: true});\r\n        renderObj._renderer = renderer;\r\n        renderer.setSize((renderObj.options.canvas.width || window.innerWidth), (renderObj.options.canvas.height || window.innerHeight));\r\n        renderer.setClearColor(0x000000, 0);\r\n        renderer.setPixelRatio(window.devicePixelRatio);\r\n        renderer.shadowMap.enabled = true;\r\n        renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n        renderObj.element.appendChild(renderObj._canvas = renderer.domElement);\r\n\r\n        let composer = new EffectComposer(renderer);\r\n        composer.setSize((renderObj.options.canvas.width || window.innerWidth), (renderObj.options.canvas.height || window.innerHeight));\r\n        renderObj._composer = composer;\r\n        let ssaaRenderPass = new SSAARenderPass(scene, camera);\r\n        ssaaRenderPass.unbiased = true;\r\n        composer.addPass(ssaaRenderPass);\r\n        // let renderPass = new RenderPass(scene, camera);\r\n        // renderPass.enabled = false;\r\n        // composer.addPass(renderPass);\r\n        let copyPass = new ShaderPass(CopyShader);\r\n        copyPass.renderToScreen = true;\r\n        composer.addPass(copyPass);\r\n\r\n        if (renderObj.options.autoResize) {\r\n            window.addEventListener(\"resize\", function () {\r\n                let width = (renderObj.element && renderObj.element !== document.body) ? renderObj.element.offsetWidth : window.innerWidth;\r\n                let height = (renderObj.element && renderObj.element !== document.body) ? renderObj.element.offsetHeight : window.innerHeight;\r\n\r\n                renderObj._resize(width, height);\r\n            });\r\n        }\r\n        renderObj._resize = function (width, height) {\r\n            if (renderObj.options.camera.type === \"orthographic\") {\r\n                camera.left = width / -2;\r\n                camera.right = width / 2;\r\n                camera.top = height / 2;\r\n                camera.bottom = height / -2;\r\n            } else {\r\n                camera.aspect = width / height;\r\n            }\r\n            camera.updateProjectionMatrix();\r\n\r\n            renderer.setSize(width, height);\r\n            composer.setSize(width, height);\r\n        };\r\n\r\n        // Helpers\r\n        if (renderObj.options.showAxes) {\r\n            scene.add(new THREE.AxesHelper(50));\r\n        }\r\n        if (renderObj.options.showGrid) {\r\n            scene.add(new THREE.GridHelper(100, 100));\r\n        }\r\n\r\n        let light = new THREE.AmbientLight(0xFFFFFF); // soft white light\r\n        scene.add(light);\r\n\r\n        // Init controls\r\n        let controls = new OrbitControls(camera, renderer.domElement);\r\n        renderObj._controls = controls;\r\n        controls.enableZoom = renderObj.options.controls.zoom;\r\n        controls.enableRotate = renderObj.options.controls.rotate;\r\n        controls.enablePan = renderObj.options.controls.pan;\r\n        controls.enableKeys = renderObj.options.controls.keys;\r\n        controls.target.set(renderObj.options.camera.target[0], renderObj.options.camera.target[1], renderObj.options.camera.target[2]);\r\n\r\n        // Set camera location & target\r\n        camera.position.x = renderObj.options.camera.x;\r\n        camera.position.y = renderObj.options.camera.y;\r\n        camera.position.z = renderObj.options.camera.z;\r\n        camera.lookAt(new THREE.Vector3(renderObj.options.camera.target[0], renderObj.options.camera.target[1], renderObj.options.camera.target[2]));\r\n\r\n        // Do the render!\r\n        let animate = function () {\r\n            renderObj._animId = requestAnimationFrame(animate);\r\n\r\n            if (renderObj.onScreen) {\r\n                if (typeof renderCb === \"function\") renderCb();\r\n\r\n                composer.render();\r\n            }\r\n        };\r\n        renderObj._animate = animate;\r\n\r\n        if (!doNotAnimate) {\r\n            animate();\r\n        }\r\n\r\n        renderObj.onScreen = true;// default to true, in case the checking is disabled\r\n        let id = \"minerender-canvas-\" + renderObj._scene.uuid + \"-\" + Date.now();\r\n        renderObj._canvas.id = id;\r\n        if (renderObj.options.pauseHidden) {\r\n            renderObj.onScreen = false;// set to false if the check is enabled\r\n            let os = new OnScreen();\r\n\r\n            os.on(\"enter\", \"#\" + id, (element, event) => {\r\n                renderObj.onScreen = true;\r\n                if (renderObj.options.forceContext) {\r\n                    renderObj._renderer.forceContextRestore();\r\n                }\r\n            })\r\n            os.on(\"leave\", \"#\" + id, (element, event) => {\r\n                renderObj.onScreen = false;\r\n                if (renderObj.options.forceContext) {\r\n                    renderObj._renderer.forceContextLoss();\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds an object to the scene & sets userData.renderType to this renderer's type\r\n     * @param toAdd object to add\r\n     */\r\n    addToScene(toAdd) {\r\n        let renderObj = this;\r\n        if (renderObj._scene && toAdd) {\r\n            toAdd.userData.renderType = renderObj.renderType;\r\n            renderObj._scene.add(toAdd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the scene\r\n     * @param onlySelfType whether to remove only objects whose type is equal to this renderer's type (useful for combined render)\r\n     * @param filterFn Filter function to check which children of the scene to remove\r\n     */\r\n    clearScene(onlySelfType, filterFn) {\r\n        if (onlySelfType || filterFn) {\r\n            for (let i = this._scene.children.length - 1; i >= 0; i--) {\r\n                let child = this._scene.children[i];\r\n                if (filterFn) {\r\n                    let shouldKeep = filterFn(child);\r\n                    if (shouldKeep) {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (onlySelfType) {\r\n                    if (child.userData.renderType !== this.renderType) {\r\n                        continue;\r\n                    }\r\n                }\r\n                deepDisposeMesh(child, true);\r\n                this._scene.remove(child);\r\n            }\r\n        } else {\r\n            while (this._scene.children.length > 0) {\r\n                this._scene.remove(this._scene.children[0]);\r\n            }\r\n        }\r\n    };\r\n\r\n    dispose() {\r\n        cancelAnimationFrame(this._animId);\r\n\r\n        this.clearScene();\r\n\r\n        this._canvas.remove();\r\n        let el = this.element;\r\n        while (el.firstChild) {\r\n            el.removeChild(el.firstChild);\r\n        }\r\n    };\r\n\r\n}\r\n\r\n// https://stackoverflow.com/questions/27217388/use-multiple-materials-for-merged-geometries-in-three-js/44485364#44485364\r\nexport function deepDisposeMesh(obj, removeChildren) {\r\n    if (!obj) return;\r\n    if (obj.geometry && obj.geometry.dispose) obj.geometry.dispose();\r\n    if (obj.material && obj.material.dispose) obj.material.dispose();\r\n    if (obj.texture && obj.texture.dispose) obj.texture.dispose();\r\n    if (obj.children) {\r\n        let children = obj.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            deepDisposeMesh(children[i], removeChildren);\r\n        }\r\n\r\n        if (removeChildren) {\r\n            for (let i = obj.children.length - 1; i >= 0; i--) {\r\n                obj.remove(children[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport function mergeMeshes__(meshes, toBufferGeometry) {\r\n    let finalGeometry,\r\n        materials = [],\r\n        mergedGeometry = new THREE.Geometry(),\r\n        mergedMesh;\r\n\r\n    meshes.forEach(function (mesh, index) {\r\n        mesh.updateMatrix();\r\n        mesh.geometry.faces.forEach(function (face) {\r\n            face.materialIndex = 0;\r\n        });\r\n        mergedGeometry.merge(mesh.geometry, mesh.matrix, index);\r\n        materials.push(mesh.material);\r\n    });\r\n\r\n    mergedGeometry.groupsNeedUpdate = true;\r\n\r\n    if (toBufferGeometry) {\r\n        finalGeometry = new THREE.BufferGeometry().fromGeometry(mergedGeometry);\r\n    } else {\r\n        finalGeometry = mergedGeometry;\r\n    }\r\n\r\n    mergedMesh = new THREE.Mesh(finalGeometry, materials);\r\n    mergedMesh.geometry.computeFaceNormals();\r\n    mergedMesh.geometry.computeVertexNormals();\r\n\r\n    return mergedMesh;\r\n\r\n}\r\n\r\nexport function mergeCubeMeshes(cubes, toBuffer) {\r\n    cubes = cubes.filter(c => !!c);\r\n\r\n    let mergedCubes = new THREE.Geometry();\r\n    let mergedMaterials = [];\r\n    for (let i = 0; i < cubes.length; i++) {\r\n        let offset = i * Math.max(cubes[i].material.length, 1);\r\n        mergedCubes.merge(cubes[i].geometry, cubes[i].matrix, offset);\r\n        for (let j = 0; j < cubes[i].material.length; j++) {\r\n            mergedMaterials.push(cubes[i].material[j]);\r\n        }\r\n        // for (let j = 0; j < cubes[i].geometry.faces.length; j++) {\r\n        //     cubes[i].geometry.faces[j].materialIndex=offset-1+j;\r\n        // }\r\n\r\n        deepDisposeMesh(cubes[i], true);\r\n    }\r\n    mergedCubes.mergeVertices();\r\n    return {\r\n        geometry: toBuffer ? new THREE.BufferGeometry().fromGeometry(mergedCubes) : mergedCubes,\r\n        materials: mergedMaterials\r\n    };\r\n}\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/renderBase.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 155,
    "kind": "variable",
    "name": "defaultOptions",
    "memberof": "src/renderBase.js",
    "static": true,
    "longname": "src/renderBase.js~defaultOptions",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/renderBase.js",
    "importStyle": "{defaultOptions}",
    "description": "",
    "lineNumber": 27,
    "properties": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "showAxes",
        "description": "Debugging - Show the scene's axes"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "showOutlines",
        "description": "Debugging - Show bounding boxes"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "showGrid",
        "description": "Debugging - Show coordinate grid"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "controls",
        "description": "Controls settings"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "controls.enabled",
        "description": "Toggle controls"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "controls.zoom",
        "description": "Toggle zoom"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "controls.rotate",
        "description": "Toggle rotation"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "controls.pan",
        "description": "Toggle panning"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "camera",
        "description": "Camera settings"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "perspective",
        "defaultRaw": "perspective",
        "name": "camera.type",
        "description": "Camera type"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "camera.x",
        "description": "Camera X-position"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "camera.y",
        "description": "Camera Y-Position"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "camera.z",
        "description": "Camera Z-Position"
      },
      {
        "nullable": null,
        "types": [
          "number[]"
        ],
        "spread": false,
        "optional": false,
        "name": "camera.target",
        "description": "[x,y,z] array where the camera should look"
      }
    ],
    "type": {
      "types": [
        "{\"showAxes\": *, \"showGrid\": *, \"autoResize\": *, \"controls\": *, \"camera\": *, \"canvas\": *, \"pauseHidden\": boolean, \"forceContext\": *, \"sendStats\": boolean}"
      ]
    }
  },
  {
    "__docId__": 156,
    "kind": "class",
    "name": "Render",
    "memberof": "src/renderBase.js",
    "static": true,
    "longname": "src/renderBase.js~Render",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/renderBase.js",
    "importStyle": "Render",
    "description": "Base class for all Renders",
    "lineNumber": 57,
    "interface": false
  },
  {
    "__docId__": 157,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 65,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The options for this renderer, see {@link defaultOptions}"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "defOptions",
        "description": "Additional default options, provided by the individual renders"
      },
      {
        "nullable": null,
        "types": [
          "HTMLElement"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "document.body",
        "defaultRaw": "document.body",
        "name": "element",
        "description": "DOM Element to attach the renderer to - defaults to document.body"
      }
    ]
  },
  {
    "__docId__": 158,
    "kind": "member",
    "name": "element",
    "memberof": "src/renderBase.js~Render",
    "static": false,
    "longname": "src/renderBase.js~Render#element",
    "access": "public",
    "description": "DOM Element to attach the renderer to",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "HTMLElement"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 159,
    "kind": "member",
    "name": "options",
    "memberof": "src/renderBase.js~Render",
    "static": false,
    "longname": "src/renderBase.js~Render#options",
    "access": "public",
    "description": "Combined options",
    "lineNumber": 75,
    "type": {
      "nullable": null,
      "types": [
        "{"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "renderType",
    "memberof": "src/renderBase.js~Render",
    "static": false,
    "longname": "src/renderBase.js~Render#renderType",
    "access": "public",
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "toImage",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#toImage",
    "access": "public",
    "description": "",
    "lineNumber": 85,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} The content of the renderer's canvas as a Base64 encoded image"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "trim",
        "description": "whether to trim transparent pixels"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "image/png",
        "defaultRaw": "image/png",
        "name": "mime",
        "description": "mime type of the image"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "The content of the renderer's canvas as a Base64 encoded image"
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "toObj",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#toObj",
    "access": "public",
    "description": "Export the current scene content in the .obj format (only geometries, no textures)",
    "lineNumber": 110,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{string} the .obj file content"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the .obj file content"
    },
    "params": []
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "toGLTF",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#toGLTF",
    "access": "public",
    "description": "Export the current scene content in the .gltf format (geometries + textures)",
    "lineNumber": 121,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise<any>} a promise which resolves with the .gltf file content"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<any>"
      ],
      "spread": false,
      "description": "a promise which resolves with the .gltf file content"
    },
    "params": [
      {
        "name": "exportOptions",
        "types": [
          "*"
        ]
      }
    ]
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "toPLY",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#toPLY",
    "access": "public",
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "params": [
      {
        "name": "exportOptions",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "initScene",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#initScene",
    "access": "protected",
    "description": "Initializes the scene",
    "lineNumber": 147,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "renderCb",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "doNotAnimate",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "addToScene",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#addToScene",
    "access": "public",
    "description": "Adds an object to the scene & sets userData.renderType to this renderer's type",
    "lineNumber": 312,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "toAdd",
        "description": "object to add"
      }
    ],
    "return": null
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "clearScene",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#clearScene",
    "access": "public",
    "description": "Clears the scene",
    "lineNumber": 325,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "onlySelfType",
        "description": "whether to remove only objects whose type is equal to this renderer's type (useful for combined render)"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "filterFn",
        "description": "Filter function to check which children of the scene to remove"
      }
    ],
    "return": null
  },
  {
    "__docId__": 168,
    "kind": "method",
    "name": "dispose",
    "memberof": "src/renderBase.js~Render",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/renderBase.js~Render#dispose",
    "access": "public",
    "description": null,
    "lineNumber": 350,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 169,
    "kind": "function",
    "name": "deepDisposeMesh",
    "memberof": "src/renderBase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/renderBase.js~deepDisposeMesh",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/renderBase.js",
    "importStyle": "{deepDisposeMesh}",
    "description": null,
    "lineNumber": 365,
    "undocument": true,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      },
      {
        "name": "removeChildren",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 170,
    "kind": "function",
    "name": "mergeMeshes__",
    "memberof": "src/renderBase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/renderBase.js~mergeMeshes__",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/renderBase.js",
    "importStyle": "{mergeMeshes__}",
    "description": null,
    "lineNumber": 384,
    "undocument": true,
    "params": [
      {
        "name": "meshes",
        "types": [
          "*"
        ]
      },
      {
        "name": "toBufferGeometry",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 171,
    "kind": "function",
    "name": "mergeCubeMeshes",
    "memberof": "src/renderBase.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/renderBase.js~mergeCubeMeshes",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/renderBase.js",
    "importStyle": "{mergeCubeMeshes}",
    "description": null,
    "lineNumber": 415,
    "undocument": true,
    "params": [
      {
        "name": "cubes",
        "types": [
          "*"
        ]
      },
      {
        "name": "toBuffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"geometry\": *, \"materials\": *}"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "file",
    "name": "src/skin/index.js",
    "content": "import * as THREE from \"three\";\r\n\r\nimport texturePositions from \"./texturePositions\";\r\nimport Render, { defaultOptions } from \"../renderBase\";\r\n\r\n/**\r\n * @see defaultOptions\r\n */\r\nlet defOptions = {\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 20,\r\n        y: 35,\r\n        z: 20,\r\n        target: [0, 18, 0]\r\n    }\r\n};\r\n\r\n/**\r\n * A renderer for Minecraft player models/skins\r\n */\r\nclass SkinRender extends Render {\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, element) {\r\n        super(options, defOptions, element);\r\n\r\n        this.renderType = \"SkinRender\";\r\n        this._animId = -1;\r\n\r\n        // bind this renderer to the element\r\n        this.element.skinRender = this;\r\n        this.attached = false;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Does the actual rendering\r\n     *\r\n     * @param {(string|Object)} texture The texture to render - May be a string with the playername/URL/Base64 or an Object\r\n     * @param {string} texture.url URL to the texture image\r\n     * @param {string} texture.data Base64 encoded image data of the texture\r\n     * @param {string} texture.username Player username\r\n     * @param {string} texture.uuid Player UUID\r\n     * @param {number} texture.mineskin ID of a MineSkin.org skin\r\n     * @param {boolean} [texture.slim=false] Whether the provided texture uses the slim skin format\r\n     *\r\n     * @param {string} [texture.cape=latest] Cape to render using capes.dev - Either a direct link to the cape data (api.capes.dev/get/...) OR a specific cape type\r\n     * @param {string} [texture.capeUser] Specify this to use a different user for the cape texture than the skin\r\n     * @param {string} [texture.capeUrl] URL to a cape texture\r\n     * @param {string} [texture.capeData] Base64 encoded image data of the cape texture\r\n     * @param {string} [texture.mineskin] deprecated; ID of a MineSkin.org skin with a cape\r\n     * @param {boolean} [texture.optifine=false] deprecated; Whether the provided cape texture is an optifine cape\r\n     *\r\n     * @param {function} [cb] Callback when rendering finished\r\n     */\r\n    render(texture, cb) {\r\n        let skinRender = this;\r\n\r\n        let renderStarted = false;\r\n\r\n        let imagesLoaded = (skinTexture, capeTexture) => {\r\n            renderStarted = true;\r\n            skinTexture.needsUpdate = true;\r\n            if (capeTexture) capeTexture.needsUpdate = true;\r\n\r\n            let textureVersion = -1;\r\n            if (skinTexture.image.height === 32) {\r\n                textureVersion = 0;\r\n            } else if (skinTexture.image.height === 64) {\r\n                textureVersion = 1;\r\n            } else {\r\n                console.error(\"Couldn't detect texture version. Invalid dimensions: \" + skinTexture.image.width + \"x\" + skinTexture.image.height)\r\n            }\r\n            console.log(\"Skin Texture Version: \" + textureVersion)\r\n\r\n            // To keep the pixelated texture\r\n            skinTexture.magFilter = THREE.NearestFilter;\r\n            skinTexture.minFilter = THREE.NearestFilter;\r\n            skinTexture.anisotropy = 0;\r\n            if (capeTexture) {\r\n                capeTexture.magFilter = THREE.NearestFilter;\r\n                capeTexture.minFilter = THREE.NearestFilter;\r\n                capeTexture.anisotropy = 0;\r\n            }\r\n\r\n            if (!skinRender.attached && !skinRender._scene) {// Don't init scene if attached, since we already have an available scene\r\n                super.initScene(function () {\r\n                    skinRender.element.dispatchEvent(new CustomEvent(\"skinRender\", {detail: {playerModel: skinRender.playerModel}}));\r\n                });\r\n            } else {\r\n                console.log(\"[SkinRender] is attached - skipping scene init\");\r\n            }\r\n\r\n            console.log(\"Slim: \" + slim)\r\n            let playerModel = createPlayerModel(skinTexture, capeTexture, textureVersion, slim, texture._capeType ? texture._capeType : texture.optifine ? \"optifine\" : \"minecraft\");\r\n            skinRender.addToScene(playerModel);\r\n            // console.log(playerModel);\r\n            skinRender.playerModel = playerModel;\r\n\r\n            if (typeof cb === \"function\") cb();\r\n        }\r\n\r\n        skinRender._skinImage = new Image();\r\n        skinRender._skinImage.crossOrigin = \"anonymous\";\r\n        skinRender._capeImage = new Image();\r\n        skinRender._capeImage.crossOrigin = \"anonymous\";\r\n        let hasCape = texture.cape !== undefined || texture.capeUrl !== undefined || texture.capeData !== undefined || texture.mineskin !== undefined;\r\n        let slim = false;\r\n        let skinLoaded = false;\r\n        let capeLoaded = false;\r\n\r\n        let skinTexture = new THREE.Texture();\r\n        let capeTexture = new THREE.Texture();\r\n        skinTexture.image = skinRender._skinImage;\r\n        skinRender._skinImage.onload = function () {\r\n            if (!skinRender._skinImage) return;\r\n\r\n            skinLoaded = true;\r\n            console.log(\"Skin Image Loaded\");\r\n\r\n            if (texture.slim === undefined) {\r\n                if(skinRender._skinImage.height !== 32) {\r\n\r\n                    let detectCanvas = document.createElement(\"canvas\");\r\n                    let detectCtx = detectCanvas.getContext(\"2d\");\r\n                    // detectCanvas.style.display = \"none\";\r\n                    detectCanvas.width = skinRender._skinImage.width;\r\n                    detectCanvas.height = skinRender._skinImage.height;\r\n                    detectCtx.drawImage(skinRender._skinImage, 0, 0);\r\n\r\n                    console.log(\"Slim Detection:\")\r\n\r\n                    // Check the 2 columns that should be transparent on slim skins\r\n                    let px1 = detectCtx.getImageData(46, 52, 1, 12).data;\r\n                    let px2 = detectCtx.getImageData(54, 20, 1, 12).data;\r\n                    let allTransparent = true;\r\n                    for (let i = 3; i < 12 * 4; i += 4) {\r\n                        if (px1[i] === 255) {\r\n                            allTransparent = false;\r\n                            break;\r\n                        }\r\n                        if (px2[i] === 255) {\r\n                            allTransparent = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    console.log(allTransparent)\r\n\r\n                    if (allTransparent) slim = true;\r\n                }\r\n            }\r\n\r\n            if (skinLoaded && (capeLoaded || !hasCape)) {\r\n                if (!renderStarted) imagesLoaded(skinTexture, capeTexture);\r\n            }\r\n        };\r\n        skinRender._skinImage.onerror = function (e) {\r\n            console.warn(\"Skin Image Error\")\r\n            console.warn(e)\r\n        }\r\n        console.log(\"Has Cape: \" + hasCape)\r\n        if (hasCape) {\r\n            capeTexture.image = skinRender._capeImage;\r\n            skinRender._capeImage.onload = function () {\r\n                if (!skinRender._capeImage) return;\r\n\r\n                capeLoaded = true;\r\n                console.log(\"Cape Image Loaded\");\r\n\r\n                if (capeLoaded && skinLoaded) {\r\n                    if (!renderStarted) imagesLoaded(skinTexture, capeTexture);\r\n                }\r\n            }\r\n            skinRender._capeImage.onerror = function (e) {\r\n                console.warn(\"Cape Image Error\")\r\n                console.warn(e);\r\n\r\n                // Continue anyway, just without the cape\r\n                capeLoaded = true;\r\n                if (skinLoaded) {\r\n                    if (!renderStarted) imagesLoaded(skinTexture);\r\n                }\r\n            }\r\n        } else {\r\n            capeTexture = null;\r\n            skinRender._capeImage = null;\r\n        }\r\n\r\n        if (typeof texture === \"string\") {\r\n            // console.log(texture)\r\n            if (texture.indexOf(\"http\") === 0) {// URL\r\n                skinRender._skinImage.src = texture\r\n            } else if (texture.length <= 16) {// Probably a Minecraft username\r\n                getJSON(\"https://minerender.org/nameToUuid.php?name=\" + texture, function (err, data) {\r\n                    if (err) return console.log(err);\r\n                    console.log(data);\r\n                    skinRender._skinImage.src = \"https://crafatar.com/skins/\" + (data.id ? data.id : texture);\r\n                });\r\n            } else if (texture.length <= 36) {// Probably player UUID\r\n                image.src = \"https://crafatar.com/skins/\" + texture + \"?overlay\";\r\n            } else {// taking a guess that it's a Base64 image\r\n                skinRender._skinImage.src = texture;\r\n            }\r\n        } else if (typeof texture === \"object\") {\r\n            if (texture.url) {\r\n                skinRender._skinImage.src = texture.url;\r\n            } else if (texture.data) {\r\n                skinRender._skinImage.src = texture.data;\r\n            } else if (texture.username) {\r\n                getJSON(\"https://minerender.org/nameToUuid.php?name=\" + texture.username, function (err, data) {\r\n                    if (err) return console.log(err);\r\n                    skinRender._skinImage.src = \"https://crafatar.com/skins/\" + (data.id ? data.id : texture.username) + \"?overlay\";\r\n                });\r\n            } else if (texture.uuid) {\r\n                skinRender._skinImage.src = \"https://crafatar.com/skins/\" + texture.uuid + \"?overlay\";\r\n            } else if (texture.mineskin) {\r\n                skinRender._skinImage.src = \"https://api.mineskin.org/render/texture/\" + texture.mineskin;\r\n            }\r\n            if (texture.cape) {\r\n                if (texture.cape.length > 36) { // Likely either a cape ID or URL\r\n                    let capeDataUrl = texture.cape.startsWith(\"http\") ? texture.cape : \"https://api.capes.dev/get/\" + texture.cape;\r\n                    getJSON(capeDataUrl, function (err, data) {\r\n                        if (err) return console.log(err);\r\n                        if (data.exists) {\r\n                            texture._capeType = data.type;\r\n                            skinRender._capeImage.src = data.imageUrls.base.full;\r\n                        }\r\n                    })\r\n                } else { // Type\r\n                    let capeLoadUrl = \"https://api.capes.dev/load/\";\r\n                    if(texture.capeUser) {// Try to find a player to use\r\n                        capeLoadUrl+=texture.capeUser;\r\n                    }else if (texture.username){\r\n                        capeLoadUrl+=texture.username;\r\n                    }else if(texture.uuid){\r\n                        capeLoadUrl+=texture.uuid;\r\n                    } else {\r\n                        console.warn(\"Couldn't find a user to get a cape from\");\r\n                    }\r\n                    capeLoadUrl += \"/\" + texture.cape; // append type\r\n\r\n                    getJSON(capeLoadUrl, function (err, data) {\r\n                        if (err) return console.log(err);\r\n                         // Should be a single object of the requested type\r\n                        if (data.exists) {\r\n                            texture._capeType = data.type;\r\n                            skinRender._capeImage.src = data.imageUrls.base.full;\r\n                        }\r\n                    })\r\n                }\r\n            } else if (texture.capeUrl) {\r\n                skinRender._capeImage.src = texture.capeUrl;\r\n            } else if (texture.capeData) {\r\n                skinRender._capeImage.src = texture.capeData;\r\n            } else if (texture.mineskin) {\r\n                skinRender._capeImage.src = \"https://api.mineskin.org/render/texture/\" + texture.mineskin + \"/cape\";\r\n            }\r\n\r\n            slim = texture.slim;\r\n        } else {\r\n            throw new Error(\"Invalid texture value\")\r\n        }\r\n    };\r\n\r\n\r\n    resize(width, height) {\r\n        return this._resize(width, height);\r\n    };\r\n\r\n    reset() {\r\n        this._skinImage = null;\r\n        this._capeImage = null;\r\n\r\n        if (this._animId) {\r\n            cancelAnimationFrame(this._animId);\r\n        }\r\n        if (this._canvas) {\r\n            this._canvas.remove();\r\n        }\r\n    };\r\n\r\n    getPlayerModel() {\r\n        return this.playerModel;\r\n    };\r\n\r\n\r\n    getModelByName(name) {\r\n        return this._scene.getObjectByName(name, true);\r\n    };\r\n\r\n    toggleSkinPart(name, visible) {\r\n        this._scene.getObjectByName(name, true).visible = visible;\r\n    };\r\n\r\n\r\n}\r\n\r\nfunction createCube(texture, width, height, depth, textures, slim, name, transparent) {\r\n    let textureWidth = texture.image.width;\r\n    let textureHeight = texture.image.height;\r\n\r\n    let geometry = new THREE.BoxGeometry(width, height, depth);\r\n    let material = new THREE.MeshBasicMaterial({\r\n        /*color: 0x00ff00,*/map: texture, transparent: transparent || false, alphaTest: 0.5, side: transparent ? THREE.DoubleSide : THREE.FrontSide//TODO: double sided not working properly\r\n    });\r\n\r\n    geometry.computeBoundingBox();\r\n\r\n    geometry.faceVertexUvs[0] = [];\r\n\r\n    let faceNames = [\"right\", \"left\", \"top\", \"bottom\", \"front\", \"back\"];\r\n    let faceUvs = [];\r\n    for (let i = 0; i < faceNames.length; i++) {\r\n        let face = textures[faceNames[i]];\r\n        if (faceNames[i] === \"back\") {\r\n            //     console.log(face)\r\n            // console.log(\"X: \" + (slim && face.sx ? face.sx : face.x))\r\n            // console.log(\"W: \" + (slim && face.sw ? face.sw : face.w))\r\n        }\r\n        let w = textureWidth;\r\n        let h = textureHeight;\r\n        let tx1 = ((slim && face.sx ? face.sx : face.x) / w);\r\n        let ty1 = (face.y / h);\r\n        let tx2 = (((slim && face.sx ? face.sx : face.x) + (slim && face.sw ? face.sw : face.w)) / w);\r\n        let ty2 = ((face.y + face.h) / h);\r\n\r\n        faceUvs[i] = [\r\n            new THREE.Vector2(tx1, ty2),\r\n            new THREE.Vector2(tx1, ty1),\r\n            new THREE.Vector2(tx2, ty1),\r\n            new THREE.Vector2(tx2, ty2)\r\n        ];\r\n        // console.log(faceUvs[i])\r\n\r\n        let flipX = face.flipX;\r\n        let flipY = face.flipY;\r\n\r\n        let temp;\r\n        if (flipY) {\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[2];\r\n            faceUvs[i][1] = temp[3];\r\n            faceUvs[i][2] = temp[0];\r\n            faceUvs[i][3] = temp[1]\r\n        }\r\n        if (flipX) {//flip x\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[3];\r\n            faceUvs[i][1] = temp[2];\r\n            faceUvs[i][2] = temp[1];\r\n            faceUvs[i][3] = temp[0]\r\n        }\r\n    }\r\n\r\n    let j = 0;\r\n    for (let i = 0; i < faceUvs.length; i++) {\r\n        geometry.faceVertexUvs[0][j] = [faceUvs[i][0], faceUvs[i][1], faceUvs[i][3]];\r\n        geometry.faceVertexUvs[0][j + 1] = [faceUvs[i][1], faceUvs[i][2], faceUvs[i][3]];\r\n        j += 2;\r\n    }\r\n    geometry.uvsNeedUpdate = true;\r\n\r\n    let cube = new THREE.Mesh(geometry, material);\r\n    cube.name = name;\r\n    // cube.position.set(x, y, z);\r\n    cube.castShadow = true;\r\n    cube.receiveShadow = false;\r\n\r\n    return cube;\r\n};\r\n\r\n\r\nfunction createPlayerModel(skinTexture, capeTexture, v, slim, capeType) {\r\n    console.log(\"capeType: \" + capeType);\r\n\r\n    let headGroup = new THREE.Object3D();\r\n    headGroup.name = \"headGroup\";\r\n    headGroup.position.x = 0;\r\n    headGroup.position.y = 28;\r\n    headGroup.position.z = 0;\r\n    headGroup.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n    let head = createCube(skinTexture,\r\n        8, 8, 8,\r\n        texturePositions.head[v],\r\n        slim,\r\n        \"head\"\r\n    );\r\n    head.translateOnAxis(new THREE.Vector3(0, 1, 0), 4);\r\n    headGroup.add(head);\r\n    if (v >= 1) {\r\n        let hat = createCube(skinTexture,\r\n            8.504, 8.504, 8.504,\r\n            texturePositions.hat,\r\n            slim,\r\n            \"hat\",\r\n            true\r\n        );\r\n        hat.translateOnAxis(new THREE.Vector3(0, 1, 0), 4);\r\n        headGroup.add(hat);\r\n    }\r\n\r\n    let bodyGroup = new THREE.Object3D();\r\n    bodyGroup.name = \"bodyGroup\";\r\n    bodyGroup.position.x = 0;\r\n    bodyGroup.position.y = 18;\r\n    bodyGroup.position.z = 0;\r\n    let body = createCube(skinTexture,\r\n        8, 12, 4,\r\n        texturePositions.body[v],\r\n        slim,\r\n        \"body\"\r\n    );\r\n    bodyGroup.add(body);\r\n    if (v >= 1) {\r\n        let jacket = createCube(skinTexture,\r\n            8.504, 12.504, 4.504,\r\n            texturePositions.jacket,\r\n            slim,\r\n            \"jacket\",\r\n            true\r\n        );\r\n        bodyGroup.add(jacket);\r\n    }\r\n\r\n    let leftArmGroup = new THREE.Object3D();\r\n    leftArmGroup.name = \"leftArmGroup\";\r\n    leftArmGroup.position.x = slim ? -5.5 : -6;\r\n    leftArmGroup.position.y = 18;\r\n    leftArmGroup.position.z = 0;\r\n    leftArmGroup.translateOnAxis(new THREE.Vector3(0, 1, 0), 4);\r\n    let leftArm = createCube(skinTexture,\r\n        slim ? 3 : 4, 12, 4,\r\n        texturePositions.leftArm[v],\r\n        slim,\r\n        \"leftArm\"\r\n    );\r\n    leftArm.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n    leftArmGroup.add(leftArm);\r\n    if (v >= 1) {\r\n        let leftSleeve = createCube(skinTexture,\r\n            slim ? 3.504 : 4.504, 12.504, 4.504,\r\n            texturePositions.leftSleeve,\r\n            slim,\r\n            \"leftSleeve\",\r\n            true\r\n        );\r\n        leftSleeve.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n        leftArmGroup.add(leftSleeve);\r\n    }\r\n\r\n    let rightArmGroup = new THREE.Object3D();\r\n    rightArmGroup.name = \"rightArmGroup\";\r\n    rightArmGroup.position.x = slim ? 5.5 : 6;\r\n    rightArmGroup.position.y = 18;\r\n    rightArmGroup.position.z = 0;\r\n    rightArmGroup.translateOnAxis(new THREE.Vector3(0, 1, 0), 4);\r\n    let rightArm = createCube(skinTexture,\r\n        slim ? 3 : 4, 12, 4,\r\n        texturePositions.rightArm[v],\r\n        slim,\r\n        \"rightArm\"\r\n    );\r\n    rightArm.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n    rightArmGroup.add(rightArm);\r\n    if (v >= 1) {\r\n        let rightSleeve = createCube(skinTexture,\r\n            slim ? 3.504 : 4.504, 12.504, 4.504,\r\n            texturePositions.rightSleeve,\r\n            slim,\r\n            \"rightSleeve\",\r\n            true\r\n        );\r\n        rightSleeve.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n        rightArmGroup.add(rightSleeve);\r\n    }\r\n\r\n    let leftLegGroup = new THREE.Object3D();\r\n    leftLegGroup.name = \"leftLegGroup\";\r\n    leftLegGroup.position.x = -2;\r\n    leftLegGroup.position.y = 6;\r\n    leftLegGroup.position.z = 0;\r\n    leftLegGroup.translateOnAxis(new THREE.Vector3(0, 1, 0), 4);\r\n    let leftLeg = createCube(skinTexture,\r\n        4, 12, 4,\r\n        texturePositions.leftLeg[v],\r\n        slim,\r\n        \"leftLeg\"\r\n    );\r\n    leftLeg.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n    leftLegGroup.add(leftLeg);\r\n    if (v >= 1) {\r\n        let leftTrousers = createCube(skinTexture,\r\n            4.504, 12.504, 4.504,\r\n            texturePositions.leftTrousers,\r\n            slim,\r\n            \"leftTrousers\",\r\n            true\r\n        );\r\n        leftTrousers.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n        leftLegGroup.add(leftTrousers);\r\n    }\r\n\r\n    let rightLegGroup = new THREE.Object3D();\r\n    rightLegGroup.name = \"rightLegGroup\";\r\n    rightLegGroup.position.x = 2;\r\n    rightLegGroup.position.y = 6;\r\n    rightLegGroup.position.z = 0;\r\n    rightLegGroup.translateOnAxis(new THREE.Vector3(0, 1, 0), 4);\r\n    let rightLeg = createCube(skinTexture,\r\n        4, 12, 4,\r\n        texturePositions.rightLeg[v],\r\n        slim,\r\n        \"rightLeg\"\r\n    );\r\n    rightLeg.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n    rightLegGroup.add(rightLeg);\r\n    if (v >= 1) {\r\n        let rightTrousers = createCube(skinTexture,\r\n            4.504, 12.504, 4.504,\r\n            texturePositions.rightTrousers,\r\n            slim,\r\n            \"rightTrousers\",\r\n            true\r\n        );\r\n        rightTrousers.translateOnAxis(new THREE.Vector3(0, 1, 0), -4);\r\n        rightLegGroup.add(rightTrousers);\r\n    }\r\n\r\n    let playerGroup = new THREE.Object3D();\r\n    playerGroup.add(headGroup);\r\n    playerGroup.add(bodyGroup);\r\n    playerGroup.add(leftArmGroup);\r\n    playerGroup.add(rightArmGroup);\r\n    playerGroup.add(leftLegGroup);\r\n    playerGroup.add(rightLegGroup);\r\n\r\n    if (capeTexture) {\r\n        console.log(texturePositions);\r\n        let capeTextureCoordinates = texturePositions.capeRelative;\r\n        if (capeType === \"optifine\" && capeTexture.image.height > 24) { // 'classic' OF capes are the same size as the official capes, just the custom ones are double sized\r\n            capeTextureCoordinates = texturePositions.capeOptifineRelative;\r\n        }\r\n        if (capeType === \"labymod\") {\r\n            capeTextureCoordinates = texturePositions.capeLabymodRelative;\r\n        }\r\n        capeTextureCoordinates = JSON.parse(JSON.stringify(capeTextureCoordinates)); // bad clone to keep the below scaling from affecting everything\r\n\r\n        console.log(capeTextureCoordinates);\r\n\r\n        // Multiply coordinates by image dimensions\r\n        for (let cord in capeTextureCoordinates) {\r\n            capeTextureCoordinates[cord].x *= capeTexture.image.width;\r\n            capeTextureCoordinates[cord].w *= capeTexture.image.width;\r\n            capeTextureCoordinates[cord].y *= capeTexture.image.height;\r\n            capeTextureCoordinates[cord].h *= capeTexture.image.height;\r\n        }\r\n\r\n        console.log(capeTextureCoordinates);\r\n\r\n        let capeGroup = new THREE.Object3D();\r\n        capeGroup.name = \"capeGroup\";\r\n        capeGroup.position.x = 0;\r\n        capeGroup.position.y = 16;\r\n        capeGroup.position.z = -2.5;\r\n        capeGroup.translateOnAxis(new THREE.Vector3(0, 1, 0), 8);\r\n        capeGroup.translateOnAxis(new THREE.Vector3(0, 0, 1), 0.5);\r\n        let cape = createCube(capeTexture,\r\n            10, 16, 1,\r\n            capeTextureCoordinates,\r\n            false,\r\n            \"cape\");\r\n        cape.rotation.x = toRadians(10); // slight backward angle\r\n        cape.translateOnAxis(new THREE.Vector3(0, 1, 0), -8);\r\n        cape.translateOnAxis(new THREE.Vector3(0, 0, 1), -0.5);\r\n        cape.rotation.y = toRadians(180); // flip front&back to be correct\r\n        capeGroup.add(cape)\r\n\r\n        playerGroup.add(capeGroup);\r\n    }\r\n\r\n    return playerGroup;\r\n};\r\n\r\n// From https://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/\r\nfunction buildAxes(length) {\r\n    let axes = new THREE.Object3D();\r\n\r\n    axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(length, 0, 0), 0xFF0000, false)); // +X\r\n    axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(-length, 0, 0), 0xFF0000, true)); // -X\r\n    axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, length, 0), 0x00FF00, false)); // +Y\r\n    axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -length, 0), 0x00FF00, true)); // -Y\r\n    axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, length), 0x0000FF, false)); // +Z\r\n    axes.add(buildAxis(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -length), 0x0000FF, true)); // -Z\r\n\r\n    return axes;\r\n\r\n};\r\n\r\nfunction buildAxis(src, dst, colorHex, dashed) {\r\n    let geom = new THREE.Geometry(),\r\n        mat;\r\n\r\n    if (dashed) {\r\n        mat = new THREE.LineDashedMaterial({linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3});\r\n    } else {\r\n        mat = new THREE.LineBasicMaterial({linewidth: 3, color: colorHex});\r\n    }\r\n\r\n    geom.vertices.push(src.clone());\r\n    geom.vertices.push(dst.clone());\r\n    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines\r\n\r\n    return new THREE.Line(geom, mat, THREE.LinePieces);\r\n};\r\n\r\nfunction toRadians(angle) {\r\n    return angle * (Math.PI / 180);\r\n}\r\n\r\nfunction getJSON(url, callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'json';\r\n    xhr.onload = function () {\r\n        let status = xhr.status;\r\n        let r = xhr.response || xhr.responseText;\r\n        if (typeof r === \"string\") {\r\n            r = JSON.parse(r);\r\n        }\r\n        if (status === 200) {\r\n            callback(null, r);\r\n        } else {\r\n            callback(xhr.statusText, r);\r\n        }\r\n    };\r\n    xhr.send();\r\n}\r\n\r\nif (typeof window !== \"undefined\")\r\n    window.SkinRender = SkinRender;\r\nif (typeof global !== \"undefined\")\r\n    global.SkinRender = SkinRender;\r\n\r\nexport default SkinRender;\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/skin/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 173,
    "kind": "variable",
    "name": "defOptions",
    "memberof": "src/skin/index.js",
    "static": true,
    "longname": "src/skin/index.js~defOptions",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": null,
    "description": "",
    "see": [
      "defaultOptions"
    ],
    "lineNumber": 9,
    "type": {
      "types": [
        "{\"camera\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 174,
    "kind": "function",
    "name": "createCube",
    "memberof": "src/skin/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/skin/index.js~createCube",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 304,
    "undocument": true,
    "params": [
      {
        "name": "texture",
        "types": [
          "*"
        ]
      },
      {
        "name": "width",
        "types": [
          "*"
        ]
      },
      {
        "name": "height",
        "types": [
          "*"
        ]
      },
      {
        "name": "depth",
        "types": [
          "*"
        ]
      },
      {
        "name": "textures",
        "types": [
          "*"
        ]
      },
      {
        "name": "slim",
        "types": [
          "*"
        ]
      },
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "transparent",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 175,
    "kind": "function",
    "name": "createPlayerModel",
    "memberof": "src/skin/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/skin/index.js~createPlayerModel",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 379,
    "undocument": true,
    "params": [
      {
        "name": "skinTexture",
        "types": [
          "*"
        ]
      },
      {
        "name": "capeTexture",
        "types": [
          "*"
        ]
      },
      {
        "name": "v",
        "types": [
          "*"
        ]
      },
      {
        "name": "slim",
        "types": [
          "*"
        ]
      },
      {
        "name": "capeType",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 176,
    "kind": "function",
    "name": "buildAxes",
    "memberof": "src/skin/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/skin/index.js~buildAxes",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 591,
    "undocument": true,
    "params": [
      {
        "name": "length",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 177,
    "kind": "function",
    "name": "buildAxis",
    "memberof": "src/skin/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/skin/index.js~buildAxis",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 605,
    "undocument": true,
    "params": [
      {
        "name": "src",
        "types": [
          "*"
        ]
      },
      {
        "name": "dst",
        "types": [
          "*"
        ]
      },
      {
        "name": "colorHex",
        "types": [
          "*"
        ]
      },
      {
        "name": "dashed",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 178,
    "kind": "function",
    "name": "toRadians",
    "memberof": "src/skin/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/skin/index.js~toRadians",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 622,
    "undocument": true,
    "params": [
      {
        "name": "angle",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 179,
    "kind": "function",
    "name": "getJSON",
    "memberof": "src/skin/index.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/skin/index.js~getJSON",
    "access": "public",
    "export": false,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 626,
    "undocument": true,
    "params": [
      {
        "name": "url",
        "types": [
          "*"
        ]
      },
      {
        "name": "callback",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 180,
    "kind": "class",
    "name": "SkinRender",
    "memberof": "src/skin/index.js",
    "static": true,
    "longname": "src/skin/index.js~SkinRender",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/skin/index.js",
    "importStyle": "SkinRender",
    "description": "A renderer for Minecraft player models/skins",
    "lineNumber": 22,
    "interface": false,
    "extends": [
      "src/renderBase.js~Render"
    ]
  },
  {
    "__docId__": 181,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/skin/index.js~SkinRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/skin/index.js~SkinRender#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 29,
    "unknown": [
      {
        "tagName": "@constructor",
        "tagValue": ""
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "options",
        "description": "The options for this renderer, see {@link defaultOptions}"
      },
      {
        "nullable": null,
        "types": [
          "HTMLElement"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "document.body",
        "defaultRaw": "document.body",
        "name": "element",
        "description": "DOM Element to attach the renderer to - defaults to document.body"
      }
    ]
  },
  {
    "__docId__": 182,
    "kind": "member",
    "name": "renderType",
    "memberof": "src/skin/index.js~SkinRender",
    "static": false,
    "longname": "src/skin/index.js~SkinRender#renderType",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 183,
    "kind": "member",
    "name": "_animId",
    "memberof": "src/skin/index.js~SkinRender",
    "static": false,
    "longname": "src/skin/index.js~SkinRender#_animId",
    "access": "private",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "member",
    "name": "attached",
    "memberof": "src/skin/index.js~SkinRender",
    "static": false,
    "longname": "src/skin/index.js~SkinRender#attached",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "render",
    "memberof": "src/skin/index.js~SkinRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/skin/index.js~SkinRender#render",
    "access": "public",
    "description": "Does the actual rendering",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "texture",
        "description": "The texture to render - May be a string with the playername/URL/Base64 or an Object"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "texture.url",
        "description": "URL to the texture image"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "texture.data",
        "description": "Base64 encoded image data of the texture"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "texture.username",
        "description": "Player username"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "texture.uuid",
        "description": "Player UUID"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "texture.mineskin",
        "description": "ID of a MineSkin.org skin"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "texture.slim",
        "description": "Whether the provided texture uses the slim skin format"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "latest",
        "defaultRaw": "latest",
        "name": "texture.cape",
        "description": "Cape to render using capes.dev - Either a direct link to the cape data (api.capes.dev/get/...) OR a specific cape type"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "texture.capeUser",
        "description": "Specify this to use a different user for the cape texture than the skin"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "texture.capeUrl",
        "description": "URL to a cape texture"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "texture.capeData",
        "description": "Base64 encoded image data of the cape texture"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "name": "texture.mineskin",
        "description": "deprecated; ID of a MineSkin.org skin with a cape"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "texture.optifine",
        "description": "deprecated; Whether the provided cape texture is an optifine cape"
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "cb",
        "description": "Callback when rendering finished"
      }
    ],
    "return": null
  },
  {
    "__docId__": 186,
    "kind": "method",
    "name": "resize",
    "memberof": "src/skin/index.js~SkinRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/skin/index.js~SkinRender#resize",
    "access": "public",
    "description": null,
    "lineNumber": 272,
    "undocument": true,
    "params": [
      {
        "name": "width",
        "types": [
          "*"
        ]
      },
      {
        "name": "height",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "method",
    "name": "reset",
    "memberof": "src/skin/index.js~SkinRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/skin/index.js~SkinRender#reset",
    "access": "public",
    "description": null,
    "lineNumber": 276,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 188,
    "kind": "member",
    "name": "_skinImage",
    "memberof": "src/skin/index.js~SkinRender",
    "static": false,
    "longname": "src/skin/index.js~SkinRender#_skinImage",
    "access": "private",
    "description": null,
    "lineNumber": 277,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "_capeImage",
    "memberof": "src/skin/index.js~SkinRender",
    "static": false,
    "longname": "src/skin/index.js~SkinRender#_capeImage",
    "access": "private",
    "description": null,
    "lineNumber": 278,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 190,
    "kind": "method",
    "name": "getPlayerModel",
    "memberof": "src/skin/index.js~SkinRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/skin/index.js~SkinRender#getPlayerModel",
    "access": "public",
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 191,
    "kind": "method",
    "name": "getModelByName",
    "memberof": "src/skin/index.js~SkinRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/skin/index.js~SkinRender#getModelByName",
    "access": "public",
    "description": null,
    "lineNumber": 293,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 192,
    "kind": "method",
    "name": "toggleSkinPart",
    "memberof": "src/skin/index.js~SkinRender",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/skin/index.js~SkinRender#toggleSkinPart",
    "access": "public",
    "description": null,
    "lineNumber": 297,
    "undocument": true,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "visible",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 193,
    "kind": "file",
    "name": "src/skin/texturePositions.js",
    "content": "/**\r\n * Texture positions for Minecraft's player model\r\n */\r\nconst texturePositions =  {\r\n    head: [\r\n        {// 64x32\r\n            left: {\r\n                x: 0,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 8,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 16,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 24,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 8,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            bottom: {\r\n                x: 16,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 0,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 8,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 16,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 24,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 8,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            bottom: {\r\n                x: 16,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        }\r\n    ],\r\n    body: [\r\n        {// 64x32\r\n            left: {\r\n                x: 16,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 0,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            right: {\r\n                x: 28,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            back: {\r\n                x: 32,\r\n                y: 0,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 12,\r\n                w: 8,\r\n                h: 4\r\n            },\r\n            bottom: {\r\n                x: 28,\r\n                y: 12,\r\n                w: 8,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 16,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 32,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            right: {\r\n                x: 28,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 32,\r\n                y: 32,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 44,\r\n                w: 8,\r\n                h: 4\r\n            },\r\n            bottom: {\r\n                x: 28,\r\n                y: 44,\r\n                w: 8,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    rightArm: [\r\n        {// 64x32 - same as rightArm\r\n            left: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 32,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 36,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 39,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 43,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 36,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 40,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                sx: 39,\r\n                sw: 3,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    leftArm: [\r\n        {// 64x32 - same as leftArm\r\n            left: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 40,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 47,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 51,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                sx: 47,\r\n                sw: 3,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    rightLeg: [\r\n        {// 64x32 - same as rightLeg\r\n            left: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 16,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 24,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 28,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 24,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    leftLeg: [\r\n        {// 64x32 - same as leftLeg\r\n            left: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 0,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n\r\n    hat: {\r\n        left: {\r\n            x: 32,\r\n            y: 48,\r\n            w: 8,\r\n            h: 8\r\n        },\r\n        front: {\r\n            x: 40,\r\n            y: 48,\r\n            w: 8,\r\n            h: 8\r\n        },\r\n        right: {\r\n            x: 48,\r\n            y: 48,\r\n            w: 8,\r\n            h: 8\r\n        },\r\n        back: {\r\n            x: 56,\r\n            y: 48,\r\n            w: 8,\r\n            h: 8\r\n        },\r\n        top: {\r\n            x: 40,\r\n            y: 56,\r\n            w: 8,\r\n            h: 8,\r\n            flipX: false\r\n        },\r\n        bottom: {\r\n            x: 48,\r\n            y: 56,\r\n            w: 8,\r\n            h: 8,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    jacket: {\r\n        left: {\r\n            x: 16,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 20,\r\n            y: 16,\r\n            w: 8,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 28,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 32,\r\n            y: 16,\r\n            w: 8,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 20,\r\n            y: 28,\r\n            w: 8,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 28,\r\n            y: 28,\r\n            w: 8,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    rightSleeve: {\r\n        left: {\r\n            x: 48,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 52,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sw: 3\r\n        },\r\n        right: {\r\n            x: 56,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 55\r\n        },\r\n        back: {\r\n            x: 60,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 59,\r\n            sw: 3\r\n        },\r\n        top: {\r\n            x: 52,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            sw: 3\r\n        },\r\n        bottom: {\r\n            x: 56,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            sx: 55,\r\n            sw: 3,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    leftSleeve: {\r\n        left: {\r\n            x: 40,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 44,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sw: 3\r\n        },\r\n        right: {\r\n            x: 48,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 47\r\n        },\r\n        back: {\r\n            x: 52,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 51,\r\n            sw: 3\r\n        },\r\n        top: {\r\n            x: 44,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            sw: 3\r\n        },\r\n        bottom: {\r\n            x: 48,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            sx: 47,\r\n            sw: 3,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    rightTrousers: {\r\n        left: {\r\n            x: 0,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 4,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 8,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 4,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 8,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    leftTrousers: {\r\n        left: {\r\n            x: 0,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 4,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 8,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 4,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 8,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n\r\n    cape: {\r\n        right: {\r\n            x: 0,\r\n            y: 5,\r\n            w: 1,\r\n            h: 16\r\n        },\r\n        front: {\r\n            x: 1,\r\n            y: 5,\r\n            w: 10,\r\n            h: 16\r\n        },\r\n        left: {\r\n            x: 11,\r\n            y: 5,\r\n            w: 1,\r\n            h: 16\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 5,\r\n            w: 10,\r\n            h: 16\r\n        },\r\n        top: {\r\n            x: 1,\r\n            y: 21,\r\n            w: 10,\r\n            h: 1\r\n        },\r\n        bottom: {\r\n            x: 11,\r\n            y: 21,\r\n            w: 10,\r\n            h: 1\r\n        }\r\n    },\r\n    capeRelative: { // Cape coordinates relative to image dimensions, starting bottom-left\r\n        right: {\r\n            x: 0,\r\n            y: 15/32,\r\n            w: 1/64,\r\n            h: 16/32\r\n        },\r\n        front: {\r\n            x: 1/64,\r\n            y: 15/32,\r\n            w: 10/64,\r\n            h: 16/32\r\n        },\r\n        left: {\r\n            x: 11/64,\r\n            y: 15/32,\r\n            w: 1/64,\r\n            h: 16/32\r\n        },\r\n        back: {\r\n            x: 12/64,\r\n            y: 15/32,\r\n            w: 10/64,\r\n            h: 16/32\r\n        },\r\n        top: {\r\n            x: 1/64,\r\n            y: 31/32,\r\n            w: 10/64,\r\n            h: 1/32\r\n        },\r\n        bottom: {\r\n            x: 11/64,\r\n            y: 31/32,\r\n            w: 10/64,\r\n            h: 1/32\r\n        }\r\n    },\r\n    capeOptifineRelative: {\r\n        right: {\r\n            x: 0,\r\n            y: 10/44,\r\n            w: 2/92,\r\n            h: 32/44\r\n        },\r\n        front: {\r\n            x: 2/92,\r\n            y: 10/44,\r\n            w: 20/92,\r\n            h: 32/44\r\n        },\r\n        left: {\r\n            x: 22/92,\r\n            y: 10/44,\r\n            w: 2/92,\r\n            h: 32/44\r\n        },\r\n        back: {\r\n            x: 24/92,\r\n            y: 10/44,\r\n            w: 20/92,\r\n            h: 32/44\r\n        },\r\n        top: {\r\n            x: 2/92,\r\n            y: 42/44,\r\n            w: 20/92,\r\n            h: 2/44\r\n        },\r\n        bottom: {\r\n            x: 22/92,\r\n            y: 42/44,\r\n            w: 20/92,\r\n            h: 2/44\r\n        }\r\n    },\r\n    capeOptifine: {\r\n        right: {\r\n            x: 0,\r\n            y: 10,\r\n            w: 2,\r\n            h: 32\r\n        },\r\n        front: {\r\n            x: 2,\r\n            y: 10,\r\n            w: 20,\r\n            h: 32\r\n        },\r\n        left: {\r\n            x: 22,\r\n            y: 10,\r\n            w: 2,\r\n            h: 32\r\n        },\r\n        back: {\r\n            x: 24,\r\n            y: 10,\r\n            w: 20,\r\n            h: 32\r\n        },\r\n        top: {\r\n            x: 2,\r\n            y: 42,\r\n            w: 20,\r\n            h: 2\r\n        },\r\n        bottom: {\r\n            x: 22,\r\n            y: 42,\r\n            w: 20,\r\n            h: 2\r\n        }\r\n    },\r\n    capeLabymodRelative: {\r\n        right: {\r\n            x: 0,\r\n            y: 0,\r\n            w: 1/22,\r\n            h: 16/17\r\n        },\r\n        front: {\r\n            x: 1/22,\r\n            y: 0,\r\n            w: 10/22,\r\n            h: 16/17\r\n        },\r\n        left: {\r\n            x: 11/22,\r\n            y: 0,\r\n            w: 1/22,\r\n            h: 16/17\r\n        },\r\n        back: {\r\n            x: 12/22,\r\n            y: 0,\r\n            w: 10/22,\r\n            h: 16/17\r\n        },\r\n        top: {\r\n            x: 1/22,\r\n            y: 16/17,\r\n            w: 10/22,\r\n            h: 1/17\r\n        },\r\n        bottom: {\r\n            x: 11/22,\r\n            y: 16/17,\r\n            w: 10/22,\r\n            h: 1/17\r\n        }\r\n    },\r\n};\r\n\r\nexport default texturePositions;\r\n",
    "static": true,
    "longname": "P:/_Projects_Node/MineRender/src/skin/texturePositions.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 194,
    "kind": "variable",
    "name": "texturePositions",
    "memberof": "src/skin/texturePositions.js",
    "static": true,
    "longname": "src/skin/texturePositions.js~texturePositions",
    "access": "public",
    "export": true,
    "importPath": "minerender/src/skin/texturePositions.js",
    "importStyle": "texturePositions",
    "description": "Texture positions for Minecraft's player model",
    "lineNumber": 4,
    "type": {
      "types": [
        "{\"head\": *, \"body\": *, \"rightArm\": *, \"leftArm\": *, \"rightLeg\": *, \"leftLeg\": *, \"hat\": *, \"jacket\": *, \"rightSleeve\": *, \"leftSleeve\": *, \"rightTrousers\": *, \"leftTrousers\": *, \"cape\": *, \"capeRelative\": *, \"capeOptifineRelative\": *, \"capeOptifine\": *, \"capeLabymodRelative\": *}"
      ]
    }
  },
  {
    "kind": "index",
    "content": "[![Build Status](https://travis-ci.org/InventivetalentDev/MineRender.svg?branch=master)](https://travis-ci.org/InventivetalentDev/MineRender) \r\n[![Documentation Coverage](https://docs.minerender.org/badge.svg)](https://docs.minerender.org)\r\n\r\n\r\n![MineRender](https://minerender.org/img/minerender-x128.png)\r\n\r\n# MineRender\r\n## Quick, Easy, Interactive 3D/2D Renders of Minecraft\r\n\r\n\r\n[MineRender.org](https://minerender.org/)\r\n",
    "longname": "P:\\_Projects_Node\\MineRender\\README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\r\n  \"name\": \"minerender\",\r\n  \"version\": \"1.3.0\",\r\n  \"description\": \"\",\r\n  \"main\": \"src/combined/index.js\",\r\n  \"scripts\": {\r\n    \"build\": \"webpack --progress\",\r\n    \"build:w\": \"webpack --progress --watch\",\r\n    \"build:silent\": \"webpack\",\r\n    \"docs\": \"./node_modules/.bin/esdoc\"\r\n  },\r\n  \"author\": \"Haylee Schfer\",\r\n  \"license\": \"MIT\",\r\n  \"dependencies\": {\r\n    \"@johh/three-effectcomposer\": \"0.0.7\",\r\n    \"deepmerge\": \"^4.0.0\",\r\n    \"esdoc\": \"^1.1.0\",\r\n    \"esdoc-standard-plugin\": \"^1.0.0\",\r\n    \"java-parser\": \"0.3.2\",\r\n    \"jquery\": \"^3.3.1\",\r\n    \"md5\": \"^2.2.1\",\r\n    \"nbt-js\": \"^0.1.0\",\r\n    \"onscreen\": \"^1.3.2\",\r\n    \"pako\": \"^1.0.6\",\r\n    \"prismarine-nbt\": \"^1.2.0\",\r\n    \"three\": \"0.93.0\",\r\n    \"three-instanced-mesh\": \"git+https://github.com/InventivetalentDev/three-instanced-mesh.git\",\r\n    \"threejs-ext\": \"^0.92.0\",\r\n    \"webworkify-webpack\": \"^2.1.3\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"progress-bar-webpack-plugin\": \"1.12.1\",\r\n    \"webpack\": \"4.41.1\",\r\n    \"webpack-cli\": \"3.0.8\",\r\n    \"worker-loader\": \"2.0.0\"\r\n  }\r\n}\r\n",
    "longname": "P:\\_Projects_Node\\MineRender\\package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]