/*!
 * MineRender 1.4.13
 * (c) 2018, Haylee Sch√§fer (inventivetalent) / MIT License
 * https://minerender.org
 * Build #1747647364648 / Mon May 19 2025 11:36:04 GMT+0200 (Central European Summer Time)
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/model/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@johh/three-effectcomposer/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _CopyShader = __webpack_require__(/*! ./lib/CopyShader */ \"./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js\");\n\nObject.defineProperty(exports, 'CopyShader', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_CopyShader).default;\n  }\n});\n\nvar _Pass = __webpack_require__(/*! ./lib/Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nObject.defineProperty(exports, 'Pass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_Pass).default;\n  }\n});\n\nvar _ShaderPass = __webpack_require__(/*! ./lib/ShaderPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js\");\n\nObject.defineProperty(exports, 'ShaderPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_ShaderPass).default;\n  }\n});\n\nvar _RenderingPass = __webpack_require__(/*! ./lib/RenderingPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js\");\n\nObject.defineProperty(exports, 'RenderingPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_RenderingPass).default;\n  }\n});\n\nvar _TexturePass = __webpack_require__(/*! ./lib/TexturePass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js\");\n\nObject.defineProperty(exports, 'TexturePass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_TexturePass).default;\n  }\n});\n\nvar _RenderPass = __webpack_require__(/*! ./lib/RenderPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js\");\n\nObject.defineProperty(exports, 'RenderPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_RenderPass).default;\n  }\n});\n\nvar _MaskPass = __webpack_require__(/*! ./lib/MaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js\");\n\nObject.defineProperty(exports, 'MaskPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_MaskPass).default;\n  }\n});\n\nvar _ClearMaskPass = __webpack_require__(/*! ./lib/ClearMaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js\");\n\nObject.defineProperty(exports, 'ClearMaskPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_ClearMaskPass).default;\n  }\n});\n\nvar _ClearPass = __webpack_require__(/*! ./lib/ClearPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js\");\n\nObject.defineProperty(exports, 'ClearPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_ClearPass).default;\n  }\n});\n\nvar _EffectComposer = __webpack_require__(/*! ./lib/EffectComposer */ \"./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js\");\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_EffectComposer).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/index.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ClearMaskPass = function (_Pass) {\n\t_inherits(ClearMaskPass, _Pass);\n\n\tfunction ClearMaskPass() {\n\t\t_classCallCheck(this, ClearMaskPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (ClearMaskPass.__proto__ || Object.getPrototypeOf(ClearMaskPass)).call(this));\n\n\t\t_this.needsSwap = false;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(ClearMaskPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer) {\n\n\t\t\trenderer.state.buffers.stencil.setTest(false);\n\t\t}\n\t}]);\n\n\treturn ClearMaskPass;\n}(_Pass3.default);\n\nexports.default = ClearMaskPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ClearPass = function (_Pass) {\n\t_inherits(ClearPass, _Pass);\n\n\tfunction ClearPass(clearColor, clearAlpha) {\n\t\t_classCallCheck(this, ClearPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (ClearPass.__proto__ || Object.getPrototypeOf(ClearPass)).call(this));\n\n\t\t_this.needsSwap = false;\n\n\t\t_this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n\t\t_this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(ClearPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer) {\n\n\t\t\tvar oldClearColor = void 0;\n\t\t\tvar oldClearAlpha = void 0;\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\t\t\trenderer.clear();\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn ClearPass;\n}(_Pass3.default);\n\nexports.default = ClearPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js":
/*!************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = {\n\tuniforms: {\n\n\t\ttDiffuse: { value: null },\n\t\topacity: { value: 1.0 }\n\n\t},\n\n\tvertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\tfragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tgl_FragColor = opacity * texel;', '}'].join('\\n')\n};\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _ShaderPass = __webpack_require__(/*! ./ShaderPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js\");\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nvar _CopyShader = __webpack_require__(/*! ./CopyShader */ \"./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js\");\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _MaskPass = __webpack_require__(/*! ./MaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js\");\n\nvar _MaskPass2 = _interopRequireDefault(_MaskPass);\n\nvar _ClearMaskPass = __webpack_require__(/*! ./ClearMaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js\");\n\nvar _ClearMaskPass2 = _interopRequireDefault(_ClearMaskPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EffectComposer = function () {\n\tfunction EffectComposer(renderer, _renderTarget) {\n\t\t_classCallCheck(this, EffectComposer);\n\n\t\tvar renderTarget = _renderTarget;\n\n\t\tthis.renderer = renderer;\n\n\t\tif (renderTarget === undefined) {\n\n\t\t\tvar parameters = {\n\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\tformat: THREE.RGBAFormat,\n\t\t\t\tstencilBuffer: false\n\t\t\t};\n\n\t\t\tvar size = renderer.getSize(new THREE.Vector2());\n\t\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);\n\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\t\t} else {\n\n\t\t\tthis._pixelRatio = 1;\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tthis.renderToScreen = true;\n\n\t\tthis.passes = [];\n\n\t\tthis.copyPass = new _ShaderPass2.default(_CopyShader2.default);\n\n\t\tthis.clock = new THREE.Clock();\n\t}\n\n\t_createClass(EffectComposer, [{\n\t\tkey: 'swapBuffers',\n\t\tvalue: function swapBuffers() {\n\n\t\t\tvar tmp = this.readBuffer;\n\t\t\tthis.readBuffer = this.writeBuffer;\n\t\t\tthis.writeBuffer = tmp;\n\t\t}\n\t}, {\n\t\tkey: 'addPass',\n\t\tvalue: function addPass(pass) {\n\n\t\t\tthis.passes.push(pass);\n\n\t\t\tvar size = this.renderer.getDrawingBufferSize(new THREE.Vector2());\n\t\t\tpass.setSize(size.width, size.height);\n\t\t}\n\t}, {\n\t\tkey: 'insertPass',\n\t\tvalue: function insertPass(pass, index) {\n\n\t\t\tthis.passes.splice(index, 0, pass);\n\t\t}\n\t}, {\n\t\tkey: 'isLastEnabledPass',\n\t\tvalue: function isLastEnabledPass(passIndex) {\n\n\t\t\tfor (var i = passIndex + 1; i < this.passes.length; i += 1) {\n\n\t\t\t\tif (this.passes[i].enabled) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render() {\n\t\t\tvar deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.clock.getDelta();\n\n\n\t\t\t// deltaTime value is in seconds\n\n\t\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\t\tvar maskActive = false;\n\n\t\t\tvar pass = void 0;\n\t\t\tvar i = void 0;\n\t\t\tvar il = this.passes.length;\n\n\t\t\tfor (i = 0; i < il; i += 1) {\n\n\t\t\t\tpass = this.passes[i];\n\n\t\t\t\tif (pass.enabled !== false) {\n\n\t\t\t\t\tpass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n\t\t\t\t\tpass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n\n\t\t\t\t\tif (pass.needsSwap) {\n\n\t\t\t\t\t\tif (maskActive) {\n\t\t\t\t\t\t\tvar context = this.renderer.context;\n\n\n\t\t\t\t\t\t\tcontext.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n\n\t\t\t\t\t\t\tthis.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);\n\n\t\t\t\t\t\t\tcontext.stencilFunc(context.EQUAL, 1, 0xffffffff);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.swapBuffers();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pass instanceof _MaskPass2.default) {\n\n\t\t\t\t\tmaskActive = true;\n\t\t\t\t} else if (pass instanceof _ClearMaskPass2.default) {\n\n\t\t\t\t\tmaskActive = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.renderer.setRenderTarget(currentRenderTarget);\n\t\t}\n\t}, {\n\t\tkey: 'reset',\n\t\tvalue: function reset(_renderTarget) {\n\n\t\t\tvar renderTarget = _renderTarget;\n\n\t\t\tif (renderTarget === undefined) {\n\n\t\t\t\tvar size = this.renderer.getSize(new THREE.Vector2());\n\t\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\t\tthis._width = size.width;\n\t\t\t\tthis._height = size.height;\n\n\t\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\t\trenderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n\t\t\t}\n\n\t\t\tthis.renderTarget1.dispose();\n\t\t\tthis.renderTarget2.dispose();\n\t\t\tthis.renderTarget1 = renderTarget;\n\t\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\t\tthis.writeBuffer = this.renderTarget1;\n\t\t\tthis.readBuffer = this.renderTarget2;\n\t\t}\n\t}, {\n\t\tkey: 'setSize',\n\t\tvalue: function setSize(width, height) {\n\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\n\t\t\tvar effectiveWidth = this._width * this._pixelRatio;\n\t\t\tvar effectiveHeight = this._height * this._pixelRatio;\n\n\t\t\tthis.renderTarget1.setSize(effectiveWidth, effectiveHeight);\n\t\t\tthis.renderTarget2.setSize(effectiveWidth, effectiveHeight);\n\n\t\t\tfor (var i = 0; i < this.passes.length; i += 1) {\n\n\t\t\t\tthis.passes[i].setSize(effectiveWidth, effectiveHeight);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'setPixelRatio',\n\t\tvalue: function setPixelRatio(pixelRatio) {\n\n\t\t\tthis._pixelRatio = pixelRatio;\n\n\t\t\tthis.setSize(this._width, this._height);\n\t\t}\n\t}]);\n\n\treturn EffectComposer;\n}();\n\nexports.default = EffectComposer;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MaskPass = function (_Pass) {\n\t_inherits(MaskPass, _Pass);\n\n\tfunction MaskPass(scene, camera) {\n\t\t_classCallCheck(this, MaskPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (MaskPass.__proto__ || Object.getPrototypeOf(MaskPass)).call(this));\n\n\t\t_this.scene = scene;\n\t\t_this.camera = camera;\n\n\t\t_this.clear = true;\n\t\t_this.needsSwap = false;\n\n\t\t_this.inverse = false;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(MaskPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer) {\n\t\t\tvar context = renderer.context,\n\t\t\t    state = renderer.state;\n\n\t\t\t// don't update color or depth\n\n\t\t\tstate.buffers.color.setMask(false);\n\t\t\tstate.buffers.depth.setMask(false);\n\n\t\t\t// lock buffers\n\n\t\t\tstate.buffers.color.setLocked(true);\n\t\t\tstate.buffers.depth.setLocked(true);\n\n\t\t\t// set up stencil\n\n\t\t\tvar writeValue = void 0;\n\t\t\tvar clearValue = void 0;\n\n\t\t\tif (this.inverse) {\n\n\t\t\t\twriteValue = 0;\n\t\t\t\tclearValue = 1;\n\t\t\t} else {\n\n\t\t\t\twriteValue = 1;\n\t\t\t\tclearValue = 0;\n\t\t\t}\n\n\t\t\tstate.buffers.stencil.setTest(true);\n\t\t\tstate.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n\t\t\tstate.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n\t\t\tstate.buffers.stencil.setClear(clearValue);\n\n\t\t\t// draw into the stencil buffer\n\n\t\t\trenderer.setRenderTarget(readBuffer);\n\t\t\tif (this.clear) renderer.clear();\n\t\t\trenderer.render(this.scene, this.camera);\n\n\t\t\trenderer.setRenderTarget(writeBuffer);\n\t\t\tif (this.clear) renderer.clear();\n\t\t\trenderer.render(this.scene, this.camera);\n\n\t\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\t\tstate.buffers.color.setLocked(false);\n\t\t\tstate.buffers.depth.setLocked(false);\n\n\t\t\t// only render where stencil is set to 1\n\n\t\t\tstate.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n\t\t\tstate.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n\t\t}\n\t}]);\n\n\treturn MaskPass;\n}(_Pass3.default);\n\nexports.default = MaskPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js":
/*!******************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar camera = new _three.OrthographicCamera(-1, 1, 1, -1, 0, 1);\nvar geometry = new _three.PlaneBufferGeometry(2, 2);\n\nvar _FullScreenQuad = function () {\n\tfunction _FullScreenQuad(material) {\n\t\t_classCallCheck(this, _FullScreenQuad);\n\n\t\tthis._mesh = new _three.Mesh(geometry, material);\n\t}\n\n\t_createClass(_FullScreenQuad, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer) {\n\n\t\t\trenderer.render(this._mesh, camera);\n\t\t}\n\t}, {\n\t\tkey: 'material',\n\t\tget: function get() {\n\n\t\t\treturn this._mesh.material;\n\t\t},\n\t\tset: function set(value) {\n\n\t\t\tthis._mesh.material = value;\n\t\t}\n\t}]);\n\n\treturn _FullScreenQuad;\n}();\n\nvar Pass = function () {\n\tfunction Pass() {\n\t\t_classCallCheck(this, Pass);\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\t\tthis.clear = false;\n\t\tthis.renderToScreen = false;\n\t}\n\n\t_createClass(Pass, [{\n\t\tkey: 'setSize',\n\t\tvalue: function setSize(width, height) {}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t\tconsole.error('THREE.Pass: .render() must be implemented in derived pass.');\n\t\t}\n\t}]);\n\n\treturn Pass;\n}();\n\nPass.FullScreenQuad = _FullScreenQuad;\nexports.default = Pass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js":
/*!************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RenderPass = function (_Pass) {\n\t_inherits(RenderPass, _Pass);\n\n\tfunction RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {\n\t\t_classCallCheck(this, RenderPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (RenderPass.__proto__ || Object.getPrototypeOf(RenderPass)).call(this));\n\n\t\t_this.scene = scene;\n\t\t_this.camera = camera;\n\n\t\t_this.overrideMaterial = overrideMaterial;\n\n\t\t_this.clearColor = clearColor;\n\t\t_this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\t\t_this.clear = true;\n\t\t_this.clearDepth = false;\n\t\t_this.needsSwap = false;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(RenderPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(_renderer, writeBuffer, readBuffer) {\n\n\t\t\tvar renderer = _renderer;\n\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t\tvar oldClearColor = void 0;\n\t\t\tvar oldClearAlpha = void 0;\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\t}\n\n\t\t\tif (this.clearDepth) {\n\n\t\t\t\trenderer.clearDepth();\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif (this.clear) {\n\n\t\t\t\trenderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t}\n\t\t\trenderer.render(this.scene, this.camera);\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t\t}\n\n\t\t\tthis.scene.overrideMaterial = null;\n\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\t}]);\n\n\treturn RenderPass;\n}(_Pass3.default);\n\nexports.default = RenderPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RenderingPass = function (_Pass) {\n\t_inherits(RenderingPass, _Pass);\n\n\tfunction RenderingPass() {\n\t\t_classCallCheck(this, RenderingPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (RenderingPass.__proto__ || Object.getPrototypeOf(RenderingPass)).call(this));\n\n\t\t_this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\t\t_this.scene = new THREE.Scene();\n\t\t_this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\t\t_this.quad.frustumCulled = false;\n\t\t_this.scene.add(_this.quad);\n\n\t\treturn _this;\n\t}\n\n\treturn RenderingPass;\n}(_Pass3.default);\n\nexports.default = RenderingPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js":
/*!************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ShaderPass = function (_Pass) {\n\t_inherits(ShaderPass, _Pass);\n\n\tfunction ShaderPass(shader, textureID) {\n\t\t_classCallCheck(this, ShaderPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (ShaderPass.__proto__ || Object.getPrototypeOf(ShaderPass)).call(this));\n\n\t\t_this.textureID = textureID !== undefined ? textureID : 'tDiffuse';\n\n\t\tif (shader instanceof THREE.ShaderMaterial) {\n\n\t\t\t_this.uniforms = shader.uniforms;\n\n\t\t\t_this.material = shader;\n\t\t} else if (shader) {\n\n\t\t\t_this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t\t_this.material = new THREE.ShaderMaterial({\n\n\t\t\t\tdefines: Object.assign({}, shader.defines),\n\t\t\t\tuniforms: _this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t});\n\t\t}\n\n\t\t_this.fsQuad = new _Pass3.default.FullScreenQuad(_this.material);\n\n\t\treturn _this;\n\t}\n\n\t_createClass(ShaderPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer) {\n\n\t\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t\t}\n\n\t\t\tthis.fsQuad.material = this.material;\n\n\t\t\tif (this.renderToScreen) {\n\n\t\t\t\trenderer.setRenderTarget(null);\n\t\t\t\tthis.fsQuad.render(renderer);\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget(writeBuffer);\n\t\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\t\tif (this.clear) {\n\n\t\t\t\t\trenderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t\t}\n\t\t\t\tthis.fsQuad.render(renderer);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn ShaderPass;\n}(_Pass3.default);\n\nexports.default = ShaderPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nvar _CopyShader = __webpack_require__(/*! ./CopyShader */ \"./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js\");\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TexturePass = function (_Pass) {\n\t_inherits(TexturePass, _Pass);\n\n\tfunction TexturePass(map, opacity) {\n\t\t_classCallCheck(this, TexturePass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (TexturePass.__proto__ || Object.getPrototypeOf(TexturePass)).call(this));\n\n\t\tvar shader = _CopyShader2.default;\n\n\t\t_this.map = map;\n\t\t_this.opacity = opacity !== undefined ? opacity : 1.0;\n\n\t\t_this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t_this.material = new THREE.ShaderMaterial({\n\n\t\t\tuniforms: _this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\n\t\t});\n\n\t\t_this.needsSwap = false;\n\n\t\t_this.fsQuad = new _Pass3.default.FullScreenQuad(null);\n\n\t\treturn _this;\n\t}\n\n\t_createClass(TexturePass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(_renderer, writeBuffer, readBuffer) {\n\n\t\t\tvar renderer = _renderer;\n\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tthis.fsQuad.material = this.material;\n\n\t\t\tthis.uniforms.opacity.value = this.opacity;\n\t\t\tthis.uniforms.tDiffuse.value = this.map;\n\t\t\tthis.material.transparent = this.opacity < 1.0;\n\n\t\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\t\t\tif (this.clear) renderer.clear();\n\t\t\tthis.fsQuad.render(renderer);\n\n\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\t}]);\n\n\treturn TexturePass;\n}(_Pass3.default);\n\nexports.default = TexturePass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js?");

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/assert/assert.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/browserify-zlib/lib/binding.js":
/*!*****************************************************!*\
  !*** ./node_modules/browserify-zlib/lib/binding.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer, process) {\n/* eslint camelcase: \"off\" */\n\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\n\nvar Zstream = __webpack_require__(/*! pako/lib/zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\nvar zlib_deflate = __webpack_require__(/*! pako/lib/zlib/deflate.js */ \"./node_modules/pako/lib/zlib/deflate.js\");\nvar zlib_inflate = __webpack_require__(/*! pako/lib/zlib/inflate.js */ \"./node_modules/pako/lib/zlib/inflate.js\");\nvar constants = __webpack_require__(/*! pako/lib/zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\n\nfor (var key in constants) {\n  exports[key] = constants[key];\n}\n\n// zlib modes\nexports.NONE = 0;\nexports.DEFLATE = 1;\nexports.INFLATE = 2;\nexports.GZIP = 3;\nexports.GUNZIP = 4;\nexports.DEFLATERAW = 5;\nexports.INFLATERAW = 6;\nexports.UNZIP = 7;\n\nvar GZIP_HEADER_ID1 = 0x1f;\nvar GZIP_HEADER_ID2 = 0x8b;\n\n/**\n * Emulate Node's zlib C++ layer for use by the JS layer in index.js\n */\nfunction Zlib(mode) {\n  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {\n    throw new TypeError('Bad argument');\n  }\n\n  this.dictionary = null;\n  this.err = 0;\n  this.flush = 0;\n  this.init_done = false;\n  this.level = 0;\n  this.memLevel = 0;\n  this.mode = mode;\n  this.strategy = 0;\n  this.windowBits = 0;\n  this.write_in_progress = false;\n  this.pending_close = false;\n  this.gzip_id_bytes_read = 0;\n}\n\nZlib.prototype.close = function () {\n  if (this.write_in_progress) {\n    this.pending_close = true;\n    return;\n  }\n\n  this.pending_close = false;\n\n  assert(this.init_done, 'close before init');\n  assert(this.mode <= exports.UNZIP);\n\n  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {\n    zlib_deflate.deflateEnd(this.strm);\n  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {\n    zlib_inflate.inflateEnd(this.strm);\n  }\n\n  this.mode = exports.NONE;\n\n  this.dictionary = null;\n};\n\nZlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {\n  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);\n};\n\nZlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {\n  assert.equal(arguments.length, 8);\n\n  assert(this.init_done, 'write before init');\n  assert(this.mode !== exports.NONE, 'already finalized');\n  assert.equal(false, this.write_in_progress, 'write already in progress');\n  assert.equal(false, this.pending_close, 'close is pending');\n\n  this.write_in_progress = true;\n\n  assert.equal(false, flush === undefined, 'must provide flush value');\n\n  this.write_in_progress = true;\n\n  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {\n    throw new Error('Invalid flush value');\n  }\n\n  if (input == null) {\n    input = Buffer.alloc(0);\n    in_len = 0;\n    in_off = 0;\n  }\n\n  this.strm.avail_in = in_len;\n  this.strm.input = input;\n  this.strm.next_in = in_off;\n  this.strm.avail_out = out_len;\n  this.strm.output = out;\n  this.strm.next_out = out_off;\n  this.flush = flush;\n\n  if (!async) {\n    // sync version\n    this._process();\n\n    if (this._checkError()) {\n      return this._afterSync();\n    }\n    return;\n  }\n\n  // async version\n  var self = this;\n  process.nextTick(function () {\n    self._process();\n    self._after();\n  });\n\n  return this;\n};\n\nZlib.prototype._afterSync = function () {\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n\n  this.write_in_progress = false;\n\n  return [avail_in, avail_out];\n};\n\nZlib.prototype._process = function () {\n  var next_expected_header_byte = null;\n\n  // If the avail_out is left at 0, then it means that it ran out\n  // of room.  If there was avail_out left over, then it means\n  // that all of the input was consumed.\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflate(this.strm, this.flush);\n      break;\n    case exports.UNZIP:\n      if (this.strm.avail_in > 0) {\n        next_expected_header_byte = this.strm.next_in;\n      }\n\n      switch (this.gzip_id_bytes_read) {\n        case 0:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {\n            this.gzip_id_bytes_read = 1;\n            next_expected_header_byte++;\n\n            if (this.strm.avail_in === 1) {\n              // The only available byte was already read.\n              break;\n            }\n          } else {\n            this.mode = exports.INFLATE;\n            break;\n          }\n\n        // fallthrough\n        case 1:\n          if (next_expected_header_byte === null) {\n            break;\n          }\n\n          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {\n            this.gzip_id_bytes_read = 2;\n            this.mode = exports.GUNZIP;\n          } else {\n            // There is no actual difference between INFLATE and INFLATERAW\n            // (after initialization).\n            this.mode = exports.INFLATE;\n          }\n\n          break;\n        default:\n          throw new Error('invalid number of gzip magic number bytes read');\n      }\n\n    // fallthrough\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n      this.err = zlib_inflate.inflate(this.strm, this.flush\n\n      // If data was encoded with dictionary\n      );if (this.err === exports.Z_NEED_DICT && this.dictionary) {\n        // Load it\n        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);\n        if (this.err === exports.Z_OK) {\n          // And try to decode again\n          this.err = zlib_inflate.inflate(this.strm, this.flush);\n        } else if (this.err === exports.Z_DATA_ERROR) {\n          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.\n          // Make it possible for After() to tell a bad dictionary from bad\n          // input.\n          this.err = exports.Z_NEED_DICT;\n        }\n      }\n      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {\n        // Bytes remain in input buffer. Perhaps this is another compressed\n        // member in the same archive, or just trailing garbage.\n        // Trailing zero bytes are okay, though, since they are frequently\n        // used for padding.\n\n        this.reset();\n        this.err = zlib_inflate.inflate(this.strm, this.flush);\n      }\n      break;\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n};\n\nZlib.prototype._checkError = function () {\n  // Acceptable error states depend on the type of zlib stream.\n  switch (this.err) {\n    case exports.Z_OK:\n    case exports.Z_BUF_ERROR:\n      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {\n        this._error('unexpected end of file');\n        return false;\n      }\n      break;\n    case exports.Z_STREAM_END:\n      // normal statuses, not fatal\n      break;\n    case exports.Z_NEED_DICT:\n      if (this.dictionary == null) {\n        this._error('Missing dictionary');\n      } else {\n        this._error('Bad dictionary');\n      }\n      return false;\n    default:\n      // something else.\n      this._error('Zlib error');\n      return false;\n  }\n\n  return true;\n};\n\nZlib.prototype._after = function () {\n  if (!this._checkError()) {\n    return;\n  }\n\n  var avail_out = this.strm.avail_out;\n  var avail_in = this.strm.avail_in;\n\n  this.write_in_progress = false;\n\n  // call the write() cb\n  this.callback(avail_in, avail_out);\n\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype._error = function (message) {\n  if (this.strm.msg) {\n    message = this.strm.msg;\n  }\n  this.onerror(message, this.err\n\n  // no hope of rescue.\n  );this.write_in_progress = false;\n  if (this.pending_close) {\n    this.close();\n  }\n};\n\nZlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {\n  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');\n\n  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');\n  assert(level >= -1 && level <= 9, 'invalid compression level');\n\n  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');\n\n  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');\n\n  this._init(level, windowBits, memLevel, strategy, dictionary);\n  this._setDictionary();\n};\n\nZlib.prototype.params = function () {\n  throw new Error('deflateParams Not supported');\n};\n\nZlib.prototype.reset = function () {\n  this._reset();\n  this._setDictionary();\n};\n\nZlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {\n  this.level = level;\n  this.windowBits = windowBits;\n  this.memLevel = memLevel;\n  this.strategy = strategy;\n\n  this.flush = exports.Z_NO_FLUSH;\n\n  this.err = exports.Z_OK;\n\n  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {\n    this.windowBits += 16;\n  }\n\n  if (this.mode === exports.UNZIP) {\n    this.windowBits += 32;\n  }\n\n  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {\n    this.windowBits = -1 * this.windowBits;\n  }\n\n  this.strm = new Zstream();\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.GZIP:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);\n      break;\n    case exports.INFLATE:\n    case exports.GUNZIP:\n    case exports.INFLATERAW:\n    case exports.UNZIP:\n      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);\n      break;\n    default:\n      throw new Error('Unknown mode ' + this.mode);\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Init error');\n  }\n\n  this.dictionary = dictionary;\n\n  this.write_in_progress = false;\n  this.init_done = true;\n};\n\nZlib.prototype._setDictionary = function () {\n  if (this.dictionary == null) {\n    return;\n  }\n\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);\n      break;\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to set dictionary');\n  }\n};\n\nZlib.prototype._reset = function () {\n  this.err = exports.Z_OK;\n\n  switch (this.mode) {\n    case exports.DEFLATE:\n    case exports.DEFLATERAW:\n    case exports.GZIP:\n      this.err = zlib_deflate.deflateReset(this.strm);\n      break;\n    case exports.INFLATE:\n    case exports.INFLATERAW:\n    case exports.GUNZIP:\n      this.err = zlib_inflate.inflateReset(this.strm);\n      break;\n    default:\n      break;\n  }\n\n  if (this.err !== exports.Z_OK) {\n    this._error('Failed to reset stream');\n  }\n};\n\nexports.Zlib = Zlib;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/browserify-zlib/lib/binding.js?");

/***/ }),

/***/ "./node_modules/browserify-zlib/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/browserify-zlib/lib/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\nvar Transform = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Transform;\nvar binding = __webpack_require__(/*! ./binding */ \"./node_modules/browserify-zlib/lib/binding.js\");\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\").ok;\nvar kMaxLength = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").kMaxLength;\nvar kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes';\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nvar bkeys = Object.keys(binding);\nfor (var bk = 0; bk < bkeys.length; bk++) {\n  var bkey = bkeys[bk];\n  if (bkey.match(/^Z/)) {\n    Object.defineProperty(exports, bkey, {\n      enumerable: true, value: binding[bkey], writable: false\n    });\n  }\n}\n\n// translation table for return codes.\nvar codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nvar ckeys = Object.keys(codes);\nfor (var ck = 0; ck < ckeys.length; ck++) {\n  var ckey = ckeys[ck];\n  codes[codes[ckey]] = ckey;\n}\n\nObject.defineProperty(exports, 'codes', {\n  enumerable: true, value: Object.freeze(codes), writable: false\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n};\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf;\n    var err = null;\n\n    if (nread >= kMaxLength) {\n      err = new RangeError(kRangeErrorMessage);\n    } else {\n      buf = Buffer.concat(buffers, nread);\n    }\n\n    buffers = [];\n    engine.close();\n    callback(err, buf);\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer);\n\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n\n  var flushFlag = engine._finishFlushFlag;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\nfunction isValidFlushFlag(flag) {\n  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  var _this = this;\n\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush && !isValidFlushFlag(opts.flush)) {\n    throw new Error('Invalid flush flag: ' + opts.flush);\n  }\n  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {\n    throw new Error('Invalid flush flag: ' + opts.finishFlush);\n  }\n\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._handle.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    _close(self);\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = Buffer.allocUnsafe(this._chunkSize);\n  this._offset = 0;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n\n  Object.defineProperty(this, '_closed', {\n    get: function () {\n      return !_this._handle;\n    },\n    configurable: true,\n    enumerable: true\n  });\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      assert(self._handle, 'zlib binding closed');\n      self._handle.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function () {\n  assert(this._handle, 'zlib binding closed');\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function (callback) {\n  this._transform(Buffer.alloc(0), '', callback);\n};\n\nZlib.prototype.flush = function (kind, callback) {\n  var _this2 = this;\n\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === undefined && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    if (callback) {\n      this.once('drain', function () {\n        return _this2.flush(kind, callback);\n      });\n    }\n  } else {\n    this._flushFlag = kind;\n    this.write(Buffer.alloc(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function (callback) {\n  _close(this, callback);\n  process.nextTick(emitCloseNT, this);\n};\n\nfunction _close(engine, callback) {\n  if (callback) process.nextTick(callback);\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) return;\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nfunction emitCloseNT(self) {\n  self.emit('close');\n}\n\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));\n\n  if (!this._handle) return cb(new Error('zlib binding closed'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag\n  // (or whatever flag was provided using opts.finishFlush).\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last) flushFlag = this._finishFlushFlag;else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n\n    assert(this._handle, 'zlib binding closed');\n    do {\n      var res = this._handle.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    if (nread >= kMaxLength) {\n      _close(this);\n      throw new RangeError(kRangeErrorMessage);\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    _close(this);\n\n    return buf;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  var req = this._handle.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    // When the callback is used in an async write, the callback's\n    // context is the `req` object that was created. The req object\n    // is === this._handle, and that's why it's important to null\n    // out the values after they are done being used. `this._handle`\n    // can stay in memory longer than the callback and buffer are needed.\n    if (this) {\n      this.buffer = null;\n      this.callback = null;\n    }\n\n    if (self._hadError) return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n\n      if (!async) return true;\n\n      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/browserify-zlib/lib/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/charenc/charenc.js":
/*!*****************************************!*\
  !*** ./node_modules/charenc/charenc.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n\n\n//# sourceURL=webpack:///./node_modules/charenc/charenc.js?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/crypt/crypt.js":
/*!*************************************!*\
  !*** ./node_modules/crypt/crypt.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n\n\n//# sourceURL=webpack:///./node_modules/crypt/crypt.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/deepmerge/dist/cjs.js":
/*!********************************************!*\
  !*** ./node_modules/deepmerge/dist/cjs.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n\n\n//# sourceURL=webpack:///./node_modules/deepmerge/dist/cjs.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/fast-json-stable-stringify/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/fast-json-stable-stringify/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (data, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (node) {\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        if (node === undefined) return;\n        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';\n        if (typeof node !== 'object') return JSON.stringify(node);\n\n        var i, out;\n        if (Array.isArray(node)) {\n            out = '[';\n            for (i = 0; i < node.length; i++) {\n                if (i) out += ',';\n                out += stringify(node[i]) || 'null';\n            }\n            return out + ']';\n        }\n\n        if (node === null) return 'null';\n\n        if (seen.indexOf(node) !== -1) {\n            if (cycles) return JSON.stringify('__cycle__');\n            throw new TypeError('Converting circular structure to JSON');\n        }\n\n        var seenIndex = seen.push(node) - 1;\n        var keys = Object.keys(node).sort(cmp && cmp(node));\n        out = '';\n        for (i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var value = stringify(node[key]);\n\n            if (!value) continue;\n            if (out) out += ',';\n            out += JSON.stringify(key) + ':' + value;\n        }\n        seen.splice(seenIndex, 1);\n        return '{' + out + '}';\n    })(data);\n};\n\n\n//# sourceURL=webpack:///./node_modules/fast-json-stable-stringify/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n//# sourceURL=webpack:///./node_modules/is-buffer/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/json-schema-traverse/index.js":
/*!****************************************************!*\
  !*** ./node_modules/json-schema-traverse/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\n//# sourceURL=webpack:///./node_modules/json-schema-traverse/index.js?");

/***/ }),

/***/ "./node_modules/lodash.get/index.js":
/*!******************************************!*\
  !*** ./node_modules/lodash.get/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/lodash.get/index.js?");

/***/ }),

/***/ "./node_modules/lodash.reduce/index.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash.reduce/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for comparison styles. */\nvar UNORDERED_COMPARE_FLAG = 1,\n    PARTIAL_COMPARE_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports =  true && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.reduce` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @param {boolean} [initAccum] Specify using the first element of `array` as\n *  the initial value.\n * @returns {*} Returns the accumulated value.\n */\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  if (initAccum && length) {\n    accumulator = array[++index];\n  }\n  while (++index < length) {\n    accumulator = iteratee(accumulator, array[index], index, array);\n  }\n  return accumulator;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array ? array.length : 0;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {*} accumulator The initial value.\n * @param {boolean} initAccum Specify using the first or last element of\n *  `collection` as the initial value.\n * @param {Function} eachFunc The function to iterate over `collection`.\n * @returns {*} Returns the accumulated value.\n */\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n  eachFunc(collection, function(value, index, collection) {\n    accumulator = initAccum\n      ? (initAccum = false, value)\n      : iteratee(accumulator, value, index, collection);\n  });\n  return accumulator;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values ? values.length : 0;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  this.__data__ = new ListCache(entries);\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  return this.__data__['delete'](key);\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var cache = this.__data__;\n  if (cache instanceof ListCache) {\n    var pairs = cache.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      return this;\n    }\n    cache = this.__data__ = new MapCache(pairs);\n  }\n  cache.set(key, value);\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getTag`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  return objectToString.call(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {boolean} [bitmask] The bitmask of comparison flags.\n *  The bitmask may be composed of the following flags:\n *     1 - Unordered comparison\n *     2 - Partial comparison\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, customizer, bitmask, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = getTag(object);\n    objTag = objTag == argsTag ? objectTag : objTag;\n  }\n  if (!othIsArr) {\n    othTag = getTag(other);\n    othTag = othTag == argsTag ? objectTag : othTag;\n  }\n  var objIsObj = objTag == objectTag && !isHostObject(object),\n      othIsObj = othTag == objectTag && !isHostObject(other),\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)\n      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n  }\n  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!seen.has(othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, customizer, bitmask, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= UNORDERED_COMPARE_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Function} customizer The function to customize comparisons.\n * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n *  for more details.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n      objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11,\n// for data views in Edge < 14, and promises in Node.js.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = objectToString.call(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : undefined;\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var result,\n      index = -1,\n      length = path.length;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result) {\n    return result;\n  }\n  var length = object ? object.length : 0;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Reduces `collection` to a value which is the accumulated result of running\n * each element in `collection` thru `iteratee`, where each successive\n * invocation is supplied the return value of the previous. If `accumulator`\n * is not given, the first element of `collection` is used as the initial\n * value. The iteratee is invoked with four arguments:\n * (accumulator, value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\n *\n * The guarded methods are:\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n * and `sortBy`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @param {*} [accumulator] The initial value.\n * @returns {*} Returns the accumulated value.\n * @see _.reduceRight\n * @example\n *\n * _.reduce([1, 2], function(sum, n) {\n *   return sum + n;\n * }, 0);\n * // => 3\n *\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n *   (result[value] || (result[value] = [])).push(key);\n *   return result;\n * }, {});\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n */\nfunction reduce(collection, iteratee, accumulator) {\n  var func = isArray(collection) ? arrayReduce : baseReduce,\n      initAccum = arguments.length < 3;\n\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\nmodule.exports = reduce;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack:///./node_modules/lodash.reduce/index.js?");

/***/ }),

/***/ "./node_modules/md5/md5.js":
/*!*********************************!*\
  !*** ./node_modules/md5/md5.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(){\r\n  var crypt = __webpack_require__(/*! crypt */ \"./node_modules/crypt/crypt.js\"),\r\n      utf8 = __webpack_require__(/*! charenc */ \"./node_modules/charenc/charenc.js\").utf8,\r\n      isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\"),\r\n      bin = __webpack_require__(/*! charenc */ \"./node_modules/charenc/charenc.js\").bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message))\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n\n\n//# sourceURL=webpack:///./node_modules/md5/md5.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/onscreen/dist/on-screen.umd.js":
/*!*****************************************************!*\
  !*** ./node_modules/onscreen/dist/on-screen.umd.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  /**\n   * Attaches the scroll event handler\n   *\n   * @return {void}\n   */\n  function attach() {\n      var container = this.options.container;\n\n      if (container instanceof HTMLElement) {\n          var style = window.getComputedStyle(container);\n\n          if (style.position === 'static') {\n              container.style.position = 'relative';\n          }\n      }\n\n      container.addEventListener('scroll', this._scroll, { passive: true });\n      window.addEventListener('resize', this._scroll, { passive: true });\n      this._scroll();\n      this.attached = true;\n  }\n\n  /**\n   * Checks an element's position in respect to the viewport\n   * and determines wether it's inside the viewport.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n   */\n  function inViewport(el) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { tolerance: 0 };\n\n      if (!el) {\n          throw new Error('You should specify the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n\n      var elRect = el.getBoundingClientRect();\n\n      return (\n          // Check bottom boundary\n          elRect.bottom - options.tolerance > 0 &&\n\n          // Check right boundary\n          elRect.right - options.tolerance > 0 &&\n\n          // Check left boundary\n          elRect.left + options.tolerance < (window.innerWidth || document.documentElement.clientWidth) &&\n\n          // Check top boundary\n          elRect.top + options.tolerance < (window.innerHeight || document.documentElement.clientHeight)\n      );\n  }\n\n  /**\n   * Checks an element's position in respect to a HTMLElement\n   * and determines wether it's within its boundaries.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the container.\n   */\n  function inContainer(el) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { tolerance: 0, container: '' };\n\n      if (!el) {\n          throw new Error('You should specify the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n      if (typeof options === 'string') {\n          options = {\n              tolerance: 0,\n              container: document.querySelector(options)\n          };\n      }\n      if (typeof options.container === 'string') {\n          options.container = document.querySelector(options.container);\n      }\n      if (options instanceof HTMLElement) {\n          options = {\n              tolerance: 0,\n              container: options\n          };\n      }\n      if (!options.container) {\n          throw new Error('You should specify a container element');\n      }\n\n      var containerRect = options.container.getBoundingClientRect();\n\n      return (\n          // // Check bottom boundary\n          el.offsetTop + el.clientHeight - options.tolerance > options.container.scrollTop &&\n\n          // Check right boundary\n          el.offsetLeft + el.clientWidth - options.tolerance > options.container.scrollLeft &&\n\n          // Check left boundary\n          el.offsetLeft + options.tolerance < containerRect.width + options.container.scrollLeft &&\n\n          // // Check top boundary\n          el.offsetTop + options.tolerance < containerRect.height + options.container.scrollTop\n      );\n  }\n\n  // TODO: Refactor this so it can be easily tested\n  /* istanbul ignore next */\n  function eventHandler() {\n      var trackedElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { tolerance: 0 };\n\n      var selectors = Object.keys(trackedElements);\n      var testVisibility = void 0;\n\n      if (!selectors.length) return;\n\n      if (options.container === window) {\n          testVisibility = inViewport;\n      } else {\n          testVisibility = inContainer;\n      }\n\n      selectors.forEach(function (selector) {\n          trackedElements[selector].nodes.forEach(function (item) {\n              if (testVisibility(item.node, options)) {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = true;\n              } else {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = false;\n              }\n              if (item.isVisible === true && item.wasVisible === false) {\n                  if (!trackedElements[selector].enter) return;\n\n                  Object.keys(trackedElements[selector].enter).forEach(function (callback) {\n                      if (typeof trackedElements[selector].enter[callback] === 'function') {\n                          trackedElements[selector].enter[callback](item.node, 'enter');\n                      }\n                  });\n              }\n              if (item.isVisible === false && item.wasVisible === true) {\n                  if (!trackedElements[selector].leave) return;\n\n                  Object.keys(trackedElements[selector].leave).forEach(function (callback) {\n                      if (typeof trackedElements[selector].leave[callback] === 'function') {\n                          trackedElements[selector].leave[callback](item.node, 'leave');\n                      }\n                  });\n              }\n          });\n      });\n  }\n\n  /**\n   * Debounces the scroll event to avoid performance issues\n   *\n   * @return {void}\n   */\n  function debouncedScroll() {\n      var _this = this;\n\n      var timeout = void 0;\n\n      return function () {\n          clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n              eventHandler(_this.trackedElements, _this.options);\n          }, _this.options.debounce);\n      };\n  }\n\n  /**\n   * Removes the scroll event handler\n   *\n   * @return {void}\n   */\n  function destroy() {\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n  }\n\n  /**\n   * Stops tracking elements matching a CSS selector. If a selector has no\n   * callbacks it gets removed.\n   *\n   * @param {string} event The event you want to stop tracking (enter or leave)\n   * @param {string} selector The CSS selector you want to stop tracking\n   * @return {void}\n   */\n  function off(event, selector, handler) {\n      var enterCallbacks = Object.keys(this.trackedElements[selector].enter || {});\n      var leaveCallbacks = Object.keys(this.trackedElements[selector].leave || {});\n\n      if ({}.hasOwnProperty.call(this.trackedElements, selector)) {\n          if (handler) {\n              if (this.trackedElements[selector][event]) {\n                  var callbackName = typeof handler === 'function' ? handler.name : handler;\n                  delete this.trackedElements[selector][event][callbackName];\n              }\n          } else {\n              delete this.trackedElements[selector][event];\n          }\n      }\n\n      if (!enterCallbacks.length && !leaveCallbacks.length) {\n          delete this.trackedElements[selector];\n      }\n  }\n\n  /**\n   * Starts tracking elements matching a CSS selector\n   *\n   * @param {string} event The event you want to track (enter or leave)\n   * @param {string} selector The element you want to track\n   * @param {function} callback The callback function to handle the event\n   * @return {void}\n   */\n  function on(event, selector, callback) {\n      var allowed = ['enter', 'leave'];\n\n      if (!event) throw new Error('No event given. Choose either enter or leave');\n      if (!selector) throw new Error('No selector to track');\n      if (allowed.indexOf(event) < 0) throw new Error(event + ' event is not supported');\n\n      if (!{}.hasOwnProperty.call(this.trackedElements, selector)) {\n          this.trackedElements[selector] = {};\n      }\n\n      this.trackedElements[selector].nodes = [];\n\n      for (var i = 0, elems = document.querySelectorAll(selector); i < elems.length; i++) {\n          var item = {\n              isVisible: false,\n              wasVisible: false,\n              node: elems[i]\n          };\n\n          this.trackedElements[selector].nodes.push(item);\n      }\n\n      if (typeof callback === 'function') {\n          if (!this.trackedElements[selector][event]) {\n              this.trackedElements[selector][event] = {};\n          }\n\n          this.trackedElements[selector][event][callback.name || 'anonymous'] = callback;\n      }\n  }\n\n  /**\n   * Observes DOM mutations and runs a callback function when\n   * detecting one.\n   *\n   * @param {node} obj The DOM node you want to observe\n   * @param {function} callback The callback function you want to call\n   * @return {void}\n   */\n  function observeDOM(obj, callback) {\n      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n      /* istanbul ignore else */\n      if (MutationObserver) {\n          var obs = new MutationObserver(callback);\n\n          obs.observe(obj, {\n              childList: true,\n              subtree: true\n          });\n      } else {\n          obj.addEventListener('DOMNodeInserted', callback, false);\n          obj.addEventListener('DOMNodeRemoved', callback, false);\n      }\n  }\n\n  /**\n   * Detects wether DOM nodes enter or leave the viewport\n   *\n   * @constructor\n   * @param {object} options The configuration object\n   */\n  function OnScreen() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { tolerance: 0, debounce: 100, container: window };\n\n      this.options = {};\n      this.trackedElements = {};\n\n      Object.defineProperties(this.options, {\n          container: {\n              configurable: false,\n              enumerable: false,\n              get: function get() {\n                  var container = void 0;\n\n                  if (typeof options.container === 'string') {\n                      container = document.querySelector(options.container);\n                  } else if (options.container instanceof HTMLElement) {\n                      container = options.container;\n                  }\n\n                  return container || window;\n              },\n              set: function set(value) {\n                  options.container = value;\n              }\n          },\n          debounce: {\n              get: function get() {\n                  return parseInt(options.debounce, 10) || 100;\n              },\n              set: function set(value) {\n                  options.debounce = value;\n              }\n          },\n          tolerance: {\n              get: function get() {\n                  return parseInt(options.tolerance, 10) || 0;\n              },\n              set: function set(value) {\n                  options.tolerance = value;\n              }\n          }\n      });\n\n      Object.defineProperty(this, '_scroll', {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: this._debouncedScroll.call(this)\n      });\n\n      observeDOM(document.querySelector('body'), function () {\n          Object.keys(_this.trackedElements).forEach(function (element) {\n              _this.on('enter', element);\n              _this.on('leave', element);\n          });\n      });\n\n      this.attach();\n  }\n\n  Object.defineProperties(OnScreen.prototype, {\n      _debouncedScroll: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: debouncedScroll\n      },\n      attach: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: attach\n      },\n      destroy: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: destroy\n      },\n      off: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: off\n      },\n      on: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: on\n      }\n  });\n\n  OnScreen.check = inViewport;\n\n  return OnScreen;\n\n}));\n//# sourceMappingURL=on-screen.umd.js.map\n\n\n//# sourceURL=webpack:///./node_modules/onscreen/dist/on-screen.umd.js?");

/***/ }),

/***/ "./node_modules/onscreen/lib/methods/off.js":
/*!**************************************************!*\
  !*** ./node_modules/onscreen/lib/methods/off.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * Stops tracking elements matching a CSS selector. If a selector has no\n * callbacks it gets removed.\n *\n * @param {string} event The event you want to stop tracking (enter or leave)\n * @param {string} selector The CSS selector you want to stop tracking\n * @return {void}\n */\nfunction off(event, selector, handler) {\n    const enterCallbacks = Object.keys(this.trackedElements[selector].enter || {});\n    const leaveCallbacks = Object.keys(this.trackedElements[selector].leave || {});\n\n    if ({}.hasOwnProperty.call(this.trackedElements, selector)) {\n        if (handler) {\n            if (this.trackedElements[selector][event]) {\n                const callbackName = (typeof handler === 'function') ? handler.name : handler;\n                delete this.trackedElements[selector][event][callbackName];\n            }\n        } else {\n            delete this.trackedElements[selector][event];\n        }\n    }\n\n    if (!enterCallbacks.length && !leaveCallbacks.length) {\n        delete this.trackedElements[selector];\n    }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (off);\n\n\n//# sourceURL=webpack:///./node_modules/onscreen/lib/methods/off.js?");

/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(/*! ./lib/utils/common */ \"./node_modules/pako/lib/utils/common.js\").assign;\n\nvar deflate   = __webpack_require__(/*! ./lib/deflate */ \"./node_modules/pako/lib/deflate.js\");\nvar inflate   = __webpack_require__(/*! ./lib/inflate */ \"./node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n//# sourceURL=webpack:///./node_modules/pako/index.js?");

/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"./node_modules/pako/lib/zlib/deflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/deflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"./node_modules/pako/lib/zlib/inflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar c            = __webpack_require__(/*! ./zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader     = __webpack_require__(/*! ./zlib/gzheader */ \"./node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/inflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/utils/common.js?");

/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(/*! ./common */ \"./node_modules/pako/lib/utils/common.js\");\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/utils/strings.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/adler32.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/constants.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/crc32.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar trees   = __webpack_require__(/*! ./trees */ \"./node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32   = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar msg     = __webpack_require__(/*! ./messages */ \"./node_modules/pako/lib/zlib/messages.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/deflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/gzheader.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/inffast.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar adler32       = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32         = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast  = __webpack_require__(/*! ./inffast */ \"./node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"./node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/inflate.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/inftrees.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/messages.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/trees.js?");

/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n//# sourceURL=webpack:///./node_modules/pako/lib/zlib/zstream.js?");

/***/ }),

/***/ "./node_modules/prismarine-nbt/compound.js":
/*!*************************************************!*\
  !*** ./node_modules/prismarine-nbt/compound.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  'compound': [readCompound, writeCompound, sizeOfCompound]\n}\n\nfunction readCompound (buffer, offset, typeArgs, rootNode) {\n  const results = {\n    value: {},\n    size: 0\n  }\n  while (true) {\n    const typ = this.read(buffer, offset, 'i8', rootNode)\n    if (typ.value === 0) {\n      offset += typ.size\n      results.size += typ.size\n      break\n    }\n\n    const readResults = this.read(buffer, offset, 'nbt', rootNode)\n    offset += readResults.size\n    results.size += readResults.size\n    results.value[readResults.value.name] = {\n      type: readResults.value.type,\n      value: readResults.value.value\n    }\n  }\n  return results\n}\n\nfunction writeCompound (value, buffer, offset, typeArgs, rootNode) {\n  const self = this\n  Object.keys(value).map(function (key) {\n    offset = self.write({\n      name: key,\n      type: value[key].type,\n      value: value[key].value\n    }, buffer, offset, 'nbt', rootNode)\n  })\n  offset = this.write(0, buffer, offset, 'i8', rootNode)\n\n  return offset\n}\n\nfunction sizeOfCompound (value, typeArgs, rootNode) {\n  const self = this\n  const size = Object.keys(value).reduce(function (size, key) {\n    return size + self.sizeOf({\n      name: key,\n      type: value[key].type,\n      value: value[key].value\n    }, 'nbt', rootNode)\n  }, 0)\n  return 1 + size\n}\n\n\n//# sourceURL=webpack:///./node_modules/prismarine-nbt/compound.js?");

/***/ }),

/***/ "./node_modules/prismarine-nbt/nbt.js":
/*!********************************************!*\
  !*** ./node_modules/prismarine-nbt/nbt.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const zlib = __webpack_require__(/*! zlib */ \"./node_modules/browserify-zlib/lib/index.js\")\nconst ProtoDef = __webpack_require__(/*! protodef */ \"./node_modules/protodef/index.js\").ProtoDef\nconst compound = __webpack_require__(/*! ./compound */ \"./node_modules/prismarine-nbt/compound.js\").compound\n\nconst nbtJson = JSON.stringify(__webpack_require__(/*! ./nbt.json */ \"./node_modules/prismarine-nbt/nbt.json\"))\nconst leNbtJson = nbtJson.replace(/(i[0-9]+)/g, 'l$1')\n\nfunction createProto (le) {\n  const proto = new ProtoDef()\n  proto.addType('compound', compound)\n  proto.addTypes(JSON.parse(le ? leNbtJson : nbtJson))\n  return proto\n}\n\nconst proto = createProto(false)\nconst protoLE = createProto(true)\n\nfunction writeUncompressed (value, le) {\n  return (le ? protoLE : proto).createPacketBuffer('nbt', value)\n}\n\nfunction parseUncompressed (data, le) {\n  return (le ? protoLE : proto).parsePacketBuffer('nbt', data).data\n}\n\nconst hasGzipHeader = function (data) {\n  let result = true\n  if (data[0] !== 0x1f) result = false\n  if (data[1] !== 0x8b) result = false\n  return result\n}\n\nfunction parse (data, le, callback) {\n  let isLe = false\n  if (typeof le === 'function') {\n    callback = le\n  } else {\n    isLe = le\n  }\n  if (hasGzipHeader(data)) {\n    zlib.gunzip(data, function (error, uncompressed) {\n      if (error) {\n        callback(error, data)\n      } else {\n        callback(null, parseUncompressed(uncompressed, isLe))\n      }\n    })\n  } else {\n    callback(null, parseUncompressed(data, isLe))\n  }\n}\n\nfunction simplify (data) {\n  function transform (value, type) {\n    if (type === 'compound') {\n      return Object.keys(value).reduce(function (acc, key) {\n        acc[key] = simplify(value[key])\n        return acc\n      }, {})\n    }\n    if (type === 'list') {\n      return value.value.map(function (v) { return transform(v, value.type) })\n    }\n    return value\n  }\n  return transform(data.value, data.type)\n}\n\nmodule.exports = {\n  writeUncompressed: writeUncompressed,\n  parseUncompressed: parseUncompressed,\n  simplify: simplify,\n  parse: parse,\n  proto: proto,\n  protoLE: protoLE\n}\n\n\n//# sourceURL=webpack:///./node_modules/prismarine-nbt/nbt.js?");

/***/ }),

/***/ "./node_modules/prismarine-nbt/nbt.json":
/*!**********************************************!*\
  !*** ./node_modules/prismarine-nbt/nbt.json ***!
  \**********************************************/
/*! exports provided: container, i8, switch, compound, i16, i32, i64, f32, f64, pstring, shortString, byteArray, list, intArray, longArray, nbtMapper, nbtSwitch, nbt, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"container\\\":\\\"native\\\",\\\"i8\\\":\\\"native\\\",\\\"switch\\\":\\\"native\\\",\\\"compound\\\":\\\"native\\\",\\\"i16\\\":\\\"native\\\",\\\"i32\\\":\\\"native\\\",\\\"i64\\\":\\\"native\\\",\\\"f32\\\":\\\"native\\\",\\\"f64\\\":\\\"native\\\",\\\"pstring\\\":\\\"native\\\",\\\"shortString\\\":[\\\"pstring\\\",{\\\"countType\\\":\\\"i16\\\"}],\\\"byteArray\\\":[\\\"array\\\",{\\\"countType\\\":\\\"i32\\\",\\\"type\\\":\\\"i8\\\"}],\\\"list\\\":[\\\"container\\\",[{\\\"name\\\":\\\"type\\\",\\\"type\\\":\\\"nbtMapper\\\"},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"array\\\",{\\\"countType\\\":\\\"i32\\\",\\\"type\\\":[\\\"nbtSwitch\\\",{\\\"type\\\":\\\"type\\\"}]}]}]],\\\"intArray\\\":[\\\"array\\\",{\\\"countType\\\":\\\"i32\\\",\\\"type\\\":\\\"i32\\\"}],\\\"longArray\\\":[\\\"array\\\",{\\\"countType\\\":\\\"i32\\\",\\\"type\\\":\\\"i64\\\"}],\\\"nbtMapper\\\":[\\\"mapper\\\",{\\\"type\\\":\\\"i8\\\",\\\"mappings\\\":{\\\"0\\\":\\\"end\\\",\\\"1\\\":\\\"byte\\\",\\\"2\\\":\\\"short\\\",\\\"3\\\":\\\"int\\\",\\\"4\\\":\\\"long\\\",\\\"5\\\":\\\"float\\\",\\\"6\\\":\\\"double\\\",\\\"7\\\":\\\"byteArray\\\",\\\"8\\\":\\\"string\\\",\\\"9\\\":\\\"list\\\",\\\"10\\\":\\\"compound\\\",\\\"11\\\":\\\"intArray\\\",\\\"12\\\":\\\"longArray\\\"}}],\\\"nbtSwitch\\\":[\\\"switch\\\",{\\\"compareTo\\\":\\\"$type\\\",\\\"fields\\\":{\\\"end\\\":\\\"void\\\",\\\"byte\\\":\\\"i8\\\",\\\"short\\\":\\\"i16\\\",\\\"int\\\":\\\"i32\\\",\\\"long\\\":\\\"i64\\\",\\\"float\\\":\\\"f32\\\",\\\"double\\\":\\\"f64\\\",\\\"byteArray\\\":\\\"byteArray\\\",\\\"string\\\":\\\"shortString\\\",\\\"list\\\":\\\"list\\\",\\\"compound\\\":\\\"compound\\\",\\\"intArray\\\":\\\"intArray\\\",\\\"longArray\\\":\\\"longArray\\\"}}],\\\"nbt\\\":[\\\"container\\\",[{\\\"name\\\":\\\"type\\\",\\\"type\\\":\\\"nbtMapper\\\"},{\\\"name\\\":\\\"name\\\",\\\"type\\\":\\\"shortString\\\"},{\\\"name\\\":\\\"value\\\",\\\"type\\\":[\\\"nbtSwitch\\\",{\\\"type\\\":\\\"type\\\"}]}]]}\");\n\n//# sourceURL=webpack:///./node_modules/prismarine-nbt/nbt.json?");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/ProtoDef/schemas/conditional.json":
/*!***************************************************************************!*\
  !*** ./node_modules/protodef-validator/ProtoDef/schemas/conditional.json ***!
  \***************************************************************************/
/*! exports provided: switch, option, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"switch\\\":{\\\"title\\\":\\\"switch\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"switch\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"compareTo\\\":{\\\"$ref\\\":\\\"definitions#/definitions/contextualizedFieldName\\\"},\\\"compareToValue\\\":{\\\"type\\\":\\\"string\\\"},\\\"fields\\\":{\\\"type\\\":\\\"object\\\",\\\"patternProperties\\\":{\\\"^[-a-zA-Z0-9 _:]+$\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false},\\\"default\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"oneOf\\\":[{\\\"required\\\":[\\\"compareTo\\\",\\\"fields\\\"]},{\\\"required\\\":[\\\"compareToValue\\\",\\\"fields\\\"]}],\\\"additionalProperties\\\":false}],\\\"additionalItems\\\":false},\\\"option\\\":{\\\"title\\\":\\\"option\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"option\\\"]},{\\\"$ref\\\":\\\"dataType\\\"}],\\\"additionalItems\\\":false}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/ProtoDef/schemas/conditional.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/ProtoDef/schemas/definitions.json":
/*!***************************************************************************!*\
  !*** ./node_modules/protodef-validator/ProtoDef/schemas/definitions.json ***!
  \***************************************************************************/
/*! exports provided: title, definitions, type, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"title\\\":\\\"definitions\\\",\\\"definitions\\\":{\\\"contextualizedFieldName\\\":{\\\"type\\\":\\\"string\\\",\\\"pattern\\\":\\\"^(this\\\\\\\\.)?.+$\\\"},\\\"dataTypeArgsCount\\\":{\\\"oneOf\\\":[{\\\"$ref\\\":\\\"#/definitions/contextualizedFieldName\\\"},{\\\"type\\\":\\\"number\\\"}]},\\\"fieldName\\\":{\\\"type\\\":\\\"string\\\",\\\"pattern\\\":\\\"^[a-zA-Z0-9_]+$\\\"}},\\\"type\\\":\\\"object\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/ProtoDef/schemas/definitions.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/ProtoDef/schemas/numeric.json":
/*!***********************************************************************!*\
  !*** ./node_modules/protodef-validator/ProtoDef/schemas/numeric.json ***!
  \***********************************************************************/
/*! exports provided: i8, u8, i16, u16, i32, u32, f32, f64, li8, lu8, li16, lu16, li32, lu32, lf32, lf64, i64, li64, u64, lu64, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"i8\\\":{\\\"enum\\\":[\\\"i8\\\"]},\\\"u8\\\":{\\\"enum\\\":[\\\"u8\\\"]},\\\"i16\\\":{\\\"enum\\\":[\\\"i16\\\"]},\\\"u16\\\":{\\\"enum\\\":[\\\"u16\\\"]},\\\"i32\\\":{\\\"enum\\\":[\\\"i32\\\"]},\\\"u32\\\":{\\\"enum\\\":[\\\"u32\\\"]},\\\"f32\\\":{\\\"enum\\\":[\\\"f32\\\"]},\\\"f64\\\":{\\\"enum\\\":[\\\"f64\\\"]},\\\"li8\\\":{\\\"enum\\\":[\\\"li8\\\"]},\\\"lu8\\\":{\\\"enum\\\":[\\\"lu8\\\"]},\\\"li16\\\":{\\\"enum\\\":[\\\"li16\\\"]},\\\"lu16\\\":{\\\"enum\\\":[\\\"lu16\\\"]},\\\"li32\\\":{\\\"enum\\\":[\\\"li32\\\"]},\\\"lu32\\\":{\\\"enum\\\":[\\\"lu32\\\"]},\\\"lf32\\\":{\\\"enum\\\":[\\\"lf32\\\"]},\\\"lf64\\\":{\\\"enum\\\":[\\\"lf64\\\"]},\\\"i64\\\":{\\\"enum\\\":[\\\"i64\\\"]},\\\"li64\\\":{\\\"enum\\\":[\\\"li64\\\"]},\\\"u64\\\":{\\\"enum\\\":[\\\"u64\\\"]},\\\"lu64\\\":{\\\"enum\\\":[\\\"lu64\\\"]}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/ProtoDef/schemas/numeric.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/ProtoDef/schemas/protocol_schema.json":
/*!*******************************************************************************!*\
  !*** ./node_modules/protodef-validator/ProtoDef/schemas/protocol_schema.json ***!
  \*******************************************************************************/
/*! exports provided: title, type, properties, patternProperties, additionalProperties, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"title\\\":\\\"protocol\\\",\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"types\\\":{\\\"type\\\":\\\"object\\\",\\\"patternProperties\\\":{\\\"^[0-9a-zA-Z_]+$\\\":{\\\"oneOf\\\":[{\\\"type\\\":\\\"string\\\"},{\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"type\\\":\\\"string\\\"},{\\\"oneOf\\\":[{\\\"type\\\":\\\"object\\\"},{\\\"type\\\":\\\"array\\\"}]}]}]}},\\\"additionalProperties\\\":false}},\\\"patternProperties\\\":{\\\"^(?!types)[a-zA-Z_]+$\\\":{\\\"$ref\\\":\\\"#\\\"}},\\\"additionalProperties\\\":false}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/ProtoDef/schemas/protocol_schema.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/ProtoDef/schemas/structures.json":
/*!**************************************************************************!*\
  !*** ./node_modules/protodef-validator/ProtoDef/schemas/structures.json ***!
  \**************************************************************************/
/*! exports provided: array, count, container, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"array\\\":{\\\"title\\\":\\\"array\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"array\\\"]},{\\\"oneOf\\\":[{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"},\\\"countType\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"type\\\",\\\"countType\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"},\\\"count\\\":{\\\"$ref\\\":\\\"definitions#/definitions/dataTypeArgsCount\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"type\\\",\\\"count\\\"]}]}],\\\"additionalItems\\\":false},\\\"count\\\":{\\\"title\\\":\\\"count\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"count\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"countFor\\\":{\\\"$ref\\\":\\\"definitions#/definitions/contextualizedFieldName\\\"},\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"required\\\":[\\\"countFor\\\",\\\"type\\\"],\\\"additionalProperties\\\":false}],\\\"additionalItems\\\":false},\\\"container\\\":{\\\"title\\\":\\\"container\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"container\\\"]},{\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"anon\\\":{\\\"type\\\":\\\"boolean\\\"},\\\"name\\\":{\\\"$ref\\\":\\\"definitions#/definitions/fieldName\\\"},\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"oneOf\\\":[{\\\"required\\\":[\\\"anon\\\"]},{\\\"required\\\":[\\\"name\\\"]}],\\\"required\\\":[\\\"type\\\"],\\\"additionalProperties\\\":false},\\\"additionalItems\\\":false}],\\\"additionalItems\\\":false}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/ProtoDef/schemas/structures.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/ProtoDef/schemas/utils.json":
/*!*********************************************************************!*\
  !*** ./node_modules/protodef-validator/ProtoDef/schemas/utils.json ***!
  \*********************************************************************/
/*! exports provided: varint, bool, pstring, buffer, void, bitfield, cstring, mapper, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"varint\\\":{\\\"enum\\\":[\\\"varint\\\"]},\\\"bool\\\":{\\\"enum\\\":[\\\"bool\\\"]},\\\"pstring\\\":{\\\"title\\\":\\\"pstring\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"pstring\\\"]},{\\\"oneOf\\\":[{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"countType\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"countType\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"count\\\":{\\\"$ref\\\":\\\"definitions#/definitions/dataTypeArgsCount\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"count\\\"]}]}],\\\"additionalItems\\\":false},\\\"buffer\\\":{\\\"title\\\":\\\"buffer\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"buffer\\\"]},{\\\"oneOf\\\":[{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"countType\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"countType\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"count\\\":{\\\"$ref\\\":\\\"definitions#/definitions/dataTypeArgsCount\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"count\\\"]}]}]},\\\"void\\\":{\\\"enum\\\":[\\\"void\\\"]},\\\"bitfield\\\":{\\\"title\\\":\\\"bitfield\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"bitfield\\\"]},{\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"name\\\":{\\\"$ref\\\":\\\"definitions#/definitions/fieldName\\\"},\\\"size\\\":{\\\"type\\\":\\\"number\\\"},\\\"signed\\\":{\\\"type\\\":\\\"boolean\\\"}},\\\"required\\\":[\\\"name\\\",\\\"size\\\",\\\"signed\\\"],\\\"additionalProperties\\\":false},\\\"additionalItems\\\":false}],\\\"additionalItems\\\":false},\\\"cstring\\\":{\\\"enum\\\":[\\\"cstring\\\"]},\\\"mapper\\\":{\\\"title\\\":\\\"mapper\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"mapper\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"},\\\"mappings\\\":{\\\"type\\\":\\\"object\\\",\\\"patternProperties\\\":{\\\"^[-a-zA-Z0-9 _]+$\\\":{\\\"type\\\":\\\"string\\\"}},\\\"additionalProperties\\\":false}},\\\"required\\\":[\\\"type\\\",\\\"mappings\\\"],\\\"additionalProperties\\\":false}],\\\"additionalItems\\\":false}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/ProtoDef/schemas/utils.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/index.js":
/*!**************************************************!*\
  !*** ./node_modules/protodef-validator/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Ajv = __webpack_require__(/*! ajv */ \"./node_modules/protodef-validator/node_modules/ajv/lib/ajv.js\");\nconst assert=__webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\n\nclass Validator {\n  constructor(typesSchemas) {\n    this.createAjvInstance(typesSchemas);\n    this.addDefaultTypes();\n  }\n\n  createAjvInstance(typesSchemas) {\n    this.typesSchemas = {};\n    this.compiled=false;\n    this.ajv = new Ajv({verbose:true});\n    this.ajv.addSchema(__webpack_require__(/*! ./ProtoDef/schemas/definitions.json */ \"./node_modules/protodef-validator/ProtoDef/schemas/definitions.json\"),\"definitions\");\n    this.ajv.addSchema(__webpack_require__(/*! ./ProtoDef/schemas/protocol_schema.json */ \"./node_modules/protodef-validator/ProtoDef/schemas/protocol_schema.json\"),\"protocol\");\n    if(typesSchemas) {\n      Object.keys(typesSchemas).forEach(s => this.addType(s, typesSchemas[s]));\n    }\n  }\n\n  addDefaultTypes() {\n    this.addTypes(__webpack_require__(/*! ./ProtoDef/schemas/numeric.json */ \"./node_modules/protodef-validator/ProtoDef/schemas/numeric.json\"));\n    this.addTypes(__webpack_require__(/*! ./ProtoDef/schemas/utils.json */ \"./node_modules/protodef-validator/ProtoDef/schemas/utils.json\"));\n    this.addTypes(__webpack_require__(/*! ./ProtoDef/schemas/structures.json */ \"./node_modules/protodef-validator/ProtoDef/schemas/structures.json\"));\n    this.addTypes(__webpack_require__(/*! ./ProtoDef/schemas/conditional.json */ \"./node_modules/protodef-validator/ProtoDef/schemas/conditional.json\"));\n  }\n\n  addTypes(schemas) {\n    Object.keys(schemas).forEach((name) => this.addType(name, schemas[name]));\n  }\n\n  typeToSchemaName(name) {\n    return name.replace('|','_');\n  }\n\n  addType(name,schema) {\n    const schemaName=this.typeToSchemaName(name);\n    if(this.typesSchemas[schemaName] != undefined)\n      return;\n\n    if(!schema) { // default schema\n      schema={\n        \"oneOf\":[\n          {\"enum\":[name]},\n          {\n            \"type\": \"array\",\n              \"items\": [\n                {\"enum\":[name]},\n                {\"oneOf\":[{\"type\": \"object\"},{\"type\": \"array\"}]}\n            ]\n          }\n        ]};\n    }\n\n    this.typesSchemas[schemaName]=schema;\n\n    // recreate ajv instance to recompile dataType (and all depending types) when adding a type\n    if(this.compiled)\n      this.createAjvInstance(this.typesSchemas);\n    else {\n      this.ajv.addSchema(schema, schemaName);\n    }\n\n\n    this.ajv.removeSchema(\"dataType\");\n    this.ajv.addSchema({\n      \"title\": \"dataType\",\n      \"oneOf\": [{\"enum\":[\"native\"]}].concat(Object.keys(this.typesSchemas).map(name => ({\"$ref\": this.typeToSchemaName(name)})))\n    },\"dataType\");\n  }\n\n  validateType(type) {\n    let valid = this.ajv.validate(\"dataType\",type);\n    this.compiled=true;\n    if(!valid) {\n      console.log(JSON.stringify(this.ajv.errors[0],null,2));\n      if(this.ajv.errors[0]['parentSchema']['title']==\"dataType\") {\n        this.validateTypeGoingInside(this.ajv.errors[0]['data']);\n      }\n      throw new Error(\"validation error\");\n    }\n  }\n\n  validateTypeGoingInside(type) {\n    if(Array.isArray(type)) {\n      assert.ok(this.typesSchemas[this.typeToSchemaName(type[0])]!=undefined,type+\" is an undefined type\");\n\n      let valid = this.ajv.validate(type[0],type);\n      this.compiled=true;\n      if(!valid) {\n        console.log(JSON.stringify(this.ajv.errors[0],null,2));\n        if(this.ajv.errors[0]['parentSchema']['title']==\"dataType\") {\n          this.validateTypeGoingInside(this.ajv.errors[0]['data']);\n        }\n        throw new Error(\"validation error\");\n      }\n    }\n    else {\n      if(type==\"native\")\n        return;\n      assert.ok(this.typesSchemas[this.typeToSchemaName(type)]!=undefined,type+\" is an undefined type\");\n    }\n  }\n\n  validateProtocol(protocol) {\n    // 1. validate with protocol schema with basic datatype def\n    let valid = this.ajv.validate(\"protocol\",protocol);\n    assert.ok(valid, JSON.stringify(this.ajv.errors,null,2));\n\n\n    // 2. recursively create several validator from current one and validate that\n    function validateTypes(p,originalValidator,path) {\n      const v=new Validator(originalValidator.typesSchemas);\n      Object.keys(p).forEach(k => {\n        if(k==\"types\") {\n          // 2 steps for recursive types\n          Object.keys(p[k]).forEach(typeName => v.addType(typeName));\n          Object.keys(p[k]).forEach(typeName => {\n            try {\n              v.validateType(p[k][typeName], path + \".\" + k + \".\" + typeName);\n            }\n            catch(e) {\n              throw new Error(\"Error at \"+path + \".\" + k + \".\" + typeName);\n            }\n          });\n        }\n        else {\n          validateTypes(p[k],v,path+\".\"+k);\n        }\n      })\n    }\n    validateTypes(protocol,this,\"root\");\n  }\n}\n\nmodule.exports=Validator;\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/index.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/ajv.js":
/*!*********************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/ajv.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar compileSchema = __webpack_require__(/*! ./compile */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/index.js\")\n  , resolve = __webpack_require__(/*! ./compile/resolve */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/resolve.js\")\n  , Cache = __webpack_require__(/*! ./cache */ \"./node_modules/protodef-validator/node_modules/ajv/lib/cache.js\")\n  , SchemaObject = __webpack_require__(/*! ./compile/schema_obj */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/schema_obj.js\")\n  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ \"./node_modules/fast-json-stable-stringify/index.js\")\n  , formats = __webpack_require__(/*! ./compile/formats */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/formats.js\")\n  , rules = __webpack_require__(/*! ./compile/rules */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/rules.js\")\n  , $dataMetaSchema = __webpack_require__(/*! ./data */ \"./node_modules/protodef-validator/node_modules/ajv/lib/data.js\")\n  , util = __webpack_require__(/*! ./compile/util */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js\");\n\nmodule.exports = Ajv;\n\nAjv.prototype.validate = validate;\nAjv.prototype.compile = compile;\nAjv.prototype.addSchema = addSchema;\nAjv.prototype.addMetaSchema = addMetaSchema;\nAjv.prototype.validateSchema = validateSchema;\nAjv.prototype.getSchema = getSchema;\nAjv.prototype.removeSchema = removeSchema;\nAjv.prototype.addFormat = addFormat;\nAjv.prototype.errorsText = errorsText;\n\nAjv.prototype._addSchema = _addSchema;\nAjv.prototype._compile = _compile;\n\nAjv.prototype.compileAsync = __webpack_require__(/*! ./compile/async */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/async.js\");\nvar customKeyword = __webpack_require__(/*! ./keyword */ \"./node_modules/protodef-validator/node_modules/ajv/lib/keyword.js\");\nAjv.prototype.addKeyword = customKeyword.add;\nAjv.prototype.getKeyword = customKeyword.get;\nAjv.prototype.removeKeyword = customKeyword.remove;\nAjv.prototype.validateKeyword = customKeyword.validate;\n\nvar errorClasses = __webpack_require__(/*! ./compile/error_classes */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/error_classes.js\");\nAjv.ValidationError = errorClasses.Validation;\nAjv.MissingRefError = errorClasses.MissingRef;\nAjv.$dataMetaSchema = $dataMetaSchema;\n\nvar META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';\n\nvar META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];\nvar META_SUPPORT_DATA = ['/properties'];\n\n/**\n * Creates validator instance.\n * Usage: `Ajv(opts)`\n * @param {Object} opts optional options\n * @return {Object} ajv instance\n */\nfunction Ajv(opts) {\n  if (!(this instanceof Ajv)) return new Ajv(opts);\n  opts = this._opts = util.copy(opts) || {};\n  setLogger(this);\n  this._schemas = {};\n  this._refs = {};\n  this._fragments = {};\n  this._formats = formats(opts.format);\n\n  this._cache = opts.cache || new Cache;\n  this._loadingSchemas = {};\n  this._compilations = [];\n  this.RULES = rules();\n  this._getId = chooseGetId(opts);\n\n  opts.loopRequired = opts.loopRequired || Infinity;\n  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;\n  if (opts.serialize === undefined) opts.serialize = stableStringify;\n  this._metaOpts = getMetaSchemaOptions(this);\n\n  if (opts.formats) addInitialFormats(this);\n  if (opts.keywords) addInitialKeywords(this);\n  addDefaultMetaSchema(this);\n  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);\n  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});\n  addInitialSchemas(this);\n}\n\n\n\n/**\n * Validate data using schema\n * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.\n * @this   Ajv\n * @param  {String|Object} schemaKeyRef key, ref or schema object\n * @param  {Any} data to be validated\n * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).\n */\nfunction validate(schemaKeyRef, data) {\n  var v;\n  if (typeof schemaKeyRef == 'string') {\n    v = this.getSchema(schemaKeyRef);\n    if (!v) throw new Error('no schema with key or ref \"' + schemaKeyRef + '\"');\n  } else {\n    var schemaObj = this._addSchema(schemaKeyRef);\n    v = schemaObj.validate || this._compile(schemaObj);\n  }\n\n  var valid = v(data);\n  if (v.$async !== true) this.errors = v.errors;\n  return valid;\n}\n\n\n/**\n * Create validating function for passed schema.\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.\n * @return {Function} validating function\n */\nfunction compile(schema, _meta) {\n  var schemaObj = this._addSchema(schema, undefined, _meta);\n  return schemaObj.validate || this._compile(schemaObj);\n}\n\n\n/**\n * Adds schema to the instance.\n * @this   Ajv\n * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.\n * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.\n * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n * @return {Ajv} this for method chaining\n */\nfunction addSchema(schema, key, _skipValidation, _meta) {\n  if (Array.isArray(schema)){\n    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);\n    return this;\n  }\n  var id = this._getId(schema);\n  if (id !== undefined && typeof id != 'string')\n    throw new Error('schema id must be string');\n  key = resolve.normalizeId(key || id);\n  checkUnique(this, key);\n  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);\n  return this;\n}\n\n\n/**\n * Add schema that will be used to validate other schemas\n * options in META_IGNORE_OPTIONS are alway set to false\n * @this   Ajv\n * @param {Object} schema schema object\n * @param {String} key optional schema key\n * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema\n * @return {Ajv} this for method chaining\n */\nfunction addMetaSchema(schema, key, skipValidation) {\n  this.addSchema(schema, key, skipValidation, true);\n  return this;\n}\n\n\n/**\n * Validate schema\n * @this   Ajv\n * @param {Object} schema schema to validate\n * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid\n * @return {Boolean} true if schema is valid\n */\nfunction validateSchema(schema, throwOrLogError) {\n  var $schema = schema.$schema;\n  if ($schema !== undefined && typeof $schema != 'string')\n    throw new Error('$schema must be a string');\n  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);\n  if (!$schema) {\n    this.logger.warn('meta-schema not available');\n    this.errors = null;\n    return true;\n  }\n  var valid = this.validate($schema, schema);\n  if (!valid && throwOrLogError) {\n    var message = 'schema is invalid: ' + this.errorsText();\n    if (this._opts.validateSchema == 'log') this.logger.error(message);\n    else throw new Error(message);\n  }\n  return valid;\n}\n\n\nfunction defaultMeta(self) {\n  var meta = self._opts.meta;\n  self._opts.defaultMeta = typeof meta == 'object'\n                            ? self._getId(meta) || meta\n                            : self.getSchema(META_SCHEMA_ID)\n                              ? META_SCHEMA_ID\n                              : undefined;\n  return self._opts.defaultMeta;\n}\n\n\n/**\n * Get compiled schema from the instance by `key` or `ref`.\n * @this   Ajv\n * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).\n * @return {Function} schema validating function (with property `schema`).\n */\nfunction getSchema(keyRef) {\n  var schemaObj = _getSchemaObj(this, keyRef);\n  switch (typeof schemaObj) {\n    case 'object': return schemaObj.validate || this._compile(schemaObj);\n    case 'string': return this.getSchema(schemaObj);\n    case 'undefined': return _getSchemaFragment(this, keyRef);\n  }\n}\n\n\nfunction _getSchemaFragment(self, ref) {\n  var res = resolve.schema.call(self, { schema: {} }, ref);\n  if (res) {\n    var schema = res.schema\n      , root = res.root\n      , baseId = res.baseId;\n    var v = compileSchema.call(self, schema, root, undefined, baseId);\n    self._fragments[ref] = new SchemaObject({\n      ref: ref,\n      fragment: true,\n      schema: schema,\n      root: root,\n      baseId: baseId,\n      validate: v\n    });\n    return v;\n  }\n}\n\n\nfunction _getSchemaObj(self, keyRef) {\n  keyRef = resolve.normalizeId(keyRef);\n  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];\n}\n\n\n/**\n * Remove cached schema(s).\n * If no parameter is passed all schemas but meta-schemas are removed.\n * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n * @this   Ajv\n * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object\n * @return {Ajv} this for method chaining\n */\nfunction removeSchema(schemaKeyRef) {\n  if (schemaKeyRef instanceof RegExp) {\n    _removeAllSchemas(this, this._schemas, schemaKeyRef);\n    _removeAllSchemas(this, this._refs, schemaKeyRef);\n    return this;\n  }\n  switch (typeof schemaKeyRef) {\n    case 'undefined':\n      _removeAllSchemas(this, this._schemas);\n      _removeAllSchemas(this, this._refs);\n      this._cache.clear();\n      return this;\n    case 'string':\n      var schemaObj = _getSchemaObj(this, schemaKeyRef);\n      if (schemaObj) this._cache.del(schemaObj.cacheKey);\n      delete this._schemas[schemaKeyRef];\n      delete this._refs[schemaKeyRef];\n      return this;\n    case 'object':\n      var serialize = this._opts.serialize;\n      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;\n      this._cache.del(cacheKey);\n      var id = this._getId(schemaKeyRef);\n      if (id) {\n        id = resolve.normalizeId(id);\n        delete this._schemas[id];\n        delete this._refs[id];\n      }\n  }\n  return this;\n}\n\n\nfunction _removeAllSchemas(self, schemas, regex) {\n  for (var keyRef in schemas) {\n    var schemaObj = schemas[keyRef];\n    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {\n      self._cache.del(schemaObj.cacheKey);\n      delete schemas[keyRef];\n    }\n  }\n}\n\n\n/* @this   Ajv */\nfunction _addSchema(schema, skipValidation, meta, shouldAddSchema) {\n  if (typeof schema != 'object' && typeof schema != 'boolean')\n    throw new Error('schema should be object or boolean');\n  var serialize = this._opts.serialize;\n  var cacheKey = serialize ? serialize(schema) : schema;\n  var cached = this._cache.get(cacheKey);\n  if (cached) return cached;\n\n  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;\n\n  var id = resolve.normalizeId(this._getId(schema));\n  if (id && shouldAddSchema) checkUnique(this, id);\n\n  var willValidate = this._opts.validateSchema !== false && !skipValidation;\n  var recursiveMeta;\n  if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))\n    this.validateSchema(schema, true);\n\n  var localRefs = resolve.ids.call(this, schema);\n\n  var schemaObj = new SchemaObject({\n    id: id,\n    schema: schema,\n    localRefs: localRefs,\n    cacheKey: cacheKey,\n    meta: meta\n  });\n\n  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;\n  this._cache.put(cacheKey, schemaObj);\n\n  if (willValidate && recursiveMeta) this.validateSchema(schema, true);\n\n  return schemaObj;\n}\n\n\n/* @this   Ajv */\nfunction _compile(schemaObj, root) {\n  if (schemaObj.compiling) {\n    schemaObj.validate = callValidate;\n    callValidate.schema = schemaObj.schema;\n    callValidate.errors = null;\n    callValidate.root = root ? root : callValidate;\n    if (schemaObj.schema.$async === true)\n      callValidate.$async = true;\n    return callValidate;\n  }\n  schemaObj.compiling = true;\n\n  var currentOpts;\n  if (schemaObj.meta) {\n    currentOpts = this._opts;\n    this._opts = this._metaOpts;\n  }\n\n  var v;\n  try { v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs); }\n  catch(e) {\n    delete schemaObj.validate;\n    throw e;\n  }\n  finally {\n    schemaObj.compiling = false;\n    if (schemaObj.meta) this._opts = currentOpts;\n  }\n\n  schemaObj.validate = v;\n  schemaObj.refs = v.refs;\n  schemaObj.refVal = v.refVal;\n  schemaObj.root = v.root;\n  return v;\n\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var _validate = schemaObj.validate;\n    var result = _validate.apply(this, arguments);\n    callValidate.errors = _validate.errors;\n    return result;\n  }\n}\n\n\nfunction chooseGetId(opts) {\n  switch (opts.schemaId) {\n    case 'auto': return _get$IdOrId;\n    case 'id': return _getId;\n    default: return _get$Id;\n  }\n}\n\n/* @this   Ajv */\nfunction _getId(schema) {\n  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);\n  return schema.id;\n}\n\n/* @this   Ajv */\nfunction _get$Id(schema) {\n  if (schema.id) this.logger.warn('schema id ignored', schema.id);\n  return schema.$id;\n}\n\n\nfunction _get$IdOrId(schema) {\n  if (schema.$id && schema.id && schema.$id != schema.id)\n    throw new Error('schema $id is different from id');\n  return schema.$id || schema.id;\n}\n\n\n/**\n * Convert array of error message objects to string\n * @this   Ajv\n * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.\n * @param  {Object} options optional options with properties `separator` and `dataVar`.\n * @return {String} human readable string with all errors descriptions\n */\nfunction errorsText(errors, options) {\n  errors = errors || this.errors;\n  if (!errors) return 'No errors';\n  options = options || {};\n  var separator = options.separator === undefined ? ', ' : options.separator;\n  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;\n\n  var text = '';\n  for (var i=0; i<errors.length; i++) {\n    var e = errors[i];\n    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;\n  }\n  return text.slice(0, -separator.length);\n}\n\n\n/**\n * Add custom format\n * @this   Ajv\n * @param {String} name format name\n * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)\n * @return {Ajv} this for method chaining\n */\nfunction addFormat(name, format) {\n  if (typeof format == 'string') format = new RegExp(format);\n  this._formats[name] = format;\n  return this;\n}\n\n\nfunction addDefaultMetaSchema(self) {\n  var $dataSchema;\n  if (self._opts.$data) {\n    $dataSchema = __webpack_require__(/*! ./refs/data.json */ \"./node_modules/protodef-validator/node_modules/ajv/lib/refs/data.json\");\n    self.addMetaSchema($dataSchema, $dataSchema.$id, true);\n  }\n  if (self._opts.meta === false) return;\n  var metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"./node_modules/protodef-validator/node_modules/ajv/lib/refs/json-schema-draft-07.json\");\n  if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);\n  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);\n  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;\n}\n\n\nfunction addInitialSchemas(self) {\n  var optsSchemas = self._opts.schemas;\n  if (!optsSchemas) return;\n  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);\n  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);\n}\n\n\nfunction addInitialFormats(self) {\n  for (var name in self._opts.formats) {\n    var format = self._opts.formats[name];\n    self.addFormat(name, format);\n  }\n}\n\n\nfunction addInitialKeywords(self) {\n  for (var name in self._opts.keywords) {\n    var keyword = self._opts.keywords[name];\n    self.addKeyword(name, keyword);\n  }\n}\n\n\nfunction checkUnique(self, id) {\n  if (self._schemas[id] || self._refs[id])\n    throw new Error('schema with key or id \"' + id + '\" already exists');\n}\n\n\nfunction getMetaSchemaOptions(self) {\n  var metaOpts = util.copy(self._opts);\n  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)\n    delete metaOpts[META_IGNORE_OPTIONS[i]];\n  return metaOpts;\n}\n\n\nfunction setLogger(self) {\n  var logger = self._opts.logger;\n  if (logger === false) {\n    self.logger = {log: noop, warn: noop, error: noop};\n  } else {\n    if (logger === undefined) logger = console;\n    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))\n      throw new Error('logger must implement log, warn and error methods');\n    self.logger = logger;\n  }\n}\n\n\nfunction noop() {}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/ajv.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/cache.js":
/*!***********************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/cache.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar Cache = module.exports = function Cache() {\n  this._cache = {};\n};\n\n\nCache.prototype.put = function Cache_put(key, value) {\n  this._cache[key] = value;\n};\n\n\nCache.prototype.get = function Cache_get(key) {\n  return this._cache[key];\n};\n\n\nCache.prototype.del = function Cache_del(key) {\n  delete this._cache[key];\n};\n\n\nCache.prototype.clear = function Cache_clear() {\n  this._cache = {};\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/cache.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/async.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/async.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar MissingRefError = __webpack_require__(/*! ./error_classes */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/error_classes.js\").MissingRef;\n\nmodule.exports = compileAsync;\n\n\n/**\n * Creates validating function for passed schema with asynchronous loading of missing schemas.\n * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n * @this  Ajv\n * @param {Object}   schema schema object\n * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped\n * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.\n * @return {Promise} promise that resolves with a validating function.\n */\nfunction compileAsync(schema, meta, callback) {\n  /* eslint no-shadow: 0 */\n  /* global Promise */\n  /* jshint validthis: true */\n  var self = this;\n  if (typeof this._opts.loadSchema != 'function')\n    throw new Error('options.loadSchema should be a function');\n\n  if (typeof meta == 'function') {\n    callback = meta;\n    meta = undefined;\n  }\n\n  var p = loadMetaSchemaOf(schema).then(function () {\n    var schemaObj = self._addSchema(schema, undefined, meta);\n    return schemaObj.validate || _compileAsync(schemaObj);\n  });\n\n  if (callback) {\n    p.then(\n      function(v) { callback(null, v); },\n      callback\n    );\n  }\n\n  return p;\n\n\n  function loadMetaSchemaOf(sch) {\n    var $schema = sch.$schema;\n    return $schema && !self.getSchema($schema)\n            ? compileAsync.call(self, { $ref: $schema }, true)\n            : Promise.resolve();\n  }\n\n\n  function _compileAsync(schemaObj) {\n    try { return self._compile(schemaObj); }\n    catch(e) {\n      if (e instanceof MissingRefError) return loadMissingSchema(e);\n      throw e;\n    }\n\n\n    function loadMissingSchema(e) {\n      var ref = e.missingSchema;\n      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');\n\n      var schemaPromise = self._loadingSchemas[ref];\n      if (!schemaPromise) {\n        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);\n        schemaPromise.then(removePromise, removePromise);\n      }\n\n      return schemaPromise.then(function (sch) {\n        if (!added(ref)) {\n          return loadMetaSchemaOf(sch).then(function () {\n            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);\n          });\n        }\n      }).then(function() {\n        return _compileAsync(schemaObj);\n      });\n\n      function removePromise() {\n        delete self._loadingSchemas[ref];\n      }\n\n      function added(ref) {\n        return self._refs[ref] || self._schemas[ref];\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/async.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/error_classes.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/error_classes.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar resolve = __webpack_require__(/*! ./resolve */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/resolve.js\");\n\nmodule.exports = {\n  Validation: errorSubclass(ValidationError),\n  MissingRef: errorSubclass(MissingRefError)\n};\n\n\nfunction ValidationError(errors) {\n  this.message = 'validation failed';\n  this.errors = errors;\n  this.ajv = this.validation = true;\n}\n\n\nMissingRefError.message = function (baseId, ref) {\n  return 'can\\'t resolve reference ' + ref + ' from id ' + baseId;\n};\n\n\nfunction MissingRefError(baseId, ref, message) {\n  this.message = message || MissingRefError.message(baseId, ref);\n  this.missingRef = resolve.url(baseId, ref);\n  this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));\n}\n\n\nfunction errorSubclass(Subclass) {\n  Subclass.prototype = Object.create(Error.prototype);\n  Subclass.prototype.constructor = Subclass;\n  return Subclass;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/error_classes.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/formats.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/formats.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js\");\n\nvar DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nvar DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];\nvar TIME = /^(\\d\\d):(\\d\\d):(\\d\\d)(\\.\\d+)?(z|[+-]\\d\\d(?::?\\d\\d)?)?$/i;\nvar HOSTNAME = /^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i;\nvar URI = /^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\nvar URIREF = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nvar URITEMPLATE = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\n// For the source: https://gist.github.com/dperini/729294\n// For test cases: https://mathiasbynens.be/demo/url-regex\n// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.\n// var URL = /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu;\nvar URL = /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i;\nvar UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;\nvar JSON_POINTER = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nvar JSON_POINTER_URI_FRAGMENT = /^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;\nvar RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\n\n\nmodule.exports = formats;\n\nfunction formats(mode) {\n  mode = mode == 'full' ? 'full' : 'fast';\n  return util.copy(formats[mode]);\n}\n\n\nformats.fast = {\n  // date: http://tools.ietf.org/html/rfc3339#section-5.6\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n  time: /^(?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)?$/i,\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s](?:[0-2]\\d:[0-5]\\d:[0-5]\\d|23:59:60)(?:\\.\\d+)?(?:z|[+-]\\d\\d(?::?\\d\\d)?)$/i,\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+-.]*:)(?:\\/?\\/)?[^\\s]*$/i,\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/?\\/)?(?:[^\\\\\\s#][^\\s#]*)?(?:#[^\\\\\\s]*)?$/i,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n  hostname: HOSTNAME,\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: UUID,\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nformats.full = {\n  date: date,\n  time: time,\n  'date-time': date_time,\n  uri: uri,\n  'uri-reference': URIREF,\n  'uri-template': URITEMPLATE,\n  url: URL,\n  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n  hostname: HOSTNAME,\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n  regex: regex,\n  uuid: UUID,\n  'json-pointer': JSON_POINTER,\n  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,\n  'relative-json-pointer': RELATIVE_JSON_POINTER\n};\n\n\nfunction isLeapYear(year) {\n  // https://tools.ietf.org/html/rfc3339#appendix-C\n  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n\n\nfunction date(str) {\n  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n  var matches = str.match(DATE);\n  if (!matches) return false;\n\n  var year = +matches[1];\n  var month = +matches[2];\n  var day = +matches[3];\n\n  return month >= 1 && month <= 12 && day >= 1 &&\n          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);\n}\n\n\nfunction time(str, full) {\n  var matches = str.match(TIME);\n  if (!matches) return false;\n\n  var hour = matches[1];\n  var minute = matches[2];\n  var second = matches[3];\n  var timeZone = matches[5];\n  return ((hour <= 23 && minute <= 59 && second <= 59) ||\n          (hour == 23 && minute == 59 && second == 60)) &&\n         (!full || timeZone);\n}\n\n\nvar DATE_TIME_SEPARATOR = /t|\\s/i;\nfunction date_time(str) {\n  // http://tools.ietf.org/html/rfc3339#section-5.6\n  var dateTime = str.split(DATE_TIME_SEPARATOR);\n  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);\n}\n\n\nvar NOT_URI_FRAGMENT = /\\/|:/;\nfunction uri(str) {\n  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n  return NOT_URI_FRAGMENT.test(str) && URI.test(str);\n}\n\n\nvar Z_ANCHOR = /[^\\\\]\\\\Z/;\nfunction regex(str) {\n  if (Z_ANCHOR.test(str)) return false;\n  try {\n    new RegExp(str);\n    return true;\n  } catch(e) {\n    return false;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/formats.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar resolve = __webpack_require__(/*! ./resolve */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/resolve.js\")\n  , util = __webpack_require__(/*! ./util */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js\")\n  , errorClasses = __webpack_require__(/*! ./error_classes */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/error_classes.js\")\n  , stableStringify = __webpack_require__(/*! fast-json-stable-stringify */ \"./node_modules/fast-json-stable-stringify/index.js\");\n\nvar validateGenerator = __webpack_require__(/*! ../dotjs/validate */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/validate.js\");\n\n/**\n * Functions below are used inside compiled validations function\n */\n\nvar ucs2length = util.ucs2length;\nvar equal = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/protodef-validator/node_modules/fast-deep-equal/index.js\");\n\n// this error is thrown by async schemas to return validation errors via exception\nvar ValidationError = errorClasses.Validation;\n\nmodule.exports = compile;\n\n\n/**\n * Compiles schema to validation function\n * @this   Ajv\n * @param  {Object} schema schema object\n * @param  {Object} root object with information about the root schema for this schema\n * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution\n * @param  {String} baseId base ID for IDs in the schema\n * @return {Function} validation function\n */\nfunction compile(schema, root, localRefs, baseId) {\n  /* jshint validthis: true, evil: true */\n  /* eslint no-shadow: 0 */\n  var self = this\n    , opts = this._opts\n    , refVal = [ undefined ]\n    , refs = {}\n    , patterns = []\n    , patternsHash = {}\n    , defaults = []\n    , defaultsHash = {}\n    , customRules = [];\n\n  root = root || { schema: schema, refVal: refVal, refs: refs };\n\n  var c = checkCompiling.call(this, schema, root, baseId);\n  var compilation = this._compilations[c.index];\n  if (c.compiling) return (compilation.callValidate = callValidate);\n\n  var formats = this._formats;\n  var RULES = this.RULES;\n\n  try {\n    var v = localCompile(schema, root, localRefs, baseId);\n    compilation.validate = v;\n    var cv = compilation.callValidate;\n    if (cv) {\n      cv.schema = v.schema;\n      cv.errors = null;\n      cv.refs = v.refs;\n      cv.refVal = v.refVal;\n      cv.root = v.root;\n      cv.$async = v.$async;\n      if (opts.sourceCode) cv.source = v.source;\n    }\n    return v;\n  } finally {\n    endCompiling.call(this, schema, root, baseId);\n  }\n\n  /* @this   {*} - custom context, see passContext option */\n  function callValidate() {\n    /* jshint validthis: true */\n    var validate = compilation.validate;\n    var result = validate.apply(this, arguments);\n    callValidate.errors = validate.errors;\n    return result;\n  }\n\n  function localCompile(_schema, _root, localRefs, baseId) {\n    var isRoot = !_root || (_root && _root.schema == _schema);\n    if (_root.schema != root.schema)\n      return compile.call(self, _schema, _root, localRefs, baseId);\n\n    var $async = _schema.$async === true;\n\n    var sourceCode = validateGenerator({\n      isTop: true,\n      schema: _schema,\n      isRoot: isRoot,\n      baseId: baseId,\n      root: _root,\n      schemaPath: '',\n      errSchemaPath: '#',\n      errorPath: '\"\"',\n      MissingRefError: errorClasses.MissingRef,\n      RULES: RULES,\n      validate: validateGenerator,\n      util: util,\n      resolve: resolve,\n      resolveRef: resolveRef,\n      usePattern: usePattern,\n      useDefault: useDefault,\n      useCustomRule: useCustomRule,\n      opts: opts,\n      formats: formats,\n      logger: self.logger,\n      self: self\n    });\n\n    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)\n                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)\n                   + sourceCode;\n\n    if (opts.processCode) sourceCode = opts.processCode(sourceCode);\n    // console.log('\\n\\n\\n *** \\n', JSON.stringify(sourceCode));\n    var validate;\n    try {\n      var makeValidate = new Function(\n        'self',\n        'RULES',\n        'formats',\n        'root',\n        'refVal',\n        'defaults',\n        'customRules',\n        'equal',\n        'ucs2length',\n        'ValidationError',\n        sourceCode\n      );\n\n      validate = makeValidate(\n        self,\n        RULES,\n        formats,\n        root,\n        refVal,\n        defaults,\n        customRules,\n        equal,\n        ucs2length,\n        ValidationError\n      );\n\n      refVal[0] = validate;\n    } catch(e) {\n      self.logger.error('Error compiling schema, function code:', sourceCode);\n      throw e;\n    }\n\n    validate.schema = _schema;\n    validate.errors = null;\n    validate.refs = refs;\n    validate.refVal = refVal;\n    validate.root = isRoot ? validate : _root;\n    if ($async) validate.$async = true;\n    if (opts.sourceCode === true) {\n      validate.source = {\n        code: sourceCode,\n        patterns: patterns,\n        defaults: defaults\n      };\n    }\n\n    return validate;\n  }\n\n  function resolveRef(baseId, ref, isRoot) {\n    ref = resolve.url(baseId, ref);\n    var refIndex = refs[ref];\n    var _refVal, refCode;\n    if (refIndex !== undefined) {\n      _refVal = refVal[refIndex];\n      refCode = 'refVal[' + refIndex + ']';\n      return resolvedRef(_refVal, refCode);\n    }\n    if (!isRoot && root.refs) {\n      var rootRefId = root.refs[ref];\n      if (rootRefId !== undefined) {\n        _refVal = root.refVal[rootRefId];\n        refCode = addLocalRef(ref, _refVal);\n        return resolvedRef(_refVal, refCode);\n      }\n    }\n\n    refCode = addLocalRef(ref);\n    var v = resolve.call(self, localCompile, root, ref);\n    if (v === undefined) {\n      var localSchema = localRefs && localRefs[ref];\n      if (localSchema) {\n        v = resolve.inlineRef(localSchema, opts.inlineRefs)\n            ? localSchema\n            : compile.call(self, localSchema, root, localRefs, baseId);\n      }\n    }\n\n    if (v === undefined) {\n      removeLocalRef(ref);\n    } else {\n      replaceLocalRef(ref, v);\n      return resolvedRef(v, refCode);\n    }\n  }\n\n  function addLocalRef(ref, v) {\n    var refId = refVal.length;\n    refVal[refId] = v;\n    refs[ref] = refId;\n    return 'refVal' + refId;\n  }\n\n  function removeLocalRef(ref) {\n    delete refs[ref];\n  }\n\n  function replaceLocalRef(ref, v) {\n    var refId = refs[ref];\n    refVal[refId] = v;\n  }\n\n  function resolvedRef(refVal, code) {\n    return typeof refVal == 'object' || typeof refVal == 'boolean'\n            ? { code: code, schema: refVal, inline: true }\n            : { code: code, $async: refVal && !!refVal.$async };\n  }\n\n  function usePattern(regexStr) {\n    var index = patternsHash[regexStr];\n    if (index === undefined) {\n      index = patternsHash[regexStr] = patterns.length;\n      patterns[index] = regexStr;\n    }\n    return 'pattern' + index;\n  }\n\n  function useDefault(value) {\n    switch (typeof value) {\n      case 'boolean':\n      case 'number':\n        return '' + value;\n      case 'string':\n        return util.toQuotedString(value);\n      case 'object':\n        if (value === null) return 'null';\n        var valueStr = stableStringify(value);\n        var index = defaultsHash[valueStr];\n        if (index === undefined) {\n          index = defaultsHash[valueStr] = defaults.length;\n          defaults[index] = value;\n        }\n        return 'default' + index;\n    }\n  }\n\n  function useCustomRule(rule, schema, parentSchema, it) {\n    if (self._opts.validateSchema !== false) {\n      var deps = rule.definition.dependencies;\n      if (deps && !deps.every(function(keyword) {\n        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);\n      }))\n        throw new Error('parent schema must have all required keywords: ' + deps.join(','));\n\n      var validateSchema = rule.definition.validateSchema;\n      if (validateSchema) {\n        var valid = validateSchema(schema);\n        if (!valid) {\n          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);\n          if (self._opts.validateSchema == 'log') self.logger.error(message);\n          else throw new Error(message);\n        }\n      }\n    }\n\n    var compile = rule.definition.compile\n      , inline = rule.definition.inline\n      , macro = rule.definition.macro;\n\n    var validate;\n    if (compile) {\n      validate = compile.call(self, schema, parentSchema, it);\n    } else if (macro) {\n      validate = macro.call(self, schema, parentSchema, it);\n      if (opts.validateSchema !== false) self.validateSchema(validate, true);\n    } else if (inline) {\n      validate = inline.call(self, it, rule.keyword, schema, parentSchema);\n    } else {\n      validate = rule.definition.validate;\n      if (!validate) return;\n    }\n\n    if (validate === undefined)\n      throw new Error('custom keyword \"' + rule.keyword + '\"failed to compile');\n\n    var index = customRules.length;\n    customRules[index] = validate;\n\n    return {\n      code: 'customRule' + index,\n      validate: validate\n    };\n  }\n}\n\n\n/**\n * Checks if the schema is currently compiled\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Object} object with properties \"index\" (compilation index) and \"compiling\" (boolean)\n */\nfunction checkCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var index = compIndex.call(this, schema, root, baseId);\n  if (index >= 0) return { index: index, compiling: true };\n  index = this._compilations.length;\n  this._compilations[index] = {\n    schema: schema,\n    root: root,\n    baseId: baseId\n  };\n  return { index: index, compiling: false };\n}\n\n\n/**\n * Removes the schema from the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n */\nfunction endCompiling(schema, root, baseId) {\n  /* jshint validthis: true */\n  var i = compIndex.call(this, schema, root, baseId);\n  if (i >= 0) this._compilations.splice(i, 1);\n}\n\n\n/**\n * Index of schema compilation in the currently compiled list\n * @this   Ajv\n * @param  {Object} schema schema to compile\n * @param  {Object} root root object\n * @param  {String} baseId base schema ID\n * @return {Integer} compilation index\n */\nfunction compIndex(schema, root, baseId) {\n  /* jshint validthis: true */\n  for (var i=0; i<this._compilations.length; i++) {\n    var c = this._compilations[i];\n    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;\n  }\n  return -1;\n}\n\n\nfunction patternCode(i, patterns) {\n  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';\n}\n\n\nfunction defaultCode(i) {\n  return 'var default' + i + ' = defaults[' + i + '];';\n}\n\n\nfunction refValCode(i, refVal) {\n  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';\n}\n\n\nfunction customRuleCode(i) {\n  return 'var customRule' + i + ' = customRules[' + i + '];';\n}\n\n\nfunction vars(arr, statement) {\n  if (!arr.length) return '';\n  var code = '';\n  for (var i=0; i<arr.length; i++)\n    code += statement(i, arr);\n  return code;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/index.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/resolve.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/resolve.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar URI = __webpack_require__(/*! uri-js */ \"./node_modules/uri-js/dist/es5/uri.all.js\")\n  , equal = __webpack_require__(/*! fast-deep-equal */ \"./node_modules/protodef-validator/node_modules/fast-deep-equal/index.js\")\n  , util = __webpack_require__(/*! ./util */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js\")\n  , SchemaObject = __webpack_require__(/*! ./schema_obj */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/schema_obj.js\")\n  , traverse = __webpack_require__(/*! json-schema-traverse */ \"./node_modules/json-schema-traverse/index.js\");\n\nmodule.exports = resolve;\n\nresolve.normalizeId = normalizeId;\nresolve.fullPath = getFullPath;\nresolve.url = resolveUrl;\nresolve.ids = resolveIds;\nresolve.inlineRef = inlineRef;\nresolve.schema = resolveSchema;\n\n/**\n * [resolve and compile the references ($ref)]\n * @this   Ajv\n * @param  {Function} compile reference to schema compilation funciton (localCompile)\n * @param  {Object} root object with information about the root schema for the current schema\n * @param  {String} ref reference to resolve\n * @return {Object|Function} schema object (if the schema can be inlined) or validation function\n */\nfunction resolve(compile, root, ref) {\n  /* jshint validthis: true */\n  var refVal = this._refs[ref];\n  if (typeof refVal == 'string') {\n    if (this._refs[refVal]) refVal = this._refs[refVal];\n    else return resolve.call(this, compile, root, refVal);\n  }\n\n  refVal = refVal || this._schemas[ref];\n  if (refVal instanceof SchemaObject) {\n    return inlineRef(refVal.schema, this._opts.inlineRefs)\n            ? refVal.schema\n            : refVal.validate || this._compile(refVal);\n  }\n\n  var res = resolveSchema.call(this, root, ref);\n  var schema, v, baseId;\n  if (res) {\n    schema = res.schema;\n    root = res.root;\n    baseId = res.baseId;\n  }\n\n  if (schema instanceof SchemaObject) {\n    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);\n  } else if (schema !== undefined) {\n    v = inlineRef(schema, this._opts.inlineRefs)\n        ? schema\n        : compile.call(this, schema, root, undefined, baseId);\n  }\n\n  return v;\n}\n\n\n/**\n * Resolve schema, its root and baseId\n * @this Ajv\n * @param  {Object} root root object with properties schema, refVal, refs\n * @param  {String} ref  reference to resolve\n * @return {Object} object with properties schema, root, baseId\n */\nfunction resolveSchema(root, ref) {\n  /* jshint validthis: true */\n  var p = URI.parse(ref)\n    , refPath = _getFullPath(p)\n    , baseId = getFullPath(this._getId(root.schema));\n  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {\n    var id = normalizeId(refPath);\n    var refVal = this._refs[id];\n    if (typeof refVal == 'string') {\n      return resolveRecursive.call(this, root, refVal, p);\n    } else if (refVal instanceof SchemaObject) {\n      if (!refVal.validate) this._compile(refVal);\n      root = refVal;\n    } else {\n      refVal = this._schemas[id];\n      if (refVal instanceof SchemaObject) {\n        if (!refVal.validate) this._compile(refVal);\n        if (id == normalizeId(ref))\n          return { schema: refVal, root: root, baseId: baseId };\n        root = refVal;\n      } else {\n        return;\n      }\n    }\n    if (!root.schema) return;\n    baseId = getFullPath(this._getId(root.schema));\n  }\n  return getJsonPointer.call(this, p, baseId, root.schema, root);\n}\n\n\n/* @this Ajv */\nfunction resolveRecursive(root, ref, parsedRef) {\n  /* jshint validthis: true */\n  var res = resolveSchema.call(this, root, ref);\n  if (res) {\n    var schema = res.schema;\n    var baseId = res.baseId;\n    root = res.root;\n    var id = this._getId(schema);\n    if (id) baseId = resolveUrl(baseId, id);\n    return getJsonPointer.call(this, parsedRef, baseId, schema, root);\n  }\n}\n\n\nvar PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);\n/* @this Ajv */\nfunction getJsonPointer(parsedRef, baseId, schema, root) {\n  /* jshint validthis: true */\n  parsedRef.fragment = parsedRef.fragment || '';\n  if (parsedRef.fragment.slice(0,1) != '/') return;\n  var parts = parsedRef.fragment.split('/');\n\n  for (var i = 1; i < parts.length; i++) {\n    var part = parts[i];\n    if (part) {\n      part = util.unescapeFragment(part);\n      schema = schema[part];\n      if (schema === undefined) break;\n      var id;\n      if (!PREVENT_SCOPE_CHANGE[part]) {\n        id = this._getId(schema);\n        if (id) baseId = resolveUrl(baseId, id);\n        if (schema.$ref) {\n          var $ref = resolveUrl(baseId, schema.$ref);\n          var res = resolveSchema.call(this, root, $ref);\n          if (res) {\n            schema = res.schema;\n            root = res.root;\n            baseId = res.baseId;\n          }\n        }\n      }\n    }\n  }\n  if (schema !== undefined && schema !== root.schema)\n    return { schema: schema, root: root, baseId: baseId };\n}\n\n\nvar SIMPLE_INLINED = util.toHash([\n  'type', 'format', 'pattern',\n  'maxLength', 'minLength',\n  'maxProperties', 'minProperties',\n  'maxItems', 'minItems',\n  'maximum', 'minimum',\n  'uniqueItems', 'multipleOf',\n  'required', 'enum'\n]);\nfunction inlineRef(schema, limit) {\n  if (limit === false) return false;\n  if (limit === undefined || limit === true) return checkNoRef(schema);\n  else if (limit) return countKeys(schema) <= limit;\n}\n\n\nfunction checkNoRef(schema) {\n  var item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return false;\n      item = schema[key];\n      if (typeof item == 'object' && !checkNoRef(item)) return false;\n    }\n  }\n  return true;\n}\n\n\nfunction countKeys(schema) {\n  var count = 0, item;\n  if (Array.isArray(schema)) {\n    for (var i=0; i<schema.length; i++) {\n      item = schema[i];\n      if (typeof item == 'object') count += countKeys(item);\n      if (count == Infinity) return Infinity;\n    }\n  } else {\n    for (var key in schema) {\n      if (key == '$ref') return Infinity;\n      if (SIMPLE_INLINED[key]) {\n        count++;\n      } else {\n        item = schema[key];\n        if (typeof item == 'object') count += countKeys(item) + 1;\n        if (count == Infinity) return Infinity;\n      }\n    }\n  }\n  return count;\n}\n\n\nfunction getFullPath(id, normalize) {\n  if (normalize !== false) id = normalizeId(id);\n  var p = URI.parse(id);\n  return _getFullPath(p);\n}\n\n\nfunction _getFullPath(p) {\n  return URI.serialize(p).split('#')[0] + '#';\n}\n\n\nvar TRAILING_SLASH_HASH = /#\\/?$/;\nfunction normalizeId(id) {\n  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';\n}\n\n\nfunction resolveUrl(baseId, id) {\n  id = normalizeId(id);\n  return URI.resolve(baseId, id);\n}\n\n\n/* @this Ajv */\nfunction resolveIds(schema) {\n  var schemaId = normalizeId(this._getId(schema));\n  var baseIds = {'': schemaId};\n  var fullPaths = {'': getFullPath(schemaId, false)};\n  var localRefs = {};\n  var self = this;\n\n  traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n    if (jsonPtr === '') return;\n    var id = self._getId(sch);\n    var baseId = baseIds[parentJsonPtr];\n    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;\n    if (keyIndex !== undefined)\n      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));\n\n    if (typeof id == 'string') {\n      id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);\n\n      var refVal = self._refs[id];\n      if (typeof refVal == 'string') refVal = self._refs[refVal];\n      if (refVal && refVal.schema) {\n        if (!equal(sch, refVal.schema))\n          throw new Error('id \"' + id + '\" resolves to more than one schema');\n      } else if (id != normalizeId(fullPath)) {\n        if (id[0] == '#') {\n          if (localRefs[id] && !equal(sch, localRefs[id]))\n            throw new Error('id \"' + id + '\" resolves to more than one schema');\n          localRefs[id] = sch;\n        } else {\n          self._refs[id] = fullPath;\n        }\n      }\n    }\n    baseIds[jsonPtr] = baseId;\n    fullPaths[jsonPtr] = fullPath;\n  });\n\n  return localRefs;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/resolve.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/rules.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/rules.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ruleModules = __webpack_require__(/*! ../dotjs */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/index.js\")\n  , toHash = __webpack_require__(/*! ./util */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js\").toHash;\n\nmodule.exports = function rules() {\n  var RULES = [\n    { type: 'number',\n      rules: [ { 'maximum': ['exclusiveMaximum'] },\n               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },\n    { type: 'string',\n      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },\n    { type: 'array',\n      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },\n    { type: 'object',\n      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',\n               { 'properties': ['additionalProperties', 'patternProperties'] } ] },\n    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }\n  ];\n\n  var ALL = [ 'type', '$comment' ];\n  var KEYWORDS = [\n    '$schema', '$id', 'id', '$data', '$async', 'title',\n    'description', 'default', 'definitions',\n    'examples', 'readOnly', 'writeOnly',\n    'contentMediaType', 'contentEncoding',\n    'additionalItems', 'then', 'else'\n  ];\n  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];\n  RULES.all = toHash(ALL);\n  RULES.types = toHash(TYPES);\n\n  RULES.forEach(function (group) {\n    group.rules = group.rules.map(function (keyword) {\n      var implKeywords;\n      if (typeof keyword == 'object') {\n        var key = Object.keys(keyword)[0];\n        implKeywords = keyword[key];\n        keyword = key;\n        implKeywords.forEach(function (k) {\n          ALL.push(k);\n          RULES.all[k] = true;\n        });\n      }\n      ALL.push(keyword);\n      var rule = RULES.all[keyword] = {\n        keyword: keyword,\n        code: ruleModules[keyword],\n        implements: implKeywords\n      };\n      return rule;\n    });\n\n    RULES.all.$comment = {\n      keyword: '$comment',\n      code: ruleModules.$comment\n    };\n\n    if (group.type) RULES.types[group.type] = group;\n  });\n\n  RULES.keywords = toHash(ALL.concat(KEYWORDS));\n  RULES.custom = {};\n\n  return RULES;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/rules.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/schema_obj.js":
/*!************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/schema_obj.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar util = __webpack_require__(/*! ./util */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js\");\n\nmodule.exports = SchemaObject;\n\nfunction SchemaObject(obj) {\n  util.copy(obj, this);\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/schema_obj.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/ucs2length.js":
/*!************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/ucs2length.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nmodule.exports = function ucs2length(str) {\n  var length = 0\n    , len = str.length\n    , pos = 0\n    , value;\n  while (pos < len) {\n    length++;\n    value = str.charCodeAt(pos++);\n    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos);\n      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate\n    }\n  }\n  return length;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/ucs2length.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js":
/*!******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = {\n  copy: copy,\n  checkDataType: checkDataType,\n  checkDataTypes: checkDataTypes,\n  coerceToTypes: coerceToTypes,\n  toHash: toHash,\n  getProperty: getProperty,\n  escapeQuotes: escapeQuotes,\n  equal: __webpack_require__(/*! fast-deep-equal */ \"./node_modules/protodef-validator/node_modules/fast-deep-equal/index.js\"),\n  ucs2length: __webpack_require__(/*! ./ucs2length */ \"./node_modules/protodef-validator/node_modules/ajv/lib/compile/ucs2length.js\"),\n  varOccurences: varOccurences,\n  varReplace: varReplace,\n  cleanUpCode: cleanUpCode,\n  finalCleanUpCode: finalCleanUpCode,\n  schemaHasRules: schemaHasRules,\n  schemaHasRulesExcept: schemaHasRulesExcept,\n  schemaUnknownRules: schemaUnknownRules,\n  toQuotedString: toQuotedString,\n  getPathExpr: getPathExpr,\n  getPath: getPath,\n  getData: getData,\n  unescapeFragment: unescapeFragment,\n  unescapeJsonPointer: unescapeJsonPointer,\n  escapeFragment: escapeFragment,\n  escapeJsonPointer: escapeJsonPointer\n};\n\n\nfunction copy(o, to) {\n  to = to || {};\n  for (var key in o) to[key] = o[key];\n  return to;\n}\n\n\nfunction checkDataType(dataType, data, negate) {\n  var EQUAL = negate ? ' !== ' : ' === '\n    , AND = negate ? ' || ' : ' && '\n    , OK = negate ? '!' : ''\n    , NOT = negate ? '' : '!';\n  switch (dataType) {\n    case 'null': return data + EQUAL + 'null';\n    case 'array': return OK + 'Array.isArray(' + data + ')';\n    case 'object': return '(' + OK + data + AND +\n                          'typeof ' + data + EQUAL + '\"object\"' + AND +\n                          NOT + 'Array.isArray(' + data + '))';\n    case 'integer': return '(typeof ' + data + EQUAL + '\"number\"' + AND +\n                           NOT + '(' + data + ' % 1)' +\n                           AND + data + EQUAL + data + ')';\n    default: return 'typeof ' + data + EQUAL + '\"' + dataType + '\"';\n  }\n}\n\n\nfunction checkDataTypes(dataTypes, data) {\n  switch (dataTypes.length) {\n    case 1: return checkDataType(dataTypes[0], data, true);\n    default:\n      var code = '';\n      var types = toHash(dataTypes);\n      if (types.array && types.object) {\n        code = types.null ? '(': '(!' + data + ' || ';\n        code += 'typeof ' + data + ' !== \"object\")';\n        delete types.null;\n        delete types.array;\n        delete types.object;\n      }\n      if (types.number) delete types.integer;\n      for (var t in types)\n        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);\n\n      return code;\n  }\n}\n\n\nvar COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);\nfunction coerceToTypes(optionCoerceTypes, dataTypes) {\n  if (Array.isArray(dataTypes)) {\n    var types = [];\n    for (var i=0; i<dataTypes.length; i++) {\n      var t = dataTypes[i];\n      if (COERCE_TO_TYPES[t]) types[types.length] = t;\n      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;\n    }\n    if (types.length) return types;\n  } else if (COERCE_TO_TYPES[dataTypes]) {\n    return [dataTypes];\n  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {\n    return ['array'];\n  }\n}\n\n\nfunction toHash(arr) {\n  var hash = {};\n  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;\n  return hash;\n}\n\n\nvar IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;\nvar SINGLE_QUOTE = /'|\\\\/g;\nfunction getProperty(key) {\n  return typeof key == 'number'\n          ? '[' + key + ']'\n          : IDENTIFIER.test(key)\n            ? '.' + key\n            : \"['\" + escapeQuotes(key) + \"']\";\n}\n\n\nfunction escapeQuotes(str) {\n  return str.replace(SINGLE_QUOTE, '\\\\$&')\n            .replace(/\\n/g, '\\\\n')\n            .replace(/\\r/g, '\\\\r')\n            .replace(/\\f/g, '\\\\f')\n            .replace(/\\t/g, '\\\\t');\n}\n\n\nfunction varOccurences(str, dataVar) {\n  dataVar += '[^0-9]';\n  var matches = str.match(new RegExp(dataVar, 'g'));\n  return matches ? matches.length : 0;\n}\n\n\nfunction varReplace(str, dataVar, expr) {\n  dataVar += '([^0-9])';\n  expr = expr.replace(/\\$/g, '$$$$');\n  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');\n}\n\n\nvar EMPTY_ELSE = /else\\s*{\\s*}/g\n  , EMPTY_IF_NO_ELSE = /if\\s*\\([^)]+\\)\\s*\\{\\s*\\}(?!\\s*else)/g\n  , EMPTY_IF_WITH_ELSE = /if\\s*\\(([^)]+)\\)\\s*\\{\\s*\\}\\s*else(?!\\s*if)/g;\nfunction cleanUpCode(out) {\n  return out.replace(EMPTY_ELSE, '')\n            .replace(EMPTY_IF_NO_ELSE, '')\n            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');\n}\n\n\nvar ERRORS_REGEXP = /[^v.]errors/g\n  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g\n  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g\n  , RETURN_VALID = 'return errors === 0;'\n  , RETURN_TRUE = 'validate.errors = null; return true;'\n  , RETURN_ASYNC = /if \\(errors === 0\\) return data;\\s*else throw new ValidationError\\(vErrors\\);/\n  , RETURN_DATA_ASYNC = 'return data;'\n  , ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g\n  , REMOVE_ROOTDATA = /if \\(rootData === undefined\\) rootData = data;/;\n\nfunction finalCleanUpCode(out, async) {\n  var matches = out.match(ERRORS_REGEXP);\n  if (matches && matches.length == 2) {\n    out = async\n          ? out.replace(REMOVE_ERRORS_ASYNC, '')\n               .replace(RETURN_ASYNC, RETURN_DATA_ASYNC)\n          : out.replace(REMOVE_ERRORS, '')\n               .replace(RETURN_VALID, RETURN_TRUE);\n  }\n\n  matches = out.match(ROOTDATA_REGEXP);\n  if (!matches || matches.length !== 3) return out;\n  return out.replace(REMOVE_ROOTDATA, '');\n}\n\n\nfunction schemaHasRules(schema, rules) {\n  if (typeof schema == 'boolean') return !schema;\n  for (var key in schema) if (rules[key]) return true;\n}\n\n\nfunction schemaHasRulesExcept(schema, rules, exceptKeyword) {\n  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';\n  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;\n}\n\n\nfunction schemaUnknownRules(schema, rules) {\n  if (typeof schema == 'boolean') return;\n  for (var key in schema) if (!rules[key]) return key;\n}\n\n\nfunction toQuotedString(str) {\n  return '\\'' + escapeQuotes(str) + '\\'';\n}\n\n\nfunction getPathExpr(currentPath, expr, jsonPointers, isNumber) {\n  var path = jsonPointers // false by default\n              ? '\\'/\\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \\'~0\\').replace(/\\\\//g, \\'~1\\')')\n              : (isNumber ? '\\'[\\' + ' + expr + ' + \\']\\'' : '\\'[\\\\\\'\\' + ' + expr + ' + \\'\\\\\\']\\'');\n  return joinPaths(currentPath, path);\n}\n\n\nfunction getPath(currentPath, prop, jsonPointers) {\n  var path = jsonPointers // false by default\n              ? toQuotedString('/' + escapeJsonPointer(prop))\n              : toQuotedString(getProperty(prop));\n  return joinPaths(currentPath, path);\n}\n\n\nvar JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nvar RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, lvl, paths) {\n  var up, jsonPointer, data, matches;\n  if ($data === '') return 'rootData';\n  if ($data[0] == '/') {\n    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);\n    jsonPointer = $data;\n    data = 'rootData';\n  } else {\n    matches = $data.match(RELATIVE_JSON_POINTER);\n    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);\n    up = +matches[1];\n    jsonPointer = matches[2];\n    if (jsonPointer == '#') {\n      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);\n      return paths[lvl - up];\n    }\n\n    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);\n    data = 'data' + ((lvl - up) || '');\n    if (!jsonPointer) return data;\n  }\n\n  var expr = data;\n  var segments = jsonPointer.split('/');\n  for (var i=0; i<segments.length; i++) {\n    var segment = segments[i];\n    if (segment) {\n      data += getProperty(unescapeJsonPointer(segment));\n      expr += ' && ' + data;\n    }\n  }\n  return expr;\n}\n\n\nfunction joinPaths (a, b) {\n  if (a == '\"\"') return b;\n  return (a + ' + ' + b).replace(/' \\+ '/g, '');\n}\n\n\nfunction unescapeFragment(str) {\n  return unescapeJsonPointer(decodeURIComponent(str));\n}\n\n\nfunction escapeFragment(str) {\n  return encodeURIComponent(escapeJsonPointer(str));\n}\n\n\nfunction escapeJsonPointer(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n\n\nfunction unescapeJsonPointer(str) {\n  return str.replace(/~1/g, '/').replace(/~0/g, '~');\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/compile/util.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/data.js":
/*!**********************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/data.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar KEYWORDS = [\n  'multipleOf',\n  'maximum',\n  'exclusiveMaximum',\n  'minimum',\n  'exclusiveMinimum',\n  'maxLength',\n  'minLength',\n  'pattern',\n  'additionalItems',\n  'maxItems',\n  'minItems',\n  'uniqueItems',\n  'maxProperties',\n  'minProperties',\n  'required',\n  'additionalProperties',\n  'enum',\n  'format',\n  'const'\n];\n\nmodule.exports = function (metaSchema, keywordsJsonPointers) {\n  for (var i=0; i<keywordsJsonPointers.length; i++) {\n    metaSchema = JSON.parse(JSON.stringify(metaSchema));\n    var segments = keywordsJsonPointers[i].split('/');\n    var keywords = metaSchema;\n    var j;\n    for (j=1; j<segments.length; j++)\n      keywords = keywords[segments[j]];\n\n    for (j=0; j<KEYWORDS.length; j++) {\n      var key = KEYWORDS[j];\n      var schema = keywords[key];\n      if (schema) {\n        keywords[key] = {\n          anyOf: [\n            schema,\n            { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n    }\n  }\n\n  return metaSchema;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/data.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/definition_schema.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/definition_schema.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar metaSchema = __webpack_require__(/*! ./refs/json-schema-draft-07.json */ \"./node_modules/protodef-validator/node_modules/ajv/lib/refs/json-schema-draft-07.json\");\n\nmodule.exports = {\n  $id: 'https://github.com/epoberezkin/ajv/blob/master/lib/definition_schema.js',\n  definitions: {\n    simpleTypes: metaSchema.definitions.simpleTypes\n  },\n  type: 'object',\n  dependencies: {\n    schema: ['validate'],\n    $data: ['validate'],\n    statements: ['inline'],\n    valid: {not: {required: ['macro']}}\n  },\n  properties: {\n    type: metaSchema.properties.type,\n    schema: {type: 'boolean'},\n    statements: {type: 'boolean'},\n    dependencies: {\n      type: 'array',\n      items: {type: 'string'}\n    },\n    metaSchema: {type: 'object'},\n    modifying: {type: 'boolean'},\n    valid: {type: 'boolean'},\n    $data: {type: 'boolean'},\n    async: {type: 'boolean'},\n    errors: {\n      anyOf: [\n        {type: 'boolean'},\n        {const: 'full'}\n      ]\n    }\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/definition_schema.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limit.js":
/*!******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limit.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate__limit(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $isMax = $keyword == 'maximum',\n    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',\n    $schemaExcl = it.schema[$exclusiveKeyword],\n    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,\n    $op = $isMax ? '<' : '>',\n    $notOp = $isMax ? '>' : '<',\n    $errorKeyword = undefined;\n  if ($isDataExcl) {\n    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),\n      $exclusive = 'exclusive' + $lvl,\n      $exclType = 'exclType' + $lvl,\n      $exclIsNumber = 'exclIsNumber' + $lvl,\n      $opExpr = 'op' + $lvl,\n      $opStr = '\\' + ' + $opExpr + ' + \\'';\n    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';\n    $schemaValueExcl = 'schemaExcl' + $lvl;\n    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \\'boolean\\' && ' + ($exclType) + ' != \\'undefined\\' && ' + ($exclType) + ' != \\'number\\') { ';\n    var $errorKeyword = $exclusiveKeyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || '_exclusiveLimit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'' + ($exclusiveKeyword) + ' should be boolean\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else if ( ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n    }\n    out += ' ' + ($exclType) + ' == \\'number\\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \\'' + ($op) + '\\' : \\'' + ($op) + '=\\'; ';\n    if ($schema === undefined) {\n      $errorKeyword = $exclusiveKeyword;\n      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n      $schemaValue = $schemaValueExcl;\n      $isData = $isDataExcl;\n    }\n  } else {\n    var $exclIsNumber = typeof $schemaExcl == 'number',\n      $opStr = $op;\n    if ($exclIsNumber && $isData) {\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';\n    } else {\n      if ($exclIsNumber && $schema === undefined) {\n        $exclusive = true;\n        $errorKeyword = $exclusiveKeyword;\n        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n        $schemaValue = $schemaExcl;\n        $notOp += '=';\n      } else {\n        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);\n        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {\n          $exclusive = true;\n          $errorKeyword = $exclusiveKeyword;\n          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;\n          $notOp += '=';\n        } else {\n          $exclusive = false;\n          $opStr += '=';\n        }\n      }\n      var $opExpr = '\\'' + $opStr + '\\'';\n      out += ' if ( ';\n      if ($isData) {\n        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n      }\n      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';\n    }\n  }\n  $errorKeyword = $errorKeyword || $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limit') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be ' + ($opStr) + ' ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limit.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitItems.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitItems.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate__limitItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $op = $keyword == 'maxItems' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxItems') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' items\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitItems.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitLength.js":
/*!************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitLength.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate__limitLength(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $op = $keyword == 'maxLength' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  if (it.opts.unicode === false) {\n    out += ' ' + ($data) + '.length ';\n  } else {\n    out += ' ucs2length(' + ($data) + ') ';\n  }\n  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitLength') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT be ';\n      if ($keyword == 'maxLength') {\n        out += 'longer';\n      } else {\n        out += 'shorter';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' characters\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitLength.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitProperties.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitProperties.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate__limitProperties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $op = $keyword == 'maxProperties' ? '>' : '<';\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'number\\') || ';\n  }\n  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';\n  var $errorKeyword = $keyword;\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ($errorKeyword || '_limitProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should NOT have ';\n      if ($keyword == 'maxProperties') {\n        out += 'more';\n      } else {\n        out += 'fewer';\n      }\n      out += ' than ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + ($schema);\n      }\n      out += ' properties\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitProperties.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/allOf.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/allOf.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_allOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $allSchemasEmpty = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $allSchemasEmpty = false;\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    if ($allSchemasEmpty) {\n      out += ' if (true) { ';\n    } else {\n      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';\n    }\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/allOf.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/anyOf.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/anyOf.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_anyOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $noEmptySchema = $schema.every(function($sch) {\n    return (it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all));\n  });\n  if ($noEmptySchema) {\n    var $currentBaseId = $it.baseId;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('anyOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match some schema in anyOf\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n    out = it.util.cleanUpCode(out);\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/anyOf.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/comment.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/comment.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_comment(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $comment = it.util.toQuotedString($schema);\n  if (it.opts.$comment === true) {\n    out += ' console.log(' + ($comment) + ');';\n  } else if (typeof it.opts.$comment == 'function') {\n    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/comment.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/const.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/const.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_const(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (!$isData) {\n    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('const') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to constant\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/const.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/contains.js":
/*!********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/contains.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_contains(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId,\n    $nonEmptySchema = (it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all));\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($nonEmptySchema) {\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    out += ' if (' + ($nextValid) + ') break; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';\n  } else {\n    out += ' if (' + ($data) + '.length == 0) {';\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('contains') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should contain a valid item\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } else { ';\n  if ($nonEmptySchema) {\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n  }\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/contains.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/custom.js":
/*!******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/custom.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_custom(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $errorKeyword;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $rule = this,\n    $definition = 'definition' + $lvl,\n    $rDef = $rule.definition,\n    $closingBraces = '';\n  var $compile, $inline, $macro, $ruleValidate, $validateCode;\n  if ($isData && $rDef.$data) {\n    $validateCode = 'keywordValidate' + $lvl;\n    var $validateSchema = $rDef.validateSchema;\n    out += ' var ' + ($definition) + ' = RULES.custom[\\'' + ($keyword) + '\\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';\n  } else {\n    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);\n    if (!$ruleValidate) return;\n    $schemaValue = 'validate.schema' + $schemaPath;\n    $validateCode = $ruleValidate.code;\n    $compile = $rDef.compile;\n    $inline = $rDef.inline;\n    $macro = $rDef.macro;\n  }\n  var $ruleErrs = $validateCode + '.errors',\n    $i = 'i' + $lvl,\n    $ruleErr = 'ruleErr' + $lvl,\n    $asyncKeyword = $rDef.async;\n  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');\n  if (!($inline || $macro)) {\n    out += '' + ($ruleErrs) + ' = null;';\n  }\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if ($isData && $rDef.$data) {\n    $closingBraces += '}';\n    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';\n    if ($validateSchema) {\n      $closingBraces += '}';\n      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';\n    }\n  }\n  if ($inline) {\n    if ($rDef.statements) {\n      out += ' ' + ($ruleValidate.validate) + ' ';\n    } else {\n      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';\n    }\n  } else if ($macro) {\n    var $it = it.util.copy(it);\n    var $closingBraces = '';\n    $it.level++;\n    var $nextValid = 'valid' + $it.level;\n    $it.schema = $ruleValidate.validate;\n    $it.schemaPath = '';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it).replace(/validate\\.schema/g, $validateCode);\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' ' + ($code);\n  } else {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    out += '  ' + ($validateCode) + '.call( ';\n    if (it.opts.passContext) {\n      out += 'this';\n    } else {\n      out += 'self';\n    }\n    if ($compile || $rDef.schema === false) {\n      out += ' , ' + ($data) + ' ';\n    } else {\n      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';\n    }\n    out += ' , (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';\n    var def_callRuleValidate = out;\n    out = $$outStack.pop();\n    if ($rDef.errors === false) {\n      out += ' ' + ($valid) + ' = ';\n      if ($asyncKeyword) {\n        out += 'await ';\n      }\n      out += '' + (def_callRuleValidate) + '; ';\n    } else {\n      if ($asyncKeyword) {\n        $ruleErrs = 'customErrors' + $lvl;\n        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';\n      } else {\n        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';\n      }\n    }\n  }\n  if ($rDef.modifying) {\n    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';\n  }\n  out += '' + ($closingBraces);\n  if ($rDef.valid) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  } else {\n    out += ' if ( ';\n    if ($rDef.valid === undefined) {\n      out += ' !';\n      if ($macro) {\n        out += '' + ($nextValid);\n      } else {\n        out += '' + ($valid);\n      }\n    } else {\n      out += ' ' + (!$rDef.valid) + ' ';\n    }\n    out += ') { ';\n    $errorKeyword = $rule.keyword;\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    var def_customError = out;\n    out = $$outStack.pop();\n    if ($inline) {\n      if ($rDef.errors) {\n        if ($rDef.errors != 'full') {\n          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } ';\n        }\n      } else {\n        if ($rDef.errors === false) {\n          out += ' ' + (def_customError) + ' ';\n        } else {\n          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\"; } ';\n          if (it.opts.verbose) {\n            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n          }\n          out += ' } } ';\n        }\n      }\n    } else if ($macro) {\n      out += '   var err =   '; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'custom') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \\'' + ($rule.keyword) + '\\' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should pass \"' + ($rule.keyword) + '\" keyword validation\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError(vErrors); ';\n        } else {\n          out += ' validate.errors = vErrors; return false; ';\n        }\n      }\n    } else {\n      if ($rDef.errors === false) {\n        out += ' ' + (def_customError) + ' ';\n      } else {\n        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \\'\\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = \"' + ($errSchemaPath) + '\";  ';\n        if (it.opts.verbose) {\n          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';\n        }\n        out += ' } } else { ' + (def_customError) + ' } ';\n      }\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/custom.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/dependencies.js":
/*!************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/dependencies.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_dependencies(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $schemaDeps = {},\n    $propertyDeps = {},\n    $ownProperties = it.opts.ownProperties;\n  for ($property in $schema) {\n    var $sch = $schema[$property];\n    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;\n    $deps[$property] = $sch;\n  }\n  out += 'var ' + ($errs) + ' = errors;';\n  var $currentErrorPath = it.errorPath;\n  out += 'var missing' + ($lvl) + ';';\n  for (var $property in $propertyDeps) {\n    $deps = $propertyDeps[$property];\n    if ($deps.length) {\n      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      if ($breakOnError) {\n        out += ' && ( ';\n        var arr1 = $deps;\n        if (arr1) {\n          var $propertyKey, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $propertyKey = arr1[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ')) {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should have ';\n            if ($deps.length == 1) {\n              out += 'property ' + (it.util.escapeQuotes($deps[0]));\n            } else {\n              out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n            }\n            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      } else {\n        out += ' ) { ';\n        var arr2 = $deps;\n        if (arr2) {\n          var $propertyKey, i2 = -1,\n            l2 = arr2.length - 1;\n          while (i2 < l2) {\n            $propertyKey = arr2[i2 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('dependencies') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \\'' + (it.util.escapeQuotes($property)) + '\\', missingProperty: \\'' + ($missingProperty) + '\\', depsCount: ' + ($deps.length) + ', deps: \\'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(\", \"))) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'should have ';\n                if ($deps.length == 1) {\n                  out += 'property ' + (it.util.escapeQuotes($deps[0]));\n                } else {\n                  out += 'properties ' + (it.util.escapeQuotes($deps.join(\", \")));\n                }\n                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n      out += ' }   ';\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n  }\n  it.errorPath = $currentErrorPath;\n  var $currentBaseId = $it.baseId;\n  for (var $property in $schemaDeps) {\n    var $sch = $schemaDeps[$property];\n    if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {\n      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';\n      if ($ownProperties) {\n        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($property)) + '\\') ';\n      }\n      out += ') { ';\n      $it.schema = $sch;\n      $it.schemaPath = $schemaPath + it.util.getProperty($property);\n      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/dependencies.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/enum.js":
/*!****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/enum.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_enum(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $i = 'i' + $lvl,\n    $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';\n  }\n  out += 'var ' + ($valid) + ';';\n  if ($isData) {\n    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n  }\n  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';\n  if ($isData) {\n    out += '  }  ';\n  }\n  out += ' if (!' + ($valid) + ') {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('enum') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be equal to one of the allowed values\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' }';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/enum.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/format.js":
/*!******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/format.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_format(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  if (it.opts.format === false) {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n    return out;\n  }\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $unknownFormats = it.opts.unknownFormats,\n    $allowUnknown = Array.isArray($unknownFormats);\n  if ($isData) {\n    var $format = 'format' + $lvl,\n      $isObject = 'isObject' + $lvl,\n      $formatType = 'formatType' + $lvl;\n    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \\'object\\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \\'string\\'; if (' + ($isObject) + ') { ';\n    if (it.async) {\n      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';\n    }\n    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';\n    if ($isData) {\n      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n    }\n    out += ' (';\n    if ($unknownFormats != 'ignore') {\n      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';\n      if ($allowUnknown) {\n        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';\n      }\n      out += ') || ';\n    }\n    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \\'' + ($ruleType) + '\\' && !(typeof ' + ($format) + ' == \\'function\\' ? ';\n    if (it.async) {\n      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';\n    } else {\n      out += ' ' + ($format) + '(' + ($data) + ') ';\n    }\n    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';\n  } else {\n    var $format = it.formats[$schema];\n    if (!$format) {\n      if ($unknownFormats == 'ignore') {\n        it.logger.warn('unknown format \"' + $schema + '\" ignored in schema at path \"' + it.errSchemaPath + '\"');\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n        return out;\n      } else {\n        throw new Error('unknown format \"' + $schema + '\" is used in schema at path \"' + it.errSchemaPath + '\"');\n      }\n    }\n    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;\n    var $formatType = $isObject && $format.type || 'string';\n    if ($isObject) {\n      var $async = $format.async === true;\n      $format = $format.validate;\n    }\n    if ($formatType != $ruleType) {\n      if ($breakOnError) {\n        out += ' if (true) { ';\n      }\n      return out;\n    }\n    if ($async) {\n      if (!it.async) throw new Error('async format in sync schema');\n      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';\n      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';\n    } else {\n      out += ' if (! ';\n      var $formatRef = 'formats' + it.util.getProperty($schema);\n      if ($isObject) $formatRef += '.validate';\n      if (typeof $format == 'function') {\n        out += ' ' + ($formatRef) + '(' + ($data) + ') ';\n      } else {\n        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';\n      }\n      out += ') { ';\n    }\n  }\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('format') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match format \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += ' } ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/format.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/if.js":
/*!**************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/if.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_if(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $thenSch = it.schema['then'],\n    $elseSch = it.schema['else'],\n    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? typeof $thenSch == 'object' && Object.keys($thenSch).length > 0 : it.util.schemaHasRules($thenSch, it.RULES.all)),\n    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? typeof $elseSch == 'object' && Object.keys($elseSch).length > 0 : it.util.schemaHasRules($elseSch, it.RULES.all)),\n    $currentBaseId = $it.baseId;\n  if ($thenPresent || $elsePresent) {\n    var $ifClause;\n    $it.createErrors = false;\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    out += '  ' + (it.validate($it)) + ' ';\n    $it.baseId = $currentBaseId;\n    $it.createErrors = true;\n    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    if ($thenPresent) {\n      out += ' if (' + ($nextValid) + ') {  ';\n      $it.schema = it.schema['then'];\n      $it.schemaPath = it.schemaPath + '.then';\n      $it.errSchemaPath = it.errSchemaPath + '/then';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'then\\'; ';\n      } else {\n        $ifClause = '\\'then\\'';\n      }\n      out += ' } ';\n      if ($elsePresent) {\n        out += ' else { ';\n      }\n    } else {\n      out += ' if (!' + ($nextValid) + ') { ';\n    }\n    if ($elsePresent) {\n      $it.schema = it.schema['else'];\n      $it.schemaPath = it.schemaPath + '.else';\n      $it.errSchemaPath = it.errSchemaPath + '/else';\n      out += '  ' + (it.validate($it)) + ' ';\n      $it.baseId = $currentBaseId;\n      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';\n      if ($thenPresent && $elsePresent) {\n        $ifClause = 'ifClause' + $lvl;\n        out += ' var ' + ($ifClause) + ' = \\'else\\'; ';\n      } else {\n        $ifClause = '\\'else\\'';\n      }\n      out += ' } ';\n    }\n    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('if') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should match \"\\' + ' + ($ifClause) + ' + \\'\" schema\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    out += ' }   ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n    out = it.util.cleanUpCode(out);\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/if.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//all requires must be explicit because browserify won't work with dynamic requires\nmodule.exports = {\n  '$ref': __webpack_require__(/*! ./ref */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/ref.js\"),\n  allOf: __webpack_require__(/*! ./allOf */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/allOf.js\"),\n  anyOf: __webpack_require__(/*! ./anyOf */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/anyOf.js\"),\n  '$comment': __webpack_require__(/*! ./comment */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/comment.js\"),\n  const: __webpack_require__(/*! ./const */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/const.js\"),\n  contains: __webpack_require__(/*! ./contains */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/contains.js\"),\n  dependencies: __webpack_require__(/*! ./dependencies */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/dependencies.js\"),\n  'enum': __webpack_require__(/*! ./enum */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/enum.js\"),\n  format: __webpack_require__(/*! ./format */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/format.js\"),\n  'if': __webpack_require__(/*! ./if */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/if.js\"),\n  items: __webpack_require__(/*! ./items */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/items.js\"),\n  maximum: __webpack_require__(/*! ./_limit */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limit.js\"),\n  minimum: __webpack_require__(/*! ./_limit */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limit.js\"),\n  maxItems: __webpack_require__(/*! ./_limitItems */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitItems.js\"),\n  minItems: __webpack_require__(/*! ./_limitItems */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitItems.js\"),\n  maxLength: __webpack_require__(/*! ./_limitLength */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitLength.js\"),\n  minLength: __webpack_require__(/*! ./_limitLength */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitLength.js\"),\n  maxProperties: __webpack_require__(/*! ./_limitProperties */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitProperties.js\"),\n  minProperties: __webpack_require__(/*! ./_limitProperties */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/_limitProperties.js\"),\n  multipleOf: __webpack_require__(/*! ./multipleOf */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/multipleOf.js\"),\n  not: __webpack_require__(/*! ./not */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/not.js\"),\n  oneOf: __webpack_require__(/*! ./oneOf */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/oneOf.js\"),\n  pattern: __webpack_require__(/*! ./pattern */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/pattern.js\"),\n  properties: __webpack_require__(/*! ./properties */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/properties.js\"),\n  propertyNames: __webpack_require__(/*! ./propertyNames */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/propertyNames.js\"),\n  required: __webpack_require__(/*! ./required */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/required.js\"),\n  uniqueItems: __webpack_require__(/*! ./uniqueItems */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/uniqueItems.js\"),\n  validate: __webpack_require__(/*! ./validate */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/validate.js\")\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/index.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/items.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/items.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_items(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $idx = 'i' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $currentBaseId = it.baseId;\n  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';\n  if (Array.isArray($schema)) {\n    var $additionalItems = it.schema.additionalItems;\n    if ($additionalItems === false) {\n      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';\n      var $currErrSchemaPath = $errSchemaPath;\n      $errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += '  if (!' + ($valid) + ') {   ';\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ('additionalItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'should NOT have more than ' + ($schema.length) + ' items\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n      out += ' } ';\n      $errSchemaPath = $currErrSchemaPath;\n      if ($breakOnError) {\n        $closingBraces += '}';\n        out += ' else { ';\n      }\n    }\n    var arr1 = $schema;\n    if (arr1) {\n      var $sch, $i = -1,\n        l1 = arr1.length - 1;\n      while ($i < l1) {\n        $sch = arr1[$i += 1];\n        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {\n          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';\n          var $passData = $data + '[' + $i + ']';\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + '[' + $i + ']';\n          $it.errSchemaPath = $errSchemaPath + '/' + $i;\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);\n          $it.dataPathArr[$dataNxt] = $i;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0 : it.util.schemaHasRules($additionalItems, it.RULES.all))) {\n      $it.schema = $additionalItems;\n      $it.schemaPath = it.schemaPath + '.additionalItems';\n      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';\n      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n      var $passData = $data + '[' + $idx + ']';\n      $it.dataPathArr[$dataNxt] = $idx;\n      var $code = it.validate($it);\n      $it.baseId = $currentBaseId;\n      if (it.util.varOccurences($code, $nextData) < 2) {\n        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n      } else {\n        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n      }\n      if ($breakOnError) {\n        out += ' if (!' + ($nextValid) + ') break; ';\n      }\n      out += ' } }  ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n        $closingBraces += '}';\n      }\n    }\n  } else if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';\n    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);\n    var $passData = $data + '[' + $idx + ']';\n    $it.dataPathArr[$dataNxt] = $idx;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    if ($breakOnError) {\n      out += ' if (!' + ($nextValid) + ') break; ';\n    }\n    out += ' }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/items.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/multipleOf.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/multipleOf.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_multipleOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  out += 'var division' + ($lvl) + ';if (';\n  if ($isData) {\n    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \\'number\\' || ';\n  }\n  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';\n  if (it.opts.multipleOfPrecision) {\n    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';\n  } else {\n    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';\n  }\n  out += ' ) ';\n  if ($isData) {\n    out += '  )  ';\n  }\n  out += ' ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('multipleOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should be multiple of ';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue);\n      } else {\n        out += '' + ($schemaValue) + '\\'';\n      }\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + ($schema);\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/multipleOf.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/not.js":
/*!***************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/not.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_not(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    out += ' var ' + ($errs) + ' = errors;  ';\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    $it.createErrors = false;\n    var $allErrorsOption;\n    if ($it.opts.allErrors) {\n      $allErrorsOption = $it.opts.allErrors;\n      $it.opts.allErrors = false;\n    }\n    out += ' ' + (it.validate($it)) + ' ';\n    $it.createErrors = true;\n    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (' + ($nextValid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';\n    if (it.opts.allErrors) {\n      out += ' } ';\n    }\n  } else {\n    out += '  var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('not') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT be valid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if ($breakOnError) {\n      out += ' if (false) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/not.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/oneOf.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/oneOf.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_oneOf(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $currentBaseId = $it.baseId,\n    $prevValid = 'prevValid' + $lvl,\n    $passingSchemas = 'passingSchemas' + $lvl;\n  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';\n  var $wasComposite = it.compositeRule;\n  it.compositeRule = $it.compositeRule = true;\n  var arr1 = $schema;\n  if (arr1) {\n    var $sch, $i = -1,\n      l1 = arr1.length - 1;\n    while ($i < l1) {\n      $sch = arr1[$i += 1];\n      if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {\n        $it.schema = $sch;\n        $it.schemaPath = $schemaPath + '[' + $i + ']';\n        $it.errSchemaPath = $errSchemaPath + '/' + $i;\n        out += '  ' + (it.validate($it)) + ' ';\n        $it.baseId = $currentBaseId;\n      } else {\n        out += ' var ' + ($nextValid) + ' = true; ';\n      }\n      if ($i) {\n        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';\n        $closingBraces += '}';\n      }\n      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';\n    }\n  }\n  it.compositeRule = $it.compositeRule = $wasComposite;\n  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('oneOf') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match exactly one schema in oneOf\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; return false; ';\n    }\n  }\n  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';\n  if (it.opts.allErrors) {\n    out += ' } ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/oneOf.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/pattern.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/pattern.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_pattern(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);\n  out += 'if ( ';\n  if ($isData) {\n    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \\'string\\') || ';\n  }\n  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';\n  var $$outStack = $$outStack || [];\n  $$outStack.push(out);\n  out = ''; /* istanbul ignore else */\n  if (it.createErrors !== false) {\n    out += ' { keyword: \\'' + ('pattern') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';\n    if ($isData) {\n      out += '' + ($schemaValue);\n    } else {\n      out += '' + (it.util.toQuotedString($schema));\n    }\n    out += '  } ';\n    if (it.opts.messages !== false) {\n      out += ' , message: \\'should match pattern \"';\n      if ($isData) {\n        out += '\\' + ' + ($schemaValue) + ' + \\'';\n      } else {\n        out += '' + (it.util.escapeQuotes($schema));\n      }\n      out += '\"\\' ';\n    }\n    if (it.opts.verbose) {\n      out += ' , schema:  ';\n      if ($isData) {\n        out += 'validate.schema' + ($schemaPath);\n      } else {\n        out += '' + (it.util.toQuotedString($schema));\n      }\n      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n    }\n    out += ' } ';\n  } else {\n    out += ' {} ';\n  }\n  var __err = out;\n  out = $$outStack.pop();\n  if (!it.compositeRule && $breakOnError) {\n    /* istanbul ignore if */\n    if (it.async) {\n      out += ' throw new ValidationError([' + (__err) + ']); ';\n    } else {\n      out += ' validate.errors = [' + (__err) + ']; return false; ';\n    }\n  } else {\n    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n  }\n  out += '} ';\n  if ($breakOnError) {\n    out += ' else { ';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/pattern.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/properties.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/properties.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_properties(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  var $key = 'key' + $lvl,\n    $idx = 'idx' + $lvl,\n    $dataNxt = $it.dataLevel = it.dataLevel + 1,\n    $nextData = 'data' + $dataNxt,\n    $dataProperties = 'dataProperties' + $lvl;\n  var $schemaKeys = Object.keys($schema || {}),\n    $pProperties = it.schema.patternProperties || {},\n    $pPropertyKeys = Object.keys($pProperties),\n    $aProperties = it.schema.additionalProperties,\n    $someProperties = $schemaKeys.length || $pPropertyKeys.length,\n    $noAdditional = $aProperties === false,\n    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,\n    $removeAdditional = it.opts.removeAdditional,\n    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,\n    $ownProperties = it.opts.ownProperties,\n    $currentBaseId = it.baseId;\n  var $required = it.schema.required;\n  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);\n  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';\n  if ($ownProperties) {\n    out += ' var ' + ($dataProperties) + ' = undefined;';\n  }\n  if ($checkAdditional) {\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    if ($someProperties) {\n      out += ' var isAdditional' + ($lvl) + ' = !(false ';\n      if ($schemaKeys.length) {\n        if ($schemaKeys.length > 8) {\n          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';\n        } else {\n          var arr1 = $schemaKeys;\n          if (arr1) {\n            var $propertyKey, i1 = -1,\n              l1 = arr1.length - 1;\n            while (i1 < l1) {\n              $propertyKey = arr1[i1 += 1];\n              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';\n            }\n          }\n        }\n      }\n      if ($pPropertyKeys.length) {\n        var arr2 = $pPropertyKeys;\n        if (arr2) {\n          var $pProperty, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $pProperty = arr2[$i += 1];\n            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';\n          }\n        }\n      }\n      out += ' ); if (isAdditional' + ($lvl) + ') { ';\n    }\n    if ($removeAdditional == 'all') {\n      out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n    } else {\n      var $currentErrorPath = it.errorPath;\n      var $additionalProperty = '\\' + ' + $key + ' + \\'';\n      if (it.opts._errorDataPathProperty) {\n        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n      }\n      if ($noAdditional) {\n        if ($removeAdditional) {\n          out += ' delete ' + ($data) + '[' + ($key) + ']; ';\n        } else {\n          out += ' ' + ($nextValid) + ' = false; ';\n          var $currErrSchemaPath = $errSchemaPath;\n          $errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          var $$outStack = $$outStack || [];\n          $$outStack.push(out);\n          out = ''; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('additionalProperties') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \\'' + ($additionalProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is an invalid additional property';\n              } else {\n                out += 'should NOT have additional properties';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          var __err = out;\n          out = $$outStack.pop();\n          if (!it.compositeRule && $breakOnError) {\n            /* istanbul ignore if */\n            if (it.async) {\n              out += ' throw new ValidationError([' + (__err) + ']); ';\n            } else {\n              out += ' validate.errors = [' + (__err) + ']; return false; ';\n            }\n          } else {\n            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n          }\n          $errSchemaPath = $currErrSchemaPath;\n          if ($breakOnError) {\n            out += ' break; ';\n          }\n        }\n      } else if ($additionalIsSchema) {\n        if ($removeAdditional == 'failing') {\n          out += ' var ' + ($errs) + ' = errors;  ';\n          var $wasComposite = it.compositeRule;\n          it.compositeRule = $it.compositeRule = true;\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';\n          it.compositeRule = $it.compositeRule = $wasComposite;\n        } else {\n          $it.schema = $aProperties;\n          $it.schemaPath = it.schemaPath + '.additionalProperties';\n          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';\n          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n        }\n      }\n      it.errorPath = $currentErrorPath;\n    }\n    if ($someProperties) {\n      out += ' } ';\n    }\n    out += ' }  ';\n    if ($breakOnError) {\n      out += ' if (' + ($nextValid) + ') { ';\n      $closingBraces += '}';\n    }\n  }\n  var $useDefaults = it.opts.useDefaults && !it.compositeRule;\n  if ($schemaKeys.length) {\n    var arr3 = $schemaKeys;\n    if (arr3) {\n      var $propertyKey, i3 = -1,\n        l3 = arr3.length - 1;\n      while (i3 < l3) {\n        $propertyKey = arr3[i3 += 1];\n        var $sch = $schema[$propertyKey];\n        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {\n          var $prop = it.util.getProperty($propertyKey),\n            $passData = $data + $prop,\n            $hasDefault = $useDefaults && $sch.default !== undefined;\n          $it.schema = $sch;\n          $it.schemaPath = $schemaPath + $prop;\n          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);\n          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);\n          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            $code = it.util.varReplace($code, $nextData, $passData);\n            var $useData = $passData;\n          } else {\n            var $useData = $nextData;\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';\n          }\n          if ($hasDefault) {\n            out += ' ' + ($code) + ' ';\n          } else {\n            if ($requiredHash && $requiredHash[$propertyKey]) {\n              out += ' if ( ' + ($useData) + ' === undefined ';\n              if ($ownProperties) {\n                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n              }\n              out += ') { ' + ($nextValid) + ' = false; ';\n              var $currentErrorPath = it.errorPath,\n                $currErrSchemaPath = $errSchemaPath,\n                $missingProperty = it.util.escapeQuotes($propertyKey);\n              if (it.opts._errorDataPathProperty) {\n                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n              }\n              $errSchemaPath = it.errSchemaPath + '/required';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'';\n                  if (it.opts._errorDataPathProperty) {\n                    out += 'is a required property';\n                  } else {\n                    out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              $errSchemaPath = $currErrSchemaPath;\n              it.errorPath = $currentErrorPath;\n              out += ' } else { ';\n            } else {\n              if ($breakOnError) {\n                out += ' if ( ' + ($useData) + ' === undefined ';\n                if ($ownProperties) {\n                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ') { ' + ($nextValid) + ' = true; } else { ';\n              } else {\n                out += ' if (' + ($useData) + ' !== undefined ';\n                if ($ownProperties) {\n                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n                }\n                out += ' ) { ';\n              }\n            }\n            out += ' ' + ($code) + ' } ';\n          }\n        }\n        if ($breakOnError) {\n          out += ' if (' + ($nextValid) + ') { ';\n          $closingBraces += '}';\n        }\n      }\n    }\n  }\n  if ($pPropertyKeys.length) {\n    var arr4 = $pPropertyKeys;\n    if (arr4) {\n      var $pProperty, i4 = -1,\n        l4 = arr4.length - 1;\n      while (i4 < l4) {\n        $pProperty = arr4[i4 += 1];\n        var $sch = $pProperties[$pProperty];\n        if ((it.opts.strictKeywords ? typeof $sch == 'object' && Object.keys($sch).length > 0 : it.util.schemaHasRules($sch, it.RULES.all))) {\n          $it.schema = $sch;\n          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);\n          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);\n          if ($ownProperties) {\n            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n          } else {\n            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n          }\n          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';\n          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);\n          var $passData = $data + '[' + $key + ']';\n          $it.dataPathArr[$dataNxt] = $key;\n          var $code = it.validate($it);\n          $it.baseId = $currentBaseId;\n          if (it.util.varOccurences($code, $nextData) < 2) {\n            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n          } else {\n            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n          }\n          if ($breakOnError) {\n            out += ' if (!' + ($nextValid) + ') break; ';\n          }\n          out += ' } ';\n          if ($breakOnError) {\n            out += ' else ' + ($nextValid) + ' = true; ';\n          }\n          out += ' }  ';\n          if ($breakOnError) {\n            out += ' if (' + ($nextValid) + ') { ';\n            $closingBraces += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/properties.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/propertyNames.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/propertyNames.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_propertyNames(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $errs = 'errs__' + $lvl;\n  var $it = it.util.copy(it);\n  var $closingBraces = '';\n  $it.level++;\n  var $nextValid = 'valid' + $it.level;\n  out += 'var ' + ($errs) + ' = errors;';\n  if ((it.opts.strictKeywords ? typeof $schema == 'object' && Object.keys($schema).length > 0 : it.util.schemaHasRules($schema, it.RULES.all))) {\n    $it.schema = $schema;\n    $it.schemaPath = $schemaPath;\n    $it.errSchemaPath = $errSchemaPath;\n    var $key = 'key' + $lvl,\n      $idx = 'idx' + $lvl,\n      $i = 'i' + $lvl,\n      $invalidName = '\\' + ' + $key + ' + \\'',\n      $dataNxt = $it.dataLevel = it.dataLevel + 1,\n      $nextData = 'data' + $dataNxt,\n      $dataProperties = 'dataProperties' + $lvl,\n      $ownProperties = it.opts.ownProperties,\n      $currentBaseId = it.baseId;\n    if ($ownProperties) {\n      out += ' var ' + ($dataProperties) + ' = undefined; ';\n    }\n    if ($ownProperties) {\n      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';\n    } else {\n      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';\n    }\n    out += ' var startErrs' + ($lvl) + ' = errors; ';\n    var $passData = $key;\n    var $wasComposite = it.compositeRule;\n    it.compositeRule = $it.compositeRule = true;\n    var $code = it.validate($it);\n    $it.baseId = $currentBaseId;\n    if (it.util.varOccurences($code, $nextData) < 2) {\n      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';\n    } else {\n      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';\n    }\n    it.compositeRule = $it.compositeRule = $wasComposite;\n    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('propertyNames') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \\'' + ($invalidName) + '\\' } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'property name \\\\\\'' + ($invalidName) + '\\\\\\' is invalid\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError(vErrors); ';\n      } else {\n        out += ' validate.errors = vErrors; return false; ';\n      }\n    }\n    if ($breakOnError) {\n      out += ' break; ';\n    }\n    out += ' } }';\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';\n  }\n  out = it.util.cleanUpCode(out);\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/propertyNames.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/ref.js":
/*!***************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/ref.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_ref(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $async, $refCode;\n  if ($schema == '#' || $schema == '#/') {\n    if (it.isRoot) {\n      $async = it.async;\n      $refCode = 'validate';\n    } else {\n      $async = it.root.schema.$async === true;\n      $refCode = 'root.refVal[0]';\n    }\n  } else {\n    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);\n    if ($refVal === undefined) {\n      var $message = it.MissingRefError.message(it.baseId, $schema);\n      if (it.opts.missingRefs == 'fail') {\n        it.logger.error($message);\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('$ref') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \\'' + (it.util.escapeQuotes($schema)) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'can\\\\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        if ($breakOnError) {\n          out += ' if (false) { ';\n        }\n      } else if (it.opts.missingRefs == 'ignore') {\n        it.logger.warn($message);\n        if ($breakOnError) {\n          out += ' if (true) { ';\n        }\n      } else {\n        throw new it.MissingRefError(it.baseId, $schema, $message);\n      }\n    } else if ($refVal.inline) {\n      var $it = it.util.copy(it);\n      $it.level++;\n      var $nextValid = 'valid' + $it.level;\n      $it.schema = $refVal.schema;\n      $it.schemaPath = '';\n      $it.errSchemaPath = $schema;\n      var $code = it.validate($it).replace(/validate\\.schema/g, $refVal.code);\n      out += ' ' + ($code) + ' ';\n      if ($breakOnError) {\n        out += ' if (' + ($nextValid) + ') { ';\n      }\n    } else {\n      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);\n      $refCode = $refVal.code;\n    }\n  }\n  if ($refCode) {\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = '';\n    if (it.opts.passContext) {\n      out += ' ' + ($refCode) + '.call(this, ';\n    } else {\n      out += ' ' + ($refCode) + '( ';\n    }\n    out += ' ' + ($data) + ', (dataPath || \\'\\')';\n    if (it.errorPath != '\"\"') {\n      out += ' + ' + (it.errorPath);\n    }\n    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';\n    var __callValidate = out;\n    out = $$outStack.pop();\n    if ($async) {\n      if (!it.async) throw new Error('async schema referenced by sync schema');\n      if ($breakOnError) {\n        out += ' var ' + ($valid) + '; ';\n      }\n      out += ' try { await ' + (__callValidate) + '; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = true; ';\n      }\n      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';\n      if ($breakOnError) {\n        out += ' ' + ($valid) + ' = false; ';\n      }\n      out += ' } ';\n      if ($breakOnError) {\n        out += ' if (' + ($valid) + ') { ';\n      }\n    } else {\n      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';\n      if ($breakOnError) {\n        out += ' else { ';\n      }\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/ref.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/required.js":
/*!********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/required.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_required(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  var $vSchema = 'schema' + $lvl;\n  if (!$isData) {\n    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {\n      var $required = [];\n      var arr1 = $schema;\n      if (arr1) {\n        var $property, i1 = -1,\n          l1 = arr1.length - 1;\n        while (i1 < l1) {\n          $property = arr1[i1 += 1];\n          var $propertySch = it.schema.properties[$property];\n          if (!($propertySch && (it.opts.strictKeywords ? typeof $propertySch == 'object' && Object.keys($propertySch).length > 0 : it.util.schemaHasRules($propertySch, it.RULES.all)))) {\n            $required[$required.length] = $property;\n          }\n        }\n      }\n    } else {\n      var $required = $schema;\n    }\n  }\n  if ($isData || $required.length) {\n    var $currentErrorPath = it.errorPath,\n      $loopRequired = $isData || $required.length >= it.opts.loopRequired,\n      $ownProperties = it.opts.ownProperties;\n    if ($breakOnError) {\n      out += ' var missing' + ($lvl) + '; ';\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        out += ' var ' + ($valid) + ' = true; ';\n        if ($isData) {\n          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';\n        if ($ownProperties) {\n          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += '; if (!' + ($valid) + ') break; } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n        out += '  if (!' + ($valid) + ') {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      } else {\n        out += ' if ( ';\n        var arr2 = $required;\n        if (arr2) {\n          var $propertyKey, $i = -1,\n            l2 = arr2.length - 1;\n          while ($i < l2) {\n            $propertyKey = arr2[$i += 1];\n            if ($i) {\n              out += ' || ';\n            }\n            var $prop = it.util.getProperty($propertyKey),\n              $useData = $data + $prop;\n            out += ' ( ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';\n          }\n        }\n        out += ') {  ';\n        var $propertyPath = 'missing' + $lvl,\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;\n        }\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else { ';\n      }\n    } else {\n      if ($loopRequired) {\n        if (!$isData) {\n          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';\n        }\n        var $i = 'i' + $lvl,\n          $propertyPath = 'schema' + $lvl + '[' + $i + ']',\n          $missingProperty = '\\' + ' + $propertyPath + ' + \\'';\n        if (it.opts._errorDataPathProperty) {\n          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);\n        }\n        if ($isData) {\n          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */\n          if (it.createErrors !== false) {\n            out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n            if (it.opts.messages !== false) {\n              out += ' , message: \\'';\n              if (it.opts._errorDataPathProperty) {\n                out += 'is a required property';\n              } else {\n                out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n              }\n              out += '\\' ';\n            }\n            if (it.opts.verbose) {\n              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n            }\n            out += ' } ';\n          } else {\n            out += ' {} ';\n          }\n          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';\n        }\n        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';\n        if ($ownProperties) {\n          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';\n        }\n        out += ') {  var err =   '; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'';\n            if (it.opts._errorDataPathProperty) {\n              out += 'is a required property';\n            } else {\n              out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';\n        if ($isData) {\n          out += '  }  ';\n        }\n      } else {\n        var arr3 = $required;\n        if (arr3) {\n          var $propertyKey, i3 = -1,\n            l3 = arr3.length - 1;\n          while (i3 < l3) {\n            $propertyKey = arr3[i3 += 1];\n            var $prop = it.util.getProperty($propertyKey),\n              $missingProperty = it.util.escapeQuotes($propertyKey),\n              $useData = $data + $prop;\n            if (it.opts._errorDataPathProperty) {\n              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);\n            }\n            out += ' if ( ' + ($useData) + ' === undefined ';\n            if ($ownProperties) {\n              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \\'' + (it.util.escapeQuotes($propertyKey)) + '\\') ';\n            }\n            out += ') {  var err =   '; /* istanbul ignore else */\n            if (it.createErrors !== false) {\n              out += ' { keyword: \\'' + ('required') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \\'' + ($missingProperty) + '\\' } ';\n              if (it.opts.messages !== false) {\n                out += ' , message: \\'';\n                if (it.opts._errorDataPathProperty) {\n                  out += 'is a required property';\n                } else {\n                  out += 'should have required property \\\\\\'' + ($missingProperty) + '\\\\\\'';\n                }\n                out += '\\' ';\n              }\n              if (it.opts.verbose) {\n                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n              }\n              out += ' } ';\n            } else {\n              out += ' {} ';\n            }\n            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';\n          }\n        }\n      }\n    }\n    it.errorPath = $currentErrorPath;\n  } else if ($breakOnError) {\n    out += ' if (true) {';\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/required.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/uniqueItems.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/uniqueItems.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_uniqueItems(it, $keyword, $ruleType) {\n  var out = ' ';\n  var $lvl = it.level;\n  var $dataLvl = it.dataLevel;\n  var $schema = it.schema[$keyword];\n  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n  var $breakOnError = !it.opts.allErrors;\n  var $data = 'data' + ($dataLvl || '');\n  var $valid = 'valid' + $lvl;\n  var $isData = it.opts.$data && $schema && $schema.$data,\n    $schemaValue;\n  if ($isData) {\n    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';\n    $schemaValue = 'schema' + $lvl;\n  } else {\n    $schemaValue = $schema;\n  }\n  if (($schema || $isData) && it.opts.uniqueItems !== false) {\n    if ($isData) {\n      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \\'boolean\\') ' + ($valid) + ' = false; else { ';\n    }\n    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';\n    var $itemType = it.schema.items && it.schema.items.type,\n      $typeIsArray = Array.isArray($itemType);\n    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {\n      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';\n    } else {\n      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';\n      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');\n      out += ' if (' + (it.util[$method]($itemType, 'item', true)) + ') continue; ';\n      if ($typeIsArray) {\n        out += ' if (typeof item == \\'string\\') item = \\'\"\\' + item; ';\n      }\n      out += ' if (typeof itemIndices[item] == \\'number\\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';\n    }\n    out += ' } ';\n    if ($isData) {\n      out += '  }  ';\n    }\n    out += ' if (!' + ($valid) + ') {   ';\n    var $$outStack = $$outStack || [];\n    $$outStack.push(out);\n    out = ''; /* istanbul ignore else */\n    if (it.createErrors !== false) {\n      out += ' { keyword: \\'' + ('uniqueItems') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';\n      if (it.opts.messages !== false) {\n        out += ' , message: \\'should NOT have duplicate items (items ## \\' + j + \\' and \\' + i + \\' are identical)\\' ';\n      }\n      if (it.opts.verbose) {\n        out += ' , schema:  ';\n        if ($isData) {\n          out += 'validate.schema' + ($schemaPath);\n        } else {\n          out += '' + ($schema);\n        }\n        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n      }\n      out += ' } ';\n    } else {\n      out += ' {} ';\n    }\n    var __err = out;\n    out = $$outStack.pop();\n    if (!it.compositeRule && $breakOnError) {\n      /* istanbul ignore if */\n      if (it.async) {\n        out += ' throw new ValidationError([' + (__err) + ']); ';\n      } else {\n        out += ' validate.errors = [' + (__err) + ']; return false; ';\n      }\n    } else {\n      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n    }\n    out += ' } ';\n    if ($breakOnError) {\n      out += ' else { ';\n    }\n  } else {\n    if ($breakOnError) {\n      out += ' if (true) { ';\n    }\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/uniqueItems.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/validate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/validate.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = function generate_validate(it, $keyword, $ruleType) {\n  var out = '';\n  var $async = it.schema.$async === true,\n    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),\n    $id = it.self._getId(it.schema);\n  if (it.opts.strictKeywords) {\n    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);\n    if ($unknownKwd) {\n      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;\n      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);\n      else throw new Error($keywordsMsg);\n    }\n  }\n  if (it.isTop) {\n    out += ' var validate = ';\n    if ($async) {\n      it.async = true;\n      out += 'async ';\n    }\n    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \\'use strict\\'; ';\n    if ($id && (it.opts.sourceCode || it.opts.processCode)) {\n      out += ' ' + ('/\\*# sourceURL=' + $id + ' */') + ' ';\n    }\n  }\n  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {\n    var $keyword = 'false schema';\n    var $lvl = it.level;\n    var $dataLvl = it.dataLevel;\n    var $schema = it.schema[$keyword];\n    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);\n    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;\n    var $breakOnError = !it.opts.allErrors;\n    var $errorKeyword;\n    var $data = 'data' + ($dataLvl || '');\n    var $valid = 'valid' + $lvl;\n    if (it.schema === false) {\n      if (it.isTop) {\n        $breakOnError = true;\n      } else {\n        out += ' var ' + ($valid) + ' = false; ';\n      }\n      var $$outStack = $$outStack || [];\n      $$outStack.push(out);\n      out = ''; /* istanbul ignore else */\n      if (it.createErrors !== false) {\n        out += ' { keyword: \\'' + ($errorKeyword || 'false schema') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';\n        if (it.opts.messages !== false) {\n          out += ' , message: \\'boolean schema is false\\' ';\n        }\n        if (it.opts.verbose) {\n          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n        }\n        out += ' } ';\n      } else {\n        out += ' {} ';\n      }\n      var __err = out;\n      out = $$outStack.pop();\n      if (!it.compositeRule && $breakOnError) {\n        /* istanbul ignore if */\n        if (it.async) {\n          out += ' throw new ValidationError([' + (__err) + ']); ';\n        } else {\n          out += ' validate.errors = [' + (__err) + ']; return false; ';\n        }\n      } else {\n        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n      }\n    } else {\n      if (it.isTop) {\n        if ($async) {\n          out += ' return data; ';\n        } else {\n          out += ' validate.errors = null; return true; ';\n        }\n      } else {\n        out += ' var ' + ($valid) + ' = true; ';\n      }\n    }\n    if (it.isTop) {\n      out += ' }; return validate; ';\n    }\n    return out;\n  }\n  if (it.isTop) {\n    var $top = it.isTop,\n      $lvl = it.level = 0,\n      $dataLvl = it.dataLevel = 0,\n      $data = 'data';\n    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));\n    it.baseId = it.baseId || it.rootId;\n    delete it.isTop;\n    it.dataPathArr = [undefined];\n    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {\n      var $defaultMsg = 'default is ignored in the schema root';\n      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n      else throw new Error($defaultMsg);\n    }\n    out += ' var vErrors = null; ';\n    out += ' var errors = 0;     ';\n    out += ' if (rootData === undefined) rootData = data; ';\n  } else {\n    var $lvl = it.level,\n      $dataLvl = it.dataLevel,\n      $data = 'data' + ($dataLvl || '');\n    if ($id) it.baseId = it.resolve.url(it.baseId, $id);\n    if ($async && !it.async) throw new Error('async schema in sync schema');\n    out += ' var errs_' + ($lvl) + ' = errors;';\n  }\n  var $valid = 'valid' + $lvl,\n    $breakOnError = !it.opts.allErrors,\n    $closingBraces1 = '',\n    $closingBraces2 = '';\n  var $errorKeyword;\n  var $typeSchema = it.schema.type,\n    $typeIsArray = Array.isArray($typeSchema);\n  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {\n    if ($typeIsArray) {\n      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');\n    } else if ($typeSchema != 'null') {\n      $typeSchema = [$typeSchema, 'null'];\n      $typeIsArray = true;\n    }\n  }\n  if ($typeIsArray && $typeSchema.length == 1) {\n    $typeSchema = $typeSchema[0];\n    $typeIsArray = false;\n  }\n  if (it.schema.$ref && $refKeywords) {\n    if (it.opts.extendRefs == 'fail') {\n      throw new Error('$ref: validation keywords used in schema at path \"' + it.errSchemaPath + '\" (see option extendRefs)');\n    } else if (it.opts.extendRefs !== true) {\n      $refKeywords = false;\n      it.logger.warn('$ref: keywords ignored in schema at path \"' + it.errSchemaPath + '\"');\n    }\n  }\n  if (it.schema.$comment && it.opts.$comment) {\n    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));\n  }\n  if ($typeSchema) {\n    if (it.opts.coerceTypes) {\n      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);\n    }\n    var $rulesGroup = it.RULES.types[$typeSchema];\n    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type';\n      var $schemaPath = it.schemaPath + '.type',\n        $errSchemaPath = it.errSchemaPath + '/type',\n        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';\n      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') { ';\n      if ($coerceToTypes) {\n        var $dataType = 'dataType' + $lvl,\n          $coerced = 'coerced' + $lvl;\n        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';\n        if (it.opts.coerceTypes == 'array') {\n          out += ' if (' + ($dataType) + ' == \\'object\\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \\'array\\'; ';\n        }\n        out += ' var ' + ($coerced) + ' = undefined; ';\n        var $bracesCoercion = '';\n        var arr1 = $coerceToTypes;\n        if (arr1) {\n          var $type, $i = -1,\n            l1 = arr1.length - 1;\n          while ($i < l1) {\n            $type = arr1[$i += 1];\n            if ($i) {\n              out += ' if (' + ($coerced) + ' === undefined) { ';\n              $bracesCoercion += '}';\n            }\n            if (it.opts.coerceTypes == 'array' && $type != 'array') {\n              out += ' if (' + ($dataType) + ' == \\'array\\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';\n            }\n            if ($type == 'string') {\n              out += ' if (' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\') ' + ($coerced) + ' = \\'\\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \\'\\'; ';\n            } else if ($type == 'number' || $type == 'integer') {\n              out += ' if (' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \\'string\\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';\n              if ($type == 'integer') {\n                out += ' && !(' + ($data) + ' % 1)';\n              }\n              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';\n            } else if ($type == 'boolean') {\n              out += ' if (' + ($data) + ' === \\'false\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \\'true\\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';\n            } else if ($type == 'null') {\n              out += ' if (' + ($data) + ' === \\'\\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';\n            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {\n              out += ' if (' + ($dataType) + ' == \\'string\\' || ' + ($dataType) + ' == \\'number\\' || ' + ($dataType) + ' == \\'boolean\\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';\n            }\n          }\n        }\n        out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n        out += ' } else {  ';\n        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',\n          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';\n        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';\n        if (!$dataLvl) {\n          out += 'if (' + ($parentData) + ' !== undefined)';\n        }\n        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';\n      } else {\n        var $$outStack = $$outStack || [];\n        $$outStack.push(out);\n        out = ''; /* istanbul ignore else */\n        if (it.createErrors !== false) {\n          out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n          if ($typeIsArray) {\n            out += '' + ($typeSchema.join(\",\"));\n          } else {\n            out += '' + ($typeSchema);\n          }\n          out += '\\' } ';\n          if (it.opts.messages !== false) {\n            out += ' , message: \\'should be ';\n            if ($typeIsArray) {\n              out += '' + ($typeSchema.join(\",\"));\n            } else {\n              out += '' + ($typeSchema);\n            }\n            out += '\\' ';\n          }\n          if (it.opts.verbose) {\n            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n          }\n          out += ' } ';\n        } else {\n          out += ' {} ';\n        }\n        var __err = out;\n        out = $$outStack.pop();\n        if (!it.compositeRule && $breakOnError) {\n          /* istanbul ignore if */\n          if (it.async) {\n            out += ' throw new ValidationError([' + (__err) + ']); ';\n          } else {\n            out += ' validate.errors = [' + (__err) + ']; return false; ';\n          }\n        } else {\n          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n        }\n      }\n      out += ' } ';\n    }\n  }\n  if (it.schema.$ref && !$refKeywords) {\n    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';\n    if ($breakOnError) {\n      out += ' } if (errors === ';\n      if ($top) {\n        out += '0';\n      } else {\n        out += 'errs_' + ($lvl);\n      }\n      out += ') { ';\n      $closingBraces2 += '}';\n    }\n  } else {\n    var arr2 = it.RULES;\n    if (arr2) {\n      var $rulesGroup, i2 = -1,\n        l2 = arr2.length - 1;\n      while (i2 < l2) {\n        $rulesGroup = arr2[i2 += 1];\n        if ($shouldUseGroup($rulesGroup)) {\n          if ($rulesGroup.type) {\n            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';\n          }\n          if (it.opts.useDefaults) {\n            if ($rulesGroup.type == 'object' && it.schema.properties) {\n              var $schema = it.schema.properties,\n                $schemaKeys = Object.keys($schema);\n              var arr3 = $schemaKeys;\n              if (arr3) {\n                var $propertyKey, i3 = -1,\n                  l3 = arr3.length - 1;\n                while (i3 < l3) {\n                  $propertyKey = arr3[i3 += 1];\n                  var $sch = $schema[$propertyKey];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + it.util.getProperty($propertyKey);\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {\n              var arr4 = it.schema.items;\n              if (arr4) {\n                var $sch, $i = -1,\n                  l4 = arr4.length - 1;\n                while ($i < l4) {\n                  $sch = arr4[$i += 1];\n                  if ($sch.default !== undefined) {\n                    var $passData = $data + '[' + $i + ']';\n                    if (it.compositeRule) {\n                      if (it.opts.strictDefaults) {\n                        var $defaultMsg = 'default is ignored for: ' + $passData;\n                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);\n                        else throw new Error($defaultMsg);\n                      }\n                    } else {\n                      out += ' if (' + ($passData) + ' === undefined ';\n                      if (it.opts.useDefaults == 'empty') {\n                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \\'\\' ';\n                      }\n                      out += ' ) ' + ($passData) + ' = ';\n                      if (it.opts.useDefaults == 'shared') {\n                        out += ' ' + (it.useDefault($sch.default)) + ' ';\n                      } else {\n                        out += ' ' + (JSON.stringify($sch.default)) + ' ';\n                      }\n                      out += '; ';\n                    }\n                  }\n                }\n              }\n            }\n          }\n          var arr5 = $rulesGroup.rules;\n          if (arr5) {\n            var $rule, i5 = -1,\n              l5 = arr5.length - 1;\n            while (i5 < l5) {\n              $rule = arr5[i5 += 1];\n              if ($shouldUseRule($rule)) {\n                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);\n                if ($code) {\n                  out += ' ' + ($code) + ' ';\n                  if ($breakOnError) {\n                    $closingBraces1 += '}';\n                  }\n                }\n              }\n            }\n          }\n          if ($breakOnError) {\n            out += ' ' + ($closingBraces1) + ' ';\n            $closingBraces1 = '';\n          }\n          if ($rulesGroup.type) {\n            out += ' } ';\n            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {\n              out += ' else { ';\n              var $schemaPath = it.schemaPath + '.type',\n                $errSchemaPath = it.errSchemaPath + '/type';\n              var $$outStack = $$outStack || [];\n              $$outStack.push(out);\n              out = ''; /* istanbul ignore else */\n              if (it.createErrors !== false) {\n                out += ' { keyword: \\'' + ($errorKeyword || 'type') + '\\' , dataPath: (dataPath || \\'\\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \\'';\n                if ($typeIsArray) {\n                  out += '' + ($typeSchema.join(\",\"));\n                } else {\n                  out += '' + ($typeSchema);\n                }\n                out += '\\' } ';\n                if (it.opts.messages !== false) {\n                  out += ' , message: \\'should be ';\n                  if ($typeIsArray) {\n                    out += '' + ($typeSchema.join(\",\"));\n                  } else {\n                    out += '' + ($typeSchema);\n                  }\n                  out += '\\' ';\n                }\n                if (it.opts.verbose) {\n                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';\n                }\n                out += ' } ';\n              } else {\n                out += ' {} ';\n              }\n              var __err = out;\n              out = $$outStack.pop();\n              if (!it.compositeRule && $breakOnError) {\n                /* istanbul ignore if */\n                if (it.async) {\n                  out += ' throw new ValidationError([' + (__err) + ']); ';\n                } else {\n                  out += ' validate.errors = [' + (__err) + ']; return false; ';\n                }\n              } else {\n                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';\n              }\n              out += ' } ';\n            }\n          }\n          if ($breakOnError) {\n            out += ' if (errors === ';\n            if ($top) {\n              out += '0';\n            } else {\n              out += 'errs_' + ($lvl);\n            }\n            out += ') { ';\n            $closingBraces2 += '}';\n          }\n        }\n      }\n    }\n  }\n  if ($breakOnError) {\n    out += ' ' + ($closingBraces2) + ' ';\n  }\n  if ($top) {\n    if ($async) {\n      out += ' if (errors === 0) return data;           ';\n      out += ' else throw new ValidationError(vErrors); ';\n    } else {\n      out += ' validate.errors = vErrors; ';\n      out += ' return errors === 0;       ';\n    }\n    out += ' }; return validate;';\n  } else {\n    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';\n  }\n  out = it.util.cleanUpCode(out);\n  if ($top) {\n    out = it.util.finalCleanUpCode(out, $async);\n  }\n\n  function $shouldUseGroup($rulesGroup) {\n    var rules = $rulesGroup.rules;\n    for (var i = 0; i < rules.length; i++)\n      if ($shouldUseRule(rules[i])) return true;\n  }\n\n  function $shouldUseRule($rule) {\n    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));\n  }\n\n  function $ruleImplementsSomeKeyword($rule) {\n    var impl = $rule.implements;\n    for (var i = 0; i < impl.length; i++)\n      if (it.schema[impl[i]] !== undefined) return true;\n  }\n  return out;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/validate.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/keyword.js":
/*!*************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/keyword.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;\nvar customRuleCode = __webpack_require__(/*! ./dotjs/custom */ \"./node_modules/protodef-validator/node_modules/ajv/lib/dotjs/custom.js\");\nvar definitionSchema = __webpack_require__(/*! ./definition_schema */ \"./node_modules/protodef-validator/node_modules/ajv/lib/definition_schema.js\");\n\nmodule.exports = {\n  add: addKeyword,\n  get: getKeyword,\n  remove: removeKeyword,\n  validate: validateKeyword\n};\n\n\n/**\n * Define custom keyword\n * @this  Ajv\n * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).\n * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.\n * @return {Ajv} this for method chaining\n */\nfunction addKeyword(keyword, definition) {\n  /* jshint validthis: true */\n  /* eslint no-shadow: 0 */\n  var RULES = this.RULES;\n  if (RULES.keywords[keyword])\n    throw new Error('Keyword ' + keyword + ' is already defined');\n\n  if (!IDENTIFIER.test(keyword))\n    throw new Error('Keyword ' + keyword + ' is not a valid identifier');\n\n  if (definition) {\n    this.validateKeyword(definition, true);\n\n    var dataType = definition.type;\n    if (Array.isArray(dataType)) {\n      for (var i=0; i<dataType.length; i++)\n        _addRule(keyword, dataType[i], definition);\n    } else {\n      _addRule(keyword, dataType, definition);\n    }\n\n    var metaSchema = definition.metaSchema;\n    if (metaSchema) {\n      if (definition.$data && this._opts.$data) {\n        metaSchema = {\n          anyOf: [\n            metaSchema,\n            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#' }\n          ]\n        };\n      }\n      definition.validateSchema = this.compile(metaSchema, true);\n    }\n  }\n\n  RULES.keywords[keyword] = RULES.all[keyword] = true;\n\n\n  function _addRule(keyword, dataType, definition) {\n    var ruleGroup;\n    for (var i=0; i<RULES.length; i++) {\n      var rg = RULES[i];\n      if (rg.type == dataType) {\n        ruleGroup = rg;\n        break;\n      }\n    }\n\n    if (!ruleGroup) {\n      ruleGroup = { type: dataType, rules: [] };\n      RULES.push(ruleGroup);\n    }\n\n    var rule = {\n      keyword: keyword,\n      definition: definition,\n      custom: true,\n      code: customRuleCode,\n      implements: definition.implements\n    };\n    ruleGroup.rules.push(rule);\n    RULES.custom[keyword] = rule;\n  }\n\n  return this;\n}\n\n\n/**\n * Get keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.\n */\nfunction getKeyword(keyword) {\n  /* jshint validthis: true */\n  var rule = this.RULES.custom[keyword];\n  return rule ? rule.definition : this.RULES.keywords[keyword] || false;\n}\n\n\n/**\n * Remove keyword\n * @this  Ajv\n * @param {String} keyword pre-defined or custom keyword.\n * @return {Ajv} this for method chaining\n */\nfunction removeKeyword(keyword) {\n  /* jshint validthis: true */\n  var RULES = this.RULES;\n  delete RULES.keywords[keyword];\n  delete RULES.all[keyword];\n  delete RULES.custom[keyword];\n  for (var i=0; i<RULES.length; i++) {\n    var rules = RULES[i].rules;\n    for (var j=0; j<rules.length; j++) {\n      if (rules[j].keyword == keyword) {\n        rules.splice(j, 1);\n        break;\n      }\n    }\n  }\n  return this;\n}\n\n\n/**\n * Validate keyword definition\n * @this  Ajv\n * @param {Object} definition keyword definition object.\n * @param {Boolean} throwError true to throw exception if definition is invalid\n * @return {boolean} validation result\n */\nfunction validateKeyword(definition, throwError) {\n  validateKeyword.errors = null;\n  var v = this._validateKeyword = this._validateKeyword\n                                  || this.compile(definitionSchema, true);\n\n  if (v(definition)) return true;\n  validateKeyword.errors = v.errors;\n  if (throwError)\n    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));\n  else\n    return false;\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/keyword.js?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/refs/data.json":
/*!*****************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/refs/data.json ***!
  \*****************************************************************************/
/*! exports provided: $schema, $id, description, type, required, properties, additionalProperties, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"$schema\\\":\\\"http://json-schema.org/draft-07/schema#\\\",\\\"$id\\\":\\\"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/data.json#\\\",\\\"description\\\":\\\"Meta-schema for $data reference (JSON Schema extension proposal)\\\",\\\"type\\\":\\\"object\\\",\\\"required\\\":[\\\"$data\\\"],\\\"properties\\\":{\\\"$data\\\":{\\\"type\\\":\\\"string\\\",\\\"anyOf\\\":[{\\\"format\\\":\\\"relative-json-pointer\\\"},{\\\"format\\\":\\\"json-pointer\\\"}]}},\\\"additionalProperties\\\":false}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/refs/data.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/ajv/lib/refs/json-schema-draft-07.json":
/*!*********************************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/ajv/lib/refs/json-schema-draft-07.json ***!
  \*********************************************************************************************/
/*! exports provided: $schema, $id, title, definitions, type, properties, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"$schema\\\":\\\"http://json-schema.org/draft-07/schema#\\\",\\\"$id\\\":\\\"http://json-schema.org/draft-07/schema#\\\",\\\"title\\\":\\\"Core schema meta-schema\\\",\\\"definitions\\\":{\\\"schemaArray\\\":{\\\"type\\\":\\\"array\\\",\\\"minItems\\\":1,\\\"items\\\":{\\\"$ref\\\":\\\"#\\\"}},\\\"nonNegativeInteger\\\":{\\\"type\\\":\\\"integer\\\",\\\"minimum\\\":0},\\\"nonNegativeIntegerDefault0\\\":{\\\"allOf\\\":[{\\\"$ref\\\":\\\"#/definitions/nonNegativeInteger\\\"},{\\\"default\\\":0}]},\\\"simpleTypes\\\":{\\\"enum\\\":[\\\"array\\\",\\\"boolean\\\",\\\"integer\\\",\\\"null\\\",\\\"number\\\",\\\"object\\\",\\\"string\\\"]},\\\"stringArray\\\":{\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\\"type\\\":\\\"string\\\"},\\\"uniqueItems\\\":true,\\\"default\\\":[]}},\\\"type\\\":[\\\"object\\\",\\\"boolean\\\"],\\\"properties\\\":{\\\"$id\\\":{\\\"type\\\":\\\"string\\\",\\\"format\\\":\\\"uri-reference\\\"},\\\"$schema\\\":{\\\"type\\\":\\\"string\\\",\\\"format\\\":\\\"uri\\\"},\\\"$ref\\\":{\\\"type\\\":\\\"string\\\",\\\"format\\\":\\\"uri-reference\\\"},\\\"$comment\\\":{\\\"type\\\":\\\"string\\\"},\\\"title\\\":{\\\"type\\\":\\\"string\\\"},\\\"description\\\":{\\\"type\\\":\\\"string\\\"},\\\"default\\\":true,\\\"readOnly\\\":{\\\"type\\\":\\\"boolean\\\",\\\"default\\\":false},\\\"examples\\\":{\\\"type\\\":\\\"array\\\",\\\"items\\\":true},\\\"multipleOf\\\":{\\\"type\\\":\\\"number\\\",\\\"exclusiveMinimum\\\":0},\\\"maximum\\\":{\\\"type\\\":\\\"number\\\"},\\\"exclusiveMaximum\\\":{\\\"type\\\":\\\"number\\\"},\\\"minimum\\\":{\\\"type\\\":\\\"number\\\"},\\\"exclusiveMinimum\\\":{\\\"type\\\":\\\"number\\\"},\\\"maxLength\\\":{\\\"$ref\\\":\\\"#/definitions/nonNegativeInteger\\\"},\\\"minLength\\\":{\\\"$ref\\\":\\\"#/definitions/nonNegativeIntegerDefault0\\\"},\\\"pattern\\\":{\\\"type\\\":\\\"string\\\",\\\"format\\\":\\\"regex\\\"},\\\"additionalItems\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"items\\\":{\\\"anyOf\\\":[{\\\"$ref\\\":\\\"#\\\"},{\\\"$ref\\\":\\\"#/definitions/schemaArray\\\"}],\\\"default\\\":true},\\\"maxItems\\\":{\\\"$ref\\\":\\\"#/definitions/nonNegativeInteger\\\"},\\\"minItems\\\":{\\\"$ref\\\":\\\"#/definitions/nonNegativeIntegerDefault0\\\"},\\\"uniqueItems\\\":{\\\"type\\\":\\\"boolean\\\",\\\"default\\\":false},\\\"contains\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"maxProperties\\\":{\\\"$ref\\\":\\\"#/definitions/nonNegativeInteger\\\"},\\\"minProperties\\\":{\\\"$ref\\\":\\\"#/definitions/nonNegativeIntegerDefault0\\\"},\\\"required\\\":{\\\"$ref\\\":\\\"#/definitions/stringArray\\\"},\\\"additionalProperties\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"definitions\\\":{\\\"type\\\":\\\"object\\\",\\\"additionalProperties\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"default\\\":{}},\\\"properties\\\":{\\\"type\\\":\\\"object\\\",\\\"additionalProperties\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"default\\\":{}},\\\"patternProperties\\\":{\\\"type\\\":\\\"object\\\",\\\"additionalProperties\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"propertyNames\\\":{\\\"format\\\":\\\"regex\\\"},\\\"default\\\":{}},\\\"dependencies\\\":{\\\"type\\\":\\\"object\\\",\\\"additionalProperties\\\":{\\\"anyOf\\\":[{\\\"$ref\\\":\\\"#\\\"},{\\\"$ref\\\":\\\"#/definitions/stringArray\\\"}]}},\\\"propertyNames\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"const\\\":true,\\\"enum\\\":{\\\"type\\\":\\\"array\\\",\\\"items\\\":true,\\\"minItems\\\":1,\\\"uniqueItems\\\":true},\\\"type\\\":{\\\"anyOf\\\":[{\\\"$ref\\\":\\\"#/definitions/simpleTypes\\\"},{\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\\"$ref\\\":\\\"#/definitions/simpleTypes\\\"},\\\"minItems\\\":1,\\\"uniqueItems\\\":true}]},\\\"format\\\":{\\\"type\\\":\\\"string\\\"},\\\"contentMediaType\\\":{\\\"type\\\":\\\"string\\\"},\\\"contentEncoding\\\":{\\\"type\\\":\\\"string\\\"},\\\"if\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"then\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"else\\\":{\\\"$ref\\\":\\\"#\\\"},\\\"allOf\\\":{\\\"$ref\\\":\\\"#/definitions/schemaArray\\\"},\\\"anyOf\\\":{\\\"$ref\\\":\\\"#/definitions/schemaArray\\\"},\\\"oneOf\\\":{\\\"$ref\\\":\\\"#/definitions/schemaArray\\\"},\\\"not\\\":{\\\"$ref\\\":\\\"#\\\"}},\\\"default\\\":true}\");\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/ajv/lib/refs/json-schema-draft-07.json?");

/***/ }),

/***/ "./node_modules/protodef-validator/node_modules/fast-deep-equal/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/protodef-validator/node_modules/fast-deep-equal/index.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef-validator/node_modules/fast-deep-equal/index.js?");

/***/ }),

/***/ "./node_modules/protodef/ProtoDef/schemas/conditional.json":
/*!*****************************************************************!*\
  !*** ./node_modules/protodef/ProtoDef/schemas/conditional.json ***!
  \*****************************************************************/
/*! exports provided: switch, option, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"switch\\\":{\\\"title\\\":\\\"switch\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"switch\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"compareTo\\\":{\\\"$ref\\\":\\\"definitions#/definitions/contextualizedFieldName\\\"},\\\"compareToValue\\\":{\\\"type\\\":\\\"string\\\"},\\\"fields\\\":{\\\"type\\\":\\\"object\\\",\\\"patternProperties\\\":{\\\"^[-a-zA-Z0-9 _:]+$\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false},\\\"default\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"oneOf\\\":[{\\\"required\\\":[\\\"compareTo\\\",\\\"fields\\\"]},{\\\"required\\\":[\\\"compareToValue\\\",\\\"fields\\\"]}],\\\"additionalProperties\\\":false}],\\\"additionalItems\\\":false},\\\"option\\\":{\\\"title\\\":\\\"option\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"option\\\"]},{\\\"$ref\\\":\\\"dataType\\\"}],\\\"additionalItems\\\":false}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef/ProtoDef/schemas/conditional.json?");

/***/ }),

/***/ "./node_modules/protodef/ProtoDef/schemas/numeric.json":
/*!*************************************************************!*\
  !*** ./node_modules/protodef/ProtoDef/schemas/numeric.json ***!
  \*************************************************************/
/*! exports provided: i8, u8, i16, u16, i32, u32, f32, f64, li8, lu8, li16, lu16, li32, lu32, lf32, lf64, i64, li64, u64, lu64, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"i8\\\":{\\\"enum\\\":[\\\"i8\\\"]},\\\"u8\\\":{\\\"enum\\\":[\\\"u8\\\"]},\\\"i16\\\":{\\\"enum\\\":[\\\"i16\\\"]},\\\"u16\\\":{\\\"enum\\\":[\\\"u16\\\"]},\\\"i32\\\":{\\\"enum\\\":[\\\"i32\\\"]},\\\"u32\\\":{\\\"enum\\\":[\\\"u32\\\"]},\\\"f32\\\":{\\\"enum\\\":[\\\"f32\\\"]},\\\"f64\\\":{\\\"enum\\\":[\\\"f64\\\"]},\\\"li8\\\":{\\\"enum\\\":[\\\"li8\\\"]},\\\"lu8\\\":{\\\"enum\\\":[\\\"lu8\\\"]},\\\"li16\\\":{\\\"enum\\\":[\\\"li16\\\"]},\\\"lu16\\\":{\\\"enum\\\":[\\\"lu16\\\"]},\\\"li32\\\":{\\\"enum\\\":[\\\"li32\\\"]},\\\"lu32\\\":{\\\"enum\\\":[\\\"lu32\\\"]},\\\"lf32\\\":{\\\"enum\\\":[\\\"lf32\\\"]},\\\"lf64\\\":{\\\"enum\\\":[\\\"lf64\\\"]},\\\"i64\\\":{\\\"enum\\\":[\\\"i64\\\"]},\\\"li64\\\":{\\\"enum\\\":[\\\"li64\\\"]},\\\"u64\\\":{\\\"enum\\\":[\\\"u64\\\"]},\\\"lu64\\\":{\\\"enum\\\":[\\\"lu64\\\"]}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef/ProtoDef/schemas/numeric.json?");

/***/ }),

/***/ "./node_modules/protodef/ProtoDef/schemas/structures.json":
/*!****************************************************************!*\
  !*** ./node_modules/protodef/ProtoDef/schemas/structures.json ***!
  \****************************************************************/
/*! exports provided: array, count, container, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"array\\\":{\\\"title\\\":\\\"array\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"array\\\"]},{\\\"oneOf\\\":[{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"},\\\"countType\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"type\\\",\\\"countType\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"},\\\"count\\\":{\\\"$ref\\\":\\\"definitions#/definitions/dataTypeArgsCount\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"type\\\",\\\"count\\\"]}]}],\\\"additionalItems\\\":false},\\\"count\\\":{\\\"title\\\":\\\"count\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"count\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"countFor\\\":{\\\"$ref\\\":\\\"definitions#/definitions/contextualizedFieldName\\\"},\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"required\\\":[\\\"countFor\\\",\\\"type\\\"],\\\"additionalProperties\\\":false}],\\\"additionalItems\\\":false},\\\"container\\\":{\\\"title\\\":\\\"container\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"container\\\"]},{\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"anon\\\":{\\\"type\\\":\\\"boolean\\\"},\\\"name\\\":{\\\"$ref\\\":\\\"definitions#/definitions/fieldName\\\"},\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"oneOf\\\":[{\\\"required\\\":[\\\"anon\\\"]},{\\\"required\\\":[\\\"name\\\"]}],\\\"required\\\":[\\\"type\\\"],\\\"additionalProperties\\\":false},\\\"additionalItems\\\":false}],\\\"additionalItems\\\":false}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef/ProtoDef/schemas/structures.json?");

/***/ }),

/***/ "./node_modules/protodef/ProtoDef/schemas/utils.json":
/*!***********************************************************!*\
  !*** ./node_modules/protodef/ProtoDef/schemas/utils.json ***!
  \***********************************************************/
/*! exports provided: varint, bool, pstring, buffer, void, bitfield, cstring, mapper, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"varint\\\":{\\\"enum\\\":[\\\"varint\\\"]},\\\"bool\\\":{\\\"enum\\\":[\\\"bool\\\"]},\\\"pstring\\\":{\\\"title\\\":\\\"pstring\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"pstring\\\"]},{\\\"oneOf\\\":[{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"countType\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"countType\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"count\\\":{\\\"$ref\\\":\\\"definitions#/definitions/dataTypeArgsCount\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"count\\\"]}]}],\\\"additionalItems\\\":false},\\\"buffer\\\":{\\\"title\\\":\\\"buffer\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"buffer\\\"]},{\\\"oneOf\\\":[{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"countType\\\":{\\\"$ref\\\":\\\"dataType\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"countType\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"count\\\":{\\\"$ref\\\":\\\"definitions#/definitions/dataTypeArgsCount\\\"}},\\\"additionalProperties\\\":false,\\\"required\\\":[\\\"count\\\"]}]}]},\\\"void\\\":{\\\"enum\\\":[\\\"void\\\"]},\\\"bitfield\\\":{\\\"title\\\":\\\"bitfield\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"bitfield\\\"]},{\\\"type\\\":\\\"array\\\",\\\"items\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"name\\\":{\\\"$ref\\\":\\\"definitions#/definitions/fieldName\\\"},\\\"size\\\":{\\\"type\\\":\\\"number\\\"},\\\"signed\\\":{\\\"type\\\":\\\"boolean\\\"}},\\\"required\\\":[\\\"name\\\",\\\"size\\\",\\\"signed\\\"],\\\"additionalProperties\\\":false},\\\"additionalItems\\\":false}],\\\"additionalItems\\\":false},\\\"cstring\\\":{\\\"enum\\\":[\\\"cstring\\\"]},\\\"mapper\\\":{\\\"title\\\":\\\"mapper\\\",\\\"type\\\":\\\"array\\\",\\\"items\\\":[{\\\"enum\\\":[\\\"mapper\\\"]},{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"type\\\":{\\\"$ref\\\":\\\"dataType\\\"},\\\"mappings\\\":{\\\"type\\\":\\\"object\\\",\\\"patternProperties\\\":{\\\"^[-a-zA-Z0-9 _]+$\\\":{\\\"type\\\":\\\"string\\\"}},\\\"additionalProperties\\\":false}},\\\"required\\\":[\\\"type\\\",\\\"mappings\\\"],\\\"additionalProperties\\\":false}],\\\"additionalItems\\\":false}}\");\n\n//# sourceURL=webpack:///./node_modules/protodef/ProtoDef/schemas/utils.json?");

/***/ }),

/***/ "./node_modules/protodef/index.js":
/*!****************************************!*\
  !*** ./node_modules/protodef/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.js */ \"./node_modules/protodef/src/index.js\")\n\n\n//# sourceURL=webpack:///./node_modules/protodef/index.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/errors-browser.js":
/*!******************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/errors-browser.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error;\n  }\n\n  function getMessage(arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message;\n    } else {\n      return message(arg1, arg2, arg3);\n    }\n  }\n\n  var NodeError =\n  /*#__PURE__*/\n  function (_Base) {\n    _inheritsLoose(NodeError, _Base);\n\n    function NodeError(arg1, arg2, arg3) {\n      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n    }\n\n    return NodeError;\n  }(Base);\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n  codes[code] = NodeError;\n} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    expected = expected.map(function (i) {\n      return String(i);\n    });\n\n    if (len > 2) {\n      return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n    } else if (len === 2) {\n      return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n    } else {\n      return \"of \".concat(thing, \" \").concat(expected[0]);\n    }\n  } else {\n    return \"of \".concat(thing, \" \").concat(String(expected));\n  }\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\nfunction startsWith(str, search, pos) {\n  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\nfunction endsWith(str, search, this_len) {\n  if (this_len === undefined || this_len > str.length) {\n    this_len = str.length;\n  }\n\n  return str.substring(this_len - search.length, this_len) === search;\n} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  var determiner;\n\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  var msg;\n\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  } else {\n    var type = includes(name, '.') ? 'property' : 'argument';\n    msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n  }\n\n  msg += \". Received type \".concat(typeof actual);\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented';\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\nmodule.exports.codes = codes;\n\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/errors-browser.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n/*<replacement>*/\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n\n  for (var key in obj) {\n    keys.push(key);\n  }\n\n  return keys;\n};\n/*</replacement>*/\n\n\nmodule.exports = Duplex;\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_readable.js\");\n\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_writable.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Duplex, Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n}); // the no-half-open enforcer\n\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return; // no more data can be written.\n  // But allow more writes to happen in this tick.\n\n  process.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_transform.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/_stream_readable.js":
/*!************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/_stream_readable.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nmodule.exports = Readable;\n/*<replacement>*/\n\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n/*<replacement>*/\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*<replacement>*/\n\n\nvar debugUtil = __webpack_require__(/*! util */ 2);\n\nvar debug;\n\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/protodef/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Readable, Stream);\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n\n  this.sync = true; // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n  this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\n\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n}; // Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\n\n\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n}; // Unshift should *always* be something directly out of read()\n\n\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  } // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n\n\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n\n  return er;\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n}; // backwards compatibility.\n\n\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n  var p = this._readableState.buffer.head;\n  var content = '';\n\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n\n  this._readableState.buffer.clear();\n\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n}; // Don't raise the hwm > 1GB\n\n\nvar MAX_HWM = 0x40000000;\n\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n\n  return n;\n} // This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\n\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n; // Don't have enough\n\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n\n  return state.length;\n} // you can override either this method, or the async _read(n) below.\n\n\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  } // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n  // if we need a readable event, then we need to do some reading.\n\n\n  var doRead = state.needReadable;\n  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  } // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n\n\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n    if (state.length === 0) state.needReadable = true; // call internal read method\n\n    this._read(state.highWaterMark);\n\n    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n\n  state.ended = true;\n\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n} // Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\n\n\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  } // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n\n\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n} // at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\n\n\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length) // didn't get any data, stop spinning.\n      break;\n  }\n\n  state.readingMore = false;\n} // abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\n\n\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  } // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n\n\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n\n  function cleanup() {\n    debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true; // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  src.on('data', ondata);\n\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n\n      src.pause();\n    }\n  } // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n\n\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  } // Make sure our error handler is attached before userland ones.\n\n\n  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n\n  dest.once('close', onclose);\n\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  } // tell the dest that it's being piped to\n\n\n  dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  }; // if we're not piping anywhere, then do nothing.\n\n  if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes; // got a match.\n\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  } // slow case. multiple pipe destinations.\n\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, {\n        hasUnpiped: false\n      });\n    }\n\n    return this;\n  } // try to find the right one.\n\n\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n}; // set up data events if they are asked for\n// Ensure readable listeners eventually get something\n\n\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n\n  return res;\n};\n\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true; // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n} // pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\n\n\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n\n  if (!state.flowing) {\n    debug('resume'); // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n\n  state.paused = false;\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n\n  this._readableState.paused = true;\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n\n  while (state.flowing && stream.read() !== null) {\n    ;\n  }\n} // wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\n\n\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  }); // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  } // proxy certain important events.\n\n\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  } // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n\n\n  this._read = function (n) {\n    debug('wrapped _read', n);\n\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n\n    return createReadableStreamAsyncIterator(this);\n  };\n}\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n}); // exposed for testing purposes only.\n\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n}); // Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\n\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/from-browser.js\");\n    }\n\n    return from(Readable, iterable, opts);\n  };\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/_stream_transform.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/_stream_transform.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\nmodule.exports = Transform;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/protodef/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  }; // start out asking for a readable event once data is transformed.\n\n  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  } // When the writable side finishes, then flush out anything remaining.\n\n\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n}; // This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\n\n\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n}; // Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\n\n\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/_stream_writable.js":
/*!************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/_stream_writable.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\nmodule.exports = Writable;\n/* <replacement> */\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\n\n\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\n\nvar OurUint8Array = global.Uint8Array || function () {};\n\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\n\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/state.js\"),\n    getHighWaterMark = _require.getHighWaterMark;\n\nvar _require$codes = __webpack_require__(/*! ../errors */ \"./node_modules/protodef/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n\n__webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\")(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {}; // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n  this.finalCalled = false; // drain event flag.\n\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // has it been destroyed\n\n  this.destroyed = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n  this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})(); // Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\n\n\nvar realHasInstance;\n\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js\"); // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n} // Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n\n  return true;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n}); // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er); // this can emit finish, and it will always happen\n    // after error\n\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er); // this can emit finish, but finish must\n    // always follow error\n\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\n\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    prefinish(stream, state);\n\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  } // reuse the free corkReq.\n\n\n  state.corkedRequestsFree.next = corkReq;\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    } // backward compatibility, the user is explicitly\n    // managing destroyed\n\n\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\n\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nvar _Object$setPrototypeO;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\n\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\n\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n\n  if (resolve !== null) {\n    var data = iter[kStream].read(); // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\n\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\n\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\n\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n\n  next: function next() {\n    var _this = this;\n\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    } // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n\n\n    var lastPromise = this[kLastPromise];\n    var promise;\n\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n\n      promise = new Promise(this[kHandlePromise]);\n    }\n\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\n\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n\n      iterator[kError] = err;\n      return;\n    }\n\n    var resolve = iterator[kLastResolve];\n\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\n\nmodule.exports = createReadableStreamAsyncIterator;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/async_iterator.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar _require = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\"),\n    Buffer = _require.Buffer;\n\nvar _require2 = __webpack_require__(/*! util */ 3),\n    inspect = _require2.inspect;\n\nvar custom = inspect && inspect.custom || 'inspect';\n\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n\n      while (p = p.next) {\n        ret += s + p.data;\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n\n      return ret;\n    } // Consumes a specified amount of bytes or characters from the buffered data.\n\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    } // Consumes a specified amount of characters from the buffered data.\n\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Consumes a specified amount of bytes from the buffered data.\n\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n\n          break;\n        }\n\n        ++c;\n      }\n\n      this.length -= c;\n      return ret;\n    } // Make sure the linked list only shows the minimal necessary information.\n\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread({}, options, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n\n  return BufferList;\n}();\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/buffer_list.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) { // undocumented cb() API, needed for core, not for public API\n\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  } // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n\n  return this;\n}\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar ERR_STREAM_PREMATURE_CLOSE = __webpack_require__(/*! ../../../errors */ \"./node_modules/protodef/node_modules/readable-stream/errors-browser.js\").codes.ERR_STREAM_PREMATURE_CLOSE;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    callback.apply(this, args);\n  };\n}\n\nfunction noop() {}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n\n  var writableEnded = stream._writableState && stream._writableState.finished;\n\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n\n  var onclose = function onclose() {\n    var err;\n\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\n\nmodule.exports = eos;\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/end-of-stream.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function () {\n  throw new Error('Readable.from is not available in the browser')\n};\n\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/from-browser.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\nvar eos;\n\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\n\nvar _require$codes = __webpack_require__(/*! ../../../errors */ \"./node_modules/protodef/node_modules/readable-stream/errors-browser.js\").codes,\n    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\n\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true; // request.destroy just do .end - .abort is what we want\n\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\n\nfunction call(fn) {\n  fn();\n}\n\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\n\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\n\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\n\nmodule.exports = pipeline;\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/pipeline.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/state.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ERR_INVALID_OPT_VALUE = __webpack_require__(/*! ../../../errors */ \"./node_modules/protodef/node_modules/readable-stream/errors-browser.js\").codes.ERR_INVALID_OPT_VALUE;\n\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\n\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n\n    return Math.floor(hwm);\n  } // Default value\n\n\n  return state.objectMode ? 16 : 16 * 1024;\n}\n\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/state.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/protodef/node_modules/readable-stream/readable-browser.js":
/*!********************************************************************************!*\
  !*** ./node_modules/protodef/node_modules/readable-stream/readable-browser.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/protodef/node_modules/readable-stream/lib/_stream_passthrough.js\");\nexports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nexports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"./node_modules/protodef/node_modules/readable-stream/lib/internal/streams/pipeline.js\");\n\n\n//# sourceURL=webpack:///./node_modules/protodef/node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/protodef/src/datatypes/conditional.js":
/*!************************************************************!*\
  !*** ./node_modules/protodef/src/datatypes/conditional.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { getField, getFieldInfo, tryDoc, PartialReadError } = __webpack_require__(/*! ../utils */ \"./node_modules/protodef/src/utils.js\")\n\nmodule.exports = {\n  'switch': [readSwitch, writeSwitch, sizeOfSwitch, __webpack_require__(/*! ../../ProtoDef/schemas/conditional.json */ \"./node_modules/protodef/ProtoDef/schemas/conditional.json\")['switch']],\n  'option': [readOption, writeOption, sizeOfOption, __webpack_require__(/*! ../../ProtoDef/schemas/conditional.json */ \"./node_modules/protodef/ProtoDef/schemas/conditional.json\")['option']]\n}\n\nfunction readSwitch (buffer, offset, { compareTo, fields, compareToValue, 'default': defVal }, rootNode) {\n  compareTo = compareToValue !== undefined ? compareToValue : getField(compareTo, rootNode)\n  if (typeof fields[compareTo] === 'undefined' && typeof defVal === 'undefined') { throw new Error(compareTo + ' has no associated fieldInfo in switch') }\n\n  const caseDefault = typeof fields[compareTo] === 'undefined'\n  const resultingType = caseDefault ? defVal : fields[compareTo]\n  const fieldInfo = getFieldInfo(resultingType)\n  return tryDoc(() => this.read(buffer, offset, fieldInfo, rootNode), caseDefault ? 'default' : compareTo)\n}\n\nfunction writeSwitch (value, buffer, offset, { compareTo, fields, compareToValue, 'default': defVal }, rootNode) {\n  compareTo = compareToValue !== undefined ? compareToValue : getField(compareTo, rootNode)\n  if (typeof fields[compareTo] === 'undefined' && typeof defVal === 'undefined') { throw new Error(compareTo + ' has no associated fieldInfo in switch') }\n\n  const caseDefault = typeof fields[compareTo] === 'undefined'\n  const fieldInfo = getFieldInfo(caseDefault ? defVal : fields[compareTo])\n  return tryDoc(() => this.write(value, buffer, offset, fieldInfo, rootNode), caseDefault ? 'default' : compareTo)\n}\n\nfunction sizeOfSwitch (value, { compareTo, fields, compareToValue, 'default': defVal }, rootNode) {\n  compareTo = compareToValue !== undefined ? compareToValue : getField(compareTo, rootNode)\n  if (typeof fields[compareTo] === 'undefined' && typeof defVal === 'undefined') { throw new Error(compareTo + ' has no associated fieldInfo in switch') }\n\n  const caseDefault = typeof fields[compareTo] === 'undefined'\n  const fieldInfo = getFieldInfo(caseDefault ? defVal : fields[compareTo])\n  return tryDoc(() => this.sizeOf(value, fieldInfo, rootNode), caseDefault ? 'default' : compareTo)\n}\n\nfunction readOption (buffer, offset, typeArgs, context) {\n  if (buffer.length < offset + 1) { throw new PartialReadError() }\n  const val = buffer.readUInt8(offset++)\n  if (val !== 0) {\n    const retval = this.read(buffer, offset, typeArgs, context)\n    retval.size++\n    return retval\n  } else { return { size: 1 } }\n}\n\nfunction writeOption (value, buffer, offset, typeArgs, context) {\n  if (value != null) {\n    buffer.writeUInt8(1, offset++)\n    offset = this.write(value, buffer, offset, typeArgs, context)\n  } else { buffer.writeUInt8(0, offset++) }\n  return offset\n}\n\nfunction sizeOfOption (value, typeArgs, context) {\n  return value == null ? 1 : this.sizeOf(value, typeArgs, context) + 1\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef/src/datatypes/conditional.js?");

/***/ }),

/***/ "./node_modules/protodef/src/datatypes/numeric.js":
/*!********************************************************!*\
  !*** ./node_modules/protodef/src/datatypes/numeric.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { PartialReadError } = __webpack_require__(/*! ../utils */ \"./node_modules/protodef/src/utils.js\")\n\nfunction readI64 (buffer, offset) {\n  if (offset + 8 > buffer.length) { throw new PartialReadError() }\n  return {\n    value: [buffer.readInt32BE(offset), buffer.readInt32BE(offset + 4)],\n    size: 8\n  }\n}\n\nfunction writeI64 (value, buffer, offset) {\n  buffer.writeInt32BE(value[0], offset)\n  buffer.writeInt32BE(value[1], offset + 4)\n  return offset + 8\n}\n\nfunction readLI64 (buffer, offset) {\n  if (offset + 8 > buffer.length) { throw new PartialReadError() }\n  return {\n    value: [buffer.readInt32LE(offset + 4), buffer.readInt32LE(offset)],\n    size: 8\n  }\n}\n\nfunction writeLI64 (value, buffer, offset) {\n  buffer.writeInt32LE(value[0], offset + 4)\n  buffer.writeInt32LE(value[1], offset)\n  return offset + 8\n}\n\nfunction readU64 (buffer, offset) {\n  if (offset + 8 > buffer.length) { throw new PartialReadError() }\n  return {\n    value: [buffer.readUInt32BE(offset), buffer.readUInt32BE(offset + 4)],\n    size: 8\n  }\n}\n\nfunction writeU64 (value, buffer, offset) {\n  buffer.writeUInt32BE(value[0], offset)\n  buffer.writeUInt32BE(value[1], offset + 4)\n  return offset + 8\n}\n\nfunction readLU64 (buffer, offset) {\n  if (offset + 8 > buffer.length) { throw new PartialReadError() }\n  return {\n    value: [buffer.readUInt32LE(offset + 4), buffer.readUInt32LE(offset)],\n    size: 8\n  }\n}\n\nfunction writeLU64 (value, buffer, offset) {\n  buffer.writeUInt32LE(value[0], offset + 4)\n  buffer.writeUInt32LE(value[1], offset)\n  return offset + 8\n}\n\nfunction generateFunctions (bufferReader, bufferWriter, size, schema) {\n  const reader = (buffer, offset) => {\n    if (offset + size > buffer.length) { throw new PartialReadError() }\n    const value = buffer[bufferReader](offset)\n    return {\n      value: value,\n      size: size\n    }\n  }\n  const writer = (value, buffer, offset) => {\n    buffer[bufferWriter](value, offset)\n    return offset + size\n  }\n  return [reader, writer, size, schema]\n}\n\nconst nums = {\n  'i8': ['readInt8', 'writeInt8', 1],\n  'u8': ['readUInt8', 'writeUInt8', 1],\n  'i16': ['readInt16BE', 'writeInt16BE', 2],\n  'u16': ['readUInt16BE', 'writeUInt16BE', 2],\n  'i32': ['readInt32BE', 'writeInt32BE', 4],\n  'u32': ['readUInt32BE', 'writeUInt32BE', 4],\n  'f32': ['readFloatBE', 'writeFloatBE', 4],\n  'f64': ['readDoubleBE', 'writeDoubleBE', 8],\n  'li8': ['readInt8', 'writeInt8', 1],\n  'lu8': ['readUInt8', 'writeUInt8', 1],\n  'li16': ['readInt16LE', 'writeInt16LE', 2],\n  'lu16': ['readUInt16LE', 'writeUInt16LE', 2],\n  'li32': ['readInt32LE', 'writeInt32LE', 4],\n  'lu32': ['readUInt32LE', 'writeUInt32LE', 4],\n  'lf32': ['readFloatLE', 'writeFloatLE', 4],\n  'lf64': ['readDoubleLE', 'writeDoubleLE', 8]\n}\n\nconst types = Object.keys(nums).reduce((types, num) => {\n  types[num] = generateFunctions(nums[num][0], nums[num][1], nums[num][2], __webpack_require__(/*! ../../ProtoDef/schemas/numeric.json */ \"./node_modules/protodef/ProtoDef/schemas/numeric.json\")[num])\n  return types\n}, {})\ntypes['i64'] = [readI64, writeI64, 8, __webpack_require__(/*! ../../ProtoDef/schemas/numeric.json */ \"./node_modules/protodef/ProtoDef/schemas/numeric.json\")['i64']]\ntypes['li64'] = [readLI64, writeLI64, 8, __webpack_require__(/*! ../../ProtoDef/schemas/numeric.json */ \"./node_modules/protodef/ProtoDef/schemas/numeric.json\")['li64']]\ntypes['u64'] = [readU64, writeU64, 8, __webpack_require__(/*! ../../ProtoDef/schemas/numeric.json */ \"./node_modules/protodef/ProtoDef/schemas/numeric.json\")['u64']]\ntypes['lu64'] = [readLU64, writeLU64, 8, __webpack_require__(/*! ../../ProtoDef/schemas/numeric.json */ \"./node_modules/protodef/ProtoDef/schemas/numeric.json\")['lu64']]\n\nmodule.exports = types\n\n\n//# sourceURL=webpack:///./node_modules/protodef/src/datatypes/numeric.js?");

/***/ }),

/***/ "./node_modules/protodef/src/datatypes/structures.js":
/*!***********************************************************!*\
  !*** ./node_modules/protodef/src/datatypes/structures.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { getField, getCount, sendCount, calcCount, tryDoc } = __webpack_require__(/*! ../utils */ \"./node_modules/protodef/src/utils.js\")\n\nmodule.exports = {\n  'array': [readArray, writeArray, sizeOfArray, __webpack_require__(/*! ../../ProtoDef/schemas/structures.json */ \"./node_modules/protodef/ProtoDef/schemas/structures.json\")['array']],\n  'count': [readCount, writeCount, sizeOfCount, __webpack_require__(/*! ../../ProtoDef/schemas/structures.json */ \"./node_modules/protodef/ProtoDef/schemas/structures.json\")['count']],\n  'container': [readContainer, writeContainer, sizeOfContainer, __webpack_require__(/*! ../../ProtoDef/schemas/structures.json */ \"./node_modules/protodef/ProtoDef/schemas/structures.json\")['container']]\n}\n\nfunction readArray (buffer, offset, typeArgs, rootNode) {\n  const results = {\n    value: [],\n    size: 0\n  }\n  let value\n  let { count, size } = getCount.call(this, buffer, offset, typeArgs, rootNode)\n  offset += size\n  results.size += size\n  for (let i = 0; i < count; i++) {\n    ({ size, value } = tryDoc(() => this.read(buffer, offset, typeArgs.type, rootNode), i))\n    results.size += size\n    offset += size\n    results.value.push(value)\n  }\n  return results\n}\n\nfunction writeArray (value, buffer, offset, typeArgs, rootNode) {\n  offset = sendCount.call(this, value.length, buffer, offset, typeArgs, rootNode)\n  return value.reduce((offset, v, index) => tryDoc(() => this.write(v, buffer, offset, typeArgs.type, rootNode), index), offset)\n}\n\nfunction sizeOfArray (value, typeArgs, rootNode) {\n  let size = calcCount.call(this, value.length, typeArgs, rootNode)\n  size = value.reduce((size, v, index) => tryDoc(() => size + this.sizeOf(v, typeArgs.type, rootNode), index), size)\n  return size\n}\n\nfunction readContainer (buffer, offset, typeArgs, context) {\n  const results = {\n    value: { '..': context },\n    size: 0\n  }\n  typeArgs.forEach(({ type, name, anon }) => {\n    tryDoc(() => {\n      const readResults = this.read(buffer, offset, type, results.value)\n      results.size += readResults.size\n      offset += readResults.size\n      if (anon) {\n        if (readResults.value !== undefined) {\n          Object.keys(readResults.value).forEach(key => {\n            results.value[key] = readResults.value[key]\n          })\n        }\n      } else { results.value[name] = readResults.value }\n    }, name || 'unknown')\n  })\n  delete results.value['..']\n  return results\n}\n\nfunction writeContainer (value, buffer, offset, typeArgs, context) {\n  value['..'] = context\n  offset = typeArgs.reduce((offset, { type, name, anon }) =>\n    tryDoc(() => this.write(anon ? value : value[name], buffer, offset, type, value), name || 'unknown'), offset)\n  delete value['..']\n  return offset\n}\n\nfunction sizeOfContainer (value, typeArgs, context) {\n  value['..'] = context\n  const size = typeArgs.reduce((size, { type, name, anon }) =>\n    size + tryDoc(() => this.sizeOf(anon ? value : value[name], type, value), name || 'unknown'), 0)\n  delete value['..']\n  return size\n}\n\nfunction readCount (buffer, offset, { type }, rootNode) {\n  return this.read(buffer, offset, type, rootNode)\n}\n\nfunction writeCount (value, buffer, offset, { countFor, type }, rootNode) {\n  // Actually gets the required field, and writes its length. Value is unused.\n  // TODO : a bit hackityhack.\n  return this.write(getField(countFor, rootNode).length, buffer, offset, type, rootNode)\n}\n\nfunction sizeOfCount (value, { countFor, type }, rootNode) {\n  // TODO : should I use value or getField().length ?\n  return this.sizeOf(getField(countFor, rootNode).length, type, rootNode)\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef/src/datatypes/structures.js?");

/***/ }),

/***/ "./node_modules/protodef/src/datatypes/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/protodef/src/datatypes/utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\")\n\nconst { getCount, sendCount, calcCount, PartialReadError } = __webpack_require__(/*! ../utils */ \"./node_modules/protodef/src/utils.js\")\n\nmodule.exports = {\n  'varint': [readVarInt, writeVarInt, sizeOfVarInt, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['varint']],\n  'bool': [readBool, writeBool, 1, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['bool']],\n  'pstring': [readPString, writePString, sizeOfPString, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['pstring']],\n  'buffer': [readBuffer, writeBuffer, sizeOfBuffer, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['buffer']],\n  'void': [readVoid, writeVoid, 0, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['void']],\n  'bitfield': [readBitField, writeBitField, sizeOfBitField, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['bitfield']],\n  'cstring': [readCString, writeCString, sizeOfCString, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['cstring']],\n  'mapper': [readMapper, writeMapper, sizeOfMapper, __webpack_require__(/*! ../../ProtoDef/schemas/utils.json */ \"./node_modules/protodef/ProtoDef/schemas/utils.json\")['mapper']]\n}\n\nfunction mapperEquality (a, b) {\n  return a === b || parseInt(a) === parseInt(b)\n}\n\nfunction readMapper (buffer, offset, { type, mappings }, rootNode) {\n  const { size, value } = this.read(buffer, offset, type, rootNode)\n  let mappedValue = null\n  const keys = Object.keys(mappings)\n  for (let i = 0; i < keys.length; i++) {\n    if (mapperEquality(keys[i], value)) {\n      mappedValue = mappings[keys[i]]\n      break\n    }\n  }\n  if (mappedValue == null) throw new Error(value + ' is not in the mappings value')\n  return {\n    size: size,\n    value: mappedValue\n  }\n}\n\nfunction writeMapper (value, buffer, offset, { type, mappings }, rootNode) {\n  const keys = Object.keys(mappings)\n  let mappedValue = null\n  for (let i = 0; i < keys.length; i++) {\n    if (mapperEquality(mappings[keys[i]], value)) {\n      mappedValue = keys[i]\n      break\n    }\n  }\n  if (mappedValue == null) throw new Error(value + ' is not in the mappings value')\n  return this.write(mappedValue, buffer, offset, type, rootNode)\n}\n\nfunction sizeOfMapper (value, { type, mappings }, rootNode) {\n  const keys = Object.keys(mappings)\n  let mappedValue = null\n  for (let i = 0; i < keys.length; i++) {\n    if (mapperEquality(mappings[keys[i]], value)) {\n      mappedValue = keys[i]\n      break\n    }\n  }\n  if (mappedValue == null) throw new Error(value + ' is not in the mappings value')\n  return this.sizeOf(mappedValue, type, rootNode)\n}\n\nfunction readVarInt (buffer, offset) {\n  let result = 0\n  let shift = 0\n  let cursor = offset\n\n  while (true) {\n    if (cursor + 1 > buffer.length) { throw new PartialReadError() }\n    const b = buffer.readUInt8(cursor)\n    result |= ((b & 0x7f) << shift) // Add the bits to our number, except MSB\n    cursor++\n    if (!(b & 0x80)) { // If the MSB is not set, we return the number\n      return {\n        value: result,\n        size: cursor - offset\n      }\n    }\n    shift += 7 // we only have 7 bits, MSB being the return-trigger\n    assert.ok(shift < 64, 'varint is too big') // Make sure our shift don't overflow.\n  }\n}\n\nfunction sizeOfVarInt (value) {\n  let cursor = 0\n  while (value & ~0x7F) {\n    value >>>= 7\n    cursor++\n  }\n  return cursor + 1\n}\n\nfunction writeVarInt (value, buffer, offset) {\n  let cursor = 0\n  while (value & ~0x7F) {\n    buffer.writeUInt8((value & 0xFF) | 0x80, offset + cursor)\n    cursor++\n    value >>>= 7\n  }\n  buffer.writeUInt8(value, offset + cursor)\n  return offset + cursor + 1\n}\n\nfunction readPString (buffer, offset, typeArgs, rootNode) {\n  const { size, count } = getCount.call(this, buffer, offset, typeArgs, rootNode)\n  const cursor = offset + size\n  const strEnd = cursor + count\n  if (strEnd > buffer.length) {\n    throw new PartialReadError('Missing characters in string, found size is ' + buffer.length +\n    ' expected size was ' + strEnd)\n  }\n\n  return {\n    value: buffer.toString('utf8', cursor, strEnd),\n    size: strEnd - offset\n  }\n}\n\nfunction writePString (value, buffer, offset, typeArgs, rootNode) {\n  const length = Buffer.byteLength(value, 'utf8')\n  offset = sendCount.call(this, length, buffer, offset, typeArgs, rootNode)\n  buffer.write(value, offset, length, 'utf8')\n  return offset + length\n}\n\nfunction sizeOfPString (value, typeArgs, rootNode) {\n  const length = Buffer.byteLength(value, 'utf8')\n  const size = calcCount.call(this, length, typeArgs, rootNode)\n  return size + length\n}\n\nfunction readBool (buffer, offset) {\n  if (offset + 1 > buffer.length) throw new PartialReadError()\n  const value = buffer.readInt8(offset)\n  return {\n    value: !!value,\n    size: 1\n  }\n}\n\nfunction writeBool (value, buffer, offset) {\n  buffer.writeInt8(+value, offset)\n  return offset + 1\n}\n\nfunction readBuffer (buffer, offset, typeArgs, rootNode) {\n  const { size, count } = getCount.call(this, buffer, offset, typeArgs, rootNode)\n  offset += size\n  if (offset + count > buffer.length) throw new PartialReadError()\n  return {\n    value: buffer.slice(offset, offset + count),\n    size: size + count\n  }\n}\n\nfunction writeBuffer (value, buffer, offset, typeArgs, rootNode) {\n  offset = sendCount.call(this, value.length, buffer, offset, typeArgs, rootNode)\n  value.copy(buffer, offset)\n  return offset + value.length\n}\n\nfunction sizeOfBuffer (value, typeArgs, rootNode) {\n  const size = calcCount.call(this, value.length, typeArgs, rootNode)\n  return size + value.length\n}\n\nfunction readVoid () {\n  return {\n    value: undefined,\n    size: 0\n  }\n}\n\nfunction writeVoid (value, buffer, offset) {\n  return offset\n}\n\nfunction generateBitMask (n) {\n  return (1 << n) - 1\n}\n\nfunction readBitField (buffer, offset, typeArgs) {\n  const beginOffset = offset\n  let curVal = null\n  let bits = 0\n  const results = {}\n  results.value = typeArgs.reduce((acc, { size, signed, name }) => {\n    let currentSize = size\n    let val = 0\n    while (currentSize > 0) {\n      if (bits === 0) {\n        if (buffer.length < offset + 1) { throw new PartialReadError() }\n        curVal = buffer[offset++]\n        bits = 8\n      }\n      const bitsToRead = Math.min(currentSize, bits)\n      val = (val << bitsToRead) | (curVal & generateBitMask(bits)) >> (bits - bitsToRead)\n      bits -= bitsToRead\n      currentSize -= bitsToRead\n    }\n    if (signed && val >= 1 << (size - 1)) { val -= 1 << size }\n    acc[name] = val\n    return acc\n  }, {})\n  results.size = offset - beginOffset\n  return results\n}\nfunction writeBitField (value, buffer, offset, typeArgs) {\n  let toWrite = 0\n  let bits = 0\n  typeArgs.forEach(({ size, signed, name }) => {\n    const val = value[name]\n    if ((!signed && val < 0) || (signed && val < -(1 << (size - 1)))) { throw new Error(value + ' < ' + signed ? (-(1 << (size - 1))) : 0) } else if ((!signed && val >= 1 << size) ||\n        (signed && val >= (1 << (size - 1)) - 1)) { throw new Error(value + ' >= ' + signed ? (1 << size) : ((1 << (size - 1)) - 1)) }\n    while (size > 0) {\n      const writeBits = Math.min(8 - bits, size)\n      toWrite = toWrite << writeBits |\n        ((val >> (size - writeBits)) & generateBitMask(writeBits))\n      size -= writeBits\n      bits += writeBits\n      if (bits === 8) {\n        buffer[offset++] = toWrite\n        bits = 0\n        toWrite = 0\n      }\n    }\n  })\n  if (bits !== 0) { buffer[offset++] = toWrite << (8 - bits) }\n  return offset\n}\n\nfunction sizeOfBitField (value, typeArgs) {\n  return Math.ceil(typeArgs.reduce((acc, { size }) => {\n    return acc + size\n  }, 0) / 8)\n}\n\nfunction readCString (buffer, offset) {\n  let size = 0\n  while (offset + size < buffer.length && buffer[offset + size] !== 0x00) { size++ }\n  if (buffer.length < offset + size + 1) { throw new PartialReadError() }\n\n  return {\n    value: buffer.toString('utf8', offset, offset + size),\n    size: size + 1\n  }\n}\n\nfunction writeCString (value, buffer, offset) {\n  const length = Buffer.byteLength(value, 'utf8')\n  buffer.write(value, offset, length, 'utf8')\n  offset += length\n  buffer.writeInt8(0x00, offset)\n  return offset + 1\n}\n\nfunction sizeOfCString (value) {\n  const length = Buffer.byteLength(value, 'utf8')\n  return length + 1\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/protodef/src/datatypes/utils.js?");

/***/ }),

/***/ "./node_modules/protodef/src/index.js":
/*!********************************************!*\
  !*** ./node_modules/protodef/src/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ProtoDef = __webpack_require__(/*! ./protodef */ \"./node_modules/protodef/src/protodef.js\")\nconst proto = new ProtoDef()\n\nmodule.exports = {\n  ProtoDef: ProtoDef,\n  Serializer: __webpack_require__(/*! ./serializer */ \"./node_modules/protodef/src/serializer.js\").Serializer,\n  Parser: __webpack_require__(/*! ./serializer */ \"./node_modules/protodef/src/serializer.js\").Parser,\n  FullPacketParser: __webpack_require__(/*! ./serializer */ \"./node_modules/protodef/src/serializer.js\").FullPacketParser,\n  types: proto.types,\n  utils: __webpack_require__(/*! ./utils */ \"./node_modules/protodef/src/utils.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef/src/index.js?");

/***/ }),

/***/ "./node_modules/protodef/src/protodef.js":
/*!***********************************************!*\
  !*** ./node_modules/protodef/src/protodef.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const { getFieldInfo, tryCatch } = __webpack_require__(/*! ./utils */ \"./node_modules/protodef/src/utils.js\")\nconst reduce = __webpack_require__(/*! lodash.reduce */ \"./node_modules/lodash.reduce/index.js\")\nconst get = __webpack_require__(/*! lodash.get */ \"./node_modules/lodash.get/index.js\")\nconst Validator = __webpack_require__(/*! protodef-validator */ \"./node_modules/protodef-validator/index.js\")\n\nfunction isFieldInfo (type) {\n  return typeof type === 'string' ||\n    (Array.isArray(type) && typeof type[0] === 'string') ||\n    type.type\n}\n\nfunction findArgs (acc, v, k) {\n  if (typeof v === 'string' && v.charAt(0) === '$') { acc.push({ 'path': k, 'val': v.substr(1) }) } else if (Array.isArray(v) || typeof v === 'object') { acc = acc.concat(reduce(v, findArgs, []).map((v) => ({ 'path': k + '.' + v.path, 'val': v.val }))) }\n  return acc\n}\n\nfunction setField (path, val, into) {\n  const c = path.split('.').reverse()\n  while (c.length > 1) {\n    into = into[c.pop()]\n  }\n  into[c.pop()] = val\n}\n\nfunction extendType (functions, defaultTypeArgs) {\n  const json = JSON.stringify(defaultTypeArgs)\n  const argPos = reduce(defaultTypeArgs, findArgs, [])\n  function produceArgs (typeArgs) {\n    const args = JSON.parse(json)\n    argPos.forEach((v) => {\n      setField(v.path, typeArgs[v.val], args)\n    })\n    return args\n  }\n  return [function read (buffer, offset, typeArgs, context) {\n    return functions[0].call(this, buffer, offset, produceArgs(typeArgs), context)\n  }, function write (value, buffer, offset, typeArgs, context) {\n    return functions[1].call(this, value, buffer, offset, produceArgs(typeArgs), context)\n  }, function sizeOf (value, typeArgs, context) {\n    if (typeof functions[2] === 'function') { return functions[2].call(this, value, produceArgs(typeArgs), context) } else { return functions[2] }\n  }]\n}\n\nclass ProtoDef {\n  constructor (validation = true) {\n    this.types = {}\n    this.validator = validation ? new Validator() : null\n    this.addDefaultTypes()\n  }\n\n  addDefaultTypes () {\n    this.addTypes(__webpack_require__(/*! ./datatypes/numeric */ \"./node_modules/protodef/src/datatypes/numeric.js\"))\n    this.addTypes(__webpack_require__(/*! ./datatypes/utils */ \"./node_modules/protodef/src/datatypes/utils.js\"))\n    this.addTypes(__webpack_require__(/*! ./datatypes/structures */ \"./node_modules/protodef/src/datatypes/structures.js\"))\n    this.addTypes(__webpack_require__(/*! ./datatypes/conditional */ \"./node_modules/protodef/src/datatypes/conditional.js\"))\n  }\n\n  addProtocol (protocolData, path) {\n    const self = this\n    function recursiveAddTypes (protocolData, path) {\n      if (protocolData === undefined) { return }\n      if (protocolData.types) { self.addTypes(protocolData.types) }\n      recursiveAddTypes(get(protocolData, path.shift()), path)\n    }\n\n    if (this.validator) { this.validator.validateProtocol(protocolData) }\n\n    recursiveAddTypes(protocolData, path)\n  }\n\n  addType (name, functions, validate = true) {\n    if (functions === 'native') {\n      if (this.validator) { this.validator.addType(name) }\n      return\n    }\n    if (isFieldInfo(functions)) {\n      if (this.validator) {\n        if (validate) { this.validator.validateType(functions) }\n        this.validator.addType(name)\n      }\n\n      let { type, typeArgs } = getFieldInfo(functions)\n      this.types[name] = typeArgs ? extendType(this.types[type], typeArgs) : this.types[type]\n    } else {\n      if (this.validator) {\n        if (functions[3]) {\n          this.validator.addType(name, functions[3])\n        } else { this.validator.addType(name) }\n      }\n\n      this.types[name] = functions\n    }\n  }\n\n  addTypes (types) {\n    Object.keys(types).forEach((name) => this.addType(name, types[name], false))\n    if (this.validator) {\n      Object.keys(types).forEach((name) => {\n        if (isFieldInfo(types[name])) {\n          this.validator.validateType(types[name])\n        }\n      })\n    }\n  }\n\n  read (buffer, cursor, _fieldInfo, rootNodes) {\n    let { type, typeArgs } = getFieldInfo(_fieldInfo)\n    const typeFunctions = this.types[type]\n    if (!typeFunctions) { throw new Error('missing data type: ' + type) }\n    return typeFunctions[0].call(this, buffer, cursor, typeArgs, rootNodes)\n  }\n\n  write (value, buffer, offset, _fieldInfo, rootNode) {\n    let { type, typeArgs } = getFieldInfo(_fieldInfo)\n    const typeFunctions = this.types[type]\n    if (!typeFunctions) { throw new Error('missing data type: ' + type) }\n    return typeFunctions[1].call(this, value, buffer, offset, typeArgs, rootNode)\n  }\n\n  sizeOf (value, _fieldInfo, rootNode) {\n    let { type, typeArgs } = getFieldInfo(_fieldInfo)\n    const typeFunctions = this.types[type]\n    if (!typeFunctions) {\n      throw new Error('missing data type: ' + type)\n    }\n    if (typeof typeFunctions[2] === 'function') {\n      return typeFunctions[2].call(this, value, typeArgs, rootNode)\n    } else {\n      return typeFunctions[2]\n    }\n  }\n\n  createPacketBuffer (type, packet) {\n    const length = tryCatch(() => this.sizeOf(packet, type, {}),\n      (e) => {\n        e.message = `SizeOf error for ${e.field} : ${e.message}`\n        throw e\n      })\n    const buffer = Buffer.allocUnsafe(length)\n    tryCatch(() => this.write(packet, buffer, 0, type, {}),\n      (e) => {\n        e.message = `Write error for ${e.field} : ${e.message}`\n        throw e\n      })\n    return buffer\n  }\n\n  parsePacketBuffer (type, buffer) {\n    const { value, size } = tryCatch(() => this.read(buffer, 0, type, {}),\n      (e) => {\n        e.message = `Read error for ${e.field} : ${e.message}`\n        throw e\n      })\n    return {\n      data: value,\n      metadata: {\n        size: size\n      },\n      buffer: buffer.slice(0, size)\n    }\n  }\n}\n\nmodule.exports = ProtoDef\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/protodef/src/protodef.js?");

/***/ }),

/***/ "./node_modules/protodef/src/serializer.js":
/*!*************************************************!*\
  !*** ./node_modules/protodef/src/serializer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {const Transform = __webpack_require__(/*! readable-stream */ \"./node_modules/protodef/node_modules/readable-stream/readable-browser.js\").Transform\n\nclass Serializer extends Transform {\n  constructor (proto, mainType) {\n    super({ writableObjectMode: true })\n    this.proto = proto\n    this.mainType = mainType\n    this.queue = Buffer.alloc(0)\n  }\n\n  createPacketBuffer (packet) {\n    return this.proto.createPacketBuffer(this.mainType, packet)\n  }\n\n  _transform (chunk, enc, cb) {\n    let buf\n    try {\n      buf = this.createPacketBuffer(chunk)\n    } catch (e) {\n      return cb(e)\n    }\n    this.push(buf)\n    return cb()\n  }\n}\n\nclass Parser extends Transform {\n  constructor (proto, mainType) {\n    super({ readableObjectMode: true })\n    this.proto = proto\n    this.mainType = mainType\n    this.queue = Buffer.alloc(0)\n  }\n\n  parsePacketBuffer (buffer) {\n    return this.proto.parsePacketBuffer(this.mainType, buffer)\n  }\n\n  _transform (chunk, enc, cb) {\n    this.queue = Buffer.concat([this.queue, chunk])\n    while (true) {\n      let packet\n      try {\n        packet = this.parsePacketBuffer(this.queue)\n      } catch (e) {\n        if (e.partialReadError) { return cb() } else {\n          e.buffer = this.queue\n          this.queue = Buffer.alloc(0)\n          return cb(e)\n        }\n      }\n\n      this.push(packet)\n      this.queue = this.queue.slice(packet.metadata.size)\n    }\n  }\n}\n\nclass FullPacketParser extends Transform {\n  constructor (proto, mainType) {\n    super({ readableObjectMode: true })\n    this.proto = proto\n    this.mainType = mainType\n  }\n\n  parsePacketBuffer (buffer) {\n    return this.proto.parsePacketBuffer(this.mainType, buffer)\n  }\n\n  _transform (chunk, enc, cb) {\n    let packet\n    try {\n      packet = this.parsePacketBuffer(chunk)\n      if (packet.metadata.size !== chunk.length) {\n        console.log('Chunk size is ' + chunk.length + ' but only ' + packet.metadata.size + ' was read ; partial packet : ' +\n          JSON.stringify(packet.data) + '; buffer :' + chunk.toString('hex'))\n      }\n    } catch (e) {\n      return cb(e)\n    }\n    this.push(packet)\n    cb()\n  }\n}\n\nmodule.exports = {\n  Serializer: Serializer,\n  Parser: Parser,\n  FullPacketParser: FullPacketParser\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/protodef/src/serializer.js?");

/***/ }),

/***/ "./node_modules/protodef/src/utils.js":
/*!********************************************!*\
  !*** ./node_modules/protodef/src/utils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function getField (countField, context) {\n  const countFieldArr = countField.split('/')\n  let i = 0\n  if (countFieldArr[i] === '') {\n    while (context.hasOwnProperty('..')) { context = context['..'] }\n    i++\n  }\n  for (; i < countFieldArr.length; i++) { context = context[countFieldArr[i]] }\n  return context\n}\n\nfunction getFieldInfo (fieldInfo) {\n  if (typeof fieldInfo === 'string') { return { type: fieldInfo } } else if (Array.isArray(fieldInfo)) { return { type: fieldInfo[0], typeArgs: fieldInfo[1] } } else if (typeof fieldInfo.type === 'string') { return fieldInfo } else { throw new Error('Not a fieldinfo') }\n}\n\nfunction getCount (buffer, offset, { count, countType }, rootNode) {\n  let c = 0\n  let size = 0\n  if (typeof count === 'number') { c = count } else if (typeof count !== 'undefined') {\n    c = getField(count, rootNode)\n  } else if (typeof countType !== 'undefined') {\n    ({ size, value: c } = tryDoc(() => this.read(buffer, offset, getFieldInfo(countType), rootNode), '$count'))\n  } else { // TODO : broken schema, should probably error out.\n    c = 0\n  }\n  return { count: c, size }\n}\n\nfunction sendCount (len, buffer, offset, { count, countType }, rootNode) {\n  if (typeof count !== 'undefined' && len !== count) {\n    // TODO: Throw\n  } else if (typeof countType !== 'undefined') {\n    offset = this.write(len, buffer, offset, getFieldInfo(countType), rootNode)\n  } else {\n    // TODO: Throw\n  }\n  return offset\n}\n\nfunction calcCount (len, { count, countType }, rootNode) {\n  if (typeof count === 'undefined' && typeof countType !== 'undefined') { return tryDoc(() => this.sizeOf(len, getFieldInfo(countType), rootNode), '$count') } else { return 0 }\n}\n\nfunction addErrorField (e, field) {\n  e.field = e.field ? field + '.' + e.field : field\n  throw e\n}\n\nfunction tryCatch (tryfn, catchfn) {\n  try { return tryfn() } catch (e) { catchfn(e) }\n}\n\nfunction tryDoc (tryfn, field) {\n  return tryCatch(tryfn, (e) => addErrorField(e, field))\n}\n\nclass ExtendableError extends Error {\n  constructor (message) {\n    super(message)\n    this.name = this.constructor.name\n    this.message = message\n    Error.captureStackTrace(this, this.constructor.name)\n  }\n}\n\nclass PartialReadError extends ExtendableError {\n  constructor (message) {\n    super(message)\n    this.partialReadError = true\n  }\n}\n\nmodule.exports = {\n  getField: getField,\n  getFieldInfo: getFieldInfo,\n  addErrorField: addErrorField,\n  getCount: getCount,\n  sendCount: sendCount,\n  calcCount: calcCount,\n  tryCatch: tryCatch,\n  tryDoc: tryDoc,\n  PartialReadError: PartialReadError\n}\n\n\n//# sourceURL=webpack:///./node_modules/protodef/src/utils.js?");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/duplex-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ 0);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ 1);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/BufferList.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").PassThrough\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").Transform\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\n\n//# sourceURL=webpack:///./node_modules/readable-stream/writable-browser.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack:///./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6‚Äì8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/stats.js/build/stats.min.js":
/*!**************************************************!*\
  !*** ./node_modules/stats.js/build/stats.min.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){ true?module.exports=e():undefined})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n\n\n//# sourceURL=webpack:///./node_modules/stats.js/build/stats.min.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"./node_modules/readable-stream/readable-browser.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"./node_modules/readable-stream/writable-browser.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"./node_modules/readable-stream/duplex-browser.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"./node_modules/readable-stream/transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"./node_modules/readable-stream/passthrough.js\");\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n//# sourceURL=webpack:///./node_modules/stream-browserify/index.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack:///./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/index.js":
/*!****************************************************!*\
  !*** ./node_modules/three-instanced-mesh/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n \nmodule.exports = function( THREE ){\n\nconst differentSignature = parseInt(THREE.REVISION) >= 96\n\n//monkeypatch shaders\n__webpack_require__(/*! ./monkey-patch.js */ \"./node_modules/three-instanced-mesh/monkey-patch.js\")(THREE);\n\n\n//depth mat\nvar DEPTH_MATERIAL = new THREE.MeshDepthMaterial();\n\nDEPTH_MATERIAL.depthPacking = THREE.RGBADepthPacking;\n\nDEPTH_MATERIAL.clipping = true;\n\nDEPTH_MATERIAL.defines = {\n\n\tINSTANCE_TRANSFORM: ''\n\n};\n\n//distance mat\nvar \n\t\n\tDISTANCE_SHADER = THREE.ShaderLib[ \"distanceRGBA\" ],\n\tDISTANCE_UNIFORMS = THREE.UniformsUtils.clone( DISTANCE_SHADER.uniforms ),\n\tDISTANCE_DEFINES = {\n\t\t'USE_SHADOWMAP': '',\n\t\t'INSTANCE_TRANSFORM': ''\n\t},\n\tDISTANCE_MATERIAL = new THREE.ShaderMaterial( {\n\t\tdefines: DISTANCE_DEFINES,\n\t\tuniforms: DISTANCE_UNIFORMS,\n\t\tvertexShader: DISTANCE_SHADER.vertexShader,\n\t\tfragmentShader: DISTANCE_SHADER.fragmentShader,\n\t\tclipping: true\n\t})\n;\n\n//main class\nTHREE.InstancedMesh = function ( \n\tbufferGeometry, \n\tmaterial, \n\tnumInstances, \n\tdynamic, \n\tcolors, \n\tuniformScale \n) {\n\n\tTHREE.Mesh.call( this , (new THREE.InstancedBufferGeometry()).copy( bufferGeometry ) ); //hacky for now\n\n\tthis._dynamic = !!dynamic; //TODO: set a bit mask for different attributes?\n\n \tthis._uniformScale = !!uniformScale;\n\n \tthis._colors = !!colors;\n\n\tthis.numInstances = numInstances;\n\n\tthis._setAttributes();\n\n\t/**\n\t * use the setter to decorate this material\n\t * this is in lieu of changing the renderer\n\t * WebGLRenderer injects stuff like this\n\t */\n\tthis.material = material;\n\n\tthis.frustumCulled = false; //you can uncheck this if you generate your own bounding info\n\n\t//make it work with depth effects\n\tthis.customDepthMaterial = DEPTH_MATERIAL; \n\n\tthis.customDistanceMaterial = DISTANCE_MATERIAL;\n\n}\n\nTHREE.InstancedMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.InstancedMesh.constructor = THREE.InstancedMesh;\n\n//this is kinda gnarly, done in order to avoid setting these defines in the WebGLRenderer (it manages most if not all of the define flags)\nObject.defineProperties( THREE.InstancedMesh.prototype , {\n\n\t'material': {\n\n            set: function (mat) {\n\n                let setM = function (m) {\n                    /**\n                     * whenever a material is set, decorate it,\n                     * if a material used with regular geometry is passed,\n                     * it will mutate it which is bad mkay\n                     *\n                     * either flag Material with these instance properties:\n                     *\n                     *  \"i want to create a RED PLASTIC material that will\n                     *   be INSTANCED and i know it will be used on clones\n                     *   that are known to be UNIFORMly scaled\"\n                     *  (also figure out where dynamic fits here)\n                     *\n                     * or check here if the material has INSTANCE_TRANSFORM\n                     * define set, if not, clone, document that it breaks reference\n                     * or do a shallow copy or something\n                     *\n                     * or something else?\n                     */\n                    if (m.defines) {\n\n                        m.defines.INSTANCE_TRANSFORM = '';\n\n                        if (this._uniformScale) m.defines.INSTANCE_UNIFORM = ''; //an optimization, should avoid doing an expensive matrix inverse in the shader\n                        else delete m.defines['INSTANCE_UNIFORM'];\n\n                        if ( this._colors ) m.defines.INSTANCE_COLOR = '';\n                        else delete m.defines['INSTANCE_COLOR'];\n                    }\n\n                    else{\n\n                        m.defines = { INSTANCE_TRANSFORM: '' };\n\n                        if ( this._uniformScale ) m.defines.INSTANCE_UNIFORM = '';\n                        if ( this._colors ) m.defines.INSTANCE_COLOR = '';\n                    }\n                };\n\n                if (Array.isArray(mat)) {\n                \tmat = mat.slice(0);\n                    for (let i = 0; i < mat.length; i++) {\n                        if(!mat[i])continue;\n                        setM(mat[i]);\n                    }\n                    this._material = mat;\n                } else {\n                \tmat = mat.clone();\n                    setM(mat);\n                    this._material = mat;\n                }\n            },\n\n\t\tget: function(){ return this._material; }\n\n\t},\n\n\t//force new attributes to be created when set?\n\t'numInstances': {\n\n\t\tset: function( v ){ \n\n\t\t\tthis._numInstances = v;\n\n\t\t\t//reset buffers\n\n\t\t\tthis._setAttributes();\n\n\t\t},\n\n\t\tget: function(){ return this._numInstances; }\n\n\t},\n\n\t//do some auto-magic when BufferGeometry is set\n\t//TODO: account for Geometry, or change this approach completely \n\t'geometry':{\n\n\t\tset: function( g ){ \n\n\t\t\t//if its not already instanced attach buffers\n\t\t\tif ( !!g.attributes.instancePosition ) {\n\n\t\t\t\tthis._geometry = new THREE.InstancedBufferGeometry();\n\n\t\t\t\tthis._setAttributes();\n\n\t\t\t} \n\n\t\t\telse \n\n\t\t\t\tthis._geometry = g;\n\n\t\t},\n\n\t\tget: function(){ return this._geometry; }\n\n\t}\n\n});\n\nTHREE.InstancedMesh.prototype.setPositionAt = function( index , position ){\n\n\tthis.geometry.attributes.instancePosition.setXYZ( index , position.x , position.y , position.z );\n\n};\n\nTHREE.InstancedMesh.prototype.setQuaternionAt = function ( index , quat ) {\n\n\tthis.geometry.attributes.instanceQuaternion.setXYZW( index , quat.x , quat.y , quat.z , quat.w );\n\n};\n\nTHREE.InstancedMesh.prototype.setScaleAt = function ( index , scale ) {\n\n\tthis.geometry.attributes.instanceScale.setXYZ( index , scale.x , scale.y , scale.z );\n\n};\n\nTHREE.InstancedMesh.prototype.setColorAt = function ( index , color ) {\n\n\tif( !this._colors ) {\n\n\t\tconsole.warn( 'THREE.InstancedMesh: color not enabled');\n\n\t\treturn;\n\n\t}\n\n\tthis.geometry.attributes.instanceColor.setXYZ( \n\t\tindex , \n\t\tMath.floor( color.r * 255 ), \n\t\tMath.floor( color.g * 255 ), \n\t\tMath.floor( color.b * 255 )\n\t);\n\n};\n\nTHREE.InstancedMesh.prototype.getPositionAt = function( index , position ){\n\n\tvar arr = this.geometry.attributes.instancePosition.array;\n\n\tindex *= 3;\n\n\treturn position ? \n\n\t\tposition.set( arr[index++], arr[index++], arr[index] ) :\n\n\t\tnew THREE.Vector3(  arr[index++], arr[index++], arr[index] )\n\t;\n\t\n};\n\nTHREE.InstancedMesh.prototype.getQuaternionAt = function ( index , quat ) {\n\n\tvar arr = this.geometry.attributes.instanceQuaternion.array;\n\n\tindex = index << 2;\n\n\treturn quat ? \n\n\t\tquat.set(       arr[index++], arr[index++], arr[index++], arr[index] ) :\n\n\t\tnew THREE.Quaternion( arr[index++], arr[index++], arr[index++], arr[index] )\n\t;\n\t\n};\n\nTHREE.InstancedMesh.prototype.getScaleAt = function ( index , scale ) {\n\n\tvar arr = this.geometry.attributes.instanceScale.array;\n\n\tindex *= 3;\n\n\treturn scale ? \n\n\t\tscale.set(   arr[index++], arr[index++], arr[index] ) :\n\n\t\tnew THREE.Vector3( arr[index++], arr[index++], arr[index] )\n\t;\n\n};\n\nTHREE.InstancedMesh.prototype.getColorAt = (function(){\n\n\tvar inv255 = 1/255;\n\n\treturn function ( index , color ) {\n\n\t\tif( !this._colors ) {\n\n\t\t\tconsole.warn( 'THREE.InstancedMesh: color not enabled');\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tvar arr = this.geometry.attributes.instanceColor.array;\n\t\t\n\t\tindex *= 3;\n\n\t\treturn color ? \n\n\t\t\tcolor.setRGB( arr[index++] * inv255, arr[index++] * inv255, arr[index] * inv255 ) :\n\n\t\t\tnew THREE.Vector3( arr[index++], arr[index++], arr[index] ).multiplyScalar( inv255 )\n\t\t;\n\n\t};\n\n})()\n\nTHREE.InstancedMesh.prototype.needsUpdate = function( attribute ){\n\n\tswitch ( attribute ){\n\n\t\tcase 'position' :\n\n\t\t\tthis.geometry.attributes.instancePosition.needsUpdate =   true;\n\n\t\t\tbreak;\n\n\t\tcase 'quaternion' :\n\n\t\t\tthis.geometry.attributes.instanceQuaternion.needsUpdate = true;\n\n\t\t\tbreak;\n\n\t\tcase 'scale' :\n\n\t\t\tthis.geometry.attributes.instanceScale.needsUpdate =      true;\n\n\t\t\tbreak;\n\n\t\tcase 'colors' :\n\n\t\t\tthis.geometry.attributes.instanceColor.needsUpdate =      true;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tthis.geometry.attributes.instancePosition.needsUpdate =   true;\n\t\t\tthis.geometry.attributes.instanceQuaternion.needsUpdate = true;\n\t\t\tthis.geometry.attributes.instanceScale.needsUpdate =      true;\n\t\t\n\t\t\tif(this._colors){\n\t\t\t\tthis.geometry.attributes.instanceColor.needsUpdate =      true;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t}\n\n};\n\nTHREE.InstancedMesh.prototype._setAttributes = function(){\n\n\tvar normalized = true\n\tvar meshPerAttribute = 1 \n\tvar vec4Size = 4\n\tvar vec3Size = 3\n\n\tvar attributes = {\n\t\tinstancePosition: [\n\t\t\tnew Float32Array( this.numInstances * vec3Size ), \n\t\t\tvec3Size, \n\t\t\t!normalized, \n\t\t\tmeshPerAttribute,\n\t\t],\n\t\tinstanceQuaternion: [\n\t\t\tnew Float32Array( this.numInstances * vec4Size ), \n\t\t\tvec4Size, \n\t\t\t!normalized, \n\t\t\tmeshPerAttribute,\n\t\t],\n\t\tinstanceScale: [\n\t\t\tnew Float32Array( this.numInstances * vec3Size ), \n\t\t\tvec3Size, \n\t\t\t!normalized,\n\t\t\tmeshPerAttribute,\n\t\t]\n\t}\n\n\tif ( this._colors ){\n\t\tattributes.instanceColor = [\n\t\t\tnew Uint8Array( this.numInstances * vec3Size ), \n\t\t\tvec3Size, \n\t\t\tnormalized, \n\t\t\tmeshPerAttribute,\n\t\t]\n\t}\n\n\tObject.keys(attributes).forEach(name=>{\n\t\tconst a = attributes[name]\n\t\tlet attribute\n\t\tif(differentSignature){\n\t\t\tattribute = new THREE.InstancedBufferAttribute(...a)\n\t\t} else {\n\t\t\tattribute = new THREE.InstancedBufferAttribute(a[0],a[1],a[3])\n\t\t\tattribute.normalized = a[2]\n\t\t}\n\t\t\t\n\t\tattribute.dynamic = this._dynamic\n\t\tthis.geometry.addAttribute(name, attribute)\n\t})\n\n};\n\nreturn THREE.InstancedMesh;\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/index.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch.js":
/*!***********************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\nmodule.exports = function ( THREE ){\n\n\tif( /InstancedMesh/.test( THREE.REVISION ) ) return THREE;\n\n\t__webpack_require__(/*! ./monkey-patch/index.js */ \"./node_modules/three-instanced-mesh/monkey-patch/index.js\")( THREE );\n\n\tTHREE.REVISION += \"_InstancedMesh\";\n\n\treturn THREE;\n\n}\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch/begin_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch/begin_vertex.glsl.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\n// transform vertices with the transform matrix\n\nmodule.exports = [\n\n\"#ifndef INSTANCE_TRANSFORM\",\n\n\"vec3 transformed = vec3( position );\",\n\n\"#else\",\n\n\"#ifndef INSTANCE_MATRIX\",\n\n\t\"mat4 _instanceMatrix = getInstanceMatrix();\",\n\n\t\"#define INSTANCE_MATRIX\",\n\n\"#endif\",\n\n\"vec3 transformed = ( _instanceMatrix * vec4( position , 1. )).xyz;\",\n\n\"#endif\",\n\n].join(\"\\n\")\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch/begin_vertex.glsl.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch/color_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch/color_fragment.glsl.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\n// multiply the color with per instance color if enabled\n\nmodule.exports = [\n\n'#ifdef USE_COLOR',\n\n\t'diffuseColor.rgb *= vColor;',\n\n'#endif',\n\n'#if defined(INSTANCE_COLOR)',\n\t\t\n\t'diffuseColor.rgb *= vInstanceColor;',\n\t\t\n'#endif'\n\n].join(\"\\n\")\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch/color_fragment.glsl.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch/color_pars_fragment.glsl.js":
/*!************************************************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch/color_pars_fragment.glsl.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\n// add fragment varying if feature enabled\n\nmodule.exports = [\n\n\"#ifdef USE_COLOR\",\n\n\t\"varying vec3 vColor;\",\n\n\"#endif\",\n\n\"#if defined( INSTANCE_COLOR )\",\n\t\t\n\t\"varying vec3 vInstanceColor;\",\n\t\t\n\"#endif\"\n\n].join(\"\\n\")\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch/color_pars_fragment.glsl.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch/color_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch/color_vertex.glsl.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\n// read per instance color from attribute, pass to varying\n\nmodule.exports = [\n\n\"#ifdef USE_COLOR\",\n\n\t\"vColor.xyz = color.xyz;\",\n\n\"#endif\",\n\n\"#if defined( INSTANCE_COLOR ) && defined( INSTANCE_TRANSFORM )\",\n\t\t\n\t\"vInstanceColor = instanceColor;\",\n\t\t\n\"#endif\",\n\n].join(\"\\n\")\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch/color_vertex.glsl.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch/defaultnormal_vertex.glsl.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch/defaultnormal_vertex.glsl.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\nmodule.exports = [\n\n\"#ifdef FLIP_SIDED\",\n\n\t\"objectNormal = -objectNormal;\",\n\n\"#endif\",\n\n\"#ifndef INSTANCE_TRANSFORM\",\n\n\t\"vec3 transformedNormal = normalMatrix * objectNormal;\",\n\n\"#else\",\n\n\t\"#ifndef INSTANCE_MATRIX \",\n\n\t\t\"mat4 _instanceMatrix = getInstanceMatrix();\",\n\n\t\t\"#define INSTANCE_MATRIX\",\n\n\t\"#endif\",\n\n\t\"#ifndef INSTANCE_UNIFORM\",\n\t\n\t\t\"vec3 transformedNormal =  transposeMat3( inverse( mat3( modelViewMatrix * _instanceMatrix ) ) ) * objectNormal ;\",\n\n\t\"#else\",\n\n\t\t\"vec3 transformedNormal = ( modelViewMatrix * _instanceMatrix * vec4( objectNormal , 0.0 ) ).xyz;\",\n\n\t\"#endif\",\n\n\"#endif\"\n\n].join(\"\\n\");\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch/defaultnormal_vertex.glsl.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch/index.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\nmodule.exports = function( THREE ){\n\n\t//patches these methods and shader chunks with the required logic \n\tTHREE.ShaderChunk[ 'begin_vertex' ] = \t\t\t\t__webpack_require__(/*! ./begin_vertex.glsl.js */ \"./node_modules/three-instanced-mesh/monkey-patch/begin_vertex.glsl.js\"); \n\tTHREE.ShaderChunk[ 'color_fragment' ] = \t\t\t__webpack_require__(/*! ./color_fragment.glsl.js */ \"./node_modules/three-instanced-mesh/monkey-patch/color_fragment.glsl.js\");\n\tTHREE.ShaderChunk[ 'color_pars_fragment' ] = \t\t__webpack_require__(/*! ./color_pars_fragment.glsl.js */ \"./node_modules/three-instanced-mesh/monkey-patch/color_pars_fragment.glsl.js\");\n\tTHREE.ShaderChunk[ 'color_vertex' ] = \t\t\t\t__webpack_require__(/*! ./color_vertex.glsl.js */ \"./node_modules/three-instanced-mesh/monkey-patch/color_vertex.glsl.js\");\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \t\t__webpack_require__(/*! ./defaultnormal_vertex.glsl.js */ \"./node_modules/three-instanced-mesh/monkey-patch/defaultnormal_vertex.glsl.js\");\n\tTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \t\t\t__webpack_require__(/*! ./uv_pars_vertex.glsl.js */ \"./node_modules/three-instanced-mesh/monkey-patch/uv_pars_vertex.glsl.js\");\n\t\n}\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch/index.js?");

/***/ }),

/***/ "./node_modules/three-instanced-mesh/monkey-patch/uv_pars_vertex.glsl.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/three-instanced-mesh/monkey-patch/uv_pars_vertex.glsl.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**************************\n * Dusan Bosnjak @pailhead\n **************************/\n\nmodule.exports = [\n\n\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\",\n \n  \"varying vec2 vUv;\",\n  \n  \"uniform mat3 uvTransform;\",\n\n\"#endif\",\n\n\"#ifdef INSTANCE_TRANSFORM\",\n\n\"mat3 inverse(mat3 m) {\",\n\n  \"float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\",\n\n  \"float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\",\n\n  \"float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\",\n\n  \"float b01 = a22 * a11 - a12 * a21;\",\n\n  \"float b11 = -a22 * a10 + a12 * a20;\",\n\n  \"float b21 = a21 * a10 - a11 * a20;\",\n\n  \"float det = a00 * b01 + a01 * b11 + a02 * b21;\",\n\n  \"return mat3(b01, (-a22 * a01 + a02 * a21), ( a12 * a01 - a02 * a11),\",\n              \"b11, ( a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\",\n              \"b21, (-a21 * a00 + a01 * a20), ( a11 * a00 - a01 * a10)) / det;\",\n\"}\",\n\n//for dynamic, avoid computing the matrices on the cpu\n\"attribute vec3 instancePosition;\",\n\"attribute vec4 instanceQuaternion;\",\n\"attribute vec3 instanceScale;\",\n\n\"#if defined( INSTANCE_COLOR )\",\n  \"attribute vec3 instanceColor;\",\n  \"varying vec3 vInstanceColor;\",\n\"#endif\",\n\n\"mat4 getInstanceMatrix(){\",\n\n  \"vec4 q = instanceQuaternion;\",\n  \"vec3 s = instanceScale;\",\n  \"vec3 v = instancePosition;\",\n\n  \"vec3 q2 = q.xyz + q.xyz;\",\n  \"vec3 a = q.xxx * q2.xyz;\",\n  \"vec3 b = q.yyz * q2.yzz;\",\n  \"vec3 c = q.www * q2.xyz;\",\n\n  \"vec3 r0 = vec3( 1.0 - (b.x + b.z) , a.y + c.z , a.z - c.y ) * s.xxx;\",\n  \"vec3 r1 = vec3( a.y - c.z , 1.0 - (a.x + b.z) , b.y + c.x ) * s.yyy;\",\n  \"vec3 r2 = vec3( a.z + c.y , b.y - c.x , 1.0 - (a.x + b.x) ) * s.zzz;\",\n\n  \"return mat4(\",\n\n      \"r0 , 0.0,\",\n      \"r1 , 0.0,\",\n      \"r2 , 0.0,\",\n      \"v  , 1.0\",\n\n  \");\",\n\n\"}\",\n\n\"#endif\"\n\n].join(\"\\n\");\n\n\n\n//# sourceURL=webpack:///./node_modules/three-instanced-mesh/monkey-patch/uv_pars_vertex.glsl.js?");

/***/ }),

/***/ "./node_modules/threejs-ext/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/threejs-ext/dist/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * The three.js expansion library v0.92.0\n * Collected by Jusfoun Visualization Department\n * Contact: \n *   vis@jusfoun.com\n *   http://vis.jusfoun.com\n *   http://jusfoun-vis.github.io\n * \n * Copyright (c) 2018, Jusfoun Big Data Group Inc.\n * All rights reserved.\n * \n * LICENSE\n * http://www.jusfoun.com/software/LICENSE.txt\n * \n * The three.js LICENSE\n * http://threejs.org/license\n */\n(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 27);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! three */ \"three\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n */\nvar Pass = function Pass() {\n\n  // if set to true, the pass is processed by the composer\n  this.enabled = true;\n\n  // if set to true, the pass indicates to swap read and write buffer after rendering\n  this.needsSwap = true;\n\n  // if set to true, the pass clears its buffer before rendering\n  this.clear = false;\n\n  // if set to true, the result of the pass is rendered to screen\n  this.renderToScreen = false;\n};\n\nObject.assign(Pass.prototype, {\n\n  setSize: function setSize(width, height) {},\n\n  render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n    console.error('THREE.Pass: .render() must be implemented in derived pass.');\n  }\n\n});\n\nexports.default = Pass;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Full-screen textured quad shader\n */\n\nvar CopyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = opacity * texel;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = CopyShader;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar ShaderPass = function ShaderPass(shader, textureID) {\n\n\t_Pass2.default.call(this);\n\n\tthis.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\n\tif (shader instanceof THREE.ShaderMaterial) {\n\n\t\tthis.uniforms = shader.uniforms;\n\n\t\tthis.material = shader;\n\t} else if (shader) {\n\n\t\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\tthis.material = new THREE.ShaderMaterial({\n\n\t\t\tdefines: Object.assign({}, shader.defines),\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t});\n\t}\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nShaderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: ShaderPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t}\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n\n});\n\nexports.default = ShaderPass;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n/**\r\n * @author Takahiro / https://github.com/takahirox\r\n *\r\n * Simple CharsetEncoder.\r\n */\r\n\r\nfunction CharsetEncoder() {\r\n}\r\n\r\n/*\r\n * Converts from Shift_JIS Uint8Array data to Unicode strings.\r\n */\r\nCharsetEncoder.prototype.s2u = function(uint8Array) {\r\n  var t = this.s2uTable;\r\n  var str = '';\r\n  var p = 0;\r\n\r\n  while(p < uint8Array.length) {\r\n    var key = uint8Array[p++];\r\n\r\n    if(! ((key >= 0x00 && key <= 0x7e) ||\r\n          (key >= 0xa1 && key <= 0xdf)) &&\r\n       p < uint8Array.length) {\r\n      key = (key << 8) | uint8Array[p++];\r\n    }\r\n\r\n    if(t[key] === undefined) {\r\n      throw 'unknown char code ' + key + '.';\r\n    }\r\n\r\n    str += String.fromCharCode(t[key]);\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\nCharsetEncoder.prototype.s2uTable = {\r\n0:0,\r\n1:1,\r\n2:2,\r\n3:3,\r\n4:4,\r\n5:5,\r\n6:6,\r\n7:7,\r\n8:8,\r\n9:9,\r\n10:10,\r\n11:11,\r\n12:12,\r\n13:13,\r\n14:14,\r\n15:15,\r\n16:16,\r\n17:17,\r\n18:18,\r\n19:19,\r\n20:20,\r\n21:21,\r\n22:22,\r\n23:23,\r\n24:24,\r\n25:25,\r\n26:26,\r\n27:27,\r\n28:28,\r\n29:29,\r\n30:30,\r\n31:31,\r\n32:32,\r\n33:33,\r\n34:34,\r\n35:35,\r\n36:36,\r\n37:37,\r\n38:38,\r\n39:39,\r\n40:40,\r\n41:41,\r\n42:42,\r\n43:43,\r\n44:44,\r\n45:45,\r\n46:46,\r\n47:47,\r\n48:48,\r\n49:49,\r\n50:50,\r\n51:51,\r\n52:52,\r\n53:53,\r\n54:54,\r\n55:55,\r\n56:56,\r\n57:57,\r\n58:58,\r\n59:59,\r\n60:60,\r\n61:61,\r\n62:62,\r\n63:63,\r\n64:64,\r\n65:65,\r\n66:66,\r\n67:67,\r\n68:68,\r\n69:69,\r\n70:70,\r\n71:71,\r\n72:72,\r\n73:73,\r\n74:74,\r\n75:75,\r\n76:76,\r\n77:77,\r\n78:78,\r\n79:79,\r\n80:80,\r\n81:81,\r\n82:82,\r\n83:83,\r\n84:84,\r\n85:85,\r\n86:86,\r\n87:87,\r\n88:88,\r\n89:89,\r\n90:90,\r\n91:91,\r\n92:92,\r\n93:93,\r\n94:94,\r\n95:95,\r\n96:96,\r\n97:97,\r\n98:98,\r\n99:99,\r\n100:100,\r\n101:101,\r\n102:102,\r\n103:103,\r\n104:104,\r\n105:105,\r\n106:106,\r\n107:107,\r\n108:108,\r\n109:109,\r\n110:110,\r\n111:111,\r\n112:112,\r\n113:113,\r\n114:114,\r\n115:115,\r\n116:116,\r\n117:117,\r\n118:118,\r\n119:119,\r\n120:120,\r\n121:121,\r\n122:122,\r\n123:123,\r\n124:124,\r\n125:125,\r\n126:126,\r\n161:65377,\r\n162:65378,\r\n163:65379,\r\n164:65380,\r\n165:65381,\r\n166:65382,\r\n167:65383,\r\n168:65384,\r\n169:65385,\r\n170:65386,\r\n171:65387,\r\n172:65388,\r\n173:65389,\r\n174:65390,\r\n175:65391,\r\n176:65392,\r\n177:65393,\r\n178:65394,\r\n179:65395,\r\n180:65396,\r\n181:65397,\r\n182:65398,\r\n183:65399,\r\n184:65400,\r\n185:65401,\r\n186:65402,\r\n187:65403,\r\n188:65404,\r\n189:65405,\r\n190:65406,\r\n191:65407,\r\n192:65408,\r\n193:65409,\r\n194:65410,\r\n195:65411,\r\n196:65412,\r\n197:65413,\r\n198:65414,\r\n199:65415,\r\n200:65416,\r\n201:65417,\r\n202:65418,\r\n203:65419,\r\n204:65420,\r\n205:65421,\r\n206:65422,\r\n207:65423,\r\n208:65424,\r\n209:65425,\r\n210:65426,\r\n211:65427,\r\n212:65428,\r\n213:65429,\r\n214:65430,\r\n215:65431,\r\n216:65432,\r\n217:65433,\r\n218:65434,\r\n219:65435,\r\n220:65436,\r\n221:65437,\r\n222:65438,\r\n223:65439,\r\n33088:12288,\r\n33089:12289,\r\n33090:12290,\r\n33091:65292,\r\n33092:65294,\r\n33093:12539,\r\n33094:65306,\r\n33095:65307,\r\n33096:65311,\r\n33097:65281,\r\n33098:12443,\r\n33099:12444,\r\n33100:180,\r\n33101:65344,\r\n33102:168,\r\n33103:65342,\r\n33104:65507,\r\n33105:65343,\r\n33106:12541,\r\n33107:12542,\r\n33108:12445,\r\n33109:12446,\r\n33110:12291,\r\n33111:20189,\r\n33112:12293,\r\n33113:12294,\r\n33114:12295,\r\n33115:12540,\r\n33116:8213,\r\n33117:8208,\r\n33118:65295,\r\n33119:65340,\r\n33120:65374,\r\n33121:8741,\r\n33122:65372,\r\n33123:8230,\r\n33124:8229,\r\n33125:8216,\r\n33126:8217,\r\n33127:8220,\r\n33128:8221,\r\n33129:65288,\r\n33130:65289,\r\n33131:12308,\r\n33132:12309,\r\n33133:65339,\r\n33134:65341,\r\n33135:65371,\r\n33136:65373,\r\n33137:12296,\r\n33138:12297,\r\n33139:12298,\r\n33140:12299,\r\n33141:12300,\r\n33142:12301,\r\n33143:12302,\r\n33144:12303,\r\n33145:12304,\r\n33146:12305,\r\n33147:65291,\r\n33148:65293,\r\n33149:177,\r\n33150:215,\r\n33152:247,\r\n33153:65309,\r\n33154:8800,\r\n33155:65308,\r\n33156:65310,\r\n33157:8806,\r\n33158:8807,\r\n33159:8734,\r\n33160:8756,\r\n33161:9794,\r\n33162:9792,\r\n33163:176,\r\n33164:8242,\r\n33165:8243,\r\n33166:8451,\r\n33167:65509,\r\n33168:65284,\r\n33169:65504,\r\n33170:65505,\r\n33171:65285,\r\n33172:65283,\r\n33173:65286,\r\n33174:65290,\r\n33175:65312,\r\n33176:167,\r\n33177:9734,\r\n33178:9733,\r\n33179:9675,\r\n33180:9679,\r\n33181:9678,\r\n33182:9671,\r\n33183:9670,\r\n33184:9633,\r\n33185:9632,\r\n33186:9651,\r\n33187:9650,\r\n33188:9661,\r\n33189:9660,\r\n33190:8251,\r\n33191:12306,\r\n33192:8594,\r\n33193:8592,\r\n33194:8593,\r\n33195:8595,\r\n33196:12307,\r\n33208:8712,\r\n33209:8715,\r\n33210:8838,\r\n33211:8839,\r\n33212:8834,\r\n33213:8835,\r\n33214:8746,\r\n33215:8745,\r\n33224:8743,\r\n33225:8744,\r\n33226:65506,\r\n33227:8658,\r\n33228:8660,\r\n33229:8704,\r\n33230:8707,\r\n33242:8736,\r\n33243:8869,\r\n33244:8978,\r\n33245:8706,\r\n33246:8711,\r\n33247:8801,\r\n33248:8786,\r\n33249:8810,\r\n33250:8811,\r\n33251:8730,\r\n33252:8765,\r\n33253:8733,\r\n33254:8757,\r\n33255:8747,\r\n33256:8748,\r\n33264:8491,\r\n33265:8240,\r\n33266:9839,\r\n33267:9837,\r\n33268:9834,\r\n33269:8224,\r\n33270:8225,\r\n33271:182,\r\n33276:9711,\r\n33359:65296,\r\n33360:65297,\r\n33361:65298,\r\n33362:65299,\r\n33363:65300,\r\n33364:65301,\r\n33365:65302,\r\n33366:65303,\r\n33367:65304,\r\n33368:65305,\r\n33376:65313,\r\n33377:65314,\r\n33378:65315,\r\n33379:65316,\r\n33380:65317,\r\n33381:65318,\r\n33382:65319,\r\n33383:65320,\r\n33384:65321,\r\n33385:65322,\r\n33386:65323,\r\n33387:65324,\r\n33388:65325,\r\n33389:65326,\r\n33390:65327,\r\n33391:65328,\r\n33392:65329,\r\n33393:65330,\r\n33394:65331,\r\n33395:65332,\r\n33396:65333,\r\n33397:65334,\r\n33398:65335,\r\n33399:65336,\r\n33400:65337,\r\n33401:65338,\r\n33409:65345,\r\n33410:65346,\r\n33411:65347,\r\n33412:65348,\r\n33413:65349,\r\n33414:65350,\r\n33415:65351,\r\n33416:65352,\r\n33417:65353,\r\n33418:65354,\r\n33419:65355,\r\n33420:65356,\r\n33421:65357,\r\n33422:65358,\r\n33423:65359,\r\n33424:65360,\r\n33425:65361,\r\n33426:65362,\r\n33427:65363,\r\n33428:65364,\r\n33429:65365,\r\n33430:65366,\r\n33431:65367,\r\n33432:65368,\r\n33433:65369,\r\n33434:65370,\r\n33439:12353,\r\n33440:12354,\r\n33441:12355,\r\n33442:12356,\r\n33443:12357,\r\n33444:12358,\r\n33445:12359,\r\n33446:12360,\r\n33447:12361,\r\n33448:12362,\r\n33449:12363,\r\n33450:12364,\r\n33451:12365,\r\n33452:12366,\r\n33453:12367,\r\n33454:12368,\r\n33455:12369,\r\n33456:12370,\r\n33457:12371,\r\n33458:12372,\r\n33459:12373,\r\n33460:12374,\r\n33461:12375,\r\n33462:12376,\r\n33463:12377,\r\n33464:12378,\r\n33465:12379,\r\n33466:12380,\r\n33467:12381,\r\n33468:12382,\r\n33469:12383,\r\n33470:12384,\r\n33471:12385,\r\n33472:12386,\r\n33473:12387,\r\n33474:12388,\r\n33475:12389,\r\n33476:12390,\r\n33477:12391,\r\n33478:12392,\r\n33479:12393,\r\n33480:12394,\r\n33481:12395,\r\n33482:12396,\r\n33483:12397,\r\n33484:12398,\r\n33485:12399,\r\n33486:12400,\r\n33487:12401,\r\n33488:12402,\r\n33489:12403,\r\n33490:12404,\r\n33491:12405,\r\n33492:12406,\r\n33493:12407,\r\n33494:12408,\r\n33495:12409,\r\n33496:12410,\r\n33497:12411,\r\n33498:12412,\r\n33499:12413,\r\n33500:12414,\r\n33501:12415,\r\n33502:12416,\r\n33503:12417,\r\n33504:12418,\r\n33505:12419,\r\n33506:12420,\r\n33507:12421,\r\n33508:12422,\r\n33509:12423,\r\n33510:12424,\r\n33511:12425,\r\n33512:12426,\r\n33513:12427,\r\n33514:12428,\r\n33515:12429,\r\n33516:12430,\r\n33517:12431,\r\n33518:12432,\r\n33519:12433,\r\n33520:12434,\r\n33521:12435,\r\n33600:12449,\r\n33601:12450,\r\n33602:12451,\r\n33603:12452,\r\n33604:12453,\r\n33605:12454,\r\n33606:12455,\r\n33607:12456,\r\n33608:12457,\r\n33609:12458,\r\n33610:12459,\r\n33611:12460,\r\n33612:12461,\r\n33613:12462,\r\n33614:12463,\r\n33615:12464,\r\n33616:12465,\r\n33617:12466,\r\n33618:12467,\r\n33619:12468,\r\n33620:12469,\r\n33621:12470,\r\n33622:12471,\r\n33623:12472,\r\n33624:12473,\r\n33625:12474,\r\n33626:12475,\r\n33627:12476,\r\n33628:12477,\r\n33629:12478,\r\n33630:12479,\r\n33631:12480,\r\n33632:12481,\r\n33633:12482,\r\n33634:12483,\r\n33635:12484,\r\n33636:12485,\r\n33637:12486,\r\n33638:12487,\r\n33639:12488,\r\n33640:12489,\r\n33641:12490,\r\n33642:12491,\r\n33643:12492,\r\n33644:12493,\r\n33645:12494,\r\n33646:12495,\r\n33647:12496,\r\n33648:12497,\r\n33649:12498,\r\n33650:12499,\r\n33651:12500,\r\n33652:12501,\r\n33653:12502,\r\n33654:12503,\r\n33655:12504,\r\n33656:12505,\r\n33657:12506,\r\n33658:12507,\r\n33659:12508,\r\n33660:12509,\r\n33661:12510,\r\n33662:12511,\r\n33664:12512,\r\n33665:12513,\r\n33666:12514,\r\n33667:12515,\r\n33668:12516,\r\n33669:12517,\r\n33670:12518,\r\n33671:12519,\r\n33672:12520,\r\n33673:12521,\r\n33674:12522,\r\n33675:12523,\r\n33676:12524,\r\n33677:12525,\r\n33678:12526,\r\n33679:12527,\r\n33680:12528,\r\n33681:12529,\r\n33682:12530,\r\n33683:12531,\r\n33684:12532,\r\n33685:12533,\r\n33686:12534,\r\n33695:913,\r\n33696:914,\r\n33697:915,\r\n33698:916,\r\n33699:917,\r\n33700:918,\r\n33701:919,\r\n33702:920,\r\n33703:921,\r\n33704:922,\r\n33705:923,\r\n33706:924,\r\n33707:925,\r\n33708:926,\r\n33709:927,\r\n33710:928,\r\n33711:929,\r\n33712:931,\r\n33713:932,\r\n33714:933,\r\n33715:934,\r\n33716:935,\r\n33717:936,\r\n33718:937,\r\n33727:945,\r\n33728:946,\r\n33729:947,\r\n33730:948,\r\n33731:949,\r\n33732:950,\r\n33733:951,\r\n33734:952,\r\n33735:953,\r\n33736:954,\r\n33737:955,\r\n33738:956,\r\n33739:957,\r\n33740:958,\r\n33741:959,\r\n33742:960,\r\n33743:961,\r\n33744:963,\r\n33745:964,\r\n33746:965,\r\n33747:966,\r\n33748:967,\r\n33749:968,\r\n33750:969,\r\n33856:1040,\r\n33857:1041,\r\n33858:1042,\r\n33859:1043,\r\n33860:1044,\r\n33861:1045,\r\n33862:1025,\r\n33863:1046,\r\n33864:1047,\r\n33865:1048,\r\n33866:1049,\r\n33867:1050,\r\n33868:1051,\r\n33869:1052,\r\n33870:1053,\r\n33871:1054,\r\n33872:1055,\r\n33873:1056,\r\n33874:1057,\r\n33875:1058,\r\n33876:1059,\r\n33877:1060,\r\n33878:1061,\r\n33879:1062,\r\n33880:1063,\r\n33881:1064,\r\n33882:1065,\r\n33883:1066,\r\n33884:1067,\r\n33885:1068,\r\n33886:1069,\r\n33887:1070,\r\n33888:1071,\r\n33904:1072,\r\n33905:1073,\r\n33906:1074,\r\n33907:1075,\r\n33908:1076,\r\n33909:1077,\r\n33910:1105,\r\n33911:1078,\r\n33912:1079,\r\n33913:1080,\r\n33914:1081,\r\n33915:1082,\r\n33916:1083,\r\n33917:1084,\r\n33918:1085,\r\n33920:1086,\r\n33921:1087,\r\n33922:1088,\r\n33923:1089,\r\n33924:1090,\r\n33925:1091,\r\n33926:1092,\r\n33927:1093,\r\n33928:1094,\r\n33929:1095,\r\n33930:1096,\r\n33931:1097,\r\n33932:1098,\r\n33933:1099,\r\n33934:1100,\r\n33935:1101,\r\n33936:1102,\r\n33937:1103,\r\n33951:9472,\r\n33952:9474,\r\n33953:9484,\r\n33954:9488,\r\n33955:9496,\r\n33956:9492,\r\n33957:9500,\r\n33958:9516,\r\n33959:9508,\r\n33960:9524,\r\n33961:9532,\r\n33962:9473,\r\n33963:9475,\r\n33964:9487,\r\n33965:9491,\r\n33966:9499,\r\n33967:9495,\r\n33968:9507,\r\n33969:9523,\r\n33970:9515,\r\n33971:9531,\r\n33972:9547,\r\n33973:9504,\r\n33974:9519,\r\n33975:9512,\r\n33976:9527,\r\n33977:9535,\r\n33978:9501,\r\n33979:9520,\r\n33980:9509,\r\n33981:9528,\r\n33982:9538,\r\n34624:9312,\r\n34625:9313,\r\n34626:9314,\r\n34627:9315,\r\n34628:9316,\r\n34629:9317,\r\n34630:9318,\r\n34631:9319,\r\n34632:9320,\r\n34633:9321,\r\n34634:9322,\r\n34635:9323,\r\n34636:9324,\r\n34637:9325,\r\n34638:9326,\r\n34639:9327,\r\n34640:9328,\r\n34641:9329,\r\n34642:9330,\r\n34643:9331,\r\n34644:8544,\r\n34645:8545,\r\n34646:8546,\r\n34647:8547,\r\n34648:8548,\r\n34649:8549,\r\n34650:8550,\r\n34651:8551,\r\n34652:8552,\r\n34653:8553,\r\n34655:13129,\r\n34656:13076,\r\n34657:13090,\r\n34658:13133,\r\n34659:13080,\r\n34660:13095,\r\n34661:13059,\r\n34662:13110,\r\n34663:13137,\r\n34664:13143,\r\n34665:13069,\r\n34666:13094,\r\n34667:13091,\r\n34668:13099,\r\n34669:13130,\r\n34670:13115,\r\n34671:13212,\r\n34672:13213,\r\n34673:13214,\r\n34674:13198,\r\n34675:13199,\r\n34676:13252,\r\n34677:13217,\r\n34686:13179,\r\n34688:12317,\r\n34689:12319,\r\n34690:8470,\r\n34691:13261,\r\n34692:8481,\r\n34693:12964,\r\n34694:12965,\r\n34695:12966,\r\n34696:12967,\r\n34697:12968,\r\n34698:12849,\r\n34699:12850,\r\n34700:12857,\r\n34701:13182,\r\n34702:13181,\r\n34703:13180,\r\n34704:8786,\r\n34705:8801,\r\n34706:8747,\r\n34707:8750,\r\n34708:8721,\r\n34709:8730,\r\n34710:8869,\r\n34711:8736,\r\n34712:8735,\r\n34713:8895,\r\n34714:8757,\r\n34715:8745,\r\n34716:8746,\r\n34975:20124,\r\n34976:21782,\r\n34977:23043,\r\n34978:38463,\r\n34979:21696,\r\n34980:24859,\r\n34981:25384,\r\n34982:23030,\r\n34983:36898,\r\n34984:33909,\r\n34985:33564,\r\n34986:31312,\r\n34987:24746,\r\n34988:25569,\r\n34989:28197,\r\n34990:26093,\r\n34991:33894,\r\n34992:33446,\r\n34993:39925,\r\n34994:26771,\r\n34995:22311,\r\n34996:26017,\r\n34997:25201,\r\n34998:23451,\r\n34999:22992,\r\n35000:34427,\r\n35001:39156,\r\n35002:32098,\r\n35003:32190,\r\n35004:39822,\r\n35005:25110,\r\n35006:31903,\r\n35007:34999,\r\n35008:23433,\r\n35009:24245,\r\n35010:25353,\r\n35011:26263,\r\n35012:26696,\r\n35013:38343,\r\n35014:38797,\r\n35015:26447,\r\n35016:20197,\r\n35017:20234,\r\n35018:20301,\r\n35019:20381,\r\n35020:20553,\r\n35021:22258,\r\n35022:22839,\r\n35023:22996,\r\n35024:23041,\r\n35025:23561,\r\n35026:24799,\r\n35027:24847,\r\n35028:24944,\r\n35029:26131,\r\n35030:26885,\r\n35031:28858,\r\n35032:30031,\r\n35033:30064,\r\n35034:31227,\r\n35035:32173,\r\n35036:32239,\r\n35037:32963,\r\n35038:33806,\r\n35039:34915,\r\n35040:35586,\r\n35041:36949,\r\n35042:36986,\r\n35043:21307,\r\n35044:20117,\r\n35045:20133,\r\n35046:22495,\r\n35047:32946,\r\n35048:37057,\r\n35049:30959,\r\n35050:19968,\r\n35051:22769,\r\n35052:28322,\r\n35053:36920,\r\n35054:31282,\r\n35055:33576,\r\n35056:33419,\r\n35057:39983,\r\n35058:20801,\r\n35059:21360,\r\n35060:21693,\r\n35061:21729,\r\n35062:22240,\r\n35063:23035,\r\n35064:24341,\r\n35065:39154,\r\n35066:28139,\r\n35067:32996,\r\n35068:34093,\r\n35136:38498,\r\n35137:38512,\r\n35138:38560,\r\n35139:38907,\r\n35140:21515,\r\n35141:21491,\r\n35142:23431,\r\n35143:28879,\r\n35144:32701,\r\n35145:36802,\r\n35146:38632,\r\n35147:21359,\r\n35148:40284,\r\n35149:31418,\r\n35150:19985,\r\n35151:30867,\r\n35152:33276,\r\n35153:28198,\r\n35154:22040,\r\n35155:21764,\r\n35156:27421,\r\n35157:34074,\r\n35158:39995,\r\n35159:23013,\r\n35160:21417,\r\n35161:28006,\r\n35162:29916,\r\n35163:38287,\r\n35164:22082,\r\n35165:20113,\r\n35166:36939,\r\n35167:38642,\r\n35168:33615,\r\n35169:39180,\r\n35170:21473,\r\n35171:21942,\r\n35172:23344,\r\n35173:24433,\r\n35174:26144,\r\n35175:26355,\r\n35176:26628,\r\n35177:27704,\r\n35178:27891,\r\n35179:27945,\r\n35180:29787,\r\n35181:30408,\r\n35182:31310,\r\n35183:38964,\r\n35184:33521,\r\n35185:34907,\r\n35186:35424,\r\n35187:37613,\r\n35188:28082,\r\n35189:30123,\r\n35190:30410,\r\n35191:39365,\r\n35192:24742,\r\n35193:35585,\r\n35194:36234,\r\n35195:38322,\r\n35196:27022,\r\n35197:21421,\r\n35198:20870,\r\n35200:22290,\r\n35201:22576,\r\n35202:22852,\r\n35203:23476,\r\n35204:24310,\r\n35205:24616,\r\n35206:25513,\r\n35207:25588,\r\n35208:27839,\r\n35209:28436,\r\n35210:28814,\r\n35211:28948,\r\n35212:29017,\r\n35213:29141,\r\n35214:29503,\r\n35215:32257,\r\n35216:33398,\r\n35217:33489,\r\n35218:34199,\r\n35219:36960,\r\n35220:37467,\r\n35221:40219,\r\n35222:22633,\r\n35223:26044,\r\n35224:27738,\r\n35225:29989,\r\n35226:20985,\r\n35227:22830,\r\n35228:22885,\r\n35229:24448,\r\n35230:24540,\r\n35231:25276,\r\n35232:26106,\r\n35233:27178,\r\n35234:27431,\r\n35235:27572,\r\n35236:29579,\r\n35237:32705,\r\n35238:35158,\r\n35239:40236,\r\n35240:40206,\r\n35241:40644,\r\n35242:23713,\r\n35243:27798,\r\n35244:33659,\r\n35245:20740,\r\n35246:23627,\r\n35247:25014,\r\n35248:33222,\r\n35249:26742,\r\n35250:29281,\r\n35251:20057,\r\n35252:20474,\r\n35253:21368,\r\n35254:24681,\r\n35255:28201,\r\n35256:31311,\r\n35257:38899,\r\n35258:19979,\r\n35259:21270,\r\n35260:20206,\r\n35261:20309,\r\n35262:20285,\r\n35263:20385,\r\n35264:20339,\r\n35265:21152,\r\n35266:21487,\r\n35267:22025,\r\n35268:22799,\r\n35269:23233,\r\n35270:23478,\r\n35271:23521,\r\n35272:31185,\r\n35273:26247,\r\n35274:26524,\r\n35275:26550,\r\n35276:27468,\r\n35277:27827,\r\n35278:28779,\r\n35279:29634,\r\n35280:31117,\r\n35281:31166,\r\n35282:31292,\r\n35283:31623,\r\n35284:33457,\r\n35285:33499,\r\n35286:33540,\r\n35287:33655,\r\n35288:33775,\r\n35289:33747,\r\n35290:34662,\r\n35291:35506,\r\n35292:22057,\r\n35293:36008,\r\n35294:36838,\r\n35295:36942,\r\n35296:38686,\r\n35297:34442,\r\n35298:20420,\r\n35299:23784,\r\n35300:25105,\r\n35301:29273,\r\n35302:30011,\r\n35303:33253,\r\n35304:33469,\r\n35305:34558,\r\n35306:36032,\r\n35307:38597,\r\n35308:39187,\r\n35309:39381,\r\n35310:20171,\r\n35311:20250,\r\n35312:35299,\r\n35313:22238,\r\n35314:22602,\r\n35315:22730,\r\n35316:24315,\r\n35317:24555,\r\n35318:24618,\r\n35319:24724,\r\n35320:24674,\r\n35321:25040,\r\n35322:25106,\r\n35323:25296,\r\n35324:25913,\r\n35392:39745,\r\n35393:26214,\r\n35394:26800,\r\n35395:28023,\r\n35396:28784,\r\n35397:30028,\r\n35398:30342,\r\n35399:32117,\r\n35400:33445,\r\n35401:34809,\r\n35402:38283,\r\n35403:38542,\r\n35404:35997,\r\n35405:20977,\r\n35406:21182,\r\n35407:22806,\r\n35408:21683,\r\n35409:23475,\r\n35410:23830,\r\n35411:24936,\r\n35412:27010,\r\n35413:28079,\r\n35414:30861,\r\n35415:33995,\r\n35416:34903,\r\n35417:35442,\r\n35418:37799,\r\n35419:39608,\r\n35420:28012,\r\n35421:39336,\r\n35422:34521,\r\n35423:22435,\r\n35424:26623,\r\n35425:34510,\r\n35426:37390,\r\n35427:21123,\r\n35428:22151,\r\n35429:21508,\r\n35430:24275,\r\n35431:25313,\r\n35432:25785,\r\n35433:26684,\r\n35434:26680,\r\n35435:27579,\r\n35436:29554,\r\n35437:30906,\r\n35438:31339,\r\n35439:35226,\r\n35440:35282,\r\n35441:36203,\r\n35442:36611,\r\n35443:37101,\r\n35444:38307,\r\n35445:38548,\r\n35446:38761,\r\n35447:23398,\r\n35448:23731,\r\n35449:27005,\r\n35450:38989,\r\n35451:38990,\r\n35452:25499,\r\n35453:31520,\r\n35454:27179,\r\n35456:27263,\r\n35457:26806,\r\n35458:39949,\r\n35459:28511,\r\n35460:21106,\r\n35461:21917,\r\n35462:24688,\r\n35463:25324,\r\n35464:27963,\r\n35465:28167,\r\n35466:28369,\r\n35467:33883,\r\n35468:35088,\r\n35469:36676,\r\n35470:19988,\r\n35471:39993,\r\n35472:21494,\r\n35473:26907,\r\n35474:27194,\r\n35475:38788,\r\n35476:26666,\r\n35477:20828,\r\n35478:31427,\r\n35479:33970,\r\n35480:37340,\r\n35481:37772,\r\n35482:22107,\r\n35483:40232,\r\n35484:26658,\r\n35485:33541,\r\n35486:33841,\r\n35487:31909,\r\n35488:21000,\r\n35489:33477,\r\n35490:29926,\r\n35491:20094,\r\n35492:20355,\r\n35493:20896,\r\n35494:23506,\r\n35495:21002,\r\n35496:21208,\r\n35497:21223,\r\n35498:24059,\r\n35499:21914,\r\n35500:22570,\r\n35501:23014,\r\n35502:23436,\r\n35503:23448,\r\n35504:23515,\r\n35505:24178,\r\n35506:24185,\r\n35507:24739,\r\n35508:24863,\r\n35509:24931,\r\n35510:25022,\r\n35511:25563,\r\n35512:25954,\r\n35513:26577,\r\n35514:26707,\r\n35515:26874,\r\n35516:27454,\r\n35517:27475,\r\n35518:27735,\r\n35519:28450,\r\n35520:28567,\r\n35521:28485,\r\n35522:29872,\r\n35523:29976,\r\n35524:30435,\r\n35525:30475,\r\n35526:31487,\r\n35527:31649,\r\n35528:31777,\r\n35529:32233,\r\n35530:32566,\r\n35531:32752,\r\n35532:32925,\r\n35533:33382,\r\n35534:33694,\r\n35535:35251,\r\n35536:35532,\r\n35537:36011,\r\n35538:36996,\r\n35539:37969,\r\n35540:38291,\r\n35541:38289,\r\n35542:38306,\r\n35543:38501,\r\n35544:38867,\r\n35545:39208,\r\n35546:33304,\r\n35547:20024,\r\n35548:21547,\r\n35549:23736,\r\n35550:24012,\r\n35551:29609,\r\n35552:30284,\r\n35553:30524,\r\n35554:23721,\r\n35555:32747,\r\n35556:36107,\r\n35557:38593,\r\n35558:38929,\r\n35559:38996,\r\n35560:39000,\r\n35561:20225,\r\n35562:20238,\r\n35563:21361,\r\n35564:21916,\r\n35565:22120,\r\n35566:22522,\r\n35567:22855,\r\n35568:23305,\r\n35569:23492,\r\n35570:23696,\r\n35571:24076,\r\n35572:24190,\r\n35573:24524,\r\n35574:25582,\r\n35575:26426,\r\n35576:26071,\r\n35577:26082,\r\n35578:26399,\r\n35579:26827,\r\n35580:26820,\r\n35648:27231,\r\n35649:24112,\r\n35650:27589,\r\n35651:27671,\r\n35652:27773,\r\n35653:30079,\r\n35654:31048,\r\n35655:23395,\r\n35656:31232,\r\n35657:32000,\r\n35658:24509,\r\n35659:35215,\r\n35660:35352,\r\n35661:36020,\r\n35662:36215,\r\n35663:36556,\r\n35664:36637,\r\n35665:39138,\r\n35666:39438,\r\n35667:39740,\r\n35668:20096,\r\n35669:20605,\r\n35670:20736,\r\n35671:22931,\r\n35672:23452,\r\n35673:25135,\r\n35674:25216,\r\n35675:25836,\r\n35676:27450,\r\n35677:29344,\r\n35678:30097,\r\n35679:31047,\r\n35680:32681,\r\n35681:34811,\r\n35682:35516,\r\n35683:35696,\r\n35684:25516,\r\n35685:33738,\r\n35686:38816,\r\n35687:21513,\r\n35688:21507,\r\n35689:21931,\r\n35690:26708,\r\n35691:27224,\r\n35692:35440,\r\n35693:30759,\r\n35694:26485,\r\n35695:40653,\r\n35696:21364,\r\n35697:23458,\r\n35698:33050,\r\n35699:34384,\r\n35700:36870,\r\n35701:19992,\r\n35702:20037,\r\n35703:20167,\r\n35704:20241,\r\n35705:21450,\r\n35706:21560,\r\n35707:23470,\r\n35708:24339,\r\n35709:24613,\r\n35710:25937,\r\n35712:26429,\r\n35713:27714,\r\n35714:27762,\r\n35715:27875,\r\n35716:28792,\r\n35717:29699,\r\n35718:31350,\r\n35719:31406,\r\n35720:31496,\r\n35721:32026,\r\n35722:31998,\r\n35723:32102,\r\n35724:26087,\r\n35725:29275,\r\n35726:21435,\r\n35727:23621,\r\n35728:24040,\r\n35729:25298,\r\n35730:25312,\r\n35731:25369,\r\n35732:28192,\r\n35733:34394,\r\n35734:35377,\r\n35735:36317,\r\n35736:37624,\r\n35737:28417,\r\n35738:31142,\r\n35739:39770,\r\n35740:20136,\r\n35741:20139,\r\n35742:20140,\r\n35743:20379,\r\n35744:20384,\r\n35745:20689,\r\n35746:20807,\r\n35747:31478,\r\n35748:20849,\r\n35749:20982,\r\n35750:21332,\r\n35751:21281,\r\n35752:21375,\r\n35753:21483,\r\n35754:21932,\r\n35755:22659,\r\n35756:23777,\r\n35757:24375,\r\n35758:24394,\r\n35759:24623,\r\n35760:24656,\r\n35761:24685,\r\n35762:25375,\r\n35763:25945,\r\n35764:27211,\r\n35765:27841,\r\n35766:29378,\r\n35767:29421,\r\n35768:30703,\r\n35769:33016,\r\n35770:33029,\r\n35771:33288,\r\n35772:34126,\r\n35773:37111,\r\n35774:37857,\r\n35775:38911,\r\n35776:39255,\r\n35777:39514,\r\n35778:20208,\r\n35779:20957,\r\n35780:23597,\r\n35781:26241,\r\n35782:26989,\r\n35783:23616,\r\n35784:26354,\r\n35785:26997,\r\n35786:29577,\r\n35787:26704,\r\n35788:31873,\r\n35789:20677,\r\n35790:21220,\r\n35791:22343,\r\n35792:24062,\r\n35793:37670,\r\n35794:26020,\r\n35795:27427,\r\n35796:27453,\r\n35797:29748,\r\n35798:31105,\r\n35799:31165,\r\n35800:31563,\r\n35801:32202,\r\n35802:33465,\r\n35803:33740,\r\n35804:34943,\r\n35805:35167,\r\n35806:35641,\r\n35807:36817,\r\n35808:37329,\r\n35809:21535,\r\n35810:37504,\r\n35811:20061,\r\n35812:20534,\r\n35813:21477,\r\n35814:21306,\r\n35815:29399,\r\n35816:29590,\r\n35817:30697,\r\n35818:33510,\r\n35819:36527,\r\n35820:39366,\r\n35821:39368,\r\n35822:39378,\r\n35823:20855,\r\n35824:24858,\r\n35825:34398,\r\n35826:21936,\r\n35827:31354,\r\n35828:20598,\r\n35829:23507,\r\n35830:36935,\r\n35831:38533,\r\n35832:20018,\r\n35833:27355,\r\n35834:37351,\r\n35835:23633,\r\n35836:23624,\r\n35904:25496,\r\n35905:31391,\r\n35906:27795,\r\n35907:38772,\r\n35908:36705,\r\n35909:31402,\r\n35910:29066,\r\n35911:38536,\r\n35912:31874,\r\n35913:26647,\r\n35914:32368,\r\n35915:26705,\r\n35916:37740,\r\n35917:21234,\r\n35918:21531,\r\n35919:34219,\r\n35920:35347,\r\n35921:32676,\r\n35922:36557,\r\n35923:37089,\r\n35924:21350,\r\n35925:34952,\r\n35926:31041,\r\n35927:20418,\r\n35928:20670,\r\n35929:21009,\r\n35930:20804,\r\n35931:21843,\r\n35932:22317,\r\n35933:29674,\r\n35934:22411,\r\n35935:22865,\r\n35936:24418,\r\n35937:24452,\r\n35938:24693,\r\n35939:24950,\r\n35940:24935,\r\n35941:25001,\r\n35942:25522,\r\n35943:25658,\r\n35944:25964,\r\n35945:26223,\r\n35946:26690,\r\n35947:28179,\r\n35948:30054,\r\n35949:31293,\r\n35950:31995,\r\n35951:32076,\r\n35952:32153,\r\n35953:32331,\r\n35954:32619,\r\n35955:33550,\r\n35956:33610,\r\n35957:34509,\r\n35958:35336,\r\n35959:35427,\r\n35960:35686,\r\n35961:36605,\r\n35962:38938,\r\n35963:40335,\r\n35964:33464,\r\n35965:36814,\r\n35966:39912,\r\n35968:21127,\r\n35969:25119,\r\n35970:25731,\r\n35971:28608,\r\n35972:38553,\r\n35973:26689,\r\n35974:20625,\r\n35975:27424,\r\n35976:27770,\r\n35977:28500,\r\n35978:31348,\r\n35979:32080,\r\n35980:34880,\r\n35981:35363,\r\n35982:26376,\r\n35983:20214,\r\n35984:20537,\r\n35985:20518,\r\n35986:20581,\r\n35987:20860,\r\n35988:21048,\r\n35989:21091,\r\n35990:21927,\r\n35991:22287,\r\n35992:22533,\r\n35993:23244,\r\n35994:24314,\r\n35995:25010,\r\n35996:25080,\r\n35997:25331,\r\n35998:25458,\r\n35999:26908,\r\n36000:27177,\r\n36001:29309,\r\n36002:29356,\r\n36003:29486,\r\n36004:30740,\r\n36005:30831,\r\n36006:32121,\r\n36007:30476,\r\n36008:32937,\r\n36009:35211,\r\n36010:35609,\r\n36011:36066,\r\n36012:36562,\r\n36013:36963,\r\n36014:37749,\r\n36015:38522,\r\n36016:38997,\r\n36017:39443,\r\n36018:40568,\r\n36019:20803,\r\n36020:21407,\r\n36021:21427,\r\n36022:24187,\r\n36023:24358,\r\n36024:28187,\r\n36025:28304,\r\n36026:29572,\r\n36027:29694,\r\n36028:32067,\r\n36029:33335,\r\n36030:35328,\r\n36031:35578,\r\n36032:38480,\r\n36033:20046,\r\n36034:20491,\r\n36035:21476,\r\n36036:21628,\r\n36037:22266,\r\n36038:22993,\r\n36039:23396,\r\n36040:24049,\r\n36041:24235,\r\n36042:24359,\r\n36043:25144,\r\n36044:25925,\r\n36045:26543,\r\n36046:28246,\r\n36047:29392,\r\n36048:31946,\r\n36049:34996,\r\n36050:32929,\r\n36051:32993,\r\n36052:33776,\r\n36053:34382,\r\n36054:35463,\r\n36055:36328,\r\n36056:37431,\r\n36057:38599,\r\n36058:39015,\r\n36059:40723,\r\n36060:20116,\r\n36061:20114,\r\n36062:20237,\r\n36063:21320,\r\n36064:21577,\r\n36065:21566,\r\n36066:23087,\r\n36067:24460,\r\n36068:24481,\r\n36069:24735,\r\n36070:26791,\r\n36071:27278,\r\n36072:29786,\r\n36073:30849,\r\n36074:35486,\r\n36075:35492,\r\n36076:35703,\r\n36077:37264,\r\n36078:20062,\r\n36079:39881,\r\n36080:20132,\r\n36081:20348,\r\n36082:20399,\r\n36083:20505,\r\n36084:20502,\r\n36085:20809,\r\n36086:20844,\r\n36087:21151,\r\n36088:21177,\r\n36089:21246,\r\n36090:21402,\r\n36091:21475,\r\n36092:21521,\r\n36160:21518,\r\n36161:21897,\r\n36162:22353,\r\n36163:22434,\r\n36164:22909,\r\n36165:23380,\r\n36166:23389,\r\n36167:23439,\r\n36168:24037,\r\n36169:24039,\r\n36170:24055,\r\n36171:24184,\r\n36172:24195,\r\n36173:24218,\r\n36174:24247,\r\n36175:24344,\r\n36176:24658,\r\n36177:24908,\r\n36178:25239,\r\n36179:25304,\r\n36180:25511,\r\n36181:25915,\r\n36182:26114,\r\n36183:26179,\r\n36184:26356,\r\n36185:26477,\r\n36186:26657,\r\n36187:26775,\r\n36188:27083,\r\n36189:27743,\r\n36190:27946,\r\n36191:28009,\r\n36192:28207,\r\n36193:28317,\r\n36194:30002,\r\n36195:30343,\r\n36196:30828,\r\n36197:31295,\r\n36198:31968,\r\n36199:32005,\r\n36200:32024,\r\n36201:32094,\r\n36202:32177,\r\n36203:32789,\r\n36204:32771,\r\n36205:32943,\r\n36206:32945,\r\n36207:33108,\r\n36208:33167,\r\n36209:33322,\r\n36210:33618,\r\n36211:34892,\r\n36212:34913,\r\n36213:35611,\r\n36214:36002,\r\n36215:36092,\r\n36216:37066,\r\n36217:37237,\r\n36218:37489,\r\n36219:30783,\r\n36220:37628,\r\n36221:38308,\r\n36222:38477,\r\n36224:38917,\r\n36225:39321,\r\n36226:39640,\r\n36227:40251,\r\n36228:21083,\r\n36229:21163,\r\n36230:21495,\r\n36231:21512,\r\n36232:22741,\r\n36233:25335,\r\n36234:28640,\r\n36235:35946,\r\n36236:36703,\r\n36237:40633,\r\n36238:20811,\r\n36239:21051,\r\n36240:21578,\r\n36241:22269,\r\n36242:31296,\r\n36243:37239,\r\n36244:40288,\r\n36245:40658,\r\n36246:29508,\r\n36247:28425,\r\n36248:33136,\r\n36249:29969,\r\n36250:24573,\r\n36251:24794,\r\n36252:39592,\r\n36253:29403,\r\n36254:36796,\r\n36255:27492,\r\n36256:38915,\r\n36257:20170,\r\n36258:22256,\r\n36259:22372,\r\n36260:22718,\r\n36261:23130,\r\n36262:24680,\r\n36263:25031,\r\n36264:26127,\r\n36265:26118,\r\n36266:26681,\r\n36267:26801,\r\n36268:28151,\r\n36269:30165,\r\n36270:32058,\r\n36271:33390,\r\n36272:39746,\r\n36273:20123,\r\n36274:20304,\r\n36275:21449,\r\n36276:21766,\r\n36277:23919,\r\n36278:24038,\r\n36279:24046,\r\n36280:26619,\r\n36281:27801,\r\n36282:29811,\r\n36283:30722,\r\n36284:35408,\r\n36285:37782,\r\n36286:35039,\r\n36287:22352,\r\n36288:24231,\r\n36289:25387,\r\n36290:20661,\r\n36291:20652,\r\n36292:20877,\r\n36293:26368,\r\n36294:21705,\r\n36295:22622,\r\n36296:22971,\r\n36297:23472,\r\n36298:24425,\r\n36299:25165,\r\n36300:25505,\r\n36301:26685,\r\n36302:27507,\r\n36303:28168,\r\n36304:28797,\r\n36305:37319,\r\n36306:29312,\r\n36307:30741,\r\n36308:30758,\r\n36309:31085,\r\n36310:25998,\r\n36311:32048,\r\n36312:33756,\r\n36313:35009,\r\n36314:36617,\r\n36315:38555,\r\n36316:21092,\r\n36317:22312,\r\n36318:26448,\r\n36319:32618,\r\n36320:36001,\r\n36321:20916,\r\n36322:22338,\r\n36323:38442,\r\n36324:22586,\r\n36325:27018,\r\n36326:32948,\r\n36327:21682,\r\n36328:23822,\r\n36329:22524,\r\n36330:30869,\r\n36331:40442,\r\n36332:20316,\r\n36333:21066,\r\n36334:21643,\r\n36335:25662,\r\n36336:26152,\r\n36337:26388,\r\n36338:26613,\r\n36339:31364,\r\n36340:31574,\r\n36341:32034,\r\n36342:37679,\r\n36343:26716,\r\n36344:39853,\r\n36345:31545,\r\n36346:21273,\r\n36347:20874,\r\n36348:21047,\r\n36416:23519,\r\n36417:25334,\r\n36418:25774,\r\n36419:25830,\r\n36420:26413,\r\n36421:27578,\r\n36422:34217,\r\n36423:38609,\r\n36424:30352,\r\n36425:39894,\r\n36426:25420,\r\n36427:37638,\r\n36428:39851,\r\n36429:30399,\r\n36430:26194,\r\n36431:19977,\r\n36432:20632,\r\n36433:21442,\r\n36434:23665,\r\n36435:24808,\r\n36436:25746,\r\n36437:25955,\r\n36438:26719,\r\n36439:29158,\r\n36440:29642,\r\n36441:29987,\r\n36442:31639,\r\n36443:32386,\r\n36444:34453,\r\n36445:35715,\r\n36446:36059,\r\n36447:37240,\r\n36448:39184,\r\n36449:26028,\r\n36450:26283,\r\n36451:27531,\r\n36452:20181,\r\n36453:20180,\r\n36454:20282,\r\n36455:20351,\r\n36456:21050,\r\n36457:21496,\r\n36458:21490,\r\n36459:21987,\r\n36460:22235,\r\n36461:22763,\r\n36462:22987,\r\n36463:22985,\r\n36464:23039,\r\n36465:23376,\r\n36466:23629,\r\n36467:24066,\r\n36468:24107,\r\n36469:24535,\r\n36470:24605,\r\n36471:25351,\r\n36472:25903,\r\n36473:23388,\r\n36474:26031,\r\n36475:26045,\r\n36476:26088,\r\n36477:26525,\r\n36478:27490,\r\n36480:27515,\r\n36481:27663,\r\n36482:29509,\r\n36483:31049,\r\n36484:31169,\r\n36485:31992,\r\n36486:32025,\r\n36487:32043,\r\n36488:32930,\r\n36489:33026,\r\n36490:33267,\r\n36491:35222,\r\n36492:35422,\r\n36493:35433,\r\n36494:35430,\r\n36495:35468,\r\n36496:35566,\r\n36497:36039,\r\n36498:36060,\r\n36499:38604,\r\n36500:39164,\r\n36501:27503,\r\n36502:20107,\r\n36503:20284,\r\n36504:20365,\r\n36505:20816,\r\n36506:23383,\r\n36507:23546,\r\n36508:24904,\r\n36509:25345,\r\n36510:26178,\r\n36511:27425,\r\n36512:28363,\r\n36513:27835,\r\n36514:29246,\r\n36515:29885,\r\n36516:30164,\r\n36517:30913,\r\n36518:31034,\r\n36519:32780,\r\n36520:32819,\r\n36521:33258,\r\n36522:33940,\r\n36523:36766,\r\n36524:27728,\r\n36525:40575,\r\n36526:24335,\r\n36527:35672,\r\n36528:40235,\r\n36529:31482,\r\n36530:36600,\r\n36531:23437,\r\n36532:38635,\r\n36533:19971,\r\n36534:21489,\r\n36535:22519,\r\n36536:22833,\r\n36537:23241,\r\n36538:23460,\r\n36539:24713,\r\n36540:28287,\r\n36541:28422,\r\n36542:30142,\r\n36543:36074,\r\n36544:23455,\r\n36545:34048,\r\n36546:31712,\r\n36547:20594,\r\n36548:26612,\r\n36549:33437,\r\n36550:23649,\r\n36551:34122,\r\n36552:32286,\r\n36553:33294,\r\n36554:20889,\r\n36555:23556,\r\n36556:25448,\r\n36557:36198,\r\n36558:26012,\r\n36559:29038,\r\n36560:31038,\r\n36561:32023,\r\n36562:32773,\r\n36563:35613,\r\n36564:36554,\r\n36565:36974,\r\n36566:34503,\r\n36567:37034,\r\n36568:20511,\r\n36569:21242,\r\n36570:23610,\r\n36571:26451,\r\n36572:28796,\r\n36573:29237,\r\n36574:37196,\r\n36575:37320,\r\n36576:37675,\r\n36577:33509,\r\n36578:23490,\r\n36579:24369,\r\n36580:24825,\r\n36581:20027,\r\n36582:21462,\r\n36583:23432,\r\n36584:25163,\r\n36585:26417,\r\n36586:27530,\r\n36587:29417,\r\n36588:29664,\r\n36589:31278,\r\n36590:33131,\r\n36591:36259,\r\n36592:37202,\r\n36593:39318,\r\n36594:20754,\r\n36595:21463,\r\n36596:21610,\r\n36597:23551,\r\n36598:25480,\r\n36599:27193,\r\n36600:32172,\r\n36601:38656,\r\n36602:22234,\r\n36603:21454,\r\n36604:21608,\r\n36672:23447,\r\n36673:23601,\r\n36674:24030,\r\n36675:20462,\r\n36676:24833,\r\n36677:25342,\r\n36678:27954,\r\n36679:31168,\r\n36680:31179,\r\n36681:32066,\r\n36682:32333,\r\n36683:32722,\r\n36684:33261,\r\n36685:33311,\r\n36686:33936,\r\n36687:34886,\r\n36688:35186,\r\n36689:35728,\r\n36690:36468,\r\n36691:36655,\r\n36692:36913,\r\n36693:37195,\r\n36694:37228,\r\n36695:38598,\r\n36696:37276,\r\n36697:20160,\r\n36698:20303,\r\n36699:20805,\r\n36700:21313,\r\n36701:24467,\r\n36702:25102,\r\n36703:26580,\r\n36704:27713,\r\n36705:28171,\r\n36706:29539,\r\n36707:32294,\r\n36708:37325,\r\n36709:37507,\r\n36710:21460,\r\n36711:22809,\r\n36712:23487,\r\n36713:28113,\r\n36714:31069,\r\n36715:32302,\r\n36716:31899,\r\n36717:22654,\r\n36718:29087,\r\n36719:20986,\r\n36720:34899,\r\n36721:36848,\r\n36722:20426,\r\n36723:23803,\r\n36724:26149,\r\n36725:30636,\r\n36726:31459,\r\n36727:33308,\r\n36728:39423,\r\n36729:20934,\r\n36730:24490,\r\n36731:26092,\r\n36732:26991,\r\n36733:27529,\r\n36734:28147,\r\n36736:28310,\r\n36737:28516,\r\n36738:30462,\r\n36739:32020,\r\n36740:24033,\r\n36741:36981,\r\n36742:37255,\r\n36743:38918,\r\n36744:20966,\r\n36745:21021,\r\n36746:25152,\r\n36747:26257,\r\n36748:26329,\r\n36749:28186,\r\n36750:24246,\r\n36751:32210,\r\n36752:32626,\r\n36753:26360,\r\n36754:34223,\r\n36755:34295,\r\n36756:35576,\r\n36757:21161,\r\n36758:21465,\r\n36759:22899,\r\n36760:24207,\r\n36761:24464,\r\n36762:24661,\r\n36763:37604,\r\n36764:38500,\r\n36765:20663,\r\n36766:20767,\r\n36767:21213,\r\n36768:21280,\r\n36769:21319,\r\n36770:21484,\r\n36771:21736,\r\n36772:21830,\r\n36773:21809,\r\n36774:22039,\r\n36775:22888,\r\n36776:22974,\r\n36777:23100,\r\n36778:23477,\r\n36779:23558,\r\n36780:23567,\r\n36781:23569,\r\n36782:23578,\r\n36783:24196,\r\n36784:24202,\r\n36785:24288,\r\n36786:24432,\r\n36787:25215,\r\n36788:25220,\r\n36789:25307,\r\n36790:25484,\r\n36791:25463,\r\n36792:26119,\r\n36793:26124,\r\n36794:26157,\r\n36795:26230,\r\n36796:26494,\r\n36797:26786,\r\n36798:27167,\r\n36799:27189,\r\n36800:27836,\r\n36801:28040,\r\n36802:28169,\r\n36803:28248,\r\n36804:28988,\r\n36805:28966,\r\n36806:29031,\r\n36807:30151,\r\n36808:30465,\r\n36809:30813,\r\n36810:30977,\r\n36811:31077,\r\n36812:31216,\r\n36813:31456,\r\n36814:31505,\r\n36815:31911,\r\n36816:32057,\r\n36817:32918,\r\n36818:33750,\r\n36819:33931,\r\n36820:34121,\r\n36821:34909,\r\n36822:35059,\r\n36823:35359,\r\n36824:35388,\r\n36825:35412,\r\n36826:35443,\r\n36827:35937,\r\n36828:36062,\r\n36829:37284,\r\n36830:37478,\r\n36831:37758,\r\n36832:37912,\r\n36833:38556,\r\n36834:38808,\r\n36835:19978,\r\n36836:19976,\r\n36837:19998,\r\n36838:20055,\r\n36839:20887,\r\n36840:21104,\r\n36841:22478,\r\n36842:22580,\r\n36843:22732,\r\n36844:23330,\r\n36845:24120,\r\n36846:24773,\r\n36847:25854,\r\n36848:26465,\r\n36849:26454,\r\n36850:27972,\r\n36851:29366,\r\n36852:30067,\r\n36853:31331,\r\n36854:33976,\r\n36855:35698,\r\n36856:37304,\r\n36857:37664,\r\n36858:22065,\r\n36859:22516,\r\n36860:39166,\r\n36928:25325,\r\n36929:26893,\r\n36930:27542,\r\n36931:29165,\r\n36932:32340,\r\n36933:32887,\r\n36934:33394,\r\n36935:35302,\r\n36936:39135,\r\n36937:34645,\r\n36938:36785,\r\n36939:23611,\r\n36940:20280,\r\n36941:20449,\r\n36942:20405,\r\n36943:21767,\r\n36944:23072,\r\n36945:23517,\r\n36946:23529,\r\n36947:24515,\r\n36948:24910,\r\n36949:25391,\r\n36950:26032,\r\n36951:26187,\r\n36952:26862,\r\n36953:27035,\r\n36954:28024,\r\n36955:28145,\r\n36956:30003,\r\n36957:30137,\r\n36958:30495,\r\n36959:31070,\r\n36960:31206,\r\n36961:32051,\r\n36962:33251,\r\n36963:33455,\r\n36964:34218,\r\n36965:35242,\r\n36966:35386,\r\n36967:36523,\r\n36968:36763,\r\n36969:36914,\r\n36970:37341,\r\n36971:38663,\r\n36972:20154,\r\n36973:20161,\r\n36974:20995,\r\n36975:22645,\r\n36976:22764,\r\n36977:23563,\r\n36978:29978,\r\n36979:23613,\r\n36980:33102,\r\n36981:35338,\r\n36982:36805,\r\n36983:38499,\r\n36984:38765,\r\n36985:31525,\r\n36986:35535,\r\n36987:38920,\r\n36988:37218,\r\n36989:22259,\r\n36990:21416,\r\n36992:36887,\r\n36993:21561,\r\n36994:22402,\r\n36995:24101,\r\n36996:25512,\r\n36997:27700,\r\n36998:28810,\r\n36999:30561,\r\n37000:31883,\r\n37001:32736,\r\n37002:34928,\r\n37003:36930,\r\n37004:37204,\r\n37005:37648,\r\n37006:37656,\r\n37007:38543,\r\n37008:29790,\r\n37009:39620,\r\n37010:23815,\r\n37011:23913,\r\n37012:25968,\r\n37013:26530,\r\n37014:36264,\r\n37015:38619,\r\n37016:25454,\r\n37017:26441,\r\n37018:26905,\r\n37019:33733,\r\n37020:38935,\r\n37021:38592,\r\n37022:35070,\r\n37023:28548,\r\n37024:25722,\r\n37025:23544,\r\n37026:19990,\r\n37027:28716,\r\n37028:30045,\r\n37029:26159,\r\n37030:20932,\r\n37031:21046,\r\n37032:21218,\r\n37033:22995,\r\n37034:24449,\r\n37035:24615,\r\n37036:25104,\r\n37037:25919,\r\n37038:25972,\r\n37039:26143,\r\n37040:26228,\r\n37041:26866,\r\n37042:26646,\r\n37043:27491,\r\n37044:28165,\r\n37045:29298,\r\n37046:29983,\r\n37047:30427,\r\n37048:31934,\r\n37049:32854,\r\n37050:22768,\r\n37051:35069,\r\n37052:35199,\r\n37053:35488,\r\n37054:35475,\r\n37055:35531,\r\n37056:36893,\r\n37057:37266,\r\n37058:38738,\r\n37059:38745,\r\n37060:25993,\r\n37061:31246,\r\n37062:33030,\r\n37063:38587,\r\n37064:24109,\r\n37065:24796,\r\n37066:25114,\r\n37067:26021,\r\n37068:26132,\r\n37069:26512,\r\n37070:30707,\r\n37071:31309,\r\n37072:31821,\r\n37073:32318,\r\n37074:33034,\r\n37075:36012,\r\n37076:36196,\r\n37077:36321,\r\n37078:36447,\r\n37079:30889,\r\n37080:20999,\r\n37081:25305,\r\n37082:25509,\r\n37083:25666,\r\n37084:25240,\r\n37085:35373,\r\n37086:31363,\r\n37087:31680,\r\n37088:35500,\r\n37089:38634,\r\n37090:32118,\r\n37091:33292,\r\n37092:34633,\r\n37093:20185,\r\n37094:20808,\r\n37095:21315,\r\n37096:21344,\r\n37097:23459,\r\n37098:23554,\r\n37099:23574,\r\n37100:24029,\r\n37101:25126,\r\n37102:25159,\r\n37103:25776,\r\n37104:26643,\r\n37105:26676,\r\n37106:27849,\r\n37107:27973,\r\n37108:27927,\r\n37109:26579,\r\n37110:28508,\r\n37111:29006,\r\n37112:29053,\r\n37113:26059,\r\n37114:31359,\r\n37115:31661,\r\n37116:32218,\r\n37184:32330,\r\n37185:32680,\r\n37186:33146,\r\n37187:33307,\r\n37188:33337,\r\n37189:34214,\r\n37190:35438,\r\n37191:36046,\r\n37192:36341,\r\n37193:36984,\r\n37194:36983,\r\n37195:37549,\r\n37196:37521,\r\n37197:38275,\r\n37198:39854,\r\n37199:21069,\r\n37200:21892,\r\n37201:28472,\r\n37202:28982,\r\n37203:20840,\r\n37204:31109,\r\n37205:32341,\r\n37206:33203,\r\n37207:31950,\r\n37208:22092,\r\n37209:22609,\r\n37210:23720,\r\n37211:25514,\r\n37212:26366,\r\n37213:26365,\r\n37214:26970,\r\n37215:29401,\r\n37216:30095,\r\n37217:30094,\r\n37218:30990,\r\n37219:31062,\r\n37220:31199,\r\n37221:31895,\r\n37222:32032,\r\n37223:32068,\r\n37224:34311,\r\n37225:35380,\r\n37226:38459,\r\n37227:36961,\r\n37228:40736,\r\n37229:20711,\r\n37230:21109,\r\n37231:21452,\r\n37232:21474,\r\n37233:20489,\r\n37234:21930,\r\n37235:22766,\r\n37236:22863,\r\n37237:29245,\r\n37238:23435,\r\n37239:23652,\r\n37240:21277,\r\n37241:24803,\r\n37242:24819,\r\n37243:25436,\r\n37244:25475,\r\n37245:25407,\r\n37246:25531,\r\n37248:25805,\r\n37249:26089,\r\n37250:26361,\r\n37251:24035,\r\n37252:27085,\r\n37253:27133,\r\n37254:28437,\r\n37255:29157,\r\n37256:20105,\r\n37257:30185,\r\n37258:30456,\r\n37259:31379,\r\n37260:31967,\r\n37261:32207,\r\n37262:32156,\r\n37263:32865,\r\n37264:33609,\r\n37265:33624,\r\n37266:33900,\r\n37267:33980,\r\n37268:34299,\r\n37269:35013,\r\n37270:36208,\r\n37271:36865,\r\n37272:36973,\r\n37273:37783,\r\n37274:38684,\r\n37275:39442,\r\n37276:20687,\r\n37277:22679,\r\n37278:24974,\r\n37279:33235,\r\n37280:34101,\r\n37281:36104,\r\n37282:36896,\r\n37283:20419,\r\n37284:20596,\r\n37285:21063,\r\n37286:21363,\r\n37287:24687,\r\n37288:25417,\r\n37289:26463,\r\n37290:28204,\r\n37291:36275,\r\n37292:36895,\r\n37293:20439,\r\n37294:23646,\r\n37295:36042,\r\n37296:26063,\r\n37297:32154,\r\n37298:21330,\r\n37299:34966,\r\n37300:20854,\r\n37301:25539,\r\n37302:23384,\r\n37303:23403,\r\n37304:23562,\r\n37305:25613,\r\n37306:26449,\r\n37307:36956,\r\n37308:20182,\r\n37309:22810,\r\n37310:22826,\r\n37311:27760,\r\n37312:35409,\r\n37313:21822,\r\n37314:22549,\r\n37315:22949,\r\n37316:24816,\r\n37317:25171,\r\n37318:26561,\r\n37319:33333,\r\n37320:26965,\r\n37321:38464,\r\n37322:39364,\r\n37323:39464,\r\n37324:20307,\r\n37325:22534,\r\n37326:23550,\r\n37327:32784,\r\n37328:23729,\r\n37329:24111,\r\n37330:24453,\r\n37331:24608,\r\n37332:24907,\r\n37333:25140,\r\n37334:26367,\r\n37335:27888,\r\n37336:28382,\r\n37337:32974,\r\n37338:33151,\r\n37339:33492,\r\n37340:34955,\r\n37341:36024,\r\n37342:36864,\r\n37343:36910,\r\n37344:38538,\r\n37345:40667,\r\n37346:39899,\r\n37347:20195,\r\n37348:21488,\r\n37349:22823,\r\n37350:31532,\r\n37351:37261,\r\n37352:38988,\r\n37353:40441,\r\n37354:28381,\r\n37355:28711,\r\n37356:21331,\r\n37357:21828,\r\n37358:23429,\r\n37359:25176,\r\n37360:25246,\r\n37361:25299,\r\n37362:27810,\r\n37363:28655,\r\n37364:29730,\r\n37365:35351,\r\n37366:37944,\r\n37367:28609,\r\n37368:35582,\r\n37369:33592,\r\n37370:20967,\r\n37371:34552,\r\n37372:21482,\r\n37440:21481,\r\n37441:20294,\r\n37442:36948,\r\n37443:36784,\r\n37444:22890,\r\n37445:33073,\r\n37446:24061,\r\n37447:31466,\r\n37448:36799,\r\n37449:26842,\r\n37450:35895,\r\n37451:29432,\r\n37452:40008,\r\n37453:27197,\r\n37454:35504,\r\n37455:20025,\r\n37456:21336,\r\n37457:22022,\r\n37458:22374,\r\n37459:25285,\r\n37460:25506,\r\n37461:26086,\r\n37462:27470,\r\n37463:28129,\r\n37464:28251,\r\n37465:28845,\r\n37466:30701,\r\n37467:31471,\r\n37468:31658,\r\n37469:32187,\r\n37470:32829,\r\n37471:32966,\r\n37472:34507,\r\n37473:35477,\r\n37474:37723,\r\n37475:22243,\r\n37476:22727,\r\n37477:24382,\r\n37478:26029,\r\n37479:26262,\r\n37480:27264,\r\n37481:27573,\r\n37482:30007,\r\n37483:35527,\r\n37484:20516,\r\n37485:30693,\r\n37486:22320,\r\n37487:24347,\r\n37488:24677,\r\n37489:26234,\r\n37490:27744,\r\n37491:30196,\r\n37492:31258,\r\n37493:32622,\r\n37494:33268,\r\n37495:34584,\r\n37496:36933,\r\n37497:39347,\r\n37498:31689,\r\n37499:30044,\r\n37500:31481,\r\n37501:31569,\r\n37502:33988,\r\n37504:36880,\r\n37505:31209,\r\n37506:31378,\r\n37507:33590,\r\n37508:23265,\r\n37509:30528,\r\n37510:20013,\r\n37511:20210,\r\n37512:23449,\r\n37513:24544,\r\n37514:25277,\r\n37515:26172,\r\n37516:26609,\r\n37517:27880,\r\n37518:34411,\r\n37519:34935,\r\n37520:35387,\r\n37521:37198,\r\n37522:37619,\r\n37523:39376,\r\n37524:27159,\r\n37525:28710,\r\n37526:29482,\r\n37527:33511,\r\n37528:33879,\r\n37529:36015,\r\n37530:19969,\r\n37531:20806,\r\n37532:20939,\r\n37533:21899,\r\n37534:23541,\r\n37535:24086,\r\n37536:24115,\r\n37537:24193,\r\n37538:24340,\r\n37539:24373,\r\n37540:24427,\r\n37541:24500,\r\n37542:25074,\r\n37543:25361,\r\n37544:26274,\r\n37545:26397,\r\n37546:28526,\r\n37547:29266,\r\n37548:30010,\r\n37549:30522,\r\n37550:32884,\r\n37551:33081,\r\n37552:33144,\r\n37553:34678,\r\n37554:35519,\r\n37555:35548,\r\n37556:36229,\r\n37557:36339,\r\n37558:37530,\r\n37559:38263,\r\n37560:38914,\r\n37561:40165,\r\n37562:21189,\r\n37563:25431,\r\n37564:30452,\r\n37565:26389,\r\n37566:27784,\r\n37567:29645,\r\n37568:36035,\r\n37569:37806,\r\n37570:38515,\r\n37571:27941,\r\n37572:22684,\r\n37573:26894,\r\n37574:27084,\r\n37575:36861,\r\n37576:37786,\r\n37577:30171,\r\n37578:36890,\r\n37579:22618,\r\n37580:26626,\r\n37581:25524,\r\n37582:27131,\r\n37583:20291,\r\n37584:28460,\r\n37585:26584,\r\n37586:36795,\r\n37587:34086,\r\n37588:32180,\r\n37589:37716,\r\n37590:26943,\r\n37591:28528,\r\n37592:22378,\r\n37593:22775,\r\n37594:23340,\r\n37595:32044,\r\n37596:29226,\r\n37597:21514,\r\n37598:37347,\r\n37599:40372,\r\n37600:20141,\r\n37601:20302,\r\n37602:20572,\r\n37603:20597,\r\n37604:21059,\r\n37605:35998,\r\n37606:21576,\r\n37607:22564,\r\n37608:23450,\r\n37609:24093,\r\n37610:24213,\r\n37611:24237,\r\n37612:24311,\r\n37613:24351,\r\n37614:24716,\r\n37615:25269,\r\n37616:25402,\r\n37617:25552,\r\n37618:26799,\r\n37619:27712,\r\n37620:30855,\r\n37621:31118,\r\n37622:31243,\r\n37623:32224,\r\n37624:33351,\r\n37625:35330,\r\n37626:35558,\r\n37627:36420,\r\n37628:36883,\r\n37696:37048,\r\n37697:37165,\r\n37698:37336,\r\n37699:40718,\r\n37700:27877,\r\n37701:25688,\r\n37702:25826,\r\n37703:25973,\r\n37704:28404,\r\n37705:30340,\r\n37706:31515,\r\n37707:36969,\r\n37708:37841,\r\n37709:28346,\r\n37710:21746,\r\n37711:24505,\r\n37712:25764,\r\n37713:36685,\r\n37714:36845,\r\n37715:37444,\r\n37716:20856,\r\n37717:22635,\r\n37718:22825,\r\n37719:23637,\r\n37720:24215,\r\n37721:28155,\r\n37722:32399,\r\n37723:29980,\r\n37724:36028,\r\n37725:36578,\r\n37726:39003,\r\n37727:28857,\r\n37728:20253,\r\n37729:27583,\r\n37730:28593,\r\n37731:30000,\r\n37732:38651,\r\n37733:20814,\r\n37734:21520,\r\n37735:22581,\r\n37736:22615,\r\n37737:22956,\r\n37738:23648,\r\n37739:24466,\r\n37740:26007,\r\n37741:26460,\r\n37742:28193,\r\n37743:30331,\r\n37744:33759,\r\n37745:36077,\r\n37746:36884,\r\n37747:37117,\r\n37748:37709,\r\n37749:30757,\r\n37750:30778,\r\n37751:21162,\r\n37752:24230,\r\n37753:22303,\r\n37754:22900,\r\n37755:24594,\r\n37756:20498,\r\n37757:20826,\r\n37758:20908,\r\n37760:20941,\r\n37761:20992,\r\n37762:21776,\r\n37763:22612,\r\n37764:22616,\r\n37765:22871,\r\n37766:23445,\r\n37767:23798,\r\n37768:23947,\r\n37769:24764,\r\n37770:25237,\r\n37771:25645,\r\n37772:26481,\r\n37773:26691,\r\n37774:26812,\r\n37775:26847,\r\n37776:30423,\r\n37777:28120,\r\n37778:28271,\r\n37779:28059,\r\n37780:28783,\r\n37781:29128,\r\n37782:24403,\r\n37783:30168,\r\n37784:31095,\r\n37785:31561,\r\n37786:31572,\r\n37787:31570,\r\n37788:31958,\r\n37789:32113,\r\n37790:21040,\r\n37791:33891,\r\n37792:34153,\r\n37793:34276,\r\n37794:35342,\r\n37795:35588,\r\n37796:35910,\r\n37797:36367,\r\n37798:36867,\r\n37799:36879,\r\n37800:37913,\r\n37801:38518,\r\n37802:38957,\r\n37803:39472,\r\n37804:38360,\r\n37805:20685,\r\n37806:21205,\r\n37807:21516,\r\n37808:22530,\r\n37809:23566,\r\n37810:24999,\r\n37811:25758,\r\n37812:27934,\r\n37813:30643,\r\n37814:31461,\r\n37815:33012,\r\n37816:33796,\r\n37817:36947,\r\n37818:37509,\r\n37819:23776,\r\n37820:40199,\r\n37821:21311,\r\n37822:24471,\r\n37823:24499,\r\n37824:28060,\r\n37825:29305,\r\n37826:30563,\r\n37827:31167,\r\n37828:31716,\r\n37829:27602,\r\n37830:29420,\r\n37831:35501,\r\n37832:26627,\r\n37833:27233,\r\n37834:20984,\r\n37835:31361,\r\n37836:26932,\r\n37837:23626,\r\n37838:40182,\r\n37839:33515,\r\n37840:23493,\r\n37841:37193,\r\n37842:28702,\r\n37843:22136,\r\n37844:23663,\r\n37845:24775,\r\n37846:25958,\r\n37847:27788,\r\n37848:35930,\r\n37849:36929,\r\n37850:38931,\r\n37851:21585,\r\n37852:26311,\r\n37853:37389,\r\n37854:22856,\r\n37855:37027,\r\n37856:20869,\r\n37857:20045,\r\n37858:20970,\r\n37859:34201,\r\n37860:35598,\r\n37861:28760,\r\n37862:25466,\r\n37863:37707,\r\n37864:26978,\r\n37865:39348,\r\n37866:32260,\r\n37867:30071,\r\n37868:21335,\r\n37869:26976,\r\n37870:36575,\r\n37871:38627,\r\n37872:27741,\r\n37873:20108,\r\n37874:23612,\r\n37875:24336,\r\n37876:36841,\r\n37877:21250,\r\n37878:36049,\r\n37879:32905,\r\n37880:34425,\r\n37881:24319,\r\n37882:26085,\r\n37883:20083,\r\n37884:20837,\r\n37952:22914,\r\n37953:23615,\r\n37954:38894,\r\n37955:20219,\r\n37956:22922,\r\n37957:24525,\r\n37958:35469,\r\n37959:28641,\r\n37960:31152,\r\n37961:31074,\r\n37962:23527,\r\n37963:33905,\r\n37964:29483,\r\n37965:29105,\r\n37966:24180,\r\n37967:24565,\r\n37968:25467,\r\n37969:25754,\r\n37970:29123,\r\n37971:31896,\r\n37972:20035,\r\n37973:24316,\r\n37974:20043,\r\n37975:22492,\r\n37976:22178,\r\n37977:24745,\r\n37978:28611,\r\n37979:32013,\r\n37980:33021,\r\n37981:33075,\r\n37982:33215,\r\n37983:36786,\r\n37984:35223,\r\n37985:34468,\r\n37986:24052,\r\n37987:25226,\r\n37988:25773,\r\n37989:35207,\r\n37990:26487,\r\n37991:27874,\r\n37992:27966,\r\n37993:29750,\r\n37994:30772,\r\n37995:23110,\r\n37996:32629,\r\n37997:33453,\r\n37998:39340,\r\n37999:20467,\r\n38000:24259,\r\n38001:25309,\r\n38002:25490,\r\n38003:25943,\r\n38004:26479,\r\n38005:30403,\r\n38006:29260,\r\n38007:32972,\r\n38008:32954,\r\n38009:36649,\r\n38010:37197,\r\n38011:20493,\r\n38012:22521,\r\n38013:23186,\r\n38014:26757,\r\n38016:26995,\r\n38017:29028,\r\n38018:29437,\r\n38019:36023,\r\n38020:22770,\r\n38021:36064,\r\n38022:38506,\r\n38023:36889,\r\n38024:34687,\r\n38025:31204,\r\n38026:30695,\r\n38027:33833,\r\n38028:20271,\r\n38029:21093,\r\n38030:21338,\r\n38031:25293,\r\n38032:26575,\r\n38033:27850,\r\n38034:30333,\r\n38035:31636,\r\n38036:31893,\r\n38037:33334,\r\n38038:34180,\r\n38039:36843,\r\n38040:26333,\r\n38041:28448,\r\n38042:29190,\r\n38043:32283,\r\n38044:33707,\r\n38045:39361,\r\n38046:40614,\r\n38047:20989,\r\n38048:31665,\r\n38049:30834,\r\n38050:31672,\r\n38051:32903,\r\n38052:31560,\r\n38053:27368,\r\n38054:24161,\r\n38055:32908,\r\n38056:30033,\r\n38057:30048,\r\n38058:20843,\r\n38059:37474,\r\n38060:28300,\r\n38061:30330,\r\n38062:37271,\r\n38063:39658,\r\n38064:20240,\r\n38065:32624,\r\n38066:25244,\r\n38067:31567,\r\n38068:38309,\r\n38069:40169,\r\n38070:22138,\r\n38071:22617,\r\n38072:34532,\r\n38073:38588,\r\n38074:20276,\r\n38075:21028,\r\n38076:21322,\r\n38077:21453,\r\n38078:21467,\r\n38079:24070,\r\n38080:25644,\r\n38081:26001,\r\n38082:26495,\r\n38083:27710,\r\n38084:27726,\r\n38085:29256,\r\n38086:29359,\r\n38087:29677,\r\n38088:30036,\r\n38089:32321,\r\n38090:33324,\r\n38091:34281,\r\n38092:36009,\r\n38093:31684,\r\n38094:37318,\r\n38095:29033,\r\n38096:38930,\r\n38097:39151,\r\n38098:25405,\r\n38099:26217,\r\n38100:30058,\r\n38101:30436,\r\n38102:30928,\r\n38103:34115,\r\n38104:34542,\r\n38105:21290,\r\n38106:21329,\r\n38107:21542,\r\n38108:22915,\r\n38109:24199,\r\n38110:24444,\r\n38111:24754,\r\n38112:25161,\r\n38113:25209,\r\n38114:25259,\r\n38115:26000,\r\n38116:27604,\r\n38117:27852,\r\n38118:30130,\r\n38119:30382,\r\n38120:30865,\r\n38121:31192,\r\n38122:32203,\r\n38123:32631,\r\n38124:32933,\r\n38125:34987,\r\n38126:35513,\r\n38127:36027,\r\n38128:36991,\r\n38129:38750,\r\n38130:39131,\r\n38131:27147,\r\n38132:31800,\r\n38133:20633,\r\n38134:23614,\r\n38135:24494,\r\n38136:26503,\r\n38137:27608,\r\n38138:29749,\r\n38139:30473,\r\n38140:32654,\r\n38208:40763,\r\n38209:26570,\r\n38210:31255,\r\n38211:21305,\r\n38212:30091,\r\n38213:39661,\r\n38214:24422,\r\n38215:33181,\r\n38216:33777,\r\n38217:32920,\r\n38218:24380,\r\n38219:24517,\r\n38220:30050,\r\n38221:31558,\r\n38222:36924,\r\n38223:26727,\r\n38224:23019,\r\n38225:23195,\r\n38226:32016,\r\n38227:30334,\r\n38228:35628,\r\n38229:20469,\r\n38230:24426,\r\n38231:27161,\r\n38232:27703,\r\n38233:28418,\r\n38234:29922,\r\n38235:31080,\r\n38236:34920,\r\n38237:35413,\r\n38238:35961,\r\n38239:24287,\r\n38240:25551,\r\n38241:30149,\r\n38242:31186,\r\n38243:33495,\r\n38244:37672,\r\n38245:37618,\r\n38246:33948,\r\n38247:34541,\r\n38248:39981,\r\n38249:21697,\r\n38250:24428,\r\n38251:25996,\r\n38252:27996,\r\n38253:28693,\r\n38254:36007,\r\n38255:36051,\r\n38256:38971,\r\n38257:25935,\r\n38258:29942,\r\n38259:19981,\r\n38260:20184,\r\n38261:22496,\r\n38262:22827,\r\n38263:23142,\r\n38264:23500,\r\n38265:20904,\r\n38266:24067,\r\n38267:24220,\r\n38268:24598,\r\n38269:25206,\r\n38270:25975,\r\n38272:26023,\r\n38273:26222,\r\n38274:28014,\r\n38275:29238,\r\n38276:31526,\r\n38277:33104,\r\n38278:33178,\r\n38279:33433,\r\n38280:35676,\r\n38281:36000,\r\n38282:36070,\r\n38283:36212,\r\n38284:38428,\r\n38285:38468,\r\n38286:20398,\r\n38287:25771,\r\n38288:27494,\r\n38289:33310,\r\n38290:33889,\r\n38291:34154,\r\n38292:37096,\r\n38293:23553,\r\n38294:26963,\r\n38295:39080,\r\n38296:33914,\r\n38297:34135,\r\n38298:20239,\r\n38299:21103,\r\n38300:24489,\r\n38301:24133,\r\n38302:26381,\r\n38303:31119,\r\n38304:33145,\r\n38305:35079,\r\n38306:35206,\r\n38307:28149,\r\n38308:24343,\r\n38309:25173,\r\n38310:27832,\r\n38311:20175,\r\n38312:29289,\r\n38313:39826,\r\n38314:20998,\r\n38315:21563,\r\n38316:22132,\r\n38317:22707,\r\n38318:24996,\r\n38319:25198,\r\n38320:28954,\r\n38321:22894,\r\n38322:31881,\r\n38323:31966,\r\n38324:32027,\r\n38325:38640,\r\n38326:25991,\r\n38327:32862,\r\n38328:19993,\r\n38329:20341,\r\n38330:20853,\r\n38331:22592,\r\n38332:24163,\r\n38333:24179,\r\n38334:24330,\r\n38335:26564,\r\n38336:20006,\r\n38337:34109,\r\n38338:38281,\r\n38339:38491,\r\n38340:31859,\r\n38341:38913,\r\n38342:20731,\r\n38343:22721,\r\n38344:30294,\r\n38345:30887,\r\n38346:21029,\r\n38347:30629,\r\n38348:34065,\r\n38349:31622,\r\n38350:20559,\r\n38351:22793,\r\n38352:29255,\r\n38353:31687,\r\n38354:32232,\r\n38355:36794,\r\n38356:36820,\r\n38357:36941,\r\n38358:20415,\r\n38359:21193,\r\n38360:23081,\r\n38361:24321,\r\n38362:38829,\r\n38363:20445,\r\n38364:33303,\r\n38365:37610,\r\n38366:22275,\r\n38367:25429,\r\n38368:27497,\r\n38369:29995,\r\n38370:35036,\r\n38371:36628,\r\n38372:31298,\r\n38373:21215,\r\n38374:22675,\r\n38375:24917,\r\n38376:25098,\r\n38377:26286,\r\n38378:27597,\r\n38379:31807,\r\n38380:33769,\r\n38381:20515,\r\n38382:20472,\r\n38383:21253,\r\n38384:21574,\r\n38385:22577,\r\n38386:22857,\r\n38387:23453,\r\n38388:23792,\r\n38389:23791,\r\n38390:23849,\r\n38391:24214,\r\n38392:25265,\r\n38393:25447,\r\n38394:25918,\r\n38395:26041,\r\n38396:26379,\r\n38464:27861,\r\n38465:27873,\r\n38466:28921,\r\n38467:30770,\r\n38468:32299,\r\n38469:32990,\r\n38470:33459,\r\n38471:33804,\r\n38472:34028,\r\n38473:34562,\r\n38474:35090,\r\n38475:35370,\r\n38476:35914,\r\n38477:37030,\r\n38478:37586,\r\n38479:39165,\r\n38480:40179,\r\n38481:40300,\r\n38482:20047,\r\n38483:20129,\r\n38484:20621,\r\n38485:21078,\r\n38486:22346,\r\n38487:22952,\r\n38488:24125,\r\n38489:24536,\r\n38490:24537,\r\n38491:25151,\r\n38492:26292,\r\n38493:26395,\r\n38494:26576,\r\n38495:26834,\r\n38496:20882,\r\n38497:32033,\r\n38498:32938,\r\n38499:33192,\r\n38500:35584,\r\n38501:35980,\r\n38502:36031,\r\n38503:37502,\r\n38504:38450,\r\n38505:21536,\r\n38506:38956,\r\n38507:21271,\r\n38508:20693,\r\n38509:21340,\r\n38510:22696,\r\n38511:25778,\r\n38512:26420,\r\n38513:29287,\r\n38514:30566,\r\n38515:31302,\r\n38516:37350,\r\n38517:21187,\r\n38518:27809,\r\n38519:27526,\r\n38520:22528,\r\n38521:24140,\r\n38522:22868,\r\n38523:26412,\r\n38524:32763,\r\n38525:20961,\r\n38526:30406,\r\n38528:25705,\r\n38529:30952,\r\n38530:39764,\r\n38531:40635,\r\n38532:22475,\r\n38533:22969,\r\n38534:26151,\r\n38535:26522,\r\n38536:27598,\r\n38537:21737,\r\n38538:27097,\r\n38539:24149,\r\n38540:33180,\r\n38541:26517,\r\n38542:39850,\r\n38543:26622,\r\n38544:40018,\r\n38545:26717,\r\n38546:20134,\r\n38547:20451,\r\n38548:21448,\r\n38549:25273,\r\n38550:26411,\r\n38551:27819,\r\n38552:36804,\r\n38553:20397,\r\n38554:32365,\r\n38555:40639,\r\n38556:19975,\r\n38557:24930,\r\n38558:28288,\r\n38559:28459,\r\n38560:34067,\r\n38561:21619,\r\n38562:26410,\r\n38563:39749,\r\n38564:24051,\r\n38565:31637,\r\n38566:23724,\r\n38567:23494,\r\n38568:34588,\r\n38569:28234,\r\n38570:34001,\r\n38571:31252,\r\n38572:33032,\r\n38573:22937,\r\n38574:31885,\r\n38575:27665,\r\n38576:30496,\r\n38577:21209,\r\n38578:22818,\r\n38579:28961,\r\n38580:29279,\r\n38581:30683,\r\n38582:38695,\r\n38583:40289,\r\n38584:26891,\r\n38585:23167,\r\n38586:23064,\r\n38587:20901,\r\n38588:21517,\r\n38589:21629,\r\n38590:26126,\r\n38591:30431,\r\n38592:36855,\r\n38593:37528,\r\n38594:40180,\r\n38595:23018,\r\n38596:29277,\r\n38597:28357,\r\n38598:20813,\r\n38599:26825,\r\n38600:32191,\r\n38601:32236,\r\n38602:38754,\r\n38603:40634,\r\n38604:25720,\r\n38605:27169,\r\n38606:33538,\r\n38607:22916,\r\n38608:23391,\r\n38609:27611,\r\n38610:29467,\r\n38611:30450,\r\n38612:32178,\r\n38613:32791,\r\n38614:33945,\r\n38615:20786,\r\n38616:26408,\r\n38617:40665,\r\n38618:30446,\r\n38619:26466,\r\n38620:21247,\r\n38621:39173,\r\n38622:23588,\r\n38623:25147,\r\n38624:31870,\r\n38625:36016,\r\n38626:21839,\r\n38627:24758,\r\n38628:32011,\r\n38629:38272,\r\n38630:21249,\r\n38631:20063,\r\n38632:20918,\r\n38633:22812,\r\n38634:29242,\r\n38635:32822,\r\n38636:37326,\r\n38637:24357,\r\n38638:30690,\r\n38639:21380,\r\n38640:24441,\r\n38641:32004,\r\n38642:34220,\r\n38643:35379,\r\n38644:36493,\r\n38645:38742,\r\n38646:26611,\r\n38647:34222,\r\n38648:37971,\r\n38649:24841,\r\n38650:24840,\r\n38651:27833,\r\n38652:30290,\r\n38720:35565,\r\n38721:36664,\r\n38722:21807,\r\n38723:20305,\r\n38724:20778,\r\n38725:21191,\r\n38726:21451,\r\n38727:23461,\r\n38728:24189,\r\n38729:24736,\r\n38730:24962,\r\n38731:25558,\r\n38732:26377,\r\n38733:26586,\r\n38734:28263,\r\n38735:28044,\r\n38736:29494,\r\n38737:29495,\r\n38738:30001,\r\n38739:31056,\r\n38740:35029,\r\n38741:35480,\r\n38742:36938,\r\n38743:37009,\r\n38744:37109,\r\n38745:38596,\r\n38746:34701,\r\n38747:22805,\r\n38748:20104,\r\n38749:20313,\r\n38750:19982,\r\n38751:35465,\r\n38752:36671,\r\n38753:38928,\r\n38754:20653,\r\n38755:24188,\r\n38756:22934,\r\n38757:23481,\r\n38758:24248,\r\n38759:25562,\r\n38760:25594,\r\n38761:25793,\r\n38762:26332,\r\n38763:26954,\r\n38764:27096,\r\n38765:27915,\r\n38766:28342,\r\n38767:29076,\r\n38768:29992,\r\n38769:31407,\r\n38770:32650,\r\n38771:32768,\r\n38772:33865,\r\n38773:33993,\r\n38774:35201,\r\n38775:35617,\r\n38776:36362,\r\n38777:36965,\r\n38778:38525,\r\n38779:39178,\r\n38780:24958,\r\n38781:25233,\r\n38782:27442,\r\n38784:27779,\r\n38785:28020,\r\n38786:32716,\r\n38787:32764,\r\n38788:28096,\r\n38789:32645,\r\n38790:34746,\r\n38791:35064,\r\n38792:26469,\r\n38793:33713,\r\n38794:38972,\r\n38795:38647,\r\n38796:27931,\r\n38797:32097,\r\n38798:33853,\r\n38799:37226,\r\n38800:20081,\r\n38801:21365,\r\n38802:23888,\r\n38803:27396,\r\n38804:28651,\r\n38805:34253,\r\n38806:34349,\r\n38807:35239,\r\n38808:21033,\r\n38809:21519,\r\n38810:23653,\r\n38811:26446,\r\n38812:26792,\r\n38813:29702,\r\n38814:29827,\r\n38815:30178,\r\n38816:35023,\r\n38817:35041,\r\n38818:37324,\r\n38819:38626,\r\n38820:38520,\r\n38821:24459,\r\n38822:29575,\r\n38823:31435,\r\n38824:33870,\r\n38825:25504,\r\n38826:30053,\r\n38827:21129,\r\n38828:27969,\r\n38829:28316,\r\n38830:29705,\r\n38831:30041,\r\n38832:30827,\r\n38833:31890,\r\n38834:38534,\r\n38835:31452,\r\n38836:40845,\r\n38837:20406,\r\n38838:24942,\r\n38839:26053,\r\n38840:34396,\r\n38841:20102,\r\n38842:20142,\r\n38843:20698,\r\n38844:20001,\r\n38845:20940,\r\n38846:23534,\r\n38847:26009,\r\n38848:26753,\r\n38849:28092,\r\n38850:29471,\r\n38851:30274,\r\n38852:30637,\r\n38853:31260,\r\n38854:31975,\r\n38855:33391,\r\n38856:35538,\r\n38857:36988,\r\n38858:37327,\r\n38859:38517,\r\n38860:38936,\r\n38861:21147,\r\n38862:32209,\r\n38863:20523,\r\n38864:21400,\r\n38865:26519,\r\n38866:28107,\r\n38867:29136,\r\n38868:29747,\r\n38869:33256,\r\n38870:36650,\r\n38871:38563,\r\n38872:40023,\r\n38873:40607,\r\n38874:29792,\r\n38875:22593,\r\n38876:28057,\r\n38877:32047,\r\n38878:39006,\r\n38879:20196,\r\n38880:20278,\r\n38881:20363,\r\n38882:20919,\r\n38883:21169,\r\n38884:23994,\r\n38885:24604,\r\n38886:29618,\r\n38887:31036,\r\n38888:33491,\r\n38889:37428,\r\n38890:38583,\r\n38891:38646,\r\n38892:38666,\r\n38893:40599,\r\n38894:40802,\r\n38895:26278,\r\n38896:27508,\r\n38897:21015,\r\n38898:21155,\r\n38899:28872,\r\n38900:35010,\r\n38901:24265,\r\n38902:24651,\r\n38903:24976,\r\n38904:28451,\r\n38905:29001,\r\n38906:31806,\r\n38907:32244,\r\n38908:32879,\r\n38976:34030,\r\n38977:36899,\r\n38978:37676,\r\n38979:21570,\r\n38980:39791,\r\n38981:27347,\r\n38982:28809,\r\n38983:36034,\r\n38984:36335,\r\n38985:38706,\r\n38986:21172,\r\n38987:23105,\r\n38988:24266,\r\n38989:24324,\r\n38990:26391,\r\n38991:27004,\r\n38992:27028,\r\n38993:28010,\r\n38994:28431,\r\n38995:29282,\r\n38996:29436,\r\n38997:31725,\r\n38998:32769,\r\n38999:32894,\r\n39000:34635,\r\n39001:37070,\r\n39002:20845,\r\n39003:40595,\r\n39004:31108,\r\n39005:32907,\r\n39006:37682,\r\n39007:35542,\r\n39008:20525,\r\n39009:21644,\r\n39010:35441,\r\n39011:27498,\r\n39012:36036,\r\n39013:33031,\r\n39014:24785,\r\n39015:26528,\r\n39016:40434,\r\n39017:20121,\r\n39018:20120,\r\n39019:39952,\r\n39020:35435,\r\n39021:34241,\r\n39022:34152,\r\n39023:26880,\r\n39024:28286,\r\n39025:30871,\r\n39026:33109,\r\n39071:24332,\r\n39072:19984,\r\n39073:19989,\r\n39074:20010,\r\n39075:20017,\r\n39076:20022,\r\n39077:20028,\r\n39078:20031,\r\n39079:20034,\r\n39080:20054,\r\n39081:20056,\r\n39082:20098,\r\n39083:20101,\r\n39084:35947,\r\n39085:20106,\r\n39086:33298,\r\n39087:24333,\r\n39088:20110,\r\n39089:20126,\r\n39090:20127,\r\n39091:20128,\r\n39092:20130,\r\n39093:20144,\r\n39094:20147,\r\n39095:20150,\r\n39096:20174,\r\n39097:20173,\r\n39098:20164,\r\n39099:20166,\r\n39100:20162,\r\n39101:20183,\r\n39102:20190,\r\n39103:20205,\r\n39104:20191,\r\n39105:20215,\r\n39106:20233,\r\n39107:20314,\r\n39108:20272,\r\n39109:20315,\r\n39110:20317,\r\n39111:20311,\r\n39112:20295,\r\n39113:20342,\r\n39114:20360,\r\n39115:20367,\r\n39116:20376,\r\n39117:20347,\r\n39118:20329,\r\n39119:20336,\r\n39120:20369,\r\n39121:20335,\r\n39122:20358,\r\n39123:20374,\r\n39124:20760,\r\n39125:20436,\r\n39126:20447,\r\n39127:20430,\r\n39128:20440,\r\n39129:20443,\r\n39130:20433,\r\n39131:20442,\r\n39132:20432,\r\n39133:20452,\r\n39134:20453,\r\n39135:20506,\r\n39136:20520,\r\n39137:20500,\r\n39138:20522,\r\n39139:20517,\r\n39140:20485,\r\n39141:20252,\r\n39142:20470,\r\n39143:20513,\r\n39144:20521,\r\n39145:20524,\r\n39146:20478,\r\n39147:20463,\r\n39148:20497,\r\n39149:20486,\r\n39150:20547,\r\n39151:20551,\r\n39152:26371,\r\n39153:20565,\r\n39154:20560,\r\n39155:20552,\r\n39156:20570,\r\n39157:20566,\r\n39158:20588,\r\n39159:20600,\r\n39160:20608,\r\n39161:20634,\r\n39162:20613,\r\n39163:20660,\r\n39164:20658,\r\n39232:20681,\r\n39233:20682,\r\n39234:20659,\r\n39235:20674,\r\n39236:20694,\r\n39237:20702,\r\n39238:20709,\r\n39239:20717,\r\n39240:20707,\r\n39241:20718,\r\n39242:20729,\r\n39243:20725,\r\n39244:20745,\r\n39245:20737,\r\n39246:20738,\r\n39247:20758,\r\n39248:20757,\r\n39249:20756,\r\n39250:20762,\r\n39251:20769,\r\n39252:20794,\r\n39253:20791,\r\n39254:20796,\r\n39255:20795,\r\n39256:20799,\r\n39257:20800,\r\n39258:20818,\r\n39259:20812,\r\n39260:20820,\r\n39261:20834,\r\n39262:31480,\r\n39263:20841,\r\n39264:20842,\r\n39265:20846,\r\n39266:20864,\r\n39267:20866,\r\n39268:22232,\r\n39269:20876,\r\n39270:20873,\r\n39271:20879,\r\n39272:20881,\r\n39273:20883,\r\n39274:20885,\r\n39275:20886,\r\n39276:20900,\r\n39277:20902,\r\n39278:20898,\r\n39279:20905,\r\n39280:20906,\r\n39281:20907,\r\n39282:20915,\r\n39283:20913,\r\n39284:20914,\r\n39285:20912,\r\n39286:20917,\r\n39287:20925,\r\n39288:20933,\r\n39289:20937,\r\n39290:20955,\r\n39291:20960,\r\n39292:34389,\r\n39293:20969,\r\n39294:20973,\r\n39296:20976,\r\n39297:20981,\r\n39298:20990,\r\n39299:20996,\r\n39300:21003,\r\n39301:21012,\r\n39302:21006,\r\n39303:21031,\r\n39304:21034,\r\n39305:21038,\r\n39306:21043,\r\n39307:21049,\r\n39308:21071,\r\n39309:21060,\r\n39310:21067,\r\n39311:21068,\r\n39312:21086,\r\n39313:21076,\r\n39314:21098,\r\n39315:21108,\r\n39316:21097,\r\n39317:21107,\r\n39318:21119,\r\n39319:21117,\r\n39320:21133,\r\n39321:21140,\r\n39322:21138,\r\n39323:21105,\r\n39324:21128,\r\n39325:21137,\r\n39326:36776,\r\n39327:36775,\r\n39328:21164,\r\n39329:21165,\r\n39330:21180,\r\n39331:21173,\r\n39332:21185,\r\n39333:21197,\r\n39334:21207,\r\n39335:21214,\r\n39336:21219,\r\n39337:21222,\r\n39338:39149,\r\n39339:21216,\r\n39340:21235,\r\n39341:21237,\r\n39342:21240,\r\n39343:21241,\r\n39344:21254,\r\n39345:21256,\r\n39346:30008,\r\n39347:21261,\r\n39348:21264,\r\n39349:21263,\r\n39350:21269,\r\n39351:21274,\r\n39352:21283,\r\n39353:21295,\r\n39354:21297,\r\n39355:21299,\r\n39356:21304,\r\n39357:21312,\r\n39358:21318,\r\n39359:21317,\r\n39360:19991,\r\n39361:21321,\r\n39362:21325,\r\n39363:20950,\r\n39364:21342,\r\n39365:21353,\r\n39366:21358,\r\n39367:22808,\r\n39368:21371,\r\n39369:21367,\r\n39370:21378,\r\n39371:21398,\r\n39372:21408,\r\n39373:21414,\r\n39374:21413,\r\n39375:21422,\r\n39376:21424,\r\n39377:21430,\r\n39378:21443,\r\n39379:31762,\r\n39380:38617,\r\n39381:21471,\r\n39382:26364,\r\n39383:29166,\r\n39384:21486,\r\n39385:21480,\r\n39386:21485,\r\n39387:21498,\r\n39388:21505,\r\n39389:21565,\r\n39390:21568,\r\n39391:21548,\r\n39392:21549,\r\n39393:21564,\r\n39394:21550,\r\n39395:21558,\r\n39396:21545,\r\n39397:21533,\r\n39398:21582,\r\n39399:21647,\r\n39400:21621,\r\n39401:21646,\r\n39402:21599,\r\n39403:21617,\r\n39404:21623,\r\n39405:21616,\r\n39406:21650,\r\n39407:21627,\r\n39408:21632,\r\n39409:21622,\r\n39410:21636,\r\n39411:21648,\r\n39412:21638,\r\n39413:21703,\r\n39414:21666,\r\n39415:21688,\r\n39416:21669,\r\n39417:21676,\r\n39418:21700,\r\n39419:21704,\r\n39420:21672,\r\n39488:21675,\r\n39489:21698,\r\n39490:21668,\r\n39491:21694,\r\n39492:21692,\r\n39493:21720,\r\n39494:21733,\r\n39495:21734,\r\n39496:21775,\r\n39497:21780,\r\n39498:21757,\r\n39499:21742,\r\n39500:21741,\r\n39501:21754,\r\n39502:21730,\r\n39503:21817,\r\n39504:21824,\r\n39505:21859,\r\n39506:21836,\r\n39507:21806,\r\n39508:21852,\r\n39509:21829,\r\n39510:21846,\r\n39511:21847,\r\n39512:21816,\r\n39513:21811,\r\n39514:21853,\r\n39515:21913,\r\n39516:21888,\r\n39517:21679,\r\n39518:21898,\r\n39519:21919,\r\n39520:21883,\r\n39521:21886,\r\n39522:21912,\r\n39523:21918,\r\n39524:21934,\r\n39525:21884,\r\n39526:21891,\r\n39527:21929,\r\n39528:21895,\r\n39529:21928,\r\n39530:21978,\r\n39531:21957,\r\n39532:21983,\r\n39533:21956,\r\n39534:21980,\r\n39535:21988,\r\n39536:21972,\r\n39537:22036,\r\n39538:22007,\r\n39539:22038,\r\n39540:22014,\r\n39541:22013,\r\n39542:22043,\r\n39543:22009,\r\n39544:22094,\r\n39545:22096,\r\n39546:29151,\r\n39547:22068,\r\n39548:22070,\r\n39549:22066,\r\n39550:22072,\r\n39552:22123,\r\n39553:22116,\r\n39554:22063,\r\n39555:22124,\r\n39556:22122,\r\n39557:22150,\r\n39558:22144,\r\n39559:22154,\r\n39560:22176,\r\n39561:22164,\r\n39562:22159,\r\n39563:22181,\r\n39564:22190,\r\n39565:22198,\r\n39566:22196,\r\n39567:22210,\r\n39568:22204,\r\n39569:22209,\r\n39570:22211,\r\n39571:22208,\r\n39572:22216,\r\n39573:22222,\r\n39574:22225,\r\n39575:22227,\r\n39576:22231,\r\n39577:22254,\r\n39578:22265,\r\n39579:22272,\r\n39580:22271,\r\n39581:22276,\r\n39582:22281,\r\n39583:22280,\r\n39584:22283,\r\n39585:22285,\r\n39586:22291,\r\n39587:22296,\r\n39588:22294,\r\n39589:21959,\r\n39590:22300,\r\n39591:22310,\r\n39592:22327,\r\n39593:22328,\r\n39594:22350,\r\n39595:22331,\r\n39596:22336,\r\n39597:22351,\r\n39598:22377,\r\n39599:22464,\r\n39600:22408,\r\n39601:22369,\r\n39602:22399,\r\n39603:22409,\r\n39604:22419,\r\n39605:22432,\r\n39606:22451,\r\n39607:22436,\r\n39608:22442,\r\n39609:22448,\r\n39610:22467,\r\n39611:22470,\r\n39612:22484,\r\n39613:22482,\r\n39614:22483,\r\n39615:22538,\r\n39616:22486,\r\n39617:22499,\r\n39618:22539,\r\n39619:22553,\r\n39620:22557,\r\n39621:22642,\r\n39622:22561,\r\n39623:22626,\r\n39624:22603,\r\n39625:22640,\r\n39626:27584,\r\n39627:22610,\r\n39628:22589,\r\n39629:22649,\r\n39630:22661,\r\n39631:22713,\r\n39632:22687,\r\n39633:22699,\r\n39634:22714,\r\n39635:22750,\r\n39636:22715,\r\n39637:22712,\r\n39638:22702,\r\n39639:22725,\r\n39640:22739,\r\n39641:22737,\r\n39642:22743,\r\n39643:22745,\r\n39644:22744,\r\n39645:22757,\r\n39646:22748,\r\n39647:22756,\r\n39648:22751,\r\n39649:22767,\r\n39650:22778,\r\n39651:22777,\r\n39652:22779,\r\n39653:22780,\r\n39654:22781,\r\n39655:22786,\r\n39656:22794,\r\n39657:22800,\r\n39658:22811,\r\n39659:26790,\r\n39660:22821,\r\n39661:22828,\r\n39662:22829,\r\n39663:22834,\r\n39664:22840,\r\n39665:22846,\r\n39666:31442,\r\n39667:22869,\r\n39668:22864,\r\n39669:22862,\r\n39670:22874,\r\n39671:22872,\r\n39672:22882,\r\n39673:22880,\r\n39674:22887,\r\n39675:22892,\r\n39676:22889,\r\n39744:22904,\r\n39745:22913,\r\n39746:22941,\r\n39747:20318,\r\n39748:20395,\r\n39749:22947,\r\n39750:22962,\r\n39751:22982,\r\n39752:23016,\r\n39753:23004,\r\n39754:22925,\r\n39755:23001,\r\n39756:23002,\r\n39757:23077,\r\n39758:23071,\r\n39759:23057,\r\n39760:23068,\r\n39761:23049,\r\n39762:23066,\r\n39763:23104,\r\n39764:23148,\r\n39765:23113,\r\n39766:23093,\r\n39767:23094,\r\n39768:23138,\r\n39769:23146,\r\n39770:23194,\r\n39771:23228,\r\n39772:23230,\r\n39773:23243,\r\n39774:23234,\r\n39775:23229,\r\n39776:23267,\r\n39777:23255,\r\n39778:23270,\r\n39779:23273,\r\n39780:23254,\r\n39781:23290,\r\n39782:23291,\r\n39783:23308,\r\n39784:23307,\r\n39785:23318,\r\n39786:23346,\r\n39787:23248,\r\n39788:23338,\r\n39789:23350,\r\n39790:23358,\r\n39791:23363,\r\n39792:23365,\r\n39793:23360,\r\n39794:23377,\r\n39795:23381,\r\n39796:23386,\r\n39797:23387,\r\n39798:23397,\r\n39799:23401,\r\n39800:23408,\r\n39801:23411,\r\n39802:23413,\r\n39803:23416,\r\n39804:25992,\r\n39805:23418,\r\n39806:23424,\r\n39808:23427,\r\n39809:23462,\r\n39810:23480,\r\n39811:23491,\r\n39812:23495,\r\n39813:23497,\r\n39814:23508,\r\n39815:23504,\r\n39816:23524,\r\n39817:23526,\r\n39818:23522,\r\n39819:23518,\r\n39820:23525,\r\n39821:23531,\r\n39822:23536,\r\n39823:23542,\r\n39824:23539,\r\n39825:23557,\r\n39826:23559,\r\n39827:23560,\r\n39828:23565,\r\n39829:23571,\r\n39830:23584,\r\n39831:23586,\r\n39832:23592,\r\n39833:23608,\r\n39834:23609,\r\n39835:23617,\r\n39836:23622,\r\n39837:23630,\r\n39838:23635,\r\n39839:23632,\r\n39840:23631,\r\n39841:23409,\r\n39842:23660,\r\n39843:23662,\r\n39844:20066,\r\n39845:23670,\r\n39846:23673,\r\n39847:23692,\r\n39848:23697,\r\n39849:23700,\r\n39850:22939,\r\n39851:23723,\r\n39852:23739,\r\n39853:23734,\r\n39854:23740,\r\n39855:23735,\r\n39856:23749,\r\n39857:23742,\r\n39858:23751,\r\n39859:23769,\r\n39860:23785,\r\n39861:23805,\r\n39862:23802,\r\n39863:23789,\r\n39864:23948,\r\n39865:23786,\r\n39866:23819,\r\n39867:23829,\r\n39868:23831,\r\n39869:23900,\r\n39870:23839,\r\n39871:23835,\r\n39872:23825,\r\n39873:23828,\r\n39874:23842,\r\n39875:23834,\r\n39876:23833,\r\n39877:23832,\r\n39878:23884,\r\n39879:23890,\r\n39880:23886,\r\n39881:23883,\r\n39882:23916,\r\n39883:23923,\r\n39884:23926,\r\n39885:23943,\r\n39886:23940,\r\n39887:23938,\r\n39888:23970,\r\n39889:23965,\r\n39890:23980,\r\n39891:23982,\r\n39892:23997,\r\n39893:23952,\r\n39894:23991,\r\n39895:23996,\r\n39896:24009,\r\n39897:24013,\r\n39898:24019,\r\n39899:24018,\r\n39900:24022,\r\n39901:24027,\r\n39902:24043,\r\n39903:24050,\r\n39904:24053,\r\n39905:24075,\r\n39906:24090,\r\n39907:24089,\r\n39908:24081,\r\n39909:24091,\r\n39910:24118,\r\n39911:24119,\r\n39912:24132,\r\n39913:24131,\r\n39914:24128,\r\n39915:24142,\r\n39916:24151,\r\n39917:24148,\r\n39918:24159,\r\n39919:24162,\r\n39920:24164,\r\n39921:24135,\r\n39922:24181,\r\n39923:24182,\r\n39924:24186,\r\n39925:40636,\r\n39926:24191,\r\n39927:24224,\r\n39928:24257,\r\n39929:24258,\r\n39930:24264,\r\n39931:24272,\r\n39932:24271,\r\n40000:24278,\r\n40001:24291,\r\n40002:24285,\r\n40003:24282,\r\n40004:24283,\r\n40005:24290,\r\n40006:24289,\r\n40007:24296,\r\n40008:24297,\r\n40009:24300,\r\n40010:24305,\r\n40011:24307,\r\n40012:24304,\r\n40013:24308,\r\n40014:24312,\r\n40015:24318,\r\n40016:24323,\r\n40017:24329,\r\n40018:24413,\r\n40019:24412,\r\n40020:24331,\r\n40021:24337,\r\n40022:24342,\r\n40023:24361,\r\n40024:24365,\r\n40025:24376,\r\n40026:24385,\r\n40027:24392,\r\n40028:24396,\r\n40029:24398,\r\n40030:24367,\r\n40031:24401,\r\n40032:24406,\r\n40033:24407,\r\n40034:24409,\r\n40035:24417,\r\n40036:24429,\r\n40037:24435,\r\n40038:24439,\r\n40039:24451,\r\n40040:24450,\r\n40041:24447,\r\n40042:24458,\r\n40043:24456,\r\n40044:24465,\r\n40045:24455,\r\n40046:24478,\r\n40047:24473,\r\n40048:24472,\r\n40049:24480,\r\n40050:24488,\r\n40051:24493,\r\n40052:24508,\r\n40053:24534,\r\n40054:24571,\r\n40055:24548,\r\n40056:24568,\r\n40057:24561,\r\n40058:24541,\r\n40059:24755,\r\n40060:24575,\r\n40061:24609,\r\n40062:24672,\r\n40064:24601,\r\n40065:24592,\r\n40066:24617,\r\n40067:24590,\r\n40068:24625,\r\n40069:24603,\r\n40070:24597,\r\n40071:24619,\r\n40072:24614,\r\n40073:24591,\r\n40074:24634,\r\n40075:24666,\r\n40076:24641,\r\n40077:24682,\r\n40078:24695,\r\n40079:24671,\r\n40080:24650,\r\n40081:24646,\r\n40082:24653,\r\n40083:24675,\r\n40084:24643,\r\n40085:24676,\r\n40086:24642,\r\n40087:24684,\r\n40088:24683,\r\n40089:24665,\r\n40090:24705,\r\n40091:24717,\r\n40092:24807,\r\n40093:24707,\r\n40094:24730,\r\n40095:24708,\r\n40096:24731,\r\n40097:24726,\r\n40098:24727,\r\n40099:24722,\r\n40100:24743,\r\n40101:24715,\r\n40102:24801,\r\n40103:24760,\r\n40104:24800,\r\n40105:24787,\r\n40106:24756,\r\n40107:24560,\r\n40108:24765,\r\n40109:24774,\r\n40110:24757,\r\n40111:24792,\r\n40112:24909,\r\n40113:24853,\r\n40114:24838,\r\n40115:24822,\r\n40116:24823,\r\n40117:24832,\r\n40118:24820,\r\n40119:24826,\r\n40120:24835,\r\n40121:24865,\r\n40122:24827,\r\n40123:24817,\r\n40124:24845,\r\n40125:24846,\r\n40126:24903,\r\n40127:24894,\r\n40128:24872,\r\n40129:24871,\r\n40130:24906,\r\n40131:24895,\r\n40132:24892,\r\n40133:24876,\r\n40134:24884,\r\n40135:24893,\r\n40136:24898,\r\n40137:24900,\r\n40138:24947,\r\n40139:24951,\r\n40140:24920,\r\n40141:24921,\r\n40142:24922,\r\n40143:24939,\r\n40144:24948,\r\n40145:24943,\r\n40146:24933,\r\n40147:24945,\r\n40148:24927,\r\n40149:24925,\r\n40150:24915,\r\n40151:24949,\r\n40152:24985,\r\n40153:24982,\r\n40154:24967,\r\n40155:25004,\r\n40156:24980,\r\n40157:24986,\r\n40158:24970,\r\n40159:24977,\r\n40160:25003,\r\n40161:25006,\r\n40162:25036,\r\n40163:25034,\r\n40164:25033,\r\n40165:25079,\r\n40166:25032,\r\n40167:25027,\r\n40168:25030,\r\n40169:25018,\r\n40170:25035,\r\n40171:32633,\r\n40172:25037,\r\n40173:25062,\r\n40174:25059,\r\n40175:25078,\r\n40176:25082,\r\n40177:25076,\r\n40178:25087,\r\n40179:25085,\r\n40180:25084,\r\n40181:25086,\r\n40182:25088,\r\n40183:25096,\r\n40184:25097,\r\n40185:25101,\r\n40186:25100,\r\n40187:25108,\r\n40188:25115,\r\n40256:25118,\r\n40257:25121,\r\n40258:25130,\r\n40259:25134,\r\n40260:25136,\r\n40261:25138,\r\n40262:25139,\r\n40263:25153,\r\n40264:25166,\r\n40265:25182,\r\n40266:25187,\r\n40267:25179,\r\n40268:25184,\r\n40269:25192,\r\n40270:25212,\r\n40271:25218,\r\n40272:25225,\r\n40273:25214,\r\n40274:25234,\r\n40275:25235,\r\n40276:25238,\r\n40277:25300,\r\n40278:25219,\r\n40279:25236,\r\n40280:25303,\r\n40281:25297,\r\n40282:25275,\r\n40283:25295,\r\n40284:25343,\r\n40285:25286,\r\n40286:25812,\r\n40287:25288,\r\n40288:25308,\r\n40289:25292,\r\n40290:25290,\r\n40291:25282,\r\n40292:25287,\r\n40293:25243,\r\n40294:25289,\r\n40295:25356,\r\n40296:25326,\r\n40297:25329,\r\n40298:25383,\r\n40299:25346,\r\n40300:25352,\r\n40301:25327,\r\n40302:25333,\r\n40303:25424,\r\n40304:25406,\r\n40305:25421,\r\n40306:25628,\r\n40307:25423,\r\n40308:25494,\r\n40309:25486,\r\n40310:25472,\r\n40311:25515,\r\n40312:25462,\r\n40313:25507,\r\n40314:25487,\r\n40315:25481,\r\n40316:25503,\r\n40317:25525,\r\n40318:25451,\r\n40320:25449,\r\n40321:25534,\r\n40322:25577,\r\n40323:25536,\r\n40324:25542,\r\n40325:25571,\r\n40326:25545,\r\n40327:25554,\r\n40328:25590,\r\n40329:25540,\r\n40330:25622,\r\n40331:25652,\r\n40332:25606,\r\n40333:25619,\r\n40334:25638,\r\n40335:25654,\r\n40336:25885,\r\n40337:25623,\r\n40338:25640,\r\n40339:25615,\r\n40340:25703,\r\n40341:25711,\r\n40342:25718,\r\n40343:25678,\r\n40344:25898,\r\n40345:25749,\r\n40346:25747,\r\n40347:25765,\r\n40348:25769,\r\n40349:25736,\r\n40350:25788,\r\n40351:25818,\r\n40352:25810,\r\n40353:25797,\r\n40354:25799,\r\n40355:25787,\r\n40356:25816,\r\n40357:25794,\r\n40358:25841,\r\n40359:25831,\r\n40360:33289,\r\n40361:25824,\r\n40362:25825,\r\n40363:25260,\r\n40364:25827,\r\n40365:25839,\r\n40366:25900,\r\n40367:25846,\r\n40368:25844,\r\n40369:25842,\r\n40370:25850,\r\n40371:25856,\r\n40372:25853,\r\n40373:25880,\r\n40374:25884,\r\n40375:25861,\r\n40376:25892,\r\n40377:25891,\r\n40378:25899,\r\n40379:25908,\r\n40380:25909,\r\n40381:25911,\r\n40382:25910,\r\n40383:25912,\r\n40384:30027,\r\n40385:25928,\r\n40386:25942,\r\n40387:25941,\r\n40388:25933,\r\n40389:25944,\r\n40390:25950,\r\n40391:25949,\r\n40392:25970,\r\n40393:25976,\r\n40394:25986,\r\n40395:25987,\r\n40396:35722,\r\n40397:26011,\r\n40398:26015,\r\n40399:26027,\r\n40400:26039,\r\n40401:26051,\r\n40402:26054,\r\n40403:26049,\r\n40404:26052,\r\n40405:26060,\r\n40406:26066,\r\n40407:26075,\r\n40408:26073,\r\n40409:26080,\r\n40410:26081,\r\n40411:26097,\r\n40412:26482,\r\n40413:26122,\r\n40414:26115,\r\n40415:26107,\r\n40416:26483,\r\n40417:26165,\r\n40418:26166,\r\n40419:26164,\r\n40420:26140,\r\n40421:26191,\r\n40422:26180,\r\n40423:26185,\r\n40424:26177,\r\n40425:26206,\r\n40426:26205,\r\n40427:26212,\r\n40428:26215,\r\n40429:26216,\r\n40430:26207,\r\n40431:26210,\r\n40432:26224,\r\n40433:26243,\r\n40434:26248,\r\n40435:26254,\r\n40436:26249,\r\n40437:26244,\r\n40438:26264,\r\n40439:26269,\r\n40440:26305,\r\n40441:26297,\r\n40442:26313,\r\n40443:26302,\r\n40444:26300,\r\n40512:26308,\r\n40513:26296,\r\n40514:26326,\r\n40515:26330,\r\n40516:26336,\r\n40517:26175,\r\n40518:26342,\r\n40519:26345,\r\n40520:26352,\r\n40521:26357,\r\n40522:26359,\r\n40523:26383,\r\n40524:26390,\r\n40525:26398,\r\n40526:26406,\r\n40527:26407,\r\n40528:38712,\r\n40529:26414,\r\n40530:26431,\r\n40531:26422,\r\n40532:26433,\r\n40533:26424,\r\n40534:26423,\r\n40535:26438,\r\n40536:26462,\r\n40537:26464,\r\n40538:26457,\r\n40539:26467,\r\n40540:26468,\r\n40541:26505,\r\n40542:26480,\r\n40543:26537,\r\n40544:26492,\r\n40545:26474,\r\n40546:26508,\r\n40547:26507,\r\n40548:26534,\r\n40549:26529,\r\n40550:26501,\r\n40551:26551,\r\n40552:26607,\r\n40553:26548,\r\n40554:26604,\r\n40555:26547,\r\n40556:26601,\r\n40557:26552,\r\n40558:26596,\r\n40559:26590,\r\n40560:26589,\r\n40561:26594,\r\n40562:26606,\r\n40563:26553,\r\n40564:26574,\r\n40565:26566,\r\n40566:26599,\r\n40567:27292,\r\n40568:26654,\r\n40569:26694,\r\n40570:26665,\r\n40571:26688,\r\n40572:26701,\r\n40573:26674,\r\n40574:26702,\r\n40576:26803,\r\n40577:26667,\r\n40578:26713,\r\n40579:26723,\r\n40580:26743,\r\n40581:26751,\r\n40582:26783,\r\n40583:26767,\r\n40584:26797,\r\n40585:26772,\r\n40586:26781,\r\n40587:26779,\r\n40588:26755,\r\n40589:27310,\r\n40590:26809,\r\n40591:26740,\r\n40592:26805,\r\n40593:26784,\r\n40594:26810,\r\n40595:26895,\r\n40596:26765,\r\n40597:26750,\r\n40598:26881,\r\n40599:26826,\r\n40600:26888,\r\n40601:26840,\r\n40602:26914,\r\n40603:26918,\r\n40604:26849,\r\n40605:26892,\r\n40606:26829,\r\n40607:26836,\r\n40608:26855,\r\n40609:26837,\r\n40610:26934,\r\n40611:26898,\r\n40612:26884,\r\n40613:26839,\r\n40614:26851,\r\n40615:26917,\r\n40616:26873,\r\n40617:26848,\r\n40618:26863,\r\n40619:26920,\r\n40620:26922,\r\n40621:26906,\r\n40622:26915,\r\n40623:26913,\r\n40624:26822,\r\n40625:27001,\r\n40626:26999,\r\n40627:26972,\r\n40628:27000,\r\n40629:26987,\r\n40630:26964,\r\n40631:27006,\r\n40632:26990,\r\n40633:26937,\r\n40634:26996,\r\n40635:26941,\r\n40636:26969,\r\n40637:26928,\r\n40638:26977,\r\n40639:26974,\r\n40640:26973,\r\n40641:27009,\r\n40642:26986,\r\n40643:27058,\r\n40644:27054,\r\n40645:27088,\r\n40646:27071,\r\n40647:27073,\r\n40648:27091,\r\n40649:27070,\r\n40650:27086,\r\n40651:23528,\r\n40652:27082,\r\n40653:27101,\r\n40654:27067,\r\n40655:27075,\r\n40656:27047,\r\n40657:27182,\r\n40658:27025,\r\n40659:27040,\r\n40660:27036,\r\n40661:27029,\r\n40662:27060,\r\n40663:27102,\r\n40664:27112,\r\n40665:27138,\r\n40666:27163,\r\n40667:27135,\r\n40668:27402,\r\n40669:27129,\r\n40670:27122,\r\n40671:27111,\r\n40672:27141,\r\n40673:27057,\r\n40674:27166,\r\n40675:27117,\r\n40676:27156,\r\n40677:27115,\r\n40678:27146,\r\n40679:27154,\r\n40680:27329,\r\n40681:27171,\r\n40682:27155,\r\n40683:27204,\r\n40684:27148,\r\n40685:27250,\r\n40686:27190,\r\n40687:27256,\r\n40688:27207,\r\n40689:27234,\r\n40690:27225,\r\n40691:27238,\r\n40692:27208,\r\n40693:27192,\r\n40694:27170,\r\n40695:27280,\r\n40696:27277,\r\n40697:27296,\r\n40698:27268,\r\n40699:27298,\r\n40700:27299,\r\n40768:27287,\r\n40769:34327,\r\n40770:27323,\r\n40771:27331,\r\n40772:27330,\r\n40773:27320,\r\n40774:27315,\r\n40775:27308,\r\n40776:27358,\r\n40777:27345,\r\n40778:27359,\r\n40779:27306,\r\n40780:27354,\r\n40781:27370,\r\n40782:27387,\r\n40783:27397,\r\n40784:34326,\r\n40785:27386,\r\n40786:27410,\r\n40787:27414,\r\n40788:39729,\r\n40789:27423,\r\n40790:27448,\r\n40791:27447,\r\n40792:30428,\r\n40793:27449,\r\n40794:39150,\r\n40795:27463,\r\n40796:27459,\r\n40797:27465,\r\n40798:27472,\r\n40799:27481,\r\n40800:27476,\r\n40801:27483,\r\n40802:27487,\r\n40803:27489,\r\n40804:27512,\r\n40805:27513,\r\n40806:27519,\r\n40807:27520,\r\n40808:27524,\r\n40809:27523,\r\n40810:27533,\r\n40811:27544,\r\n40812:27541,\r\n40813:27550,\r\n40814:27556,\r\n40815:27562,\r\n40816:27563,\r\n40817:27567,\r\n40818:27570,\r\n40819:27569,\r\n40820:27571,\r\n40821:27575,\r\n40822:27580,\r\n40823:27590,\r\n40824:27595,\r\n40825:27603,\r\n40826:27615,\r\n40827:27628,\r\n40828:27627,\r\n40829:27635,\r\n40830:27631,\r\n40832:40638,\r\n40833:27656,\r\n40834:27667,\r\n40835:27668,\r\n40836:27675,\r\n40837:27684,\r\n40838:27683,\r\n40839:27742,\r\n40840:27733,\r\n40841:27746,\r\n40842:27754,\r\n40843:27778,\r\n40844:27789,\r\n40845:27802,\r\n40846:27777,\r\n40847:27803,\r\n40848:27774,\r\n40849:27752,\r\n40850:27763,\r\n40851:27794,\r\n40852:27792,\r\n40853:27844,\r\n40854:27889,\r\n40855:27859,\r\n40856:27837,\r\n40857:27863,\r\n40858:27845,\r\n40859:27869,\r\n40860:27822,\r\n40861:27825,\r\n40862:27838,\r\n40863:27834,\r\n40864:27867,\r\n40865:27887,\r\n40866:27865,\r\n40867:27882,\r\n40868:27935,\r\n40869:34893,\r\n40870:27958,\r\n40871:27947,\r\n40872:27965,\r\n40873:27960,\r\n40874:27929,\r\n40875:27957,\r\n40876:27955,\r\n40877:27922,\r\n40878:27916,\r\n40879:28003,\r\n40880:28051,\r\n40881:28004,\r\n40882:27994,\r\n40883:28025,\r\n40884:27993,\r\n40885:28046,\r\n40886:28053,\r\n40887:28644,\r\n40888:28037,\r\n40889:28153,\r\n40890:28181,\r\n40891:28170,\r\n40892:28085,\r\n40893:28103,\r\n40894:28134,\r\n40895:28088,\r\n40896:28102,\r\n40897:28140,\r\n40898:28126,\r\n40899:28108,\r\n40900:28136,\r\n40901:28114,\r\n40902:28101,\r\n40903:28154,\r\n40904:28121,\r\n40905:28132,\r\n40906:28117,\r\n40907:28138,\r\n40908:28142,\r\n40909:28205,\r\n40910:28270,\r\n40911:28206,\r\n40912:28185,\r\n40913:28274,\r\n40914:28255,\r\n40915:28222,\r\n40916:28195,\r\n40917:28267,\r\n40918:28203,\r\n40919:28278,\r\n40920:28237,\r\n40921:28191,\r\n40922:28227,\r\n40923:28218,\r\n40924:28238,\r\n40925:28196,\r\n40926:28415,\r\n40927:28189,\r\n40928:28216,\r\n40929:28290,\r\n40930:28330,\r\n40931:28312,\r\n40932:28361,\r\n40933:28343,\r\n40934:28371,\r\n40935:28349,\r\n40936:28335,\r\n40937:28356,\r\n40938:28338,\r\n40939:28372,\r\n40940:28373,\r\n40941:28303,\r\n40942:28325,\r\n40943:28354,\r\n40944:28319,\r\n40945:28481,\r\n40946:28433,\r\n40947:28748,\r\n40948:28396,\r\n40949:28408,\r\n40950:28414,\r\n40951:28479,\r\n40952:28402,\r\n40953:28465,\r\n40954:28399,\r\n40955:28466,\r\n40956:28364,\r\n57408:28478,\r\n57409:28435,\r\n57410:28407,\r\n57411:28550,\r\n57412:28538,\r\n57413:28536,\r\n57414:28545,\r\n57415:28544,\r\n57416:28527,\r\n57417:28507,\r\n57418:28659,\r\n57419:28525,\r\n57420:28546,\r\n57421:28540,\r\n57422:28504,\r\n57423:28558,\r\n57424:28561,\r\n57425:28610,\r\n57426:28518,\r\n57427:28595,\r\n57428:28579,\r\n57429:28577,\r\n57430:28580,\r\n57431:28601,\r\n57432:28614,\r\n57433:28586,\r\n57434:28639,\r\n57435:28629,\r\n57436:28652,\r\n57437:28628,\r\n57438:28632,\r\n57439:28657,\r\n57440:28654,\r\n57441:28635,\r\n57442:28681,\r\n57443:28683,\r\n57444:28666,\r\n57445:28689,\r\n57446:28673,\r\n57447:28687,\r\n57448:28670,\r\n57449:28699,\r\n57450:28698,\r\n57451:28532,\r\n57452:28701,\r\n57453:28696,\r\n57454:28703,\r\n57455:28720,\r\n57456:28734,\r\n57457:28722,\r\n57458:28753,\r\n57459:28771,\r\n57460:28825,\r\n57461:28818,\r\n57462:28847,\r\n57463:28913,\r\n57464:28844,\r\n57465:28856,\r\n57466:28851,\r\n57467:28846,\r\n57468:28895,\r\n57469:28875,\r\n57470:28893,\r\n57472:28889,\r\n57473:28937,\r\n57474:28925,\r\n57475:28956,\r\n57476:28953,\r\n57477:29029,\r\n57478:29013,\r\n57479:29064,\r\n57480:29030,\r\n57481:29026,\r\n57482:29004,\r\n57483:29014,\r\n57484:29036,\r\n57485:29071,\r\n57486:29179,\r\n57487:29060,\r\n57488:29077,\r\n57489:29096,\r\n57490:29100,\r\n57491:29143,\r\n57492:29113,\r\n57493:29118,\r\n57494:29138,\r\n57495:29129,\r\n57496:29140,\r\n57497:29134,\r\n57498:29152,\r\n57499:29164,\r\n57500:29159,\r\n57501:29173,\r\n57502:29180,\r\n57503:29177,\r\n57504:29183,\r\n57505:29197,\r\n57506:29200,\r\n57507:29211,\r\n57508:29224,\r\n57509:29229,\r\n57510:29228,\r\n57511:29232,\r\n57512:29234,\r\n57513:29243,\r\n57514:29244,\r\n57515:29247,\r\n57516:29248,\r\n57517:29254,\r\n57518:29259,\r\n57519:29272,\r\n57520:29300,\r\n57521:29310,\r\n57522:29314,\r\n57523:29313,\r\n57524:29319,\r\n57525:29330,\r\n57526:29334,\r\n57527:29346,\r\n57528:29351,\r\n57529:29369,\r\n57530:29362,\r\n57531:29379,\r\n57532:29382,\r\n57533:29380,\r\n57534:29390,\r\n57535:29394,\r\n57536:29410,\r\n57537:29408,\r\n57538:29409,\r\n57539:29433,\r\n57540:29431,\r\n57541:20495,\r\n57542:29463,\r\n57543:29450,\r\n57544:29468,\r\n57545:29462,\r\n57546:29469,\r\n57547:29492,\r\n57548:29487,\r\n57549:29481,\r\n57550:29477,\r\n57551:29502,\r\n57552:29518,\r\n57553:29519,\r\n57554:40664,\r\n57555:29527,\r\n57556:29546,\r\n57557:29544,\r\n57558:29552,\r\n57559:29560,\r\n57560:29557,\r\n57561:29563,\r\n57562:29562,\r\n57563:29640,\r\n57564:29619,\r\n57565:29646,\r\n57566:29627,\r\n57567:29632,\r\n57568:29669,\r\n57569:29678,\r\n57570:29662,\r\n57571:29858,\r\n57572:29701,\r\n57573:29807,\r\n57574:29733,\r\n57575:29688,\r\n57576:29746,\r\n57577:29754,\r\n57578:29781,\r\n57579:29759,\r\n57580:29791,\r\n57581:29785,\r\n57582:29761,\r\n57583:29788,\r\n57584:29801,\r\n57585:29808,\r\n57586:29795,\r\n57587:29802,\r\n57588:29814,\r\n57589:29822,\r\n57590:29835,\r\n57591:29854,\r\n57592:29863,\r\n57593:29898,\r\n57594:29903,\r\n57595:29908,\r\n57596:29681,\r\n57664:29920,\r\n57665:29923,\r\n57666:29927,\r\n57667:29929,\r\n57668:29934,\r\n57669:29938,\r\n57670:29936,\r\n57671:29937,\r\n57672:29944,\r\n57673:29943,\r\n57674:29956,\r\n57675:29955,\r\n57676:29957,\r\n57677:29964,\r\n57678:29966,\r\n57679:29965,\r\n57680:29973,\r\n57681:29971,\r\n57682:29982,\r\n57683:29990,\r\n57684:29996,\r\n57685:30012,\r\n57686:30020,\r\n57687:30029,\r\n57688:30026,\r\n57689:30025,\r\n57690:30043,\r\n57691:30022,\r\n57692:30042,\r\n57693:30057,\r\n57694:30052,\r\n57695:30055,\r\n57696:30059,\r\n57697:30061,\r\n57698:30072,\r\n57699:30070,\r\n57700:30086,\r\n57701:30087,\r\n57702:30068,\r\n57703:30090,\r\n57704:30089,\r\n57705:30082,\r\n57706:30100,\r\n57707:30106,\r\n57708:30109,\r\n57709:30117,\r\n57710:30115,\r\n57711:30146,\r\n57712:30131,\r\n57713:30147,\r\n57714:30133,\r\n57715:30141,\r\n57716:30136,\r\n57717:30140,\r\n57718:30129,\r\n57719:30157,\r\n57720:30154,\r\n57721:30162,\r\n57722:30169,\r\n57723:30179,\r\n57724:30174,\r\n57725:30206,\r\n57726:30207,\r\n57728:30204,\r\n57729:30209,\r\n57730:30192,\r\n57731:30202,\r\n57732:30194,\r\n57733:30195,\r\n57734:30219,\r\n57735:30221,\r\n57736:30217,\r\n57737:30239,\r\n57738:30247,\r\n57739:30240,\r\n57740:30241,\r\n57741:30242,\r\n57742:30244,\r\n57743:30260,\r\n57744:30256,\r\n57745:30267,\r\n57746:30279,\r\n57747:30280,\r\n57748:30278,\r\n57749:30300,\r\n57750:30296,\r\n57751:30305,\r\n57752:30306,\r\n57753:30312,\r\n57754:30313,\r\n57755:30314,\r\n57756:30311,\r\n57757:30316,\r\n57758:30320,\r\n57759:30322,\r\n57760:30326,\r\n57761:30328,\r\n57762:30332,\r\n57763:30336,\r\n57764:30339,\r\n57765:30344,\r\n57766:30347,\r\n57767:30350,\r\n57768:30358,\r\n57769:30355,\r\n57770:30361,\r\n57771:30362,\r\n57772:30384,\r\n57773:30388,\r\n57774:30392,\r\n57775:30393,\r\n57776:30394,\r\n57777:30402,\r\n57778:30413,\r\n57779:30422,\r\n57780:30418,\r\n57781:30430,\r\n57782:30433,\r\n57783:30437,\r\n57784:30439,\r\n57785:30442,\r\n57786:34351,\r\n57787:30459,\r\n57788:30472,\r\n57789:30471,\r\n57790:30468,\r\n57791:30505,\r\n57792:30500,\r\n57793:30494,\r\n57794:30501,\r\n57795:30502,\r\n57796:30491,\r\n57797:30519,\r\n57798:30520,\r\n57799:30535,\r\n57800:30554,\r\n57801:30568,\r\n57802:30571,\r\n57803:30555,\r\n57804:30565,\r\n57805:30591,\r\n57806:30590,\r\n57807:30585,\r\n57808:30606,\r\n57809:30603,\r\n57810:30609,\r\n57811:30624,\r\n57812:30622,\r\n57813:30640,\r\n57814:30646,\r\n57815:30649,\r\n57816:30655,\r\n57817:30652,\r\n57818:30653,\r\n57819:30651,\r\n57820:30663,\r\n57821:30669,\r\n57822:30679,\r\n57823:30682,\r\n57824:30684,\r\n57825:30691,\r\n57826:30702,\r\n57827:30716,\r\n57828:30732,\r\n57829:30738,\r\n57830:31014,\r\n57831:30752,\r\n57832:31018,\r\n57833:30789,\r\n57834:30862,\r\n57835:30836,\r\n57836:30854,\r\n57837:30844,\r\n57838:30874,\r\n57839:30860,\r\n57840:30883,\r\n57841:30901,\r\n57842:30890,\r\n57843:30895,\r\n57844:30929,\r\n57845:30918,\r\n57846:30923,\r\n57847:30932,\r\n57848:30910,\r\n57849:30908,\r\n57850:30917,\r\n57851:30922,\r\n57852:30956,\r\n57920:30951,\r\n57921:30938,\r\n57922:30973,\r\n57923:30964,\r\n57924:30983,\r\n57925:30994,\r\n57926:30993,\r\n57927:31001,\r\n57928:31020,\r\n57929:31019,\r\n57930:31040,\r\n57931:31072,\r\n57932:31063,\r\n57933:31071,\r\n57934:31066,\r\n57935:31061,\r\n57936:31059,\r\n57937:31098,\r\n57938:31103,\r\n57939:31114,\r\n57940:31133,\r\n57941:31143,\r\n57942:40779,\r\n57943:31146,\r\n57944:31150,\r\n57945:31155,\r\n57946:31161,\r\n57947:31162,\r\n57948:31177,\r\n57949:31189,\r\n57950:31207,\r\n57951:31212,\r\n57952:31201,\r\n57953:31203,\r\n57954:31240,\r\n57955:31245,\r\n57956:31256,\r\n57957:31257,\r\n57958:31264,\r\n57959:31263,\r\n57960:31104,\r\n57961:31281,\r\n57962:31291,\r\n57963:31294,\r\n57964:31287,\r\n57965:31299,\r\n57966:31319,\r\n57967:31305,\r\n57968:31329,\r\n57969:31330,\r\n57970:31337,\r\n57971:40861,\r\n57972:31344,\r\n57973:31353,\r\n57974:31357,\r\n57975:31368,\r\n57976:31383,\r\n57977:31381,\r\n57978:31384,\r\n57979:31382,\r\n57980:31401,\r\n57981:31432,\r\n57982:31408,\r\n57984:31414,\r\n57985:31429,\r\n57986:31428,\r\n57987:31423,\r\n57988:36995,\r\n57989:31431,\r\n57990:31434,\r\n57991:31437,\r\n57992:31439,\r\n57993:31445,\r\n57994:31443,\r\n57995:31449,\r\n57996:31450,\r\n57997:31453,\r\n57998:31457,\r\n57999:31458,\r\n58000:31462,\r\n58001:31469,\r\n58002:31472,\r\n58003:31490,\r\n58004:31503,\r\n58005:31498,\r\n58006:31494,\r\n58007:31539,\r\n58008:31512,\r\n58009:31513,\r\n58010:31518,\r\n58011:31541,\r\n58012:31528,\r\n58013:31542,\r\n58014:31568,\r\n58015:31610,\r\n58016:31492,\r\n58017:31565,\r\n58018:31499,\r\n58019:31564,\r\n58020:31557,\r\n58021:31605,\r\n58022:31589,\r\n58023:31604,\r\n58024:31591,\r\n58025:31600,\r\n58026:31601,\r\n58027:31596,\r\n58028:31598,\r\n58029:31645,\r\n58030:31640,\r\n58031:31647,\r\n58032:31629,\r\n58033:31644,\r\n58034:31642,\r\n58035:31627,\r\n58036:31634,\r\n58037:31631,\r\n58038:31581,\r\n58039:31641,\r\n58040:31691,\r\n58041:31681,\r\n58042:31692,\r\n58043:31695,\r\n58044:31668,\r\n58045:31686,\r\n58046:31709,\r\n58047:31721,\r\n58048:31761,\r\n58049:31764,\r\n58050:31718,\r\n58051:31717,\r\n58052:31840,\r\n58053:31744,\r\n58054:31751,\r\n58055:31763,\r\n58056:31731,\r\n58057:31735,\r\n58058:31767,\r\n58059:31757,\r\n58060:31734,\r\n58061:31779,\r\n58062:31783,\r\n58063:31786,\r\n58064:31775,\r\n58065:31799,\r\n58066:31787,\r\n58067:31805,\r\n58068:31820,\r\n58069:31811,\r\n58070:31828,\r\n58071:31823,\r\n58072:31808,\r\n58073:31824,\r\n58074:31832,\r\n58075:31839,\r\n58076:31844,\r\n58077:31830,\r\n58078:31845,\r\n58079:31852,\r\n58080:31861,\r\n58081:31875,\r\n58082:31888,\r\n58083:31908,\r\n58084:31917,\r\n58085:31906,\r\n58086:31915,\r\n58087:31905,\r\n58088:31912,\r\n58089:31923,\r\n58090:31922,\r\n58091:31921,\r\n58092:31918,\r\n58093:31929,\r\n58094:31933,\r\n58095:31936,\r\n58096:31941,\r\n58097:31938,\r\n58098:31960,\r\n58099:31954,\r\n58100:31964,\r\n58101:31970,\r\n58102:39739,\r\n58103:31983,\r\n58104:31986,\r\n58105:31988,\r\n58106:31990,\r\n58107:31994,\r\n58108:32006,\r\n58176:32002,\r\n58177:32028,\r\n58178:32021,\r\n58179:32010,\r\n58180:32069,\r\n58181:32075,\r\n58182:32046,\r\n58183:32050,\r\n58184:32063,\r\n58185:32053,\r\n58186:32070,\r\n58187:32115,\r\n58188:32086,\r\n58189:32078,\r\n58190:32114,\r\n58191:32104,\r\n58192:32110,\r\n58193:32079,\r\n58194:32099,\r\n58195:32147,\r\n58196:32137,\r\n58197:32091,\r\n58198:32143,\r\n58199:32125,\r\n58200:32155,\r\n58201:32186,\r\n58202:32174,\r\n58203:32163,\r\n58204:32181,\r\n58205:32199,\r\n58206:32189,\r\n58207:32171,\r\n58208:32317,\r\n58209:32162,\r\n58210:32175,\r\n58211:32220,\r\n58212:32184,\r\n58213:32159,\r\n58214:32176,\r\n58215:32216,\r\n58216:32221,\r\n58217:32228,\r\n58218:32222,\r\n58219:32251,\r\n58220:32242,\r\n58221:32225,\r\n58222:32261,\r\n58223:32266,\r\n58224:32291,\r\n58225:32289,\r\n58226:32274,\r\n58227:32305,\r\n58228:32287,\r\n58229:32265,\r\n58230:32267,\r\n58231:32290,\r\n58232:32326,\r\n58233:32358,\r\n58234:32315,\r\n58235:32309,\r\n58236:32313,\r\n58237:32323,\r\n58238:32311,\r\n58240:32306,\r\n58241:32314,\r\n58242:32359,\r\n58243:32349,\r\n58244:32342,\r\n58245:32350,\r\n58246:32345,\r\n58247:32346,\r\n58248:32377,\r\n58249:32362,\r\n58250:32361,\r\n58251:32380,\r\n58252:32379,\r\n58253:32387,\r\n58254:32213,\r\n58255:32381,\r\n58256:36782,\r\n58257:32383,\r\n58258:32392,\r\n58259:32393,\r\n58260:32396,\r\n58261:32402,\r\n58262:32400,\r\n58263:32403,\r\n58264:32404,\r\n58265:32406,\r\n58266:32398,\r\n58267:32411,\r\n58268:32412,\r\n58269:32568,\r\n58270:32570,\r\n58271:32581,\r\n58272:32588,\r\n58273:32589,\r\n58274:32590,\r\n58275:32592,\r\n58276:32593,\r\n58277:32597,\r\n58278:32596,\r\n58279:32600,\r\n58280:32607,\r\n58281:32608,\r\n58282:32616,\r\n58283:32617,\r\n58284:32615,\r\n58285:32632,\r\n58286:32642,\r\n58287:32646,\r\n58288:32643,\r\n58289:32648,\r\n58290:32647,\r\n58291:32652,\r\n58292:32660,\r\n58293:32670,\r\n58294:32669,\r\n58295:32666,\r\n58296:32675,\r\n58297:32687,\r\n58298:32690,\r\n58299:32697,\r\n58300:32686,\r\n58301:32694,\r\n58302:32696,\r\n58303:35697,\r\n58304:32709,\r\n58305:32710,\r\n58306:32714,\r\n58307:32725,\r\n58308:32724,\r\n58309:32737,\r\n58310:32742,\r\n58311:32745,\r\n58312:32755,\r\n58313:32761,\r\n58314:39132,\r\n58315:32774,\r\n58316:32772,\r\n58317:32779,\r\n58318:32786,\r\n58319:32792,\r\n58320:32793,\r\n58321:32796,\r\n58322:32801,\r\n58323:32808,\r\n58324:32831,\r\n58325:32827,\r\n58326:32842,\r\n58327:32838,\r\n58328:32850,\r\n58329:32856,\r\n58330:32858,\r\n58331:32863,\r\n58332:32866,\r\n58333:32872,\r\n58334:32883,\r\n58335:32882,\r\n58336:32880,\r\n58337:32886,\r\n58338:32889,\r\n58339:32893,\r\n58340:32895,\r\n58341:32900,\r\n58342:32902,\r\n58343:32901,\r\n58344:32923,\r\n58345:32915,\r\n58346:32922,\r\n58347:32941,\r\n58348:20880,\r\n58349:32940,\r\n58350:32987,\r\n58351:32997,\r\n58352:32985,\r\n58353:32989,\r\n58354:32964,\r\n58355:32986,\r\n58356:32982,\r\n58357:33033,\r\n58358:33007,\r\n58359:33009,\r\n58360:33051,\r\n58361:33065,\r\n58362:33059,\r\n58363:33071,\r\n58364:33099,\r\n58432:38539,\r\n58433:33094,\r\n58434:33086,\r\n58435:33107,\r\n58436:33105,\r\n58437:33020,\r\n58438:33137,\r\n58439:33134,\r\n58440:33125,\r\n58441:33126,\r\n58442:33140,\r\n58443:33155,\r\n58444:33160,\r\n58445:33162,\r\n58446:33152,\r\n58447:33154,\r\n58448:33184,\r\n58449:33173,\r\n58450:33188,\r\n58451:33187,\r\n58452:33119,\r\n58453:33171,\r\n58454:33193,\r\n58455:33200,\r\n58456:33205,\r\n58457:33214,\r\n58458:33208,\r\n58459:33213,\r\n58460:33216,\r\n58461:33218,\r\n58462:33210,\r\n58463:33225,\r\n58464:33229,\r\n58465:33233,\r\n58466:33241,\r\n58467:33240,\r\n58468:33224,\r\n58469:33242,\r\n58470:33247,\r\n58471:33248,\r\n58472:33255,\r\n58473:33274,\r\n58474:33275,\r\n58475:33278,\r\n58476:33281,\r\n58477:33282,\r\n58478:33285,\r\n58479:33287,\r\n58480:33290,\r\n58481:33293,\r\n58482:33296,\r\n58483:33302,\r\n58484:33321,\r\n58485:33323,\r\n58486:33336,\r\n58487:33331,\r\n58488:33344,\r\n58489:33369,\r\n58490:33368,\r\n58491:33373,\r\n58492:33370,\r\n58493:33375,\r\n58494:33380,\r\n58496:33378,\r\n58497:33384,\r\n58498:33386,\r\n58499:33387,\r\n58500:33326,\r\n58501:33393,\r\n58502:33399,\r\n58503:33400,\r\n58504:33406,\r\n58505:33421,\r\n58506:33426,\r\n58507:33451,\r\n58508:33439,\r\n58509:33467,\r\n58510:33452,\r\n58511:33505,\r\n58512:33507,\r\n58513:33503,\r\n58514:33490,\r\n58515:33524,\r\n58516:33523,\r\n58517:33530,\r\n58518:33683,\r\n58519:33539,\r\n58520:33531,\r\n58521:33529,\r\n58522:33502,\r\n58523:33542,\r\n58524:33500,\r\n58525:33545,\r\n58526:33497,\r\n58527:33589,\r\n58528:33588,\r\n58529:33558,\r\n58530:33586,\r\n58531:33585,\r\n58532:33600,\r\n58533:33593,\r\n58534:33616,\r\n58535:33605,\r\n58536:33583,\r\n58537:33579,\r\n58538:33559,\r\n58539:33560,\r\n58540:33669,\r\n58541:33690,\r\n58542:33706,\r\n58543:33695,\r\n58544:33698,\r\n58545:33686,\r\n58546:33571,\r\n58547:33678,\r\n58548:33671,\r\n58549:33674,\r\n58550:33660,\r\n58551:33717,\r\n58552:33651,\r\n58553:33653,\r\n58554:33696,\r\n58555:33673,\r\n58556:33704,\r\n58557:33780,\r\n58558:33811,\r\n58559:33771,\r\n58560:33742,\r\n58561:33789,\r\n58562:33795,\r\n58563:33752,\r\n58564:33803,\r\n58565:33729,\r\n58566:33783,\r\n58567:33799,\r\n58568:33760,\r\n58569:33778,\r\n58570:33805,\r\n58571:33826,\r\n58572:33824,\r\n58573:33725,\r\n58574:33848,\r\n58575:34054,\r\n58576:33787,\r\n58577:33901,\r\n58578:33834,\r\n58579:33852,\r\n58580:34138,\r\n58581:33924,\r\n58582:33911,\r\n58583:33899,\r\n58584:33965,\r\n58585:33902,\r\n58586:33922,\r\n58587:33897,\r\n58588:33862,\r\n58589:33836,\r\n58590:33903,\r\n58591:33913,\r\n58592:33845,\r\n58593:33994,\r\n58594:33890,\r\n58595:33977,\r\n58596:33983,\r\n58597:33951,\r\n58598:34009,\r\n58599:33997,\r\n58600:33979,\r\n58601:34010,\r\n58602:34000,\r\n58603:33985,\r\n58604:33990,\r\n58605:34006,\r\n58606:33953,\r\n58607:34081,\r\n58608:34047,\r\n58609:34036,\r\n58610:34071,\r\n58611:34072,\r\n58612:34092,\r\n58613:34079,\r\n58614:34069,\r\n58615:34068,\r\n58616:34044,\r\n58617:34112,\r\n58618:34147,\r\n58619:34136,\r\n58620:34120,\r\n58688:34113,\r\n58689:34306,\r\n58690:34123,\r\n58691:34133,\r\n58692:34176,\r\n58693:34212,\r\n58694:34184,\r\n58695:34193,\r\n58696:34186,\r\n58697:34216,\r\n58698:34157,\r\n58699:34196,\r\n58700:34203,\r\n58701:34282,\r\n58702:34183,\r\n58703:34204,\r\n58704:34167,\r\n58705:34174,\r\n58706:34192,\r\n58707:34249,\r\n58708:34234,\r\n58709:34255,\r\n58710:34233,\r\n58711:34256,\r\n58712:34261,\r\n58713:34269,\r\n58714:34277,\r\n58715:34268,\r\n58716:34297,\r\n58717:34314,\r\n58718:34323,\r\n58719:34315,\r\n58720:34302,\r\n58721:34298,\r\n58722:34310,\r\n58723:34338,\r\n58724:34330,\r\n58725:34352,\r\n58726:34367,\r\n58727:34381,\r\n58728:20053,\r\n58729:34388,\r\n58730:34399,\r\n58731:34407,\r\n58732:34417,\r\n58733:34451,\r\n58734:34467,\r\n58735:34473,\r\n58736:34474,\r\n58737:34443,\r\n58738:34444,\r\n58739:34486,\r\n58740:34479,\r\n58741:34500,\r\n58742:34502,\r\n58743:34480,\r\n58744:34505,\r\n58745:34851,\r\n58746:34475,\r\n58747:34516,\r\n58748:34526,\r\n58749:34537,\r\n58750:34540,\r\n58752:34527,\r\n58753:34523,\r\n58754:34543,\r\n58755:34578,\r\n58756:34566,\r\n58757:34568,\r\n58758:34560,\r\n58759:34563,\r\n58760:34555,\r\n58761:34577,\r\n58762:34569,\r\n58763:34573,\r\n58764:34553,\r\n58765:34570,\r\n58766:34612,\r\n58767:34623,\r\n58768:34615,\r\n58769:34619,\r\n58770:34597,\r\n58771:34601,\r\n58772:34586,\r\n58773:34656,\r\n58774:34655,\r\n58775:34680,\r\n58776:34636,\r\n58777:34638,\r\n58778:34676,\r\n58779:34647,\r\n58780:34664,\r\n58781:34670,\r\n58782:34649,\r\n58783:34643,\r\n58784:34659,\r\n58785:34666,\r\n58786:34821,\r\n58787:34722,\r\n58788:34719,\r\n58789:34690,\r\n58790:34735,\r\n58791:34763,\r\n58792:34749,\r\n58793:34752,\r\n58794:34768,\r\n58795:38614,\r\n58796:34731,\r\n58797:34756,\r\n58798:34739,\r\n58799:34759,\r\n58800:34758,\r\n58801:34747,\r\n58802:34799,\r\n58803:34802,\r\n58804:34784,\r\n58805:34831,\r\n58806:34829,\r\n58807:34814,\r\n58808:34806,\r\n58809:34807,\r\n58810:34830,\r\n58811:34770,\r\n58812:34833,\r\n58813:34838,\r\n58814:34837,\r\n58815:34850,\r\n58816:34849,\r\n58817:34865,\r\n58818:34870,\r\n58819:34873,\r\n58820:34855,\r\n58821:34875,\r\n58822:34884,\r\n58823:34882,\r\n58824:34898,\r\n58825:34905,\r\n58826:34910,\r\n58827:34914,\r\n58828:34923,\r\n58829:34945,\r\n58830:34942,\r\n58831:34974,\r\n58832:34933,\r\n58833:34941,\r\n58834:34997,\r\n58835:34930,\r\n58836:34946,\r\n58837:34967,\r\n58838:34962,\r\n58839:34990,\r\n58840:34969,\r\n58841:34978,\r\n58842:34957,\r\n58843:34980,\r\n58844:34992,\r\n58845:35007,\r\n58846:34993,\r\n58847:35011,\r\n58848:35012,\r\n58849:35028,\r\n58850:35032,\r\n58851:35033,\r\n58852:35037,\r\n58853:35065,\r\n58854:35074,\r\n58855:35068,\r\n58856:35060,\r\n58857:35048,\r\n58858:35058,\r\n58859:35076,\r\n58860:35084,\r\n58861:35082,\r\n58862:35091,\r\n58863:35139,\r\n58864:35102,\r\n58865:35109,\r\n58866:35114,\r\n58867:35115,\r\n58868:35137,\r\n58869:35140,\r\n58870:35131,\r\n58871:35126,\r\n58872:35128,\r\n58873:35148,\r\n58874:35101,\r\n58875:35168,\r\n58876:35166,\r\n58944:35174,\r\n58945:35172,\r\n58946:35181,\r\n58947:35178,\r\n58948:35183,\r\n58949:35188,\r\n58950:35191,\r\n58951:35198,\r\n58952:35203,\r\n58953:35208,\r\n58954:35210,\r\n58955:35219,\r\n58956:35224,\r\n58957:35233,\r\n58958:35241,\r\n58959:35238,\r\n58960:35244,\r\n58961:35247,\r\n58962:35250,\r\n58963:35258,\r\n58964:35261,\r\n58965:35263,\r\n58966:35264,\r\n58967:35290,\r\n58968:35292,\r\n58969:35293,\r\n58970:35303,\r\n58971:35316,\r\n58972:35320,\r\n58973:35331,\r\n58974:35350,\r\n58975:35344,\r\n58976:35340,\r\n58977:35355,\r\n58978:35357,\r\n58979:35365,\r\n58980:35382,\r\n58981:35393,\r\n58982:35419,\r\n58983:35410,\r\n58984:35398,\r\n58985:35400,\r\n58986:35452,\r\n58987:35437,\r\n58988:35436,\r\n58989:35426,\r\n58990:35461,\r\n58991:35458,\r\n58992:35460,\r\n58993:35496,\r\n58994:35489,\r\n58995:35473,\r\n58996:35493,\r\n58997:35494,\r\n58998:35482,\r\n58999:35491,\r\n59000:35524,\r\n59001:35533,\r\n59002:35522,\r\n59003:35546,\r\n59004:35563,\r\n59005:35571,\r\n59006:35559,\r\n59008:35556,\r\n59009:35569,\r\n59010:35604,\r\n59011:35552,\r\n59012:35554,\r\n59013:35575,\r\n59014:35550,\r\n59015:35547,\r\n59016:35596,\r\n59017:35591,\r\n59018:35610,\r\n59019:35553,\r\n59020:35606,\r\n59021:35600,\r\n59022:35607,\r\n59023:35616,\r\n59024:35635,\r\n59025:38827,\r\n59026:35622,\r\n59027:35627,\r\n59028:35646,\r\n59029:35624,\r\n59030:35649,\r\n59031:35660,\r\n59032:35663,\r\n59033:35662,\r\n59034:35657,\r\n59035:35670,\r\n59036:35675,\r\n59037:35674,\r\n59038:35691,\r\n59039:35679,\r\n59040:35692,\r\n59041:35695,\r\n59042:35700,\r\n59043:35709,\r\n59044:35712,\r\n59045:35724,\r\n59046:35726,\r\n59047:35730,\r\n59048:35731,\r\n59049:35734,\r\n59050:35737,\r\n59051:35738,\r\n59052:35898,\r\n59053:35905,\r\n59054:35903,\r\n59055:35912,\r\n59056:35916,\r\n59057:35918,\r\n59058:35920,\r\n59059:35925,\r\n59060:35938,\r\n59061:35948,\r\n59062:35960,\r\n59063:35962,\r\n59064:35970,\r\n59065:35977,\r\n59066:35973,\r\n59067:35978,\r\n59068:35981,\r\n59069:35982,\r\n59070:35988,\r\n59071:35964,\r\n59072:35992,\r\n59073:25117,\r\n59074:36013,\r\n59075:36010,\r\n59076:36029,\r\n59077:36018,\r\n59078:36019,\r\n59079:36014,\r\n59080:36022,\r\n59081:36040,\r\n59082:36033,\r\n59083:36068,\r\n59084:36067,\r\n59085:36058,\r\n59086:36093,\r\n59087:36090,\r\n59088:36091,\r\n59089:36100,\r\n59090:36101,\r\n59091:36106,\r\n59092:36103,\r\n59093:36111,\r\n59094:36109,\r\n59095:36112,\r\n59096:40782,\r\n59097:36115,\r\n59098:36045,\r\n59099:36116,\r\n59100:36118,\r\n59101:36199,\r\n59102:36205,\r\n59103:36209,\r\n59104:36211,\r\n59105:36225,\r\n59106:36249,\r\n59107:36290,\r\n59108:36286,\r\n59109:36282,\r\n59110:36303,\r\n59111:36314,\r\n59112:36310,\r\n59113:36300,\r\n59114:36315,\r\n59115:36299,\r\n59116:36330,\r\n59117:36331,\r\n59118:36319,\r\n59119:36323,\r\n59120:36348,\r\n59121:36360,\r\n59122:36361,\r\n59123:36351,\r\n59124:36381,\r\n59125:36382,\r\n59126:36368,\r\n59127:36383,\r\n59128:36418,\r\n59129:36405,\r\n59130:36400,\r\n59131:36404,\r\n59132:36426,\r\n59200:36423,\r\n59201:36425,\r\n59202:36428,\r\n59203:36432,\r\n59204:36424,\r\n59205:36441,\r\n59206:36452,\r\n59207:36448,\r\n59208:36394,\r\n59209:36451,\r\n59210:36437,\r\n59211:36470,\r\n59212:36466,\r\n59213:36476,\r\n59214:36481,\r\n59215:36487,\r\n59216:36485,\r\n59217:36484,\r\n59218:36491,\r\n59219:36490,\r\n59220:36499,\r\n59221:36497,\r\n59222:36500,\r\n59223:36505,\r\n59224:36522,\r\n59225:36513,\r\n59226:36524,\r\n59227:36528,\r\n59228:36550,\r\n59229:36529,\r\n59230:36542,\r\n59231:36549,\r\n59232:36552,\r\n59233:36555,\r\n59234:36571,\r\n59235:36579,\r\n59236:36604,\r\n59237:36603,\r\n59238:36587,\r\n59239:36606,\r\n59240:36618,\r\n59241:36613,\r\n59242:36629,\r\n59243:36626,\r\n59244:36633,\r\n59245:36627,\r\n59246:36636,\r\n59247:36639,\r\n59248:36635,\r\n59249:36620,\r\n59250:36646,\r\n59251:36659,\r\n59252:36667,\r\n59253:36665,\r\n59254:36677,\r\n59255:36674,\r\n59256:36670,\r\n59257:36684,\r\n59258:36681,\r\n59259:36678,\r\n59260:36686,\r\n59261:36695,\r\n59262:36700,\r\n59264:36706,\r\n59265:36707,\r\n59266:36708,\r\n59267:36764,\r\n59268:36767,\r\n59269:36771,\r\n59270:36781,\r\n59271:36783,\r\n59272:36791,\r\n59273:36826,\r\n59274:36837,\r\n59275:36834,\r\n59276:36842,\r\n59277:36847,\r\n59278:36999,\r\n59279:36852,\r\n59280:36869,\r\n59281:36857,\r\n59282:36858,\r\n59283:36881,\r\n59284:36885,\r\n59285:36897,\r\n59286:36877,\r\n59287:36894,\r\n59288:36886,\r\n59289:36875,\r\n59290:36903,\r\n59291:36918,\r\n59292:36917,\r\n59293:36921,\r\n59294:36856,\r\n59295:36943,\r\n59296:36944,\r\n59297:36945,\r\n59298:36946,\r\n59299:36878,\r\n59300:36937,\r\n59301:36926,\r\n59302:36950,\r\n59303:36952,\r\n59304:36958,\r\n59305:36968,\r\n59306:36975,\r\n59307:36982,\r\n59308:38568,\r\n59309:36978,\r\n59310:36994,\r\n59311:36989,\r\n59312:36993,\r\n59313:36992,\r\n59314:37002,\r\n59315:37001,\r\n59316:37007,\r\n59317:37032,\r\n59318:37039,\r\n59319:37041,\r\n59320:37045,\r\n59321:37090,\r\n59322:37092,\r\n59323:25160,\r\n59324:37083,\r\n59325:37122,\r\n59326:37138,\r\n59327:37145,\r\n59328:37170,\r\n59329:37168,\r\n59330:37194,\r\n59331:37206,\r\n59332:37208,\r\n59333:37219,\r\n59334:37221,\r\n59335:37225,\r\n59336:37235,\r\n59337:37234,\r\n59338:37259,\r\n59339:37257,\r\n59340:37250,\r\n59341:37282,\r\n59342:37291,\r\n59343:37295,\r\n59344:37290,\r\n59345:37301,\r\n59346:37300,\r\n59347:37306,\r\n59348:37312,\r\n59349:37313,\r\n59350:37321,\r\n59351:37323,\r\n59352:37328,\r\n59353:37334,\r\n59354:37343,\r\n59355:37345,\r\n59356:37339,\r\n59357:37372,\r\n59358:37365,\r\n59359:37366,\r\n59360:37406,\r\n59361:37375,\r\n59362:37396,\r\n59363:37420,\r\n59364:37397,\r\n59365:37393,\r\n59366:37470,\r\n59367:37463,\r\n59368:37445,\r\n59369:37449,\r\n59370:37476,\r\n59371:37448,\r\n59372:37525,\r\n59373:37439,\r\n59374:37451,\r\n59375:37456,\r\n59376:37532,\r\n59377:37526,\r\n59378:37523,\r\n59379:37531,\r\n59380:37466,\r\n59381:37583,\r\n59382:37561,\r\n59383:37559,\r\n59384:37609,\r\n59385:37647,\r\n59386:37626,\r\n59387:37700,\r\n59388:37678,\r\n59456:37657,\r\n59457:37666,\r\n59458:37658,\r\n59459:37667,\r\n59460:37690,\r\n59461:37685,\r\n59462:37691,\r\n59463:37724,\r\n59464:37728,\r\n59465:37756,\r\n59466:37742,\r\n59467:37718,\r\n59468:37808,\r\n59469:37804,\r\n59470:37805,\r\n59471:37780,\r\n59472:37817,\r\n59473:37846,\r\n59474:37847,\r\n59475:37864,\r\n59476:37861,\r\n59477:37848,\r\n59478:37827,\r\n59479:37853,\r\n59480:37840,\r\n59481:37832,\r\n59482:37860,\r\n59483:37914,\r\n59484:37908,\r\n59485:37907,\r\n59486:37891,\r\n59487:37895,\r\n59488:37904,\r\n59489:37942,\r\n59490:37931,\r\n59491:37941,\r\n59492:37921,\r\n59493:37946,\r\n59494:37953,\r\n59495:37970,\r\n59496:37956,\r\n59497:37979,\r\n59498:37984,\r\n59499:37986,\r\n59500:37982,\r\n59501:37994,\r\n59502:37417,\r\n59503:38000,\r\n59504:38005,\r\n59505:38007,\r\n59506:38013,\r\n59507:37978,\r\n59508:38012,\r\n59509:38014,\r\n59510:38017,\r\n59511:38015,\r\n59512:38274,\r\n59513:38279,\r\n59514:38282,\r\n59515:38292,\r\n59516:38294,\r\n59517:38296,\r\n59518:38297,\r\n59520:38304,\r\n59521:38312,\r\n59522:38311,\r\n59523:38317,\r\n59524:38332,\r\n59525:38331,\r\n59526:38329,\r\n59527:38334,\r\n59528:38346,\r\n59529:28662,\r\n59530:38339,\r\n59531:38349,\r\n59532:38348,\r\n59533:38357,\r\n59534:38356,\r\n59535:38358,\r\n59536:38364,\r\n59537:38369,\r\n59538:38373,\r\n59539:38370,\r\n59540:38433,\r\n59541:38440,\r\n59542:38446,\r\n59543:38447,\r\n59544:38466,\r\n59545:38476,\r\n59546:38479,\r\n59547:38475,\r\n59548:38519,\r\n59549:38492,\r\n59550:38494,\r\n59551:38493,\r\n59552:38495,\r\n59553:38502,\r\n59554:38514,\r\n59555:38508,\r\n59556:38541,\r\n59557:38552,\r\n59558:38549,\r\n59559:38551,\r\n59560:38570,\r\n59561:38567,\r\n59562:38577,\r\n59563:38578,\r\n59564:38576,\r\n59565:38580,\r\n59566:38582,\r\n59567:38584,\r\n59568:38585,\r\n59569:38606,\r\n59570:38603,\r\n59571:38601,\r\n59572:38605,\r\n59573:35149,\r\n59574:38620,\r\n59575:38669,\r\n59576:38613,\r\n59577:38649,\r\n59578:38660,\r\n59579:38662,\r\n59580:38664,\r\n59581:38675,\r\n59582:38670,\r\n59583:38673,\r\n59584:38671,\r\n59585:38678,\r\n59586:38681,\r\n59587:38692,\r\n59588:38698,\r\n59589:38704,\r\n59590:38713,\r\n59591:38717,\r\n59592:38718,\r\n59593:38724,\r\n59594:38726,\r\n59595:38728,\r\n59596:38722,\r\n59597:38729,\r\n59598:38748,\r\n59599:38752,\r\n59600:38756,\r\n59601:38758,\r\n59602:38760,\r\n59603:21202,\r\n59604:38763,\r\n59605:38769,\r\n59606:38777,\r\n59607:38789,\r\n59608:38780,\r\n59609:38785,\r\n59610:38778,\r\n59611:38790,\r\n59612:38795,\r\n59613:38799,\r\n59614:38800,\r\n59615:38812,\r\n59616:38824,\r\n59617:38822,\r\n59618:38819,\r\n59619:38835,\r\n59620:38836,\r\n59621:38851,\r\n59622:38854,\r\n59623:38856,\r\n59624:38859,\r\n59625:38876,\r\n59626:38893,\r\n59627:40783,\r\n59628:38898,\r\n59629:31455,\r\n59630:38902,\r\n59631:38901,\r\n59632:38927,\r\n59633:38924,\r\n59634:38968,\r\n59635:38948,\r\n59636:38945,\r\n59637:38967,\r\n59638:38973,\r\n59639:38982,\r\n59640:38991,\r\n59641:38987,\r\n59642:39019,\r\n59643:39023,\r\n59644:39024,\r\n59712:39025,\r\n59713:39028,\r\n59714:39027,\r\n59715:39082,\r\n59716:39087,\r\n59717:39089,\r\n59718:39094,\r\n59719:39108,\r\n59720:39107,\r\n59721:39110,\r\n59722:39145,\r\n59723:39147,\r\n59724:39171,\r\n59725:39177,\r\n59726:39186,\r\n59727:39188,\r\n59728:39192,\r\n59729:39201,\r\n59730:39197,\r\n59731:39198,\r\n59732:39204,\r\n59733:39200,\r\n59734:39212,\r\n59735:39214,\r\n59736:39229,\r\n59737:39230,\r\n59738:39234,\r\n59739:39241,\r\n59740:39237,\r\n59741:39248,\r\n59742:39243,\r\n59743:39249,\r\n59744:39250,\r\n59745:39244,\r\n59746:39253,\r\n59747:39319,\r\n59748:39320,\r\n59749:39333,\r\n59750:39341,\r\n59751:39342,\r\n59752:39356,\r\n59753:39391,\r\n59754:39387,\r\n59755:39389,\r\n59756:39384,\r\n59757:39377,\r\n59758:39405,\r\n59759:39406,\r\n59760:39409,\r\n59761:39410,\r\n59762:39419,\r\n59763:39416,\r\n59764:39425,\r\n59765:39439,\r\n59766:39429,\r\n59767:39394,\r\n59768:39449,\r\n59769:39467,\r\n59770:39479,\r\n59771:39493,\r\n59772:39490,\r\n59773:39488,\r\n59774:39491,\r\n59776:39486,\r\n59777:39509,\r\n59778:39501,\r\n59779:39515,\r\n59780:39511,\r\n59781:39519,\r\n59782:39522,\r\n59783:39525,\r\n59784:39524,\r\n59785:39529,\r\n59786:39531,\r\n59787:39530,\r\n59788:39597,\r\n59789:39600,\r\n59790:39612,\r\n59791:39616,\r\n59792:39631,\r\n59793:39633,\r\n59794:39635,\r\n59795:39636,\r\n59796:39646,\r\n59797:39647,\r\n59798:39650,\r\n59799:39651,\r\n59800:39654,\r\n59801:39663,\r\n59802:39659,\r\n59803:39662,\r\n59804:39668,\r\n59805:39665,\r\n59806:39671,\r\n59807:39675,\r\n59808:39686,\r\n59809:39704,\r\n59810:39706,\r\n59811:39711,\r\n59812:39714,\r\n59813:39715,\r\n59814:39717,\r\n59815:39719,\r\n59816:39720,\r\n59817:39721,\r\n59818:39722,\r\n59819:39726,\r\n59820:39727,\r\n59821:39730,\r\n59822:39748,\r\n59823:39747,\r\n59824:39759,\r\n59825:39757,\r\n59826:39758,\r\n59827:39761,\r\n59828:39768,\r\n59829:39796,\r\n59830:39827,\r\n59831:39811,\r\n59832:39825,\r\n59833:39830,\r\n59834:39831,\r\n59835:39839,\r\n59836:39840,\r\n59837:39848,\r\n59838:39860,\r\n59839:39872,\r\n59840:39882,\r\n59841:39865,\r\n59842:39878,\r\n59843:39887,\r\n59844:39889,\r\n59845:39890,\r\n59846:39907,\r\n59847:39906,\r\n59848:39908,\r\n59849:39892,\r\n59850:39905,\r\n59851:39994,\r\n59852:39922,\r\n59853:39921,\r\n59854:39920,\r\n59855:39957,\r\n59856:39956,\r\n59857:39945,\r\n59858:39955,\r\n59859:39948,\r\n59860:39942,\r\n59861:39944,\r\n59862:39954,\r\n59863:39946,\r\n59864:39940,\r\n59865:39982,\r\n59866:39963,\r\n59867:39973,\r\n59868:39972,\r\n59869:39969,\r\n59870:39984,\r\n59871:40007,\r\n59872:39986,\r\n59873:40006,\r\n59874:39998,\r\n59875:40026,\r\n59876:40032,\r\n59877:40039,\r\n59878:40054,\r\n59879:40056,\r\n59880:40167,\r\n59881:40172,\r\n59882:40176,\r\n59883:40201,\r\n59884:40200,\r\n59885:40171,\r\n59886:40195,\r\n59887:40198,\r\n59888:40234,\r\n59889:40230,\r\n59890:40367,\r\n59891:40227,\r\n59892:40223,\r\n59893:40260,\r\n59894:40213,\r\n59895:40210,\r\n59896:40257,\r\n59897:40255,\r\n59898:40254,\r\n59899:40262,\r\n59900:40264,\r\n59968:40285,\r\n59969:40286,\r\n59970:40292,\r\n59971:40273,\r\n59972:40272,\r\n59973:40281,\r\n59974:40306,\r\n59975:40329,\r\n59976:40327,\r\n59977:40363,\r\n59978:40303,\r\n59979:40314,\r\n59980:40346,\r\n59981:40356,\r\n59982:40361,\r\n59983:40370,\r\n59984:40388,\r\n59985:40385,\r\n59986:40379,\r\n59987:40376,\r\n59988:40378,\r\n59989:40390,\r\n59990:40399,\r\n59991:40386,\r\n59992:40409,\r\n59993:40403,\r\n59994:40440,\r\n59995:40422,\r\n59996:40429,\r\n59997:40431,\r\n59998:40445,\r\n59999:40474,\r\n60000:40475,\r\n60001:40478,\r\n60002:40565,\r\n60003:40569,\r\n60004:40573,\r\n60005:40577,\r\n60006:40584,\r\n60007:40587,\r\n60008:40588,\r\n60009:40594,\r\n60010:40597,\r\n60011:40593,\r\n60012:40605,\r\n60013:40613,\r\n60014:40617,\r\n60015:40632,\r\n60016:40618,\r\n60017:40621,\r\n60018:38753,\r\n60019:40652,\r\n60020:40654,\r\n60021:40655,\r\n60022:40656,\r\n60023:40660,\r\n60024:40668,\r\n60025:40670,\r\n60026:40669,\r\n60027:40672,\r\n60028:40677,\r\n60029:40680,\r\n60030:40687,\r\n60032:40692,\r\n60033:40694,\r\n60034:40695,\r\n60035:40697,\r\n60036:40699,\r\n60037:40700,\r\n60038:40701,\r\n60039:40711,\r\n60040:40712,\r\n60041:30391,\r\n60042:40725,\r\n60043:40737,\r\n60044:40748,\r\n60045:40766,\r\n60046:40778,\r\n60047:40786,\r\n60048:40788,\r\n60049:40803,\r\n60050:40799,\r\n60051:40800,\r\n60052:40801,\r\n60053:40806,\r\n60054:40807,\r\n60055:40812,\r\n60056:40810,\r\n60057:40823,\r\n60058:40818,\r\n60059:40822,\r\n60060:40853,\r\n60061:40860,\r\n60062:40864,\r\n60063:22575,\r\n60064:27079,\r\n60065:36953,\r\n60066:29796,\r\n60067:20956,\r\n60068:29081,\r\n60736:32394,\r\n60737:35100,\r\n60738:37704,\r\n60739:37512,\r\n60740:34012,\r\n60741:20425,\r\n60742:28859,\r\n60743:26161,\r\n60744:26824,\r\n60745:37625,\r\n60746:26363,\r\n60747:24389,\r\n60748:20008,\r\n60749:20193,\r\n60750:20220,\r\n60751:20224,\r\n60752:20227,\r\n60753:20281,\r\n60754:20310,\r\n60755:20370,\r\n60756:20362,\r\n60757:20378,\r\n60758:20372,\r\n60759:20429,\r\n60760:20544,\r\n60761:20514,\r\n60762:20479,\r\n60763:20510,\r\n60764:20550,\r\n60765:20592,\r\n60766:20546,\r\n60767:20628,\r\n60768:20724,\r\n60769:20696,\r\n60770:20810,\r\n60771:20836,\r\n60772:20893,\r\n60773:20926,\r\n60774:20972,\r\n60775:21013,\r\n60776:21148,\r\n60777:21158,\r\n60778:21184,\r\n60779:21211,\r\n60780:21248,\r\n60781:21255,\r\n60782:21284,\r\n60783:21362,\r\n60784:21395,\r\n60785:21426,\r\n60786:21469,\r\n60787:64014,\r\n60788:21660,\r\n60789:21642,\r\n60790:21673,\r\n60791:21759,\r\n60792:21894,\r\n60793:22361,\r\n60794:22373,\r\n60795:22444,\r\n60796:22472,\r\n60797:22471,\r\n60798:64015,\r\n60800:64016,\r\n60801:22686,\r\n60802:22706,\r\n60803:22795,\r\n60804:22867,\r\n60805:22875,\r\n60806:22877,\r\n60807:22883,\r\n60808:22948,\r\n60809:22970,\r\n60810:23382,\r\n60811:23488,\r\n60812:29999,\r\n60813:23512,\r\n60814:23532,\r\n60815:23582,\r\n60816:23718,\r\n60817:23738,\r\n60818:23797,\r\n60819:23847,\r\n60820:23891,\r\n60821:64017,\r\n60822:23874,\r\n60823:23917,\r\n60824:23992,\r\n60825:23993,\r\n60826:24016,\r\n60827:24353,\r\n60828:24372,\r\n60829:24423,\r\n60830:24503,\r\n60831:24542,\r\n60832:24669,\r\n60833:24709,\r\n60834:24714,\r\n60835:24798,\r\n60836:24789,\r\n60837:24864,\r\n60838:24818,\r\n60839:24849,\r\n60840:24887,\r\n60841:24880,\r\n60842:24984,\r\n60843:25107,\r\n60844:25254,\r\n60845:25589,\r\n60846:25696,\r\n60847:25757,\r\n60848:25806,\r\n60849:25934,\r\n60850:26112,\r\n60851:26133,\r\n60852:26171,\r\n60853:26121,\r\n60854:26158,\r\n60855:26142,\r\n60856:26148,\r\n60857:26213,\r\n60858:26199,\r\n60859:26201,\r\n60860:64018,\r\n60861:26227,\r\n60862:26265,\r\n60863:26272,\r\n60864:26290,\r\n60865:26303,\r\n60866:26362,\r\n60867:26382,\r\n60868:63785,\r\n60869:26470,\r\n60870:26555,\r\n60871:26706,\r\n60872:26560,\r\n60873:26625,\r\n60874:26692,\r\n60875:26831,\r\n60876:64019,\r\n60877:26984,\r\n60878:64020,\r\n60879:27032,\r\n60880:27106,\r\n60881:27184,\r\n60882:27243,\r\n60883:27206,\r\n60884:27251,\r\n60885:27262,\r\n60886:27362,\r\n60887:27364,\r\n60888:27606,\r\n60889:27711,\r\n60890:27740,\r\n60891:27782,\r\n60892:27759,\r\n60893:27866,\r\n60894:27908,\r\n60895:28039,\r\n60896:28015,\r\n60897:28054,\r\n60898:28076,\r\n60899:28111,\r\n60900:28152,\r\n60901:28146,\r\n60902:28156,\r\n60903:28217,\r\n60904:28252,\r\n60905:28199,\r\n60906:28220,\r\n60907:28351,\r\n60908:28552,\r\n60909:28597,\r\n60910:28661,\r\n60911:28677,\r\n60912:28679,\r\n60913:28712,\r\n60914:28805,\r\n60915:28843,\r\n60916:28943,\r\n60917:28932,\r\n60918:29020,\r\n60919:28998,\r\n60920:28999,\r\n60921:64021,\r\n60922:29121,\r\n60923:29182,\r\n60924:29361,\r\n60992:29374,\r\n60993:29476,\r\n60994:64022,\r\n60995:29559,\r\n60996:29629,\r\n60997:29641,\r\n60998:29654,\r\n60999:29667,\r\n61000:29650,\r\n61001:29703,\r\n61002:29685,\r\n61003:29734,\r\n61004:29738,\r\n61005:29737,\r\n61006:29742,\r\n61007:29794,\r\n61008:29833,\r\n61009:29855,\r\n61010:29953,\r\n61011:30063,\r\n61012:30338,\r\n61013:30364,\r\n61014:30366,\r\n61015:30363,\r\n61016:30374,\r\n61017:64023,\r\n61018:30534,\r\n61019:21167,\r\n61020:30753,\r\n61021:30798,\r\n61022:30820,\r\n61023:30842,\r\n61024:31024,\r\n61025:64024,\r\n61026:64025,\r\n61027:64026,\r\n61028:31124,\r\n61029:64027,\r\n61030:31131,\r\n61031:31441,\r\n61032:31463,\r\n61033:64028,\r\n61034:31467,\r\n61035:31646,\r\n61036:64029,\r\n61037:32072,\r\n61038:32092,\r\n61039:32183,\r\n61040:32160,\r\n61041:32214,\r\n61042:32338,\r\n61043:32583,\r\n61044:32673,\r\n61045:64030,\r\n61046:33537,\r\n61047:33634,\r\n61048:33663,\r\n61049:33735,\r\n61050:33782,\r\n61051:33864,\r\n61052:33972,\r\n61053:34131,\r\n61054:34137,\r\n61056:34155,\r\n61057:64031,\r\n61058:34224,\r\n61059:64032,\r\n61060:64033,\r\n61061:34823,\r\n61062:35061,\r\n61063:35346,\r\n61064:35383,\r\n61065:35449,\r\n61066:35495,\r\n61067:35518,\r\n61068:35551,\r\n61069:64034,\r\n61070:35574,\r\n61071:35667,\r\n61072:35711,\r\n61073:36080,\r\n61074:36084,\r\n61075:36114,\r\n61076:36214,\r\n61077:64035,\r\n61078:36559,\r\n61079:64036,\r\n61080:64037,\r\n61081:36967,\r\n61082:37086,\r\n61083:64038,\r\n61084:37141,\r\n61085:37159,\r\n61086:37338,\r\n61087:37335,\r\n61088:37342,\r\n61089:37357,\r\n61090:37358,\r\n61091:37348,\r\n61092:37349,\r\n61093:37382,\r\n61094:37392,\r\n61095:37386,\r\n61096:37434,\r\n61097:37440,\r\n61098:37436,\r\n61099:37454,\r\n61100:37465,\r\n61101:37457,\r\n61102:37433,\r\n61103:37479,\r\n61104:37543,\r\n61105:37495,\r\n61106:37496,\r\n61107:37607,\r\n61108:37591,\r\n61109:37593,\r\n61110:37584,\r\n61111:64039,\r\n61112:37589,\r\n61113:37600,\r\n61114:37587,\r\n61115:37669,\r\n61116:37665,\r\n61117:37627,\r\n61118:64040,\r\n61119:37662,\r\n61120:37631,\r\n61121:37661,\r\n61122:37634,\r\n61123:37744,\r\n61124:37719,\r\n61125:37796,\r\n61126:37830,\r\n61127:37854,\r\n61128:37880,\r\n61129:37937,\r\n61130:37957,\r\n61131:37960,\r\n61132:38290,\r\n61133:63964,\r\n61134:64041,\r\n61135:38557,\r\n61136:38575,\r\n61137:38707,\r\n61138:38715,\r\n61139:38723,\r\n61140:38733,\r\n61141:38735,\r\n61142:38737,\r\n61143:38741,\r\n61144:38999,\r\n61145:39013,\r\n61146:64042,\r\n61147:64043,\r\n61148:39207,\r\n61149:64044,\r\n61150:39326,\r\n61151:39502,\r\n61152:39641,\r\n61153:39644,\r\n61154:39797,\r\n61155:39794,\r\n61156:39823,\r\n61157:39857,\r\n61158:39867,\r\n61159:39936,\r\n61160:40304,\r\n61161:40299,\r\n61162:64045,\r\n61163:40473,\r\n61164:40657,\r\n61167:8560,\r\n61168:8561,\r\n61169:8562,\r\n61170:8563,\r\n61171:8564,\r\n61172:8565,\r\n61173:8566,\r\n61174:8567,\r\n61175:8568,\r\n61176:8569,\r\n61177:65506,\r\n61178:65508,\r\n61179:65287,\r\n61180:65282,\r\n61504:57344,\r\n61505:57345,\r\n61506:57346,\r\n61507:57347,\r\n61508:57348,\r\n61509:57349,\r\n61510:57350,\r\n61511:57351,\r\n61512:57352,\r\n61513:57353,\r\n61514:57354,\r\n61515:57355,\r\n61516:57356,\r\n61517:57357,\r\n61518:57358,\r\n61519:57359,\r\n61520:57360,\r\n61521:57361,\r\n61522:57362,\r\n61523:57363,\r\n61524:57364,\r\n61525:57365,\r\n61526:57366,\r\n61527:57367,\r\n61528:57368,\r\n61529:57369,\r\n61530:57370,\r\n61531:57371,\r\n61532:57372,\r\n61533:57373,\r\n61534:57374,\r\n61535:57375,\r\n61536:57376,\r\n61537:57377,\r\n61538:57378,\r\n61539:57379,\r\n61540:57380,\r\n61541:57381,\r\n61542:57382,\r\n61543:57383,\r\n61544:57384,\r\n61545:57385,\r\n61546:57386,\r\n61547:57387,\r\n61548:57388,\r\n61549:57389,\r\n61550:57390,\r\n61551:57391,\r\n61552:57392,\r\n61553:57393,\r\n61554:57394,\r\n61555:57395,\r\n61556:57396,\r\n61557:57397,\r\n61558:57398,\r\n61559:57399,\r\n61560:57400,\r\n61561:57401,\r\n61562:57402,\r\n61563:57403,\r\n61564:57404,\r\n61565:57405,\r\n61566:57406,\r\n61568:57407,\r\n61569:57408,\r\n61570:57409,\r\n61571:57410,\r\n61572:57411,\r\n61573:57412,\r\n61574:57413,\r\n61575:57414,\r\n61576:57415,\r\n61577:57416,\r\n61578:57417,\r\n61579:57418,\r\n61580:57419,\r\n61581:57420,\r\n61582:57421,\r\n61583:57422,\r\n61584:57423,\r\n61585:57424,\r\n61586:57425,\r\n61587:57426,\r\n61588:57427,\r\n61589:57428,\r\n61590:57429,\r\n61591:57430,\r\n61592:57431,\r\n61593:57432,\r\n61594:57433,\r\n61595:57434,\r\n61596:57435,\r\n61597:57436,\r\n61598:57437,\r\n61599:57438,\r\n61600:57439,\r\n61601:57440,\r\n61602:57441,\r\n61603:57442,\r\n61604:57443,\r\n61605:57444,\r\n61606:57445,\r\n61607:57446,\r\n61608:57447,\r\n61609:57448,\r\n61610:57449,\r\n61611:57450,\r\n61612:57451,\r\n61613:57452,\r\n61614:57453,\r\n61615:57454,\r\n61616:57455,\r\n61617:57456,\r\n61618:57457,\r\n61619:57458,\r\n61620:57459,\r\n61621:57460,\r\n61622:57461,\r\n61623:57462,\r\n61624:57463,\r\n61625:57464,\r\n61626:57465,\r\n61627:57466,\r\n61628:57467,\r\n61629:57468,\r\n61630:57469,\r\n61631:57470,\r\n61632:57471,\r\n61633:57472,\r\n61634:57473,\r\n61635:57474,\r\n61636:57475,\r\n61637:57476,\r\n61638:57477,\r\n61639:57478,\r\n61640:57479,\r\n61641:57480,\r\n61642:57481,\r\n61643:57482,\r\n61644:57483,\r\n61645:57484,\r\n61646:57485,\r\n61647:57486,\r\n61648:57487,\r\n61649:57488,\r\n61650:57489,\r\n61651:57490,\r\n61652:57491,\r\n61653:57492,\r\n61654:57493,\r\n61655:57494,\r\n61656:57495,\r\n61657:57496,\r\n61658:57497,\r\n61659:57498,\r\n61660:57499,\r\n61661:57500,\r\n61662:57501,\r\n61663:57502,\r\n61664:57503,\r\n61665:57504,\r\n61666:57505,\r\n61667:57506,\r\n61668:57507,\r\n61669:57508,\r\n61670:57509,\r\n61671:57510,\r\n61672:57511,\r\n61673:57512,\r\n61674:57513,\r\n61675:57514,\r\n61676:57515,\r\n61677:57516,\r\n61678:57517,\r\n61679:57518,\r\n61680:57519,\r\n61681:57520,\r\n61682:57521,\r\n61683:57522,\r\n61684:57523,\r\n61685:57524,\r\n61686:57525,\r\n61687:57526,\r\n61688:57527,\r\n61689:57528,\r\n61690:57529,\r\n61691:57530,\r\n61692:57531,\r\n61760:57532,\r\n61761:57533,\r\n61762:57534,\r\n61763:57535,\r\n61764:57536,\r\n61765:57537,\r\n61766:57538,\r\n61767:57539,\r\n61768:57540,\r\n61769:57541,\r\n61770:57542,\r\n61771:57543,\r\n61772:57544,\r\n61773:57545,\r\n61774:57546,\r\n61775:57547,\r\n61776:57548,\r\n61777:57549,\r\n61778:57550,\r\n61779:57551,\r\n61780:57552,\r\n61781:57553,\r\n61782:57554,\r\n61783:57555,\r\n61784:57556,\r\n61785:57557,\r\n61786:57558,\r\n61787:57559,\r\n61788:57560,\r\n61789:57561,\r\n61790:57562,\r\n61791:57563,\r\n61792:57564,\r\n61793:57565,\r\n61794:57566,\r\n61795:57567,\r\n61796:57568,\r\n61797:57569,\r\n61798:57570,\r\n61799:57571,\r\n61800:57572,\r\n61801:57573,\r\n61802:57574,\r\n61803:57575,\r\n61804:57576,\r\n61805:57577,\r\n61806:57578,\r\n61807:57579,\r\n61808:57580,\r\n61809:57581,\r\n61810:57582,\r\n61811:57583,\r\n61812:57584,\r\n61813:57585,\r\n61814:57586,\r\n61815:57587,\r\n61816:57588,\r\n61817:57589,\r\n61818:57590,\r\n61819:57591,\r\n61820:57592,\r\n61821:57593,\r\n61822:57594,\r\n61824:57595,\r\n61825:57596,\r\n61826:57597,\r\n61827:57598,\r\n61828:57599,\r\n61829:57600,\r\n61830:57601,\r\n61831:57602,\r\n61832:57603,\r\n61833:57604,\r\n61834:57605,\r\n61835:57606,\r\n61836:57607,\r\n61837:57608,\r\n61838:57609,\r\n61839:57610,\r\n61840:57611,\r\n61841:57612,\r\n61842:57613,\r\n61843:57614,\r\n61844:57615,\r\n61845:57616,\r\n61846:57617,\r\n61847:57618,\r\n61848:57619,\r\n61849:57620,\r\n61850:57621,\r\n61851:57622,\r\n61852:57623,\r\n61853:57624,\r\n61854:57625,\r\n61855:57626,\r\n61856:57627,\r\n61857:57628,\r\n61858:57629,\r\n61859:57630,\r\n61860:57631,\r\n61861:57632,\r\n61862:57633,\r\n61863:57634,\r\n61864:57635,\r\n61865:57636,\r\n61866:57637,\r\n61867:57638,\r\n61868:57639,\r\n61869:57640,\r\n61870:57641,\r\n61871:57642,\r\n61872:57643,\r\n61873:57644,\r\n61874:57645,\r\n61875:57646,\r\n61876:57647,\r\n61877:57648,\r\n61878:57649,\r\n61879:57650,\r\n61880:57651,\r\n61881:57652,\r\n61882:57653,\r\n61883:57654,\r\n61884:57655,\r\n61885:57656,\r\n61886:57657,\r\n61887:57658,\r\n61888:57659,\r\n61889:57660,\r\n61890:57661,\r\n61891:57662,\r\n61892:57663,\r\n61893:57664,\r\n61894:57665,\r\n61895:57666,\r\n61896:57667,\r\n61897:57668,\r\n61898:57669,\r\n61899:57670,\r\n61900:57671,\r\n61901:57672,\r\n61902:57673,\r\n61903:57674,\r\n61904:57675,\r\n61905:57676,\r\n61906:57677,\r\n61907:57678,\r\n61908:57679,\r\n61909:57680,\r\n61910:57681,\r\n61911:57682,\r\n61912:57683,\r\n61913:57684,\r\n61914:57685,\r\n61915:57686,\r\n61916:57687,\r\n61917:57688,\r\n61918:57689,\r\n61919:57690,\r\n61920:57691,\r\n61921:57692,\r\n61922:57693,\r\n61923:57694,\r\n61924:57695,\r\n61925:57696,\r\n61926:57697,\r\n61927:57698,\r\n61928:57699,\r\n61929:57700,\r\n61930:57701,\r\n61931:57702,\r\n61932:57703,\r\n61933:57704,\r\n61934:57705,\r\n61935:57706,\r\n61936:57707,\r\n61937:57708,\r\n61938:57709,\r\n61939:57710,\r\n61940:57711,\r\n61941:57712,\r\n61942:57713,\r\n61943:57714,\r\n61944:57715,\r\n61945:57716,\r\n61946:57717,\r\n61947:57718,\r\n61948:57719,\r\n62016:57720,\r\n62017:57721,\r\n62018:57722,\r\n62019:57723,\r\n62020:57724,\r\n62021:57725,\r\n62022:57726,\r\n62023:57727,\r\n62024:57728,\r\n62025:57729,\r\n62026:57730,\r\n62027:57731,\r\n62028:57732,\r\n62029:57733,\r\n62030:57734,\r\n62031:57735,\r\n62032:57736,\r\n62033:57737,\r\n62034:57738,\r\n62035:57739,\r\n62036:57740,\r\n62037:57741,\r\n62038:57742,\r\n62039:57743,\r\n62040:57744,\r\n62041:57745,\r\n62042:57746,\r\n62043:57747,\r\n62044:57748,\r\n62045:57749,\r\n62046:57750,\r\n62047:57751,\r\n62048:57752,\r\n62049:57753,\r\n62050:57754,\r\n62051:57755,\r\n62052:57756,\r\n62053:57757,\r\n62054:57758,\r\n62055:57759,\r\n62056:57760,\r\n62057:57761,\r\n62058:57762,\r\n62059:57763,\r\n62060:57764,\r\n62061:57765,\r\n62062:57766,\r\n62063:57767,\r\n62064:57768,\r\n62065:57769,\r\n62066:57770,\r\n62067:57771,\r\n62068:57772,\r\n62069:57773,\r\n62070:57774,\r\n62071:57775,\r\n62072:57776,\r\n62073:57777,\r\n62074:57778,\r\n62075:57779,\r\n62076:57780,\r\n62077:57781,\r\n62078:57782,\r\n62080:57783,\r\n62081:57784,\r\n62082:57785,\r\n62083:57786,\r\n62084:57787,\r\n62085:57788,\r\n62086:57789,\r\n62087:57790,\r\n62088:57791,\r\n62089:57792,\r\n62090:57793,\r\n62091:57794,\r\n62092:57795,\r\n62093:57796,\r\n62094:57797,\r\n62095:57798,\r\n62096:57799,\r\n62097:57800,\r\n62098:57801,\r\n62099:57802,\r\n62100:57803,\r\n62101:57804,\r\n62102:57805,\r\n62103:57806,\r\n62104:57807,\r\n62105:57808,\r\n62106:57809,\r\n62107:57810,\r\n62108:57811,\r\n62109:57812,\r\n62110:57813,\r\n62111:57814,\r\n62112:57815,\r\n62113:57816,\r\n62114:57817,\r\n62115:57818,\r\n62116:57819,\r\n62117:57820,\r\n62118:57821,\r\n62119:57822,\r\n62120:57823,\r\n62121:57824,\r\n62122:57825,\r\n62123:57826,\r\n62124:57827,\r\n62125:57828,\r\n62126:57829,\r\n62127:57830,\r\n62128:57831,\r\n62129:57832,\r\n62130:57833,\r\n62131:57834,\r\n62132:57835,\r\n62133:57836,\r\n62134:57837,\r\n62135:57838,\r\n62136:57839,\r\n62137:57840,\r\n62138:57841,\r\n62139:57842,\r\n62140:57843,\r\n62141:57844,\r\n62142:57845,\r\n62143:57846,\r\n62144:57847,\r\n62145:57848,\r\n62146:57849,\r\n62147:57850,\r\n62148:57851,\r\n62149:57852,\r\n62150:57853,\r\n62151:57854,\r\n62152:57855,\r\n62153:57856,\r\n62154:57857,\r\n62155:57858,\r\n62156:57859,\r\n62157:57860,\r\n62158:57861,\r\n62159:57862,\r\n62160:57863,\r\n62161:57864,\r\n62162:57865,\r\n62163:57866,\r\n62164:57867,\r\n62165:57868,\r\n62166:57869,\r\n62167:57870,\r\n62168:57871,\r\n62169:57872,\r\n62170:57873,\r\n62171:57874,\r\n62172:57875,\r\n62173:57876,\r\n62174:57877,\r\n62175:57878,\r\n62176:57879,\r\n62177:57880,\r\n62178:57881,\r\n62179:57882,\r\n62180:57883,\r\n62181:57884,\r\n62182:57885,\r\n62183:57886,\r\n62184:57887,\r\n62185:57888,\r\n62186:57889,\r\n62187:57890,\r\n62188:57891,\r\n62189:57892,\r\n62190:57893,\r\n62191:57894,\r\n62192:57895,\r\n62193:57896,\r\n62194:57897,\r\n62195:57898,\r\n62196:57899,\r\n62197:57900,\r\n62198:57901,\r\n62199:57902,\r\n62200:57903,\r\n62201:57904,\r\n62202:57905,\r\n62203:57906,\r\n62204:57907,\r\n62272:57908,\r\n62273:57909,\r\n62274:57910,\r\n62275:57911,\r\n62276:57912,\r\n62277:57913,\r\n62278:57914,\r\n62279:57915,\r\n62280:57916,\r\n62281:57917,\r\n62282:57918,\r\n62283:57919,\r\n62284:57920,\r\n62285:57921,\r\n62286:57922,\r\n62287:57923,\r\n62288:57924,\r\n62289:57925,\r\n62290:57926,\r\n62291:57927,\r\n62292:57928,\r\n62293:57929,\r\n62294:57930,\r\n62295:57931,\r\n62296:57932,\r\n62297:57933,\r\n62298:57934,\r\n62299:57935,\r\n62300:57936,\r\n62301:57937,\r\n62302:57938,\r\n62303:57939,\r\n62304:57940,\r\n62305:57941,\r\n62306:57942,\r\n62307:57943,\r\n62308:57944,\r\n62309:57945,\r\n62310:57946,\r\n62311:57947,\r\n62312:57948,\r\n62313:57949,\r\n62314:57950,\r\n62315:57951,\r\n62316:57952,\r\n62317:57953,\r\n62318:57954,\r\n62319:57955,\r\n62320:57956,\r\n62321:57957,\r\n62322:57958,\r\n62323:57959,\r\n62324:57960,\r\n62325:57961,\r\n62326:57962,\r\n62327:57963,\r\n62328:57964,\r\n62329:57965,\r\n62330:57966,\r\n62331:57967,\r\n62332:57968,\r\n62333:57969,\r\n62334:57970,\r\n62336:57971,\r\n62337:57972,\r\n62338:57973,\r\n62339:57974,\r\n62340:57975,\r\n62341:57976,\r\n62342:57977,\r\n62343:57978,\r\n62344:57979,\r\n62345:57980,\r\n62346:57981,\r\n62347:57982,\r\n62348:57983,\r\n62349:57984,\r\n62350:57985,\r\n62351:57986,\r\n62352:57987,\r\n62353:57988,\r\n62354:57989,\r\n62355:57990,\r\n62356:57991,\r\n62357:57992,\r\n62358:57993,\r\n62359:57994,\r\n62360:57995,\r\n62361:57996,\r\n62362:57997,\r\n62363:57998,\r\n62364:57999,\r\n62365:58000,\r\n62366:58001,\r\n62367:58002,\r\n62368:58003,\r\n62369:58004,\r\n62370:58005,\r\n62371:58006,\r\n62372:58007,\r\n62373:58008,\r\n62374:58009,\r\n62375:58010,\r\n62376:58011,\r\n62377:58012,\r\n62378:58013,\r\n62379:58014,\r\n62380:58015,\r\n62381:58016,\r\n62382:58017,\r\n62383:58018,\r\n62384:58019,\r\n62385:58020,\r\n62386:58021,\r\n62387:58022,\r\n62388:58023,\r\n62389:58024,\r\n62390:58025,\r\n62391:58026,\r\n62392:58027,\r\n62393:58028,\r\n62394:58029,\r\n62395:58030,\r\n62396:58031,\r\n62397:58032,\r\n62398:58033,\r\n62399:58034,\r\n62400:58035,\r\n62401:58036,\r\n62402:58037,\r\n62403:58038,\r\n62404:58039,\r\n62405:58040,\r\n62406:58041,\r\n62407:58042,\r\n62408:58043,\r\n62409:58044,\r\n62410:58045,\r\n62411:58046,\r\n62412:58047,\r\n62413:58048,\r\n62414:58049,\r\n62415:58050,\r\n62416:58051,\r\n62417:58052,\r\n62418:58053,\r\n62419:58054,\r\n62420:58055,\r\n62421:58056,\r\n62422:58057,\r\n62423:58058,\r\n62424:58059,\r\n62425:58060,\r\n62426:58061,\r\n62427:58062,\r\n62428:58063,\r\n62429:58064,\r\n62430:58065,\r\n62431:58066,\r\n62432:58067,\r\n62433:58068,\r\n62434:58069,\r\n62435:58070,\r\n62436:58071,\r\n62437:58072,\r\n62438:58073,\r\n62439:58074,\r\n62440:58075,\r\n62441:58076,\r\n62442:58077,\r\n62443:58078,\r\n62444:58079,\r\n62445:58080,\r\n62446:58081,\r\n62447:58082,\r\n62448:58083,\r\n62449:58084,\r\n62450:58085,\r\n62451:58086,\r\n62452:58087,\r\n62453:58088,\r\n62454:58089,\r\n62455:58090,\r\n62456:58091,\r\n62457:58092,\r\n62458:58093,\r\n62459:58094,\r\n62460:58095,\r\n62528:58096,\r\n62529:58097,\r\n62530:58098,\r\n62531:58099,\r\n62532:58100,\r\n62533:58101,\r\n62534:58102,\r\n62535:58103,\r\n62536:58104,\r\n62537:58105,\r\n62538:58106,\r\n62539:58107,\r\n62540:58108,\r\n62541:58109,\r\n62542:58110,\r\n62543:58111,\r\n62544:58112,\r\n62545:58113,\r\n62546:58114,\r\n62547:58115,\r\n62548:58116,\r\n62549:58117,\r\n62550:58118,\r\n62551:58119,\r\n62552:58120,\r\n62553:58121,\r\n62554:58122,\r\n62555:58123,\r\n62556:58124,\r\n62557:58125,\r\n62558:58126,\r\n62559:58127,\r\n62560:58128,\r\n62561:58129,\r\n62562:58130,\r\n62563:58131,\r\n62564:58132,\r\n62565:58133,\r\n62566:58134,\r\n62567:58135,\r\n62568:58136,\r\n62569:58137,\r\n62570:58138,\r\n62571:58139,\r\n62572:58140,\r\n62573:58141,\r\n62574:58142,\r\n62575:58143,\r\n62576:58144,\r\n62577:58145,\r\n62578:58146,\r\n62579:58147,\r\n62580:58148,\r\n62581:58149,\r\n62582:58150,\r\n62583:58151,\r\n62584:58152,\r\n62585:58153,\r\n62586:58154,\r\n62587:58155,\r\n62588:58156,\r\n62589:58157,\r\n62590:58158,\r\n62592:58159,\r\n62593:58160,\r\n62594:58161,\r\n62595:58162,\r\n62596:58163,\r\n62597:58164,\r\n62598:58165,\r\n62599:58166,\r\n62600:58167,\r\n62601:58168,\r\n62602:58169,\r\n62603:58170,\r\n62604:58171,\r\n62605:58172,\r\n62606:58173,\r\n62607:58174,\r\n62608:58175,\r\n62609:58176,\r\n62610:58177,\r\n62611:58178,\r\n62612:58179,\r\n62613:58180,\r\n62614:58181,\r\n62615:58182,\r\n62616:58183,\r\n62617:58184,\r\n62618:58185,\r\n62619:58186,\r\n62620:58187,\r\n62621:58188,\r\n62622:58189,\r\n62623:58190,\r\n62624:58191,\r\n62625:58192,\r\n62626:58193,\r\n62627:58194,\r\n62628:58195,\r\n62629:58196,\r\n62630:58197,\r\n62631:58198,\r\n62632:58199,\r\n62633:58200,\r\n62634:58201,\r\n62635:58202,\r\n62636:58203,\r\n62637:58204,\r\n62638:58205,\r\n62639:58206,\r\n62640:58207,\r\n62641:58208,\r\n62642:58209,\r\n62643:58210,\r\n62644:58211,\r\n62645:58212,\r\n62646:58213,\r\n62647:58214,\r\n62648:58215,\r\n62649:58216,\r\n62650:58217,\r\n62651:58218,\r\n62652:58219,\r\n62653:58220,\r\n62654:58221,\r\n62655:58222,\r\n62656:58223,\r\n62657:58224,\r\n62658:58225,\r\n62659:58226,\r\n62660:58227,\r\n62661:58228,\r\n62662:58229,\r\n62663:58230,\r\n62664:58231,\r\n62665:58232,\r\n62666:58233,\r\n62667:58234,\r\n62668:58235,\r\n62669:58236,\r\n62670:58237,\r\n62671:58238,\r\n62672:58239,\r\n62673:58240,\r\n62674:58241,\r\n62675:58242,\r\n62676:58243,\r\n62677:58244,\r\n62678:58245,\r\n62679:58246,\r\n62680:58247,\r\n62681:58248,\r\n62682:58249,\r\n62683:58250,\r\n62684:58251,\r\n62685:58252,\r\n62686:58253,\r\n62687:58254,\r\n62688:58255,\r\n62689:58256,\r\n62690:58257,\r\n62691:58258,\r\n62692:58259,\r\n62693:58260,\r\n62694:58261,\r\n62695:58262,\r\n62696:58263,\r\n62697:58264,\r\n62698:58265,\r\n62699:58266,\r\n62700:58267,\r\n62701:58268,\r\n62702:58269,\r\n62703:58270,\r\n62704:58271,\r\n62705:58272,\r\n62706:58273,\r\n62707:58274,\r\n62708:58275,\r\n62709:58276,\r\n62710:58277,\r\n62711:58278,\r\n62712:58279,\r\n62713:58280,\r\n62714:58281,\r\n62715:58282,\r\n62716:58283,\r\n62784:58284,\r\n62785:58285,\r\n62786:58286,\r\n62787:58287,\r\n62788:58288,\r\n62789:58289,\r\n62790:58290,\r\n62791:58291,\r\n62792:58292,\r\n62793:58293,\r\n62794:58294,\r\n62795:58295,\r\n62796:58296,\r\n62797:58297,\r\n62798:58298,\r\n62799:58299,\r\n62800:58300,\r\n62801:58301,\r\n62802:58302,\r\n62803:58303,\r\n62804:58304,\r\n62805:58305,\r\n62806:58306,\r\n62807:58307,\r\n62808:58308,\r\n62809:58309,\r\n62810:58310,\r\n62811:58311,\r\n62812:58312,\r\n62813:58313,\r\n62814:58314,\r\n62815:58315,\r\n62816:58316,\r\n62817:58317,\r\n62818:58318,\r\n62819:58319,\r\n62820:58320,\r\n62821:58321,\r\n62822:58322,\r\n62823:58323,\r\n62824:58324,\r\n62825:58325,\r\n62826:58326,\r\n62827:58327,\r\n62828:58328,\r\n62829:58329,\r\n62830:58330,\r\n62831:58331,\r\n62832:58332,\r\n62833:58333,\r\n62834:58334,\r\n62835:58335,\r\n62836:58336,\r\n62837:58337,\r\n62838:58338,\r\n62839:58339,\r\n62840:58340,\r\n62841:58341,\r\n62842:58342,\r\n62843:58343,\r\n62844:58344,\r\n62845:58345,\r\n62846:58346,\r\n62848:58347,\r\n62849:58348,\r\n62850:58349,\r\n62851:58350,\r\n62852:58351,\r\n62853:58352,\r\n62854:58353,\r\n62855:58354,\r\n62856:58355,\r\n62857:58356,\r\n62858:58357,\r\n62859:58358,\r\n62860:58359,\r\n62861:58360,\r\n62862:58361,\r\n62863:58362,\r\n62864:58363,\r\n62865:58364,\r\n62866:58365,\r\n62867:58366,\r\n62868:58367,\r\n62869:58368,\r\n62870:58369,\r\n62871:58370,\r\n62872:58371,\r\n62873:58372,\r\n62874:58373,\r\n62875:58374,\r\n62876:58375,\r\n62877:58376,\r\n62878:58377,\r\n62879:58378,\r\n62880:58379,\r\n62881:58380,\r\n62882:58381,\r\n62883:58382,\r\n62884:58383,\r\n62885:58384,\r\n62886:58385,\r\n62887:58386,\r\n62888:58387,\r\n62889:58388,\r\n62890:58389,\r\n62891:58390,\r\n62892:58391,\r\n62893:58392,\r\n62894:58393,\r\n62895:58394,\r\n62896:58395,\r\n62897:58396,\r\n62898:58397,\r\n62899:58398,\r\n62900:58399,\r\n62901:58400,\r\n62902:58401,\r\n62903:58402,\r\n62904:58403,\r\n62905:58404,\r\n62906:58405,\r\n62907:58406,\r\n62908:58407,\r\n62909:58408,\r\n62910:58409,\r\n62911:58410,\r\n62912:58411,\r\n62913:58412,\r\n62914:58413,\r\n62915:58414,\r\n62916:58415,\r\n62917:58416,\r\n62918:58417,\r\n62919:58418,\r\n62920:58419,\r\n62921:58420,\r\n62922:58421,\r\n62923:58422,\r\n62924:58423,\r\n62925:58424,\r\n62926:58425,\r\n62927:58426,\r\n62928:58427,\r\n62929:58428,\r\n62930:58429,\r\n62931:58430,\r\n62932:58431,\r\n62933:58432,\r\n62934:58433,\r\n62935:58434,\r\n62936:58435,\r\n62937:58436,\r\n62938:58437,\r\n62939:58438,\r\n62940:58439,\r\n62941:58440,\r\n62942:58441,\r\n62943:58442,\r\n62944:58443,\r\n62945:58444,\r\n62946:58445,\r\n62947:58446,\r\n62948:58447,\r\n62949:58448,\r\n62950:58449,\r\n62951:58450,\r\n62952:58451,\r\n62953:58452,\r\n62954:58453,\r\n62955:58454,\r\n62956:58455,\r\n62957:58456,\r\n62958:58457,\r\n62959:58458,\r\n62960:58459,\r\n62961:58460,\r\n62962:58461,\r\n62963:58462,\r\n62964:58463,\r\n62965:58464,\r\n62966:58465,\r\n62967:58466,\r\n62968:58467,\r\n62969:58468,\r\n62970:58469,\r\n62971:58470,\r\n62972:58471,\r\n63040:58472,\r\n63041:58473,\r\n63042:58474,\r\n63043:58475,\r\n63044:58476,\r\n63045:58477,\r\n63046:58478,\r\n63047:58479,\r\n63048:58480,\r\n63049:58481,\r\n63050:58482,\r\n63051:58483,\r\n63052:58484,\r\n63053:58485,\r\n63054:58486,\r\n63055:58487,\r\n63056:58488,\r\n63057:58489,\r\n63058:58490,\r\n63059:58491,\r\n63060:58492,\r\n63061:58493,\r\n63062:58494,\r\n63063:58495,\r\n63064:58496,\r\n63065:58497,\r\n63066:58498,\r\n63067:58499,\r\n63068:58500,\r\n63069:58501,\r\n63070:58502,\r\n63071:58503,\r\n63072:58504,\r\n63073:58505,\r\n63074:58506,\r\n63075:58507,\r\n63076:58508,\r\n63077:58509,\r\n63078:58510,\r\n63079:58511,\r\n63080:58512,\r\n63081:58513,\r\n63082:58514,\r\n63083:58515,\r\n63084:58516,\r\n63085:58517,\r\n63086:58518,\r\n63087:58519,\r\n63088:58520,\r\n63089:58521,\r\n63090:58522,\r\n63091:58523,\r\n63092:58524,\r\n63093:58525,\r\n63094:58526,\r\n63095:58527,\r\n63096:58528,\r\n63097:58529,\r\n63098:58530,\r\n63099:58531,\r\n63100:58532,\r\n63101:58533,\r\n63102:58534,\r\n63104:58535,\r\n63105:58536,\r\n63106:58537,\r\n63107:58538,\r\n63108:58539,\r\n63109:58540,\r\n63110:58541,\r\n63111:58542,\r\n63112:58543,\r\n63113:58544,\r\n63114:58545,\r\n63115:58546,\r\n63116:58547,\r\n63117:58548,\r\n63118:58549,\r\n63119:58550,\r\n63120:58551,\r\n63121:58552,\r\n63122:58553,\r\n63123:58554,\r\n63124:58555,\r\n63125:58556,\r\n63126:58557,\r\n63127:58558,\r\n63128:58559,\r\n63129:58560,\r\n63130:58561,\r\n63131:58562,\r\n63132:58563,\r\n63133:58564,\r\n63134:58565,\r\n63135:58566,\r\n63136:58567,\r\n63137:58568,\r\n63138:58569,\r\n63139:58570,\r\n63140:58571,\r\n63141:58572,\r\n63142:58573,\r\n63143:58574,\r\n63144:58575,\r\n63145:58576,\r\n63146:58577,\r\n63147:58578,\r\n63148:58579,\r\n63149:58580,\r\n63150:58581,\r\n63151:58582,\r\n63152:58583,\r\n63153:58584,\r\n63154:58585,\r\n63155:58586,\r\n63156:58587,\r\n63157:58588,\r\n63158:58589,\r\n63159:58590,\r\n63160:58591,\r\n63161:58592,\r\n63162:58593,\r\n63163:58594,\r\n63164:58595,\r\n63165:58596,\r\n63166:58597,\r\n63167:58598,\r\n63168:58599,\r\n63169:58600,\r\n63170:58601,\r\n63171:58602,\r\n63172:58603,\r\n63173:58604,\r\n63174:58605,\r\n63175:58606,\r\n63176:58607,\r\n63177:58608,\r\n63178:58609,\r\n63179:58610,\r\n63180:58611,\r\n63181:58612,\r\n63182:58613,\r\n63183:58614,\r\n63184:58615,\r\n63185:58616,\r\n63186:58617,\r\n63187:58618,\r\n63188:58619,\r\n63189:58620,\r\n63190:58621,\r\n63191:58622,\r\n63192:58623,\r\n63193:58624,\r\n63194:58625,\r\n63195:58626,\r\n63196:58627,\r\n63197:58628,\r\n63198:58629,\r\n63199:58630,\r\n63200:58631,\r\n63201:58632,\r\n63202:58633,\r\n63203:58634,\r\n63204:58635,\r\n63205:58636,\r\n63206:58637,\r\n63207:58638,\r\n63208:58639,\r\n63209:58640,\r\n63210:58641,\r\n63211:58642,\r\n63212:58643,\r\n63213:58644,\r\n63214:58645,\r\n63215:58646,\r\n63216:58647,\r\n63217:58648,\r\n63218:58649,\r\n63219:58650,\r\n63220:58651,\r\n63221:58652,\r\n63222:58653,\r\n63223:58654,\r\n63224:58655,\r\n63225:58656,\r\n63226:58657,\r\n63227:58658,\r\n63228:58659,\r\n63296:58660,\r\n63297:58661,\r\n63298:58662,\r\n63299:58663,\r\n63300:58664,\r\n63301:58665,\r\n63302:58666,\r\n63303:58667,\r\n63304:58668,\r\n63305:58669,\r\n63306:58670,\r\n63307:58671,\r\n63308:58672,\r\n63309:58673,\r\n63310:58674,\r\n63311:58675,\r\n63312:58676,\r\n63313:58677,\r\n63314:58678,\r\n63315:58679,\r\n63316:58680,\r\n63317:58681,\r\n63318:58682,\r\n63319:58683,\r\n63320:58684,\r\n63321:58685,\r\n63322:58686,\r\n63323:58687,\r\n63324:58688,\r\n63325:58689,\r\n63326:58690,\r\n63327:58691,\r\n63328:58692,\r\n63329:58693,\r\n63330:58694,\r\n63331:58695,\r\n63332:58696,\r\n63333:58697,\r\n63334:58698,\r\n63335:58699,\r\n63336:58700,\r\n63337:58701,\r\n63338:58702,\r\n63339:58703,\r\n63340:58704,\r\n63341:58705,\r\n63342:58706,\r\n63343:58707,\r\n63344:58708,\r\n63345:58709,\r\n63346:58710,\r\n63347:58711,\r\n63348:58712,\r\n63349:58713,\r\n63350:58714,\r\n63351:58715,\r\n63352:58716,\r\n63353:58717,\r\n63354:58718,\r\n63355:58719,\r\n63356:58720,\r\n63357:58721,\r\n63358:58722,\r\n63360:58723,\r\n63361:58724,\r\n63362:58725,\r\n63363:58726,\r\n63364:58727,\r\n63365:58728,\r\n63366:58729,\r\n63367:58730,\r\n63368:58731,\r\n63369:58732,\r\n63370:58733,\r\n63371:58734,\r\n63372:58735,\r\n63373:58736,\r\n63374:58737,\r\n63375:58738,\r\n63376:58739,\r\n63377:58740,\r\n63378:58741,\r\n63379:58742,\r\n63380:58743,\r\n63381:58744,\r\n63382:58745,\r\n63383:58746,\r\n63384:58747,\r\n63385:58748,\r\n63386:58749,\r\n63387:58750,\r\n63388:58751,\r\n63389:58752,\r\n63390:58753,\r\n63391:58754,\r\n63392:58755,\r\n63393:58756,\r\n63394:58757,\r\n63395:58758,\r\n63396:58759,\r\n63397:58760,\r\n63398:58761,\r\n63399:58762,\r\n63400:58763,\r\n63401:58764,\r\n63402:58765,\r\n63403:58766,\r\n63404:58767,\r\n63405:58768,\r\n63406:58769,\r\n63407:58770,\r\n63408:58771,\r\n63409:58772,\r\n63410:58773,\r\n63411:58774,\r\n63412:58775,\r\n63413:58776,\r\n63414:58777,\r\n63415:58778,\r\n63416:58779,\r\n63417:58780,\r\n63418:58781,\r\n63419:58782,\r\n63420:58783,\r\n63421:58784,\r\n63422:58785,\r\n63423:58786,\r\n63424:58787,\r\n63425:58788,\r\n63426:58789,\r\n63427:58790,\r\n63428:58791,\r\n63429:58792,\r\n63430:58793,\r\n63431:58794,\r\n63432:58795,\r\n63433:58796,\r\n63434:58797,\r\n63435:58798,\r\n63436:58799,\r\n63437:58800,\r\n63438:58801,\r\n63439:58802,\r\n63440:58803,\r\n63441:58804,\r\n63442:58805,\r\n63443:58806,\r\n63444:58807,\r\n63445:58808,\r\n63446:58809,\r\n63447:58810,\r\n63448:58811,\r\n63449:58812,\r\n63450:58813,\r\n63451:58814,\r\n63452:58815,\r\n63453:58816,\r\n63454:58817,\r\n63455:58818,\r\n63456:58819,\r\n63457:58820,\r\n63458:58821,\r\n63459:58822,\r\n63460:58823,\r\n63461:58824,\r\n63462:58825,\r\n63463:58826,\r\n63464:58827,\r\n63465:58828,\r\n63466:58829,\r\n63467:58830,\r\n63468:58831,\r\n63469:58832,\r\n63470:58833,\r\n63471:58834,\r\n63472:58835,\r\n63473:58836,\r\n63474:58837,\r\n63475:58838,\r\n63476:58839,\r\n63477:58840,\r\n63478:58841,\r\n63479:58842,\r\n63480:58843,\r\n63481:58844,\r\n63482:58845,\r\n63483:58846,\r\n63484:58847,\r\n63552:58848,\r\n63553:58849,\r\n63554:58850,\r\n63555:58851,\r\n63556:58852,\r\n63557:58853,\r\n63558:58854,\r\n63559:58855,\r\n63560:58856,\r\n63561:58857,\r\n63562:58858,\r\n63563:58859,\r\n63564:58860,\r\n63565:58861,\r\n63566:58862,\r\n63567:58863,\r\n63568:58864,\r\n63569:58865,\r\n63570:58866,\r\n63571:58867,\r\n63572:58868,\r\n63573:58869,\r\n63574:58870,\r\n63575:58871,\r\n63576:58872,\r\n63577:58873,\r\n63578:58874,\r\n63579:58875,\r\n63580:58876,\r\n63581:58877,\r\n63582:58878,\r\n63583:58879,\r\n63584:58880,\r\n63585:58881,\r\n63586:58882,\r\n63587:58883,\r\n63588:58884,\r\n63589:58885,\r\n63590:58886,\r\n63591:58887,\r\n63592:58888,\r\n63593:58889,\r\n63594:58890,\r\n63595:58891,\r\n63596:58892,\r\n63597:58893,\r\n63598:58894,\r\n63599:58895,\r\n63600:58896,\r\n63601:58897,\r\n63602:58898,\r\n63603:58899,\r\n63604:58900,\r\n63605:58901,\r\n63606:58902,\r\n63607:58903,\r\n63608:58904,\r\n63609:58905,\r\n63610:58906,\r\n63611:58907,\r\n63612:58908,\r\n63613:58909,\r\n63614:58910,\r\n63616:58911,\r\n63617:58912,\r\n63618:58913,\r\n63619:58914,\r\n63620:58915,\r\n63621:58916,\r\n63622:58917,\r\n63623:58918,\r\n63624:58919,\r\n63625:58920,\r\n63626:58921,\r\n63627:58922,\r\n63628:58923,\r\n63629:58924,\r\n63630:58925,\r\n63631:58926,\r\n63632:58927,\r\n63633:58928,\r\n63634:58929,\r\n63635:58930,\r\n63636:58931,\r\n63637:58932,\r\n63638:58933,\r\n63639:58934,\r\n63640:58935,\r\n63641:58936,\r\n63642:58937,\r\n63643:58938,\r\n63644:58939,\r\n63645:58940,\r\n63646:58941,\r\n63647:58942,\r\n63648:58943,\r\n63649:58944,\r\n63650:58945,\r\n63651:58946,\r\n63652:58947,\r\n63653:58948,\r\n63654:58949,\r\n63655:58950,\r\n63656:58951,\r\n63657:58952,\r\n63658:58953,\r\n63659:58954,\r\n63660:58955,\r\n63661:58956,\r\n63662:58957,\r\n63663:58958,\r\n63664:58959,\r\n63665:58960,\r\n63666:58961,\r\n63667:58962,\r\n63668:58963,\r\n63669:58964,\r\n63670:58965,\r\n63671:58966,\r\n63672:58967,\r\n63673:58968,\r\n63674:58969,\r\n63675:58970,\r\n63676:58971,\r\n63677:58972,\r\n63678:58973,\r\n63679:58974,\r\n63680:58975,\r\n63681:58976,\r\n63682:58977,\r\n63683:58978,\r\n63684:58979,\r\n63685:58980,\r\n63686:58981,\r\n63687:58982,\r\n63688:58983,\r\n63689:58984,\r\n63690:58985,\r\n63691:58986,\r\n63692:58987,\r\n63693:58988,\r\n63694:58989,\r\n63695:58990,\r\n63696:58991,\r\n63697:58992,\r\n63698:58993,\r\n63699:58994,\r\n63700:58995,\r\n63701:58996,\r\n63702:58997,\r\n63703:58998,\r\n63704:58999,\r\n63705:59000,\r\n63706:59001,\r\n63707:59002,\r\n63708:59003,\r\n63709:59004,\r\n63710:59005,\r\n63711:59006,\r\n63712:59007,\r\n63713:59008,\r\n63714:59009,\r\n63715:59010,\r\n63716:59011,\r\n63717:59012,\r\n63718:59013,\r\n63719:59014,\r\n63720:59015,\r\n63721:59016,\r\n63722:59017,\r\n63723:59018,\r\n63724:59019,\r\n63725:59020,\r\n63726:59021,\r\n63727:59022,\r\n63728:59023,\r\n63729:59024,\r\n63730:59025,\r\n63731:59026,\r\n63732:59027,\r\n63733:59028,\r\n63734:59029,\r\n63735:59030,\r\n63736:59031,\r\n63737:59032,\r\n63738:59033,\r\n63739:59034,\r\n63740:59035,\r\n64064:8560,\r\n64065:8561,\r\n64066:8562,\r\n64067:8563,\r\n64068:8564,\r\n64069:8565,\r\n64070:8566,\r\n64071:8567,\r\n64072:8568,\r\n64073:8569,\r\n64074:8544,\r\n64075:8545,\r\n64076:8546,\r\n64077:8547,\r\n64078:8548,\r\n64079:8549,\r\n64080:8550,\r\n64081:8551,\r\n64082:8552,\r\n64083:8553,\r\n64084:65506,\r\n64085:65508,\r\n64086:65287,\r\n64087:65282,\r\n64088:12849,\r\n64089:8470,\r\n64090:8481,\r\n64091:8757,\r\n64092:32394,\r\n64093:35100,\r\n64094:37704,\r\n64095:37512,\r\n64096:34012,\r\n64097:20425,\r\n64098:28859,\r\n64099:26161,\r\n64100:26824,\r\n64101:37625,\r\n64102:26363,\r\n64103:24389,\r\n64104:20008,\r\n64105:20193,\r\n64106:20220,\r\n64107:20224,\r\n64108:20227,\r\n64109:20281,\r\n64110:20310,\r\n64111:20370,\r\n64112:20362,\r\n64113:20378,\r\n64114:20372,\r\n64115:20429,\r\n64116:20544,\r\n64117:20514,\r\n64118:20479,\r\n64119:20510,\r\n64120:20550,\r\n64121:20592,\r\n64122:20546,\r\n64123:20628,\r\n64124:20724,\r\n64125:20696,\r\n64126:20810,\r\n64128:20836,\r\n64129:20893,\r\n64130:20926,\r\n64131:20972,\r\n64132:21013,\r\n64133:21148,\r\n64134:21158,\r\n64135:21184,\r\n64136:21211,\r\n64137:21248,\r\n64138:21255,\r\n64139:21284,\r\n64140:21362,\r\n64141:21395,\r\n64142:21426,\r\n64143:21469,\r\n64144:64014,\r\n64145:21660,\r\n64146:21642,\r\n64147:21673,\r\n64148:21759,\r\n64149:21894,\r\n64150:22361,\r\n64151:22373,\r\n64152:22444,\r\n64153:22472,\r\n64154:22471,\r\n64155:64015,\r\n64156:64016,\r\n64157:22686,\r\n64158:22706,\r\n64159:22795,\r\n64160:22867,\r\n64161:22875,\r\n64162:22877,\r\n64163:22883,\r\n64164:22948,\r\n64165:22970,\r\n64166:23382,\r\n64167:23488,\r\n64168:29999,\r\n64169:23512,\r\n64170:23532,\r\n64171:23582,\r\n64172:23718,\r\n64173:23738,\r\n64174:23797,\r\n64175:23847,\r\n64176:23891,\r\n64177:64017,\r\n64178:23874,\r\n64179:23917,\r\n64180:23992,\r\n64181:23993,\r\n64182:24016,\r\n64183:24353,\r\n64184:24372,\r\n64185:24423,\r\n64186:24503,\r\n64187:24542,\r\n64188:24669,\r\n64189:24709,\r\n64190:24714,\r\n64191:24798,\r\n64192:24789,\r\n64193:24864,\r\n64194:24818,\r\n64195:24849,\r\n64196:24887,\r\n64197:24880,\r\n64198:24984,\r\n64199:25107,\r\n64200:25254,\r\n64201:25589,\r\n64202:25696,\r\n64203:25757,\r\n64204:25806,\r\n64205:25934,\r\n64206:26112,\r\n64207:26133,\r\n64208:26171,\r\n64209:26121,\r\n64210:26158,\r\n64211:26142,\r\n64212:26148,\r\n64213:26213,\r\n64214:26199,\r\n64215:26201,\r\n64216:64018,\r\n64217:26227,\r\n64218:26265,\r\n64219:26272,\r\n64220:26290,\r\n64221:26303,\r\n64222:26362,\r\n64223:26382,\r\n64224:63785,\r\n64225:26470,\r\n64226:26555,\r\n64227:26706,\r\n64228:26560,\r\n64229:26625,\r\n64230:26692,\r\n64231:26831,\r\n64232:64019,\r\n64233:26984,\r\n64234:64020,\r\n64235:27032,\r\n64236:27106,\r\n64237:27184,\r\n64238:27243,\r\n64239:27206,\r\n64240:27251,\r\n64241:27262,\r\n64242:27362,\r\n64243:27364,\r\n64244:27606,\r\n64245:27711,\r\n64246:27740,\r\n64247:27782,\r\n64248:27759,\r\n64249:27866,\r\n64250:27908,\r\n64251:28039,\r\n64252:28015,\r\n64320:28054,\r\n64321:28076,\r\n64322:28111,\r\n64323:28152,\r\n64324:28146,\r\n64325:28156,\r\n64326:28217,\r\n64327:28252,\r\n64328:28199,\r\n64329:28220,\r\n64330:28351,\r\n64331:28552,\r\n64332:28597,\r\n64333:28661,\r\n64334:28677,\r\n64335:28679,\r\n64336:28712,\r\n64337:28805,\r\n64338:28843,\r\n64339:28943,\r\n64340:28932,\r\n64341:29020,\r\n64342:28998,\r\n64343:28999,\r\n64344:64021,\r\n64345:29121,\r\n64346:29182,\r\n64347:29361,\r\n64348:29374,\r\n64349:29476,\r\n64350:64022,\r\n64351:29559,\r\n64352:29629,\r\n64353:29641,\r\n64354:29654,\r\n64355:29667,\r\n64356:29650,\r\n64357:29703,\r\n64358:29685,\r\n64359:29734,\r\n64360:29738,\r\n64361:29737,\r\n64362:29742,\r\n64363:29794,\r\n64364:29833,\r\n64365:29855,\r\n64366:29953,\r\n64367:30063,\r\n64368:30338,\r\n64369:30364,\r\n64370:30366,\r\n64371:30363,\r\n64372:30374,\r\n64373:64023,\r\n64374:30534,\r\n64375:21167,\r\n64376:30753,\r\n64377:30798,\r\n64378:30820,\r\n64379:30842,\r\n64380:31024,\r\n64381:64024,\r\n64382:64025,\r\n64384:64026,\r\n64385:31124,\r\n64386:64027,\r\n64387:31131,\r\n64388:31441,\r\n64389:31463,\r\n64390:64028,\r\n64391:31467,\r\n64392:31646,\r\n64393:64029,\r\n64394:32072,\r\n64395:32092,\r\n64396:32183,\r\n64397:32160,\r\n64398:32214,\r\n64399:32338,\r\n64400:32583,\r\n64401:32673,\r\n64402:64030,\r\n64403:33537,\r\n64404:33634,\r\n64405:33663,\r\n64406:33735,\r\n64407:33782,\r\n64408:33864,\r\n64409:33972,\r\n64410:34131,\r\n64411:34137,\r\n64412:34155,\r\n64413:64031,\r\n64414:34224,\r\n64415:64032,\r\n64416:64033,\r\n64417:34823,\r\n64418:35061,\r\n64419:35346,\r\n64420:35383,\r\n64421:35449,\r\n64422:35495,\r\n64423:35518,\r\n64424:35551,\r\n64425:64034,\r\n64426:35574,\r\n64427:35667,\r\n64428:35711,\r\n64429:36080,\r\n64430:36084,\r\n64431:36114,\r\n64432:36214,\r\n64433:64035,\r\n64434:36559,\r\n64435:64036,\r\n64436:64037,\r\n64437:36967,\r\n64438:37086,\r\n64439:64038,\r\n64440:37141,\r\n64441:37159,\r\n64442:37338,\r\n64443:37335,\r\n64444:37342,\r\n64445:37357,\r\n64446:37358,\r\n64447:37348,\r\n64448:37349,\r\n64449:37382,\r\n64450:37392,\r\n64451:37386,\r\n64452:37434,\r\n64453:37440,\r\n64454:37436,\r\n64455:37454,\r\n64456:37465,\r\n64457:37457,\r\n64458:37433,\r\n64459:37479,\r\n64460:37543,\r\n64461:37495,\r\n64462:37496,\r\n64463:37607,\r\n64464:37591,\r\n64465:37593,\r\n64466:37584,\r\n64467:64039,\r\n64468:37589,\r\n64469:37600,\r\n64470:37587,\r\n64471:37669,\r\n64472:37665,\r\n64473:37627,\r\n64474:64040,\r\n64475:37662,\r\n64476:37631,\r\n64477:37661,\r\n64478:37634,\r\n64479:37744,\r\n64480:37719,\r\n64481:37796,\r\n64482:37830,\r\n64483:37854,\r\n64484:37880,\r\n64485:37937,\r\n64486:37957,\r\n64487:37960,\r\n64488:38290,\r\n64489:63964,\r\n64490:64041,\r\n64491:38557,\r\n64492:38575,\r\n64493:38707,\r\n64494:38715,\r\n64495:38723,\r\n64496:38733,\r\n64497:38735,\r\n64498:38737,\r\n64499:38741,\r\n64500:38999,\r\n64501:39013,\r\n64502:64042,\r\n64503:64043,\r\n64504:39207,\r\n64505:64044,\r\n64506:39326,\r\n64507:39502,\r\n64508:39641,\r\n64576:39644,\r\n64577:39797,\r\n64578:39794,\r\n64579:39823,\r\n64580:39857,\r\n64581:39867,\r\n64582:39936,\r\n64583:40304,\r\n64584:40299,\r\n64585:64045,\r\n64586:40473,\r\n64587:40657\r\n};\n\n/**\r\n * @author takahiro / https://github.com/takahirox\r\n */\r\n\r\nfunction DataViewEx ( buffer, littleEndian ) {\r\n\r\n\tthis.dv = new DataView( buffer );\r\n\tthis.offset = 0;\r\n\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\r\n\tthis.encoder = new CharsetEncoder();\r\n\r\n}\r\n\r\nDataViewEx.prototype = {\r\n\r\n\tconstructor: DataViewEx,\r\n\r\n\tgetInt8: function () {\r\n\r\n\t\tvar value = this.dv.getInt8( this.offset );\r\n\t\tthis.offset += 1;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetInt8Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getInt8() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetUint8: function () {\r\n\r\n\t\tvar value = this.dv.getUint8( this.offset );\r\n\t\tthis.offset += 1;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetUint8Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getUint8() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\r\n\tgetInt16: function () {\r\n\r\n\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\r\n\t\tthis.offset += 2;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetInt16Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getInt16() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetUint16: function () {\r\n\r\n\t\tvar value = this.dv.getUint16( this.offset, this.littleEndian );\r\n\t\tthis.offset += 2;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetUint16Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getUint16() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetInt32: function () {\r\n\r\n\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\r\n\t\tthis.offset += 4;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetInt32Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getInt32() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetUint32: function () {\r\n\r\n\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\r\n\t\tthis.offset += 4;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetUint32Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getUint32() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetFloat32: function () {\r\n\r\n\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\r\n\t\tthis.offset += 4;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetFloat32Array: function( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getFloat32() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetFloat64: function () {\r\n\r\n\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\r\n\t\tthis.offset += 8;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetFloat64Array: function( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getFloat64() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetIndex: function ( type, isUnsigned ) {\r\n\r\n\t\tswitch ( type ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\treturn ( isUnsigned === true ) ? this.getUint8() : this.getInt8();\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\treturn ( isUnsigned === true ) ? this.getUint16() : this.getInt16();\r\n\r\n\t\t\tcase 4:\r\n\t\t\t\treturn this.getInt32(); // No Uint32\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow 'unknown number type ' + type + ' exception.';\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetIndexArray: function ( type, size, isUnsigned ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getIndex( type, isUnsigned ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetChars: function ( size ) {\r\n\r\n\t\tvar str = '';\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tvar value = this.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t\tif ( value === 0 ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstr += String.fromCharCode( value );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tthis.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\r\n\t},\r\n\r\n\tgetSjisStringsAsUnicode: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tvar value = this.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t\tif ( value === 0 ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ta.push( value );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tthis.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.encoder.s2u( new Uint8Array( a ) );\r\n\r\n\t},\r\n\r\n\tgetUnicodeStrings: function ( size ) {\r\n\r\n\t\tvar str = '';\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tvar value = this.getUint16();\r\n\t\t\tsize -= 2;\r\n\r\n\t\t\tif ( value === 0 ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstr += String.fromCharCode( value );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tthis.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\r\n\t},\r\n\r\n\tgetTextBuffer: function () {\r\n\r\n\t\tvar size = this.getUint32();\r\n\t\treturn this.getUnicodeStrings( size );\r\n\r\n\t}\r\n\r\n};\n\n/**\r\n * @author takahiro / https://github.com/takahirox\r\n */\r\n\r\nfunction DataCreationHelper () {\r\n}\r\n\r\nDataCreationHelper.prototype = {\r\n\r\n\tconstructor: DataCreationHelper,\r\n\r\n\tleftToRightVector3: function ( v ) {\r\n\r\n\t\tv[ 2 ] = -v[ 2 ];\r\n\r\n\t},\r\n\r\n\tleftToRightQuaternion: function ( q ) {\r\n\r\n\t\tq[ 0 ] = -q[ 0 ];\r\n\t\tq[ 1 ] = -q[ 1 ];\r\n\r\n\t},\r\n\r\n\tleftToRightEuler: function ( r ) {\r\n\r\n\t\tr[ 0 ] = -r[ 0 ];\r\n\t\tr[ 1 ] = -r[ 1 ];\r\n\r\n\t},\r\n\r\n\tleftToRightIndexOrder: function ( p ) {\r\n\r\n\t\tvar tmp = p[ 2 ];\r\n\t\tp[ 2 ] = p[ 0 ];\r\n\t\tp[ 0 ] = tmp;\r\n\r\n\t},\r\n\r\n\tleftToRightVector3Range: function ( v1, v2 ) {\r\n\r\n\t\tvar tmp = -v2[ 2 ];\r\n\t\tv2[ 2 ] = -v1[ 2 ];\r\n\t\tv1[ 2 ] = tmp;\r\n\r\n\t},\r\n\r\n\tleftToRightEulerRange: function ( r1, r2 ) {\r\n\r\n\t\tvar tmp1 = -r2[ 0 ];\r\n\t\tvar tmp2 = -r2[ 1 ];\r\n\t\tr2[ 0 ] = -r1[ 0 ];\r\n\t\tr2[ 1 ] = -r1[ 1 ];\r\n\t\tr1[ 0 ] = tmp1;\r\n\t\tr1[ 1 ] = tmp2;\r\n\r\n\t}\r\n\r\n};\n\n/**\r\n * @author takahiro / https://github.com/takahirox\r\n */\r\n\r\nfunction Parser() {\r\n}\r\n\r\nParser.prototype.parsePmd = function ( buffer, leftToRight ) {\r\n\r\n\tvar pmd = {};\r\n\tvar dv = new DataViewEx( buffer );\r\n\r\n\tpmd.metadata = {};\r\n\tpmd.metadata.format = 'pmd';\r\n\tpmd.metadata.coordinateSystem = 'left';\r\n\r\n\tvar parseHeader = function () {\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.magic = dv.getChars( 3 );\r\n\r\n\t\tif ( metadata.magic !== 'Pmd' ) {\r\n\r\n\t\t\tthrow 'PMD file magic is not Pmd, but ' + metadata.magic;\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.version = dv.getFloat32();\r\n\t\tmetadata.modelName = dv.getSjisStringsAsUnicode( 20 );\r\n\t\tmetadata.comment = dv.getSjisStringsAsUnicode( 256 );\r\n\r\n\t};\r\n\r\n\tvar parseVertices = function () {\r\n\r\n\t\tvar parseVertex = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.normal = dv.getFloat32Array( 3 );\r\n\t\t\tp.uv = dv.getFloat32Array( 2 );\r\n\t\t\tp.skinIndices = dv.getUint16Array( 2 );\r\n\t\t\tp.skinWeights = [ dv.getUint8() / 100 ];\r\n\t\t\tp.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );\r\n\t\t\tp.edgeFlag = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.vertexCount = dv.getUint32();\r\n\r\n\t\tpmd.vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.vertexCount; i++ ) {\r\n\r\n\t\t\tpmd.vertices.push( parseVertex() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseFaces = function () {\r\n\r\n\t\tvar parseFace = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.indices = dv.getUint16Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.faceCount = dv.getUint32() / 3;\r\n\r\n\t\tpmd.faces = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.faceCount; i++ ) {\r\n\r\n\t\t\tpmd.faces.push( parseFace() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMaterials = function () {\r\n\r\n\t\tvar parseMaterial = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.diffuse = dv.getFloat32Array( 4 );\r\n\t\t\tp.shininess = dv.getFloat32();\r\n\t\t\tp.specular = dv.getFloat32Array( 3 );\r\n\t\t\tp.ambient = dv.getFloat32Array( 3 );\r\n\t\t\tp.toonIndex = dv.getInt8();\r\n\t\t\tp.edgeFlag = dv.getUint8();\r\n\t\t\tp.faceCount = dv.getUint32() / 3;\r\n\t\t\tp.fileName = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.materialCount = dv.getUint32();\r\n\r\n\t\tpmd.materials = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.materialCount; i++ ) {\r\n\r\n\t\t\tpmd.materials.push( parseMaterial() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBones = function () {\r\n\r\n\t\tvar parseBone = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.parentIndex = dv.getInt16();\r\n\t\t\tp.tailIndex = dv.getInt16();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.ikIndex = dv.getInt16();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.boneCount = dv.getUint16();\r\n\r\n\t\tpmd.bones = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneCount; i++ ) {\r\n\r\n\t\t\tpmd.bones.push( parseBone() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseIks = function () {\r\n\r\n\t\tvar parseIk = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.target = dv.getUint16();\r\n\t\t\tp.effector = dv.getUint16();\r\n\t\t\tp.linkCount = dv.getUint8();\r\n\t\t\tp.iteration = dv.getUint16();\r\n\t\t\tp.maxAngle = dv.getFloat32();\r\n\r\n\t\t\tp.links = [];\r\n\t\t\tfor ( var i = 0; i < p.linkCount; i++ ) {\r\n\r\n\t\t\t\tvar link = {};\r\n\t\t\t\tlink.index = dv.getUint16();\r\n\t\t\t\tp.links.push( link );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.ikCount = dv.getUint16();\r\n\r\n\t\tpmd.iks = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.ikCount; i++ ) {\r\n\r\n\t\t\tpmd.iks.push( parseIk() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMorphs = function () {\r\n\r\n\t\tvar parseMorph = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.elementCount = dv.getUint32();\r\n\t\t\tp.type = dv.getUint8();\r\n\r\n\t\t\tp.elements = [];\r\n\t\t\tfor ( var i = 0; i < p.elementCount; i++ ) {\r\n\r\n\t\t\t\tp.elements.push( {\r\n\t\t\t\t\tindex: dv.getUint32(),\r\n\t\t\t\t\tposition: dv.getFloat32Array( 3 )\r\n\t\t\t\t} ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.morphCount = dv.getUint16();\r\n\r\n\t\tpmd.morphs = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphCount; i++ ) {\r\n\r\n\t\t\tpmd.morphs.push( parseMorph() );\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tvar parseMorphFrames = function () {\r\n\r\n\t\tvar parseMorphFrame = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.index = dv.getUint16();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.morphFrameCount = dv.getUint8();\r\n\r\n\t\tpmd.morphFrames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphFrameCount; i++ ) {\r\n\r\n\t\t\tpmd.morphFrames.push( parseMorphFrame() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBoneFrameNames = function () {\r\n\r\n\t\tvar parseBoneFrameName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 50 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.boneFrameNameCount = dv.getUint8();\r\n\r\n\t\tpmd.boneFrameNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneFrameNameCount; i++ ) {\r\n\r\n\t\t\tpmd.boneFrameNames.push( parseBoneFrameName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBoneFrames = function () {\r\n\r\n\t\tvar parseBoneFrame = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.boneIndex = dv.getInt16();\r\n\t\t\tp.frameIndex = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.boneFrameCount = dv.getUint32();\r\n\r\n\t\tpmd.boneFrames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneFrameCount; i++ ) {\r\n\r\n\t\t\tpmd.boneFrames.push( parseBoneFrame() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishHeader = function () {\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.englishCompatibility = dv.getUint8();\r\n\r\n\t\tif ( metadata.englishCompatibility > 0 ) {\r\n\r\n\t\t\tmetadata.englishModelName = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tmetadata.englishComment = dv.getSjisStringsAsUnicode( 256 );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishBoneNames = function () {\r\n\r\n\t\tvar parseEnglishBoneName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\r\n\t\tif ( metadata.englishCompatibility === 0 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tpmd.englishBoneNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneCount; i++ ) {\r\n\r\n\t\t\tpmd.englishBoneNames.push( parseEnglishBoneName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishMorphNames = function () {\r\n\r\n\t\tvar parseEnglishMorphName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\r\n\t\tif ( metadata.englishCompatibility === 0 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tpmd.englishMorphNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphCount - 1; i++ ) {\r\n\r\n\t\t\tpmd.englishMorphNames.push( parseEnglishMorphName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishBoneFrameNames = function () {\r\n\r\n\t\tvar parseEnglishBoneFrameName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 50 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\r\n\t\tif ( metadata.englishCompatibility === 0 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tpmd.englishBoneFrameNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneFrameNameCount; i++ ) {\r\n\r\n\t\t\tpmd.englishBoneFrameNames.push( parseEnglishBoneFrameName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseToonTextures = function () {\r\n\r\n\t\tvar parseToonTexture = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.fileName = dv.getSjisStringsAsUnicode( 100 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tpmd.toonTextures = [];\r\n\r\n\t\tfor ( var i = 0; i < 10; i++ ) {\r\n\r\n\t\t\tpmd.toonTextures.push( parseToonTexture() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseRigidBodies = function () {\r\n\r\n\t\tvar parseRigidBody = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.boneIndex = dv.getInt16();\r\n\t\t\tp.groupIndex = dv.getUint8();\r\n\t\t\tp.groupTarget = dv.getUint16();\r\n\t\t\tp.shapeType = dv.getUint8();\r\n\t\t\tp.width = dv.getFloat32();\r\n\t\t\tp.height = dv.getFloat32();\r\n\t\t\tp.depth = dv.getFloat32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.weight = dv.getFloat32();\r\n\t\t\tp.positionDamping = dv.getFloat32();\r\n\t\t\tp.rotationDamping = dv.getFloat32();\r\n\t\t\tp.restitution = dv.getFloat32();\r\n\t\t\tp.friction = dv.getFloat32();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.rigidBodyCount = dv.getUint32();\r\n\r\n\t\tpmd.rigidBodies = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.rigidBodyCount; i++ ) {\r\n\r\n\t\t\tpmd.rigidBodies.push( parseRigidBody() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseConstraints = function () {\r\n\r\n\t\tvar parseConstraint = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.rigidBodyIndex1 = dv.getUint32();\r\n\t\t\tp.rigidBodyIndex2 = dv.getUint32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.springPosition = dv.getFloat32Array( 3 );\r\n\t\t\tp.springRotation = dv.getFloat32Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.constraintCount = dv.getUint32();\r\n\r\n\t\tpmd.constraints = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.constraintCount; i++ ) {\r\n\r\n\t\t\tpmd.constraints.push( parseConstraint() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tparseHeader();\r\n\tparseVertices();\r\n\tparseFaces();\r\n\tparseMaterials();\r\n\tparseBones();\r\n\tparseIks();\r\n\tparseMorphs();\r\n\tparseMorphFrames();\r\n\tparseBoneFrameNames();\r\n\tparseBoneFrames();\r\n\tparseEnglishHeader();\r\n\tparseEnglishBoneNames();\r\n\tparseEnglishMorphNames();\r\n\tparseEnglishBoneFrameNames();\r\n\tparseToonTextures();\r\n\tparseRigidBodies();\r\n\tparseConstraints();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightModel( pmd );\r\n\r\n\t// console.log( pmd ); // for console debug\r\n\r\n\treturn pmd;\r\n\r\n};\r\n\r\nParser.prototype.parsePmx = function ( buffer, leftToRight ) {\r\n\r\n\tvar pmx = {};\r\n\tvar dv = new DataViewEx( buffer );\r\n\r\n\tpmx.metadata = {};\r\n\tpmx.metadata.format = 'pmx';\r\n\tpmx.metadata.coordinateSystem = 'left';\r\n\r\n\tvar parseHeader = function () {\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.magic = dv.getChars( 4 );\r\n\r\n\t\t// Note: don't remove the last blank space.\r\n\t\tif ( metadata.magic !== 'PMX ' ) {\r\n\r\n\t\t\tthrow 'PMX file magic is not PMX , but ' + metadata.magic;\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.version = dv.getFloat32();\r\n\r\n\t\tif ( metadata.version !== 2.0 && metadata.version !== 2.1 ) {\r\n\r\n\t\t\tthrow 'PMX version ' + metadata.version + ' is not supported.';\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.headerSize = dv.getUint8();\r\n\t\tmetadata.encoding = dv.getUint8();\r\n\t\tmetadata.additionalUvNum = dv.getUint8();\r\n\t\tmetadata.vertexIndexSize = dv.getUint8();\r\n\t\tmetadata.textureIndexSize = dv.getUint8();\r\n\t\tmetadata.materialIndexSize = dv.getUint8();\r\n\t\tmetadata.boneIndexSize = dv.getUint8();\r\n\t\tmetadata.morphIndexSize = dv.getUint8();\r\n\t\tmetadata.rigidBodyIndexSize = dv.getUint8();\r\n\t\tmetadata.modelName = dv.getTextBuffer();\r\n\t\tmetadata.englishModelName = dv.getTextBuffer();\r\n\t\tmetadata.comment = dv.getTextBuffer();\r\n\t\tmetadata.englishComment = dv.getTextBuffer();\r\n\r\n\t};\r\n\r\n\tvar parseVertices = function () {\r\n\r\n\t\tvar parseVertex = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.normal = dv.getFloat32Array( 3 );\r\n\t\t\tp.uv = dv.getFloat32Array( 2 );\r\n\r\n\t\t\tp.auvs = [];\r\n\r\n\t\t\tfor ( var i = 0; i < pmx.metadata.additionalUvNum; i++ ) {\r\n\r\n\t\t\t\tp.auvs.push( dv.getFloat32Array( 4 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp.type = dv.getUint8();\r\n\r\n\t\t\tvar indexSize = metadata.boneIndexSize;\r\n\r\n\t\t\tif ( p.type === 0 ) {  // BDEF1\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 1 );\r\n\t\t\t\tp.skinWeights = [ 1.0 ];\r\n\r\n\t\t\t} else if ( p.type === 1 ) {  // BDEF2\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 2 );\r\n\t\t\t\tp.skinWeights = dv.getFloat32Array( 1 );\r\n\t\t\t\tp.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );\r\n\r\n\t\t\t} else if ( p.type === 2 ) {  // BDEF4\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 4 );\r\n\t\t\t\tp.skinWeights = dv.getFloat32Array( 4 );\r\n\r\n\t\t\t} else if ( p.type === 3 ) {  // SDEF\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 2 );\r\n\t\t\t\tp.skinWeights = dv.getFloat32Array( 1 );\r\n\t\t\t\tp.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );\r\n\r\n\t\t\t\tp.skinC = dv.getFloat32Array( 3 );\r\n\t\t\t\tp.skinR0 = dv.getFloat32Array( 3 );\r\n\t\t\t\tp.skinR1 = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t\t// SDEF is not supported yet and is handled as BDEF2 so far.\r\n\t\t\t\t// TODO: SDEF support\r\n\t\t\t\tp.type = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'unsupport bone type ' + p.type + ' exception.';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp.edgeRatio = dv.getFloat32();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.vertexCount = dv.getUint32();\r\n\r\n\t\tpmx.vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.vertexCount; i++ ) {\r\n\r\n\t\t\tpmx.vertices.push( parseVertex() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseFaces = function () {\r\n\r\n\t\tvar parseFace = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.indices = dv.getIndexArray( metadata.vertexIndexSize, 3, true );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.faceCount = dv.getUint32() / 3;\r\n\r\n\t\tpmx.faces = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.faceCount; i++ ) {\r\n\r\n\t\t\tpmx.faces.push( parseFace() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseTextures = function () {\r\n\r\n\t\tvar parseTexture = function () {\r\n\r\n\t\t\treturn dv.getTextBuffer();\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.textureCount = dv.getUint32();\r\n\r\n\t\tpmx.textures = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.textureCount; i++ ) {\r\n\r\n\t\t\tpmx.textures.push( parseTexture() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMaterials = function () {\r\n\r\n\t\tvar parseMaterial = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.diffuse = dv.getFloat32Array( 4 );\r\n\t\t\tp.specular = dv.getFloat32Array( 3 );\r\n\t\t\tp.shininess = dv.getFloat32();\r\n\t\t\tp.ambient = dv.getFloat32Array( 3 );\r\n\t\t\tp.flag = dv.getUint8();\r\n\t\t\tp.edgeColor = dv.getFloat32Array( 4 );\r\n\t\t\tp.edgeSize = dv.getFloat32();\r\n\t\t\tp.textureIndex = dv.getIndex( pmx.metadata.textureIndexSize );\r\n\t\t\tp.envTextureIndex = dv.getIndex( pmx.metadata.textureIndexSize );\r\n\t\t\tp.envFlag = dv.getUint8();\r\n\t\t\tp.toonFlag = dv.getUint8();\r\n\r\n\t\t\tif ( p.toonFlag === 0 ) {\r\n\r\n\t\t\t\tp.toonIndex = dv.getIndex( pmx.metadata.textureIndexSize );\r\n\r\n\t\t\t} else if ( p.toonFlag === 1 ) {\r\n\r\n\t\t\t\tp.toonIndex = dv.getInt8();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'unknown toon flag ' + p.toonFlag + ' exception.';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp.comment = dv.getTextBuffer();\r\n\t\t\tp.faceCount = dv.getUint32() / 3;\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.materialCount = dv.getUint32();\r\n\r\n\t\tpmx.materials = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.materialCount; i++ ) {\r\n\r\n\t\t\tpmx.materials.push( parseMaterial() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBones = function () {\r\n\r\n\t\tvar parseBone = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.parentIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\tp.transformationClass = dv.getUint32();\r\n\t\t\tp.flag = dv.getUint16();\r\n\r\n\t\t\tif ( p.flag & 0x1 ) {\r\n\r\n\t\t\t\tp.connectIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp.offsetPosition = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x100 || p.flag & 0x200 ) {\r\n\r\n\t\t\t\t// Note: I don't think Grant is an appropriate name\r\n\t\t\t\t//       but I found that some English translated MMD tools use this term\r\n\t\t\t\t//       so I've named it Grant so far.\r\n\t\t\t\t//       I'd rename to more appropriate name from Grant later.\r\n\t\t\t\tvar grant = {};\r\n\r\n\t\t\t\tgrant.isLocal = ( p.flag & 0x80 ) !== 0 ? true : false;\r\n\t\t\t\tgrant.affectRotation = ( p.flag & 0x100 ) !== 0 ? true : false;\r\n\t\t\t\tgrant.affectPosition = ( p.flag & 0x200 ) !== 0 ? true : false;\r\n\t\t\t\tgrant.parentIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\tgrant.ratio = dv.getFloat32();\r\n\r\n\t\t\t\tp.grant = grant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x400 ) {\r\n\r\n\t\t\t\tp.fixAxis = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x800 ) {\r\n\r\n\t\t\t\tp.localXVector = dv.getFloat32Array( 3 );\r\n\t\t\t\tp.localZVector = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x2000 ) {\r\n\r\n\t\t\t\tp.key = dv.getUint32();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x20 ) {\r\n\r\n\t\t\t\tvar ik = {};\r\n\r\n\t\t\t\tik.effector = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\tik.target = null;\r\n\t\t\t\tik.iteration = dv.getUint32();\r\n\t\t\t\tik.maxAngle = dv.getFloat32();\r\n\t\t\t\tik.linkCount = dv.getUint32();\r\n\t\t\t\tik.links = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < ik.linkCount; i++ ) {\r\n\r\n\t\t\t\t\tvar link = {};\r\n\t\t\t\t\tlink.index = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\t\tlink.angleLimitation = dv.getUint8();\r\n\r\n\t\t\t\t\tif ( link.angleLimitation === 1 ) {\r\n\r\n\t\t\t\t\t\tlink.lowerLimitationAngle = dv.getFloat32Array( 3 );\r\n\t\t\t\t\t\tlink.upperLimitationAngle = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tik.links.push( link );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tp.ik = ik;\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.boneCount = dv.getUint32();\r\n\r\n\t\tpmx.bones = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneCount; i++ ) {\r\n\r\n\t\t\tpmx.bones.push( parseBone() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMorphs = function () {\r\n\r\n\t\tvar parseMorph = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.panel = dv.getUint8();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.elementCount = dv.getUint32();\r\n\t\t\tp.elements = [];\r\n\r\n\t\t\tfor ( var i = 0; i < p.elementCount; i++ ) {\r\n\r\n\t\t\t\tif ( p.type === 0 ) {  // group morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.morphIndexSize );\r\n\t\t\t\t\tm.ratio = dv.getFloat32();\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 1 ) {  // vertex morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.vertexIndexSize, true );\r\n\t\t\t\t\tm.position = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 2 ) {  // bone morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\t\tm.position = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tm.rotation = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 3 ) {  // uv morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.vertexIndexSize, true );\r\n\t\t\t\t\tm.uv = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 4 ) {  // additional uv1\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 5 ) {  // additional uv2\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 6 ) {  // additional uv3\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 7 ) {  // additional uv4\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 8 ) {  // material morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.materialIndexSize );\r\n\t\t\t\t\tm.type = dv.getUint8();\r\n\t\t\t\t\tm.diffuse = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.specular = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tm.shininess = dv.getFloat32();\r\n\t\t\t\t\tm.ambient = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tm.edgeColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.edgeSize = dv.getFloat32();\r\n\t\t\t\t\tm.textureColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.sphereTextureColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.toonColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.morphCount = dv.getUint32();\r\n\r\n\t\tpmx.morphs = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphCount; i++ ) {\r\n\r\n\t\t\tpmx.morphs.push( parseMorph() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseFrames = function () {\r\n\r\n\t\tvar parseFrame = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.elementCount = dv.getUint32();\r\n\t\t\tp.elements = [];\r\n\r\n\t\t\tfor ( var i = 0; i < p.elementCount; i++ ) {\r\n\r\n\t\t\t\tvar e = {};\r\n\t\t\t\te.target = dv.getUint8();\r\n\t\t\t\te.index = ( e.target === 0 ) ? dv.getIndex( pmx.metadata.boneIndexSize ) : dv.getIndex( pmx.metadata.morphIndexSize );\r\n\t\t\t\tp.elements.push( e );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.frameCount = dv.getUint32();\r\n\r\n\t\tpmx.frames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.frameCount; i++ ) {\r\n\r\n\t\t\tpmx.frames.push( parseFrame() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseRigidBodies = function () {\r\n\r\n\t\tvar parseRigidBody = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.boneIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\tp.groupIndex = dv.getUint8();\r\n\t\t\tp.groupTarget = dv.getUint16();\r\n\t\t\tp.shapeType = dv.getUint8();\r\n\t\t\tp.width = dv.getFloat32();\r\n\t\t\tp.height = dv.getFloat32();\r\n\t\t\tp.depth = dv.getFloat32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.weight = dv.getFloat32();\r\n\t\t\tp.positionDamping = dv.getFloat32();\r\n\t\t\tp.rotationDamping = dv.getFloat32();\r\n\t\t\tp.restitution = dv.getFloat32();\r\n\t\t\tp.friction = dv.getFloat32();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.rigidBodyCount = dv.getUint32();\r\n\r\n\t\tpmx.rigidBodies = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.rigidBodyCount; i++ ) {\r\n\r\n\t\t\tpmx.rigidBodies.push( parseRigidBody() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseConstraints = function () {\r\n\r\n\t\tvar parseConstraint = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.rigidBodyIndex1 = dv.getIndex( pmx.metadata.rigidBodyIndexSize );\r\n\t\t\tp.rigidBodyIndex2 = dv.getIndex( pmx.metadata.rigidBodyIndexSize );\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.springPosition = dv.getFloat32Array( 3 );\r\n\t\t\tp.springRotation = dv.getFloat32Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.constraintCount = dv.getUint32();\r\n\r\n\t\tpmx.constraints = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.constraintCount; i++ ) {\r\n\r\n\t\t\tpmx.constraints.push( parseConstraint() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tparseHeader();\r\n\tparseVertices();\r\n\tparseFaces();\r\n\tparseTextures();\r\n\tparseMaterials();\r\n\tparseBones();\r\n\tparseMorphs();\r\n\tparseFrames();\r\n\tparseRigidBodies();\r\n\tparseConstraints();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightModel( pmx );\r\n\r\n\t// console.log( pmx ); // for console debug\r\n\r\n\treturn pmx;\r\n\r\n};\r\n\r\nParser.prototype.parseVmd = function ( buffer, leftToRight ) {\r\n\r\n\tvar vmd = {};\r\n\tvar dv = new DataViewEx( buffer );\r\n\r\n\tvmd.metadata = {};\r\n\tvmd.metadata.coordinateSystem = 'left';\r\n\r\n\tvar parseHeader = function () {\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.magic = dv.getChars( 30 );\r\n\r\n\t\tif ( metadata.magic !== 'Vocaloid Motion Data 0002' ) {\r\n\r\n\t\t\tthrow 'VMD file magic is not Vocaloid Motion Data 0002, but ' + metadata.magic;\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.name = dv.getSjisStringsAsUnicode( 20 );\r\n\r\n\t};\r\n\r\n\tvar parseMotions = function () {\r\n\r\n\t\tvar parseMotion = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.boneName = dv.getSjisStringsAsUnicode( 15 );\r\n\t\t\tp.frameNum = dv.getUint32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 4 );\r\n\t\t\tp.interpolation = dv.getUint8Array( 64 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.motionCount = dv.getUint32();\r\n\r\n\t\tvmd.motions = [];\r\n\t\tfor ( var i = 0; i < metadata.motionCount; i++ ) {\r\n\r\n\t\t\tvmd.motions.push( parseMotion() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMorphs = function () {\r\n\r\n\t\tvar parseMorph = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.morphName = dv.getSjisStringsAsUnicode( 15 );\r\n\t\t\tp.frameNum = dv.getUint32();\r\n\t\t\tp.weight = dv.getFloat32();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.morphCount = dv.getUint32();\r\n\r\n\t\tvmd.morphs = [];\r\n\t\tfor ( var i = 0; i < metadata.morphCount; i++ ) {\r\n\r\n\t\t\tvmd.morphs.push( parseMorph() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseCameras = function () {\r\n\r\n\t\tvar parseCamera = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.frameNum = dv.getUint32();\r\n\t\t\tp.distance = dv.getFloat32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.interpolation = dv.getUint8Array( 24 );\r\n\t\t\tp.fov = dv.getUint32();\r\n\t\t\tp.perspective = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.cameraCount = dv.getUint32();\r\n\r\n\t\tvmd.cameras = [];\r\n\t\tfor ( var i = 0; i < metadata.cameraCount; i++ ) {\r\n\r\n\t\t\tvmd.cameras.push( parseCamera() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tparseHeader();\r\n\tparseMotions();\r\n\tparseMorphs();\r\n\tparseCameras();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightVmd( vmd );\r\n\r\n\t// console.log( vmd ); // for console debug\r\n\r\n\treturn vmd;\r\n\r\n};\r\n\r\nParser.prototype.parseVpd = function ( text, leftToRight ) {\r\n\r\n\tvar vpd = {};\r\n\r\n\tvpd.metadata = {};\r\n\tvpd.metadata.coordinateSystem = 'left';\r\n\r\n\tvpd.bones = [];\r\n\r\n\tvar commentPatternG = /\\/\\/\\w*(\\r|\\n|\\r\\n)/g;\r\n\tvar newlinePattern = /\\r|\\n|\\r\\n/;\r\n\r\n\tvar lines = text.replace( commentPatternG, '' ).split( newlinePattern );\r\n\r\n\tfunction throwError () {\r\n\r\n\t\tthrow 'the file seems not vpd file.';\r\n\r\n\t}\r\n\r\n\tfunction checkMagic () {\r\n\r\n\t\tif ( lines[ 0 ] !== 'Vocaloid Pose Data file' ) {\r\n\r\n\t\t\tthrowError();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction parseHeader () {\r\n\r\n\t\tif ( lines.length < 4 ) {\r\n\r\n\t\t\tthrowError();\r\n\r\n\t\t}\r\n\r\n\t\tvpd.metadata.parentFile = lines[ 2 ];\r\n\t\tvpd.metadata.boneCount = parseInt( lines[ 3 ] );\r\n\r\n\t}\r\n\r\n\tfunction parseBones () {\r\n\r\n\t\tvar boneHeaderPattern = /^\\s*(Bone[0-9]+)\\s*\\{\\s*(.*)$/;\r\n\t\tvar boneVectorPattern = /^\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*;/;\r\n\t\tvar boneQuaternionPattern = /^\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*;/;\r\n\t\tvar boneFooterPattern = /^\\s*}/;\r\n\r\n\t\tvar bones = vpd.bones;\r\n\t\tvar n = null;\r\n\t\tvar v = null;\r\n\t\tvar q = null;\r\n\r\n\t\tfor ( var i = 4; i < lines.length; i++ ) {\r\n\r\n\t\t\tvar line = lines[ i ];\r\n\r\n\t\t\tvar result;\r\n\r\n\t\t\tresult = line.match( boneHeaderPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( n !== null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tn = result[ 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = line.match( boneVectorPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( v !== null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tv = [\r\n\r\n\t\t\t\t\tparseFloat( result[ 1 ] ),\r\n\t\t\t\t\tparseFloat( result[ 2 ] ),\r\n\t\t\t\t\tparseFloat( result[ 3 ] )\r\n\r\n\t\t\t\t];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = line.match( boneQuaternionPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( q !== null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tq = [\r\n\r\n\t\t\t\t\tparseFloat( result[ 1 ] ),\r\n\t\t\t\t\tparseFloat( result[ 2 ] ),\r\n\t\t\t\t\tparseFloat( result[ 3 ] ),\r\n\t\t\t\t\tparseFloat( result[ 4 ] )\r\n\r\n\t\t\t\t];\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = line.match( boneFooterPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( n === null || v === null || q === null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbones.push( {\r\n\r\n\t\t\t\t\tname: n,\r\n\t\t\t\t\ttranslation: v,\r\n\t\t\t\t\tquaternion: q\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tn = null;\r\n\t\t\t\tv = null;\r\n\t\t\t\tq = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( n !== null || v !== null || q !== null ) {\r\n\r\n\t\t\tthrowError();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcheckMagic();\r\n\tparseHeader();\r\n\tparseBones();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightVpd( vpd );\r\n\r\n\t// console.log( vpd );  // for console debug\r\n\r\n\treturn vpd;\r\n\r\n};\r\n\r\nParser.prototype.mergeVmds = function ( vmds ) {\r\n\r\n\tvar v = {};\r\n\tv.metadata = {};\r\n\tv.metadata.name = vmds[ 0 ].metadata.name;\r\n\tv.metadata.coordinateSystem = vmds[ 0 ].metadata.coordinateSystem;\r\n\tv.metadata.motionCount = 0;\r\n\tv.metadata.morphCount = 0;\r\n\tv.metadata.cameraCount = 0;\r\n\tv.motions = [];\r\n\tv.morphs = [];\r\n\tv.cameras = [];\r\n\r\n\tfor ( var i = 0; i < vmds.length; i++ ) {\r\n\r\n\t\tvar v2 = vmds[ i ];\r\n\r\n\t\tv.metadata.motionCount += v2.metadata.motionCount;\r\n\t\tv.metadata.morphCount += v2.metadata.morphCount;\r\n\t\tv.metadata.cameraCount += v2.metadata.cameraCount;\r\n\r\n\t\tfor ( var j = 0; j < v2.metadata.motionCount; j++ ) {\r\n\r\n\t\t\tv.motions.push( v2.motions[ j ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 0; j < v2.metadata.morphCount; j++ ) {\r\n\r\n\t\t\tv.morphs.push( v2.morphs[ j ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 0; j < v2.metadata.cameraCount; j++ ) {\r\n\r\n\t\t\tv.cameras.push( v2.cameras[ j ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nParser.prototype.leftToRightModel = function ( model ) {\r\n\r\n\tif ( model.metadata.coordinateSystem === 'right' ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tmodel.metadata.coordinateSystem = 'right';\r\n\r\n\tvar helper = new DataCreationHelper();\r\n\r\n\tfor ( var i = 0; i < model.metadata.vertexCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.vertices[ i ].position );\r\n\t\thelper.leftToRightVector3( model.vertices[ i ].normal );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.faceCount; i++ ) {\r\n\r\n\t\thelper.leftToRightIndexOrder( model.faces[ i ].indices );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.boneCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.bones[ i ].position );\r\n\r\n\t}\r\n\r\n\t// TODO: support other morph for PMX\r\n\tfor ( var i = 0; i < model.metadata.morphCount; i++ ) {\r\n\r\n\t\tvar m = model.morphs[ i ];\r\n\r\n\t\tif ( model.metadata.format === 'pmx' && m.type !== 1 ) {\r\n\r\n\t\t\t// TODO: implement\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 0; j < m.elements.length; j++ ) {\r\n\r\n\t\t\thelper.leftToRightVector3( m.elements[ j ].position );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.rigidBodyCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.rigidBodies[ i ].position );\r\n\t\thelper.leftToRightEuler( model.rigidBodies[ i ].rotation );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.constraintCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.constraints[ i ].position );\r\n\t\thelper.leftToRightEuler( model.constraints[ i ].rotation );\r\n\t\thelper.leftToRightVector3Range( model.constraints[ i ].translationLimitation1, model.constraints[ i ].translationLimitation2 );\r\n\t\thelper.leftToRightEulerRange( model.constraints[ i ].rotationLimitation1, model.constraints[ i ].rotationLimitation2 );\r\n\r\n\t}\r\n\r\n};\r\n\r\nParser.prototype.leftToRightVmd = function ( vmd ) {\r\n\r\n\tif ( vmd.metadata.coordinateSystem === 'right' ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvmd.metadata.coordinateSystem = 'right';\r\n\r\n\tvar helper = new DataCreationHelper();\r\n\r\n\tfor ( var i = 0; i < vmd.metadata.motionCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( vmd.motions[ i ].position );\r\n\t\thelper.leftToRightQuaternion( vmd.motions[ i ].rotation );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < vmd.metadata.cameraCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( vmd.cameras[ i ].position );\r\n\t\thelper.leftToRightEuler( vmd.cameras[ i ].rotation );\r\n\r\n\t}\r\n\r\n};\r\n\r\nParser.prototype.leftToRightVpd = function ( vpd ) {\r\n\r\n\tif ( vpd.metadata.coordinateSystem === 'right' ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvpd.metadata.coordinateSystem = 'right';\r\n\r\n\tvar helper = new DataCreationHelper();\r\n\r\n\tfor ( var i = 0; i < vpd.bones.length; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( vpd.bones[ i ].translation );\r\n\t\thelper.leftToRightQuaternion( vpd.bones[ i ].quaternion );\r\n\r\n\t}\r\n\r\n};\n\nexports.CharsetEncoder = CharsetEncoder;\nexports.Parser = Parser;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nvar GLTFLoader = function () {\n\n\tfunction GLTFLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\tthis.dracoLoader = null;\n\t}\n\n\tGLTFLoader.prototype = {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);\n\n\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\n\t\t\tloader.setResponseType('arraybuffer');\n\n\t\t\tloader.load(url, function (data) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse(data, path, onLoad, onError);\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tif (onError !== undefined) {\n\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\t},\n\n\t\tsetPath: function setPath(value) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\t},\n\n\t\tsetDRACOLoader: function setDRACOLoader(dracoLoader) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\t\t},\n\n\t\tparse: function parse(data, path, onLoad, onError) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\n\t\t\tif (typeof data === 'string') {\n\n\t\t\t\tcontent = data;\n\t\t\t} else {\n\n\t\t\t\tvar magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n\t\t\t\tif (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n\t\t\t\t\t} catch (error) {\n\n\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar json = JSON.parse(content);\n\n\t\t\tif (json.asset === undefined || json.asset.version[0] < 2) {\n\n\t\t\t\tif (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (json.extensionsUsed) {\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_LIGHTS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_LIGHTS] = new GLTFLightsExtension(json);\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_UNLIT) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_MATERIALS_UNLIT] = new GLTFMaterialsUnlitExtension(json);\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_DRACO_MESH_COMPRESSION) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] = new GLTFDracoMeshCompressionExtension(this.dracoLoader);\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.MSFT_TEXTURE_DDS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parser = new GLTFParser(json, extensions, {\n\n\t\t\t\tpath: path || this.path || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\tmanager: this.manager\n\n\t\t\t});\n\n\t\t\tparser.parse(function (scene, scenes, cameras, animations, asset) {\n\n\t\t\t\tvar glTF = {\n\t\t\t\t\tscene: scene,\n\t\t\t\t\tscenes: scenes,\n\t\t\t\t\tcameras: cameras,\n\t\t\t\t\tanimations: animations,\n\t\t\t\t\tasset: asset\n\t\t\t\t};\n\n\t\t\t\tonLoad(glTF);\n\t\t\t}, onError);\n\t\t}\n\n\t};\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn {\n\n\t\t\tget: function get(key) {\n\n\t\t\t\treturn objects[key];\n\t\t\t},\n\n\t\t\tadd: function add(key, object) {\n\n\t\t\t\tobjects[key] = object;\n\t\t\t},\n\n\t\t\tremove: function remove(key) {\n\n\t\t\t\tdelete objects[key];\n\t\t\t},\n\n\t\t\tremoveAll: function removeAll() {\n\n\t\t\t\tobjects = {};\n\t\t\t}\n\n\t\t};\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS: 'KHR_lights',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n\t};\n\n\t/**\n  * DDS Texture Extension\n  *\n  * Specification:\n  * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n  *\n  */\n\tfunction GLTFTextureDDSExtension() {\n\n\t\tif (!THREE.DDSLoader) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');\n\t\t}\n\n\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n\t\tthis.ddsLoader = new THREE.DDSLoader();\n\t}\n\n\t/**\n  * Lights Extension\n  *\n  * Specification: PENDING\n  */\n\tfunction GLTFLightsExtension(json) {\n\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS;\n\n\t\tthis.lights = {};\n\n\t\tvar extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS] || {};\n\t\tvar lights = extension.lights || {};\n\n\t\tfor (var lightId in lights) {\n\n\t\t\tvar light = lights[lightId];\n\t\t\tvar lightNode;\n\n\t\t\tvar color = new THREE.Color().fromArray(light.color);\n\n\t\t\tswitch (light.type) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlightNode = new THREE.DirectionalLight(color);\n\t\t\t\t\tlightNode.target.position.set(0, 0, 1);\n\t\t\t\t\tlightNode.add(lightNode.target);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlightNode = new THREE.PointLight(color);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlightNode = new THREE.SpotLight(color);\n\t\t\t\t\t// Handle spotlight properties.\n\t\t\t\t\tlight.spot = light.spot || {};\n\t\t\t\t\tlight.spot.innerConeAngle = light.spot.innerConeAngle !== undefined ? light.spot.innerConeAngle : 0;\n\t\t\t\t\tlight.spot.outerConeAngle = light.spot.outerConeAngle !== undefined ? light.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\t\tlightNode.angle = light.spot.outerConeAngle;\n\t\t\t\t\tlightNode.penumbra = 1.0 - light.spot.innerConeAngle / light.spot.outerConeAngle;\n\t\t\t\t\tlightNode.target.position.set(0, 0, 1);\n\t\t\t\t\tlightNode.add(lightNode.target);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlightNode = new THREE.AmbientLight(color);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (lightNode) {\n\n\t\t\t\tlightNode.decay = 2;\n\n\t\t\t\tif (light.intensity !== undefined) {\n\n\t\t\t\t\tlightNode.intensity = light.intensity;\n\t\t\t\t}\n\n\t\t\t\tlightNode.name = light.name || 'light_' + lightId;\n\t\t\t\tthis.lights[lightId] = lightNode;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Unlit Materials Extension (pending)\n  *\n  * PR: https://github.com/KhronosGroup/glTF/pull/1163\n  */\n\tfunction GLTFMaterialsUnlitExtension(json) {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function (material) {\n\n\t\treturn THREE.MeshBasicMaterial;\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, material, parser) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = material.pbrMetallicRoughness;\n\n\t\tif (metallicRoughness) {\n\n\t\t\tif (Array.isArray(metallicRoughness.baseColorFactor)) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray(array);\n\t\t\t\tmaterialParams.opacity = array[3];\n\t\t\t}\n\n\t\t\tif (metallicRoughness.baseColorTexture !== undefined) {\n\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all(pending);\n\t};\n\n\t/* BINARY EXTENSION */\n\n\tvar BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension(data) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n\n\t\tthis.header = {\n\t\t\tmagic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n\t\t\tversion: headerView.getUint32(4, true),\n\t\t\tlength: headerView.getUint32(8, true)\n\t\t};\n\n\t\tif (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n\t\t} else if (this.header.version < 2.0) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n\t\t}\n\n\t\tvar chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n\t\tvar chunkIndex = 0;\n\n\t\twhile (chunkIndex < chunkView.byteLength) {\n\n\t\t\tvar chunkLength = chunkView.getUint32(chunkIndex, true);\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32(chunkIndex, true);\n\t\t\tchunkIndex += 4;\n\n\t\t\tif (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n\n\t\t\t\tvar contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n\t\t\t\tthis.content = THREE.LoaderUtils.decodeText(contentArray);\n\t\t\t} else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice(byteOffset, byteOffset + chunkLength);\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\t\t}\n\n\t\tif (this.content === null) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: JSON content not found.');\n\t\t}\n\t}\n\n\t/**\n  * DRACO Mesh Compression Extension\n  *\n  * Specification: https://github.com/KhronosGroup/glTF/pull/874\n  */\n\tfunction GLTFDracoMeshCompressionExtension(dracoLoader) {\n\n\t\tif (!dracoLoader) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.dracoLoader = dracoLoader;\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[this.name].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[this.name].attributes;\n\t\tvar threeAttributeMap = {};\n\n\t\tfor (var attributeName in gltfAttributeMap) {\n\n\t\t\tif (!(attributeName in ATTRIBUTES)) continue;\n\n\t\t\tthreeAttributeMap[ATTRIBUTES[attributeName]] = gltfAttributeMap[attributeName];\n\t\t}\n\n\t\treturn parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n\n\t\t\treturn new Promise(function (resolve) {\n\n\t\t\t\tdracoLoader.decodeDracoFile(bufferView, resolve, threeAttributeMap);\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specular-Glossiness Extension\n  *\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n  */\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n\n\t\t\tgetMaterialType: function getMaterialType() {\n\n\t\t\t\treturn THREE.ShaderMaterial;\n\t\t\t},\n\n\t\t\textendParams: function extendParams(params, material, parser) {\n\n\t\t\t\tvar pbrSpecularGlossiness = material.extensions[this.name];\n\n\t\t\t\tvar shader = THREE.ShaderLib['standard'];\n\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t\t\tvar specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n\n\t\t\t\tvar glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n\n\t\t\t\tvar specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n\n\t\t\t\tvar glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n\n\t\t\t\tvar lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n\n\t\t\t\tvar fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n\n\t\t\t\tdelete uniforms.roughness;\n\t\t\t\tdelete uniforms.metalness;\n\t\t\t\tdelete uniforms.roughnessMap;\n\t\t\t\tdelete uniforms.metalnessMap;\n\n\t\t\t\tuniforms.specular = { value: new THREE.Color().setHex(0x111111) };\n\t\t\t\tuniforms.glossiness = { value: 0.5 };\n\t\t\t\tuniforms.specularMap = { value: null };\n\t\t\t\tuniforms.glossinessMap = { value: null };\n\n\t\t\t\tparams.vertexShader = shader.vertexShader;\n\t\t\t\tparams.fragmentShader = fragmentShader;\n\t\t\t\tparams.uniforms = uniforms;\n\t\t\t\tparams.defines = { 'STANDARD': '' };\n\n\t\t\t\tparams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\t\t\tparams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tparams.color.fromArray(array);\n\t\t\t\t\tparams.opacity = array[3];\n\t\t\t\t}\n\n\t\t\t\tif (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'map', pbrSpecularGlossiness.diffuseTexture.index));\n\t\t\t\t}\n\n\t\t\t\tparams.emissive = new THREE.Color(0.0, 0.0, 0.0);\n\t\t\t\tparams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tparams.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n\t\t\t\tif (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n\n\t\t\t\t\tparams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n\t\t\t\t}\n\n\t\t\t\tif (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n\n\t\t\t\t\tvar specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'glossinessMap', specGlossIndex));\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'specularMap', specGlossIndex));\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all(pending);\n\t\t\t},\n\n\t\t\tcreateMaterial: function createMaterial(params) {\n\n\t\t\t\t// setup material properties based on MeshStandardMaterial for Specular-Glossiness\n\n\t\t\t\tvar material = new THREE.ShaderMaterial({\n\t\t\t\t\tdefines: params.defines,\n\t\t\t\t\tvertexShader: params.vertexShader,\n\t\t\t\t\tfragmentShader: params.fragmentShader,\n\t\t\t\t\tuniforms: params.uniforms,\n\t\t\t\t\tfog: true,\n\t\t\t\t\tlights: true,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\ttransparent: params.transparent\n\t\t\t\t});\n\n\t\t\t\tmaterial.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tmaterial.color = params.color;\n\n\t\t\t\tmaterial.map = params.map === undefined ? null : params.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = params.aoMap === undefined ? null : params.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = params.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = params.normalMap === undefined ? null : params.normalMap;\n\t\t\t\tif (params.normalScale) material.normalScale = params.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = params.specularMap === undefined ? null : params.specularMap;\n\t\t\t\tmaterial.specular = params.specular;\n\n\t\t\t\tmaterial.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n\t\t\t\tmaterial.glossiness = params.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = params.envMap === undefined ? null : params.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\tmaterial.extensions.derivatives = true;\n\n\t\t\t\treturn material;\n\t\t\t},\n\n\t\t\t/**\n    * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n    * copy only properties it knows about or inherits, and misses many properties that would\n    * normally be defined by MeshStandardMaterial.\n    *\n    * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n    * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n    * AND also updating `.onBeforeRender` on the parent mesh.\n    *\n    * @param  {THREE.ShaderMaterial} source\n    * @return {THREE.ShaderMaterial}\n    */\n\t\t\tcloneMaterial: function cloneMaterial(source) {\n\n\t\t\t\tvar target = source.clone();\n\n\t\t\t\ttarget.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tvar params = this.specularGlossinessParams;\n\n\t\t\t\tfor (var i = 0, il = params.length; i < il; i++) {\n\n\t\t\t\t\ttarget[params[i]] = source[params[i]];\n\t\t\t\t}\n\n\t\t\t\treturn target;\n\t\t\t},\n\n\t\t\t// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n\t\t\trefreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material, group) {\n\n\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial !== true) {\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar uniforms = material.uniforms;\n\t\t\t\tvar defines = material.defines;\n\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\t\tuniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\n\t\t\t\tvar uvScaleMap;\n\n\t\t\t\tif (material.map) {\n\n\t\t\t\t\tuvScaleMap = material.map;\n\t\t\t\t} else if (material.specularMap) {\n\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\t\t\t\t} else if (material.displacementMap) {\n\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\t\t\t\t} else if (material.normalMap) {\n\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\t\t\t\t} else if (material.bumpMap) {\n\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\t\t\t\t} else if (material.glossinessMap) {\n\n\t\t\t\t\tuvScaleMap = material.glossinessMap;\n\t\t\t\t} else if (material.alphaMap) {\n\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t\t} else if (material.emissiveMap) {\n\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\t\t\t}\n\n\t\t\t\tif (uvScaleMap !== undefined) {\n\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif (uvScaleMap.isWebGLRenderTarget) {\n\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar offset;\n\t\t\t\t\tvar repeat;\n\n\t\t\t\t\tif (uvScaleMap.matrix !== undefined) {\n\n\t\t\t\t\t\t// > r88.\n\n\t\t\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\n\t\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\t\t\t\t\t\t\tvar rotation = uvScaleMap.rotation;\n\t\t\t\t\t\t\tvar center = uvScaleMap.center;\n\n\t\t\t\t\t\t\tuvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// <= r87. Remove when reasonable.\n\n\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\n\t\t\t\t\t\tuniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t\tuniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1;\n\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tuniforms.specular.value.copy(material.specular);\n\t\t\t\tuniforms.glossiness.value = material.glossiness;\n\n\t\t\t\tuniforms.glossinessMap.value = material.glossinessMap;\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\tif (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n\n\t\t\t\t\tdefines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\tdefines.USE_ROUGHNESSMAP = '';\n\t\t\t\t}\n\n\t\t\t\tif (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n\n\t\t\t\t\tdelete defines.USE_GLOSSINESSMAP;\n\t\t\t\t\tdelete defines.USE_ROUGHNESSMAP;\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\n\t\tTHREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = (t - t0) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s0 = 2 * ppp - 3 * pp + 1;\n\t\tvar s1 = ppp - 2 * pp + p;\n\t\tvar s2 = -2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor (var i = 0; i !== stride; i++) {\n\n\t\t\tvar p0 = values[offset0 + i + stride]; // splineVertex_k\n\t\t\tvar m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\t\t\tvar m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_TYPE = {\n\t\t5126: Number,\n\t\t//35674: THREE.Matrix2,\n\t\t35675: THREE.Matrix3,\n\t\t35676: THREE.Matrix4,\n\t\t35664: THREE.Vector2,\n\t\t35665: THREE.Vector3,\n\t\t35666: THREE.Vector4,\n\t\t35678: THREE.Texture\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: THREE.NearestFilter,\n\t\t9729: THREE.LinearFilter,\n\t\t9984: THREE.NearestMipMapNearestFilter,\n\t\t9985: THREE.LinearMipMapNearestFilter,\n\t\t9986: THREE.NearestMipMapLinearFilter,\n\t\t9987: THREE.LinearMipMapLinearFilter\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t10497: THREE.RepeatWrapping\n\t};\n\n\tvar WEBGL_TEXTURE_FORMATS = {\n\t\t6406: THREE.AlphaFormat,\n\t\t6407: THREE.RGBFormat,\n\t\t6408: THREE.RGBAFormat,\n\t\t6409: THREE.LuminanceFormat,\n\t\t6410: THREE.LuminanceAlphaFormat\n\t};\n\n\tvar WEBGL_TEXTURE_DATATYPES = {\n\t\t5121: THREE.UnsignedByteType,\n\t\t32819: THREE.UnsignedShort4444Type,\n\t\t32820: THREE.UnsignedShort5551Type,\n\t\t33635: THREE.UnsignedShort565Type\n\t};\n\n\tvar WEBGL_SIDES = {\n\t\t1028: THREE.BackSide, // Culling front\n\t\t1029: THREE.FrontSide // Culling back\n\t\t//1032: THREE.NoSide   // Culling front and back, what to do?\n\t};\n\n\tvar WEBGL_DEPTH_FUNCS = {\n\t\t512: THREE.NeverDepth,\n\t\t513: THREE.LessDepth,\n\t\t514: THREE.EqualDepth,\n\t\t515: THREE.LessEqualDepth,\n\t\t516: THREE.GreaterEqualDepth,\n\t\t517: THREE.NotEqualDepth,\n\t\t518: THREE.GreaterEqualDepth,\n\t\t519: THREE.AlwaysDepth\n\t};\n\n\tvar WEBGL_BLEND_EQUATIONS = {\n\t\t32774: THREE.AddEquation,\n\t\t32778: THREE.SubtractEquation,\n\t\t32779: THREE.ReverseSubtractEquation\n\t};\n\n\tvar WEBGL_BLEND_FUNCS = {\n\t\t0: THREE.ZeroFactor,\n\t\t1: THREE.OneFactor,\n\t\t768: THREE.SrcColorFactor,\n\t\t769: THREE.OneMinusSrcColorFactor,\n\t\t770: THREE.SrcAlphaFactor,\n\t\t771: THREE.OneMinusSrcAlphaFactor,\n\t\t772: THREE.DstAlphaFactor,\n\t\t773: THREE.OneMinusDstAlphaFactor,\n\t\t774: THREE.DstColorFactor,\n\t\t775: THREE.OneMinusDstColorFactor,\n\t\t776: THREE.SrcAlphaSaturateFactor\n\t\t// The followings are not supported by Three.js yet\n\t\t//32769: CONSTANT_COLOR,\n\t\t//32770: ONE_MINUS_CONSTANT_COLOR,\n\t\t//32771: CONSTANT_ALPHA,\n\t\t//32772: ONE_MINUS_CONSTANT_COLOR\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD0: 'uv', // deprecated\n\t\tTEXCOORD: 'uv', // deprecated\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tCOLOR0: 'color', // deprecated\n\t\tCOLOR: 'color', // deprecated\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tWEIGHT: 'skinWeight', // deprecated\n\t\tJOINTS_0: 'skinIndex',\n\t\tJOINT: 'skinIndex' // deprecated\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.\n\t\t// KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,\n\t\t// using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.\n\t\t// See KeyframeTrack.optimize() for the detail.\n\t\tLINEAR: THREE.InterpolateLinear,\n\t\tSTEP: THREE.InterpolateDiscrete\n\t};\n\n\tvar STATES_ENABLES = {\n\t\t2884: 'CULL_FACE',\n\t\t2929: 'DEPTH_TEST',\n\t\t3042: 'BLEND',\n\t\t3089: 'SCISSOR_TEST',\n\t\t32823: 'POLYGON_OFFSET_FILL',\n\t\t32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL(url, path) {\n\n\t\t// Invalid URL\n\t\tif (typeof url !== 'string' || url === '') return '';\n\n\t\t// Absolute URL http://,https://,//\n\t\tif (/^(https?:)?\\/\\//i.test(url)) return url;\n\n\t\t// Data URI\n\t\tif (/^data:.*,.*$/i.test(url)) return url;\n\n\t\t// Blob URL\n\t\tif (/^blob:.*$/i.test(url)) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n  */\n\tfunction createDefaultMaterial() {\n\n\t\treturn new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: THREE.FrontSide\n\t\t});\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n  *\n  * @param {THREE.Mesh} mesh\n  * @param {GLTF.Mesh} meshDef\n  * @param {GLTF.Primitive} primitiveDef\n  * @param {Array<THREE.BufferAttribute>} accessors\n  */\n\tfunction addMorphTargets(mesh, meshDef, primitiveDef, accessors) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar targets = primitiveDef.targets;\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tfor (var i = 0, il = targets.length; i < il; i++) {\n\n\t\t\tvar target = targets[i];\n\n\t\t\tif (target.POSITION !== undefined) hasMorphPosition = true;\n\t\t\tif (target.NORMAL !== undefined) hasMorphNormal = true;\n\n\t\t\tif (hasMorphPosition && hasMorphNormal) break;\n\t\t}\n\n\t\tif (!hasMorphPosition && !hasMorphNormal) return;\n\n\t\tvar morphPositions = [];\n\t\tvar morphNormals = [];\n\n\t\tfor (var i = 0, il = targets.length; i < il; i++) {\n\n\t\t\tvar target = targets[i];\n\t\t\tvar attributeName = 'morphTarget' + i;\n\n\t\t\tif (hasMorphPosition) {\n\n\t\t\t\t// Three.js morph position is absolute value. The formula is\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * ( morphPosition0 - basePosition )\n\t\t\t\t//     + weight1 * ( morphPosition1 - basePosition )\n\t\t\t\t//     ...\n\t\t\t\t// while the glTF one is relative\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * glTFmorphPosition0\n\t\t\t\t//     + weight1 * glTFmorphPosition1\n\t\t\t\t//     ...\n\t\t\t\t// then we need to convert from relative to absolute here.\n\n\t\t\t\tif (target.POSITION !== undefined) {\n\n\t\t\t\t\t// Cloning not to pollute original accessor\n\t\t\t\t\tvar positionAttribute = cloneBufferAttribute(accessors[target.POSITION]);\n\t\t\t\t\tpositionAttribute.name = attributeName;\n\n\t\t\t\t\tvar position = geometry.attributes.position;\n\n\t\t\t\t\tfor (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n\n\t\t\t\t\t\tpositionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tpositionAttribute = geometry.attributes.position;\n\t\t\t\t}\n\n\t\t\t\tmorphPositions.push(positionAttribute);\n\t\t\t}\n\n\t\t\tif (hasMorphNormal) {\n\n\t\t\t\t// see target.POSITION's comment\n\n\t\t\t\tvar normalAttribute;\n\n\t\t\t\tif (target.NORMAL !== undefined) {\n\n\t\t\t\t\tvar normalAttribute = cloneBufferAttribute(accessors[target.NORMAL]);\n\t\t\t\t\tnormalAttribute.name = attributeName;\n\n\t\t\t\t\tvar normal = geometry.attributes.normal;\n\n\t\t\t\t\tfor (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n\n\t\t\t\t\t\tnormalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = geometry.attributes.normal;\n\t\t\t\t}\n\n\t\t\t\tmorphNormals.push(normalAttribute);\n\t\t\t}\n\t\t}\n\n\t\tif (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n\t\tif (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif (meshDef.weights !== undefined) {\n\n\t\t\tfor (var i = 0, il = meshDef.weights.length; i < il; i++) {\n\n\t\t\t\tmesh.morphTargetInfluences[i] = meshDef.weights[i];\n\t\t\t}\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif (mesh.morphTargetInfluences.length === targetNames.length) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor (var i = 0, il = targetNames.length; i < il; i++) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[targetNames[i]] = i;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isPrimitiveEqual(a, b) {\n\n\t\tif (a.indices !== b.indices) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tvar attribA = a.attributes || {};\n\t\tvar attribB = b.attributes || {};\n\t\tvar keysA = Object.keys(attribA);\n\t\tvar keysB = Object.keys(attribB);\n\n\t\tif (keysA.length !== keysB.length) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (var i = 0, il = keysA.length; i < il; i++) {\n\n\t\t\tvar key = keysA[i];\n\n\t\t\tif (attribA[key] !== attribB[key]) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction getCachedGeometry(cache, newPrimitive) {\n\n\t\tfor (var i = 0, il = cache.length; i < il; i++) {\n\n\t\t\tvar cached = cache[i];\n\n\t\t\tif (isPrimitiveEqual(cached.primitive, newPrimitive)) {\n\n\t\t\t\treturn cached.promise;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction cloneBufferAttribute(attribute) {\n\n\t\tif (attribute.isInterleavedBufferAttribute) {\n\n\t\t\tvar count = attribute.count;\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar array = attribute.array.slice(0, count * itemSize);\n\n\t\t\tfor (var i = 0; i < count; ++i) {\n\n\t\t\t\tarray[i] = attribute.getX(i);\n\t\t\t\tif (itemSize >= 2) array[i + 1] = attribute.getY(i);\n\t\t\t\tif (itemSize >= 3) array[i + 2] = attribute.getZ(i);\n\t\t\t\tif (itemSize >= 4) array[i + 3] = attribute.getW(i);\n\t\t\t}\n\n\t\t\treturn new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n\t\t}\n\n\t\treturn attribute.clone();\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser(json, extensions, options) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = extensions || {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = [];\n\n\t\tthis.textureLoader = new THREE.TextureLoader(this.options.manager);\n\t\tthis.textureLoader.setCrossOrigin(this.options.crossOrigin);\n\n\t\tthis.fileLoader = new THREE.FileLoader(this.options.manager);\n\t\tthis.fileLoader.setResponseType('arraybuffer');\n\t}\n\n\tGLTFParser.prototype.parse = function (onLoad, onError) {\n\n\t\tvar json = this.json;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis.markDefs();\n\n\t\t// Fire the callback on complete\n\t\tthis.getMultiDependencies(['scene', 'animation', 'camera']).then(function (dependencies) {\n\n\t\t\tvar scenes = dependencies.scenes || [];\n\t\t\tvar scene = scenes[json.scene || 0];\n\t\t\tvar animations = dependencies.animations || [];\n\t\t\tvar asset = json.asset;\n\t\t\tvar cameras = dependencies.cameras || [];\n\n\t\t\tonLoad(scene, scenes, cameras, animations, asset);\n\t\t}).catch(onError);\n\t};\n\n\t/**\n  * Marks the special nodes/meshes in json for efficient parse.\n  */\n\tGLTFParser.prototype.markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\tvar meshReferences = {};\n\t\tvar meshUses = {};\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n\n\t\t\tvar joints = skinDefs[skinIndex].joints;\n\n\t\t\tfor (var i = 0, il = joints.length; i < il; i++) {\n\n\t\t\t\tnodeDefs[joints[i]].isBone = true;\n\t\t\t}\n\t\t}\n\n\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t// references and rename instances below.\n\t\t//\n\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\tfor (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n\n\t\t\tvar nodeDef = nodeDefs[nodeIndex];\n\n\t\t\tif (nodeDef.mesh !== undefined) {\n\n\t\t\t\tif (meshReferences[nodeDef.mesh] === undefined) {\n\n\t\t\t\t\tmeshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n\t\t\t\t}\n\n\t\t\t\tmeshReferences[nodeDef.mesh]++;\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif (nodeDef.skin !== undefined) {\n\n\t\t\t\t\tmeshDefs[nodeDef.mesh].isSkinnedMesh = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.json.meshReferences = meshReferences;\n\t\tthis.json.meshUses = meshUses;\n\t};\n\n\t/**\n  * Requests the specified dependency asynchronously, with caching.\n  * @param {string} type\n  * @param {number} index\n  * @return {Promise<Object>}\n  */\n\tGLTFParser.prototype.getDependency = function (type, index) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get(cacheKey);\n\n\t\tif (!dependency) {\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this.loadMesh(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this.loadBufferView(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this.loadMaterial(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this.loadTexture(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown type: ' + type);\n\n\t\t\t}\n\n\t\t\tthis.cache.add(cacheKey, dependency);\n\t\t}\n\n\t\treturn dependency;\n\t};\n\n\t/**\n  * Requests all dependencies of the specified type asynchronously, with caching.\n  * @param {string} type\n  * @return {Promise<Array<Object>>}\n  */\n\tGLTFParser.prototype.getDependencies = function (type) {\n\n\t\tvar dependencies = this.cache.get(type);\n\n\t\tif (!dependencies) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n\n\t\t\tdependencies = Promise.all(defs.map(function (def, index) {\n\n\t\t\t\treturn parser.getDependency(type, index);\n\t\t\t}));\n\n\t\t\tthis.cache.add(type, dependencies);\n\t\t}\n\n\t\treturn dependencies;\n\t};\n\n\t/**\n  * Requests all multiple dependencies of the specified types asynchronously, with caching.\n  * @param {Array<string>} types\n  * @return {Promise<Object<Array<Object>>>}\n  */\n\tGLTFParser.prototype.getMultiDependencies = function (types) {\n\n\t\tvar results = {};\n\t\tvar pendings = [];\n\n\t\tfor (var i = 0, il = types.length; i < il; i++) {\n\n\t\t\tvar type = types[i];\n\t\t\tvar value = this.getDependencies(type);\n\n\t\t\tvalue = value.then(function (key, value) {\n\n\t\t\t\tresults[key] = value;\n\t\t\t}.bind(this, type + (type === 'mesh' ? 'es' : 's')));\n\n\t\t\tpendings.push(value);\n\t\t}\n\n\t\treturn Promise.all(pendings).then(function () {\n\n\t\t\treturn results;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n  * @param {number} bufferIndex\n  * @return {Promise<ArrayBuffer>}\n  */\n\tGLTFParser.prototype.loadBuffer = function (bufferIndex) {\n\n\t\tvar bufferDef = this.json.buffers[bufferIndex];\n\t\tvar loader = this.fileLoader;\n\n\t\tif (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif (bufferDef.uri === undefined && bufferIndex === 0) {\n\n\t\t\treturn Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise(function (resolve, reject) {\n\n\t\t\tloader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n\n\t\t\t\treject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n  * @param {number} bufferViewIndex\n  * @return {Promise<ArrayBuffer>}\n  */\n\tGLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[bufferViewIndex];\n\n\t\treturn this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n  * @param {number} accessorIndex\n  * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n  */\n\tGLTFParser.prototype.loadAccessor = function (accessorIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[accessorIndex];\n\n\t\tif (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn null;\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif (accessorDef.bufferView !== undefined) {\n\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n\t\t} else {\n\n\t\t\tpendingBufferViews.push(null);\n\t\t}\n\n\t\tif (accessorDef.sparse !== undefined) {\n\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n\t\t}\n\n\t\treturn Promise.all(pendingBufferViews).then(function (bufferViews) {\n\n\t\t\tvar bufferView = bufferViews[0];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = json.bufferViews[accessorDef.bufferView].byteStride;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif (byteStride && byteStride !== itemBytes) {\n\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n\t\t\t\tvar ib = parser.cache.get(ibCacheKey);\n\n\t\t\t\tif (!ib) {\n\n\t\t\t\t\t// Use the full buffer if it's interleaved.\n\t\t\t\t\tarray = new TypedArray(bufferView);\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n\n\t\t\t\t\tparser.cache.add(ibCacheKey, ib);\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);\n\t\t\t} else {\n\n\t\t\t\tif (bufferView === null) {\n\n\t\t\t\t\tarray = new TypedArray(accessorDef.count * itemSize);\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif (accessorDef.sparse !== undefined) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n\t\t\t\tvar sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n\t\t\t\tif (bufferView !== null) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute.setArray(bufferAttribute.array.slice());\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, il = sparseIndices.length; i < il; i++) {\n\n\t\t\t\t\tvar index = sparseIndices[i];\n\n\t\t\t\t\tbufferAttribute.setX(index, sparseValues[i * itemSize]);\n\t\t\t\t\tif (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n\t\t\t\t\tif (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n\t\t\t\t\tif (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n\t\t\t\t\tif (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n  * @param {number} textureIndex\n  * @return {Promise<THREE.Texture>}\n  */\n\tGLTFParser.prototype.loadTexture = function (textureIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureLoader = this.textureLoader;\n\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tvar textureDef = json.textures[textureIndex];\n\n\t\tvar textureExtensions = textureDef.extensions || {};\n\n\t\tvar source;\n\n\t\tif (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n\n\t\t\tsource = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n\t\t} else {\n\n\t\t\tsource = json.images[textureDef.source];\n\t\t}\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\n\t\tif (source.bufferView !== undefined) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob([bufferView], { type: source.mimeType });\n\t\t\t\tsourceURI = URL.createObjectURL(blob);\n\t\t\t\treturn sourceURI;\n\t\t\t});\n\t\t}\n\n\t\treturn Promise.resolve(sourceURI).then(function (sourceURI) {\n\n\t\t\t// Load Texture resource.\n\n\t\t\tvar loader = THREE.Loader.Handlers.get(sourceURI);\n\n\t\t\tif (!loader) {\n\n\t\t\t\tloader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n\t\t\t}\n\n\t\t\treturn new Promise(function (resolve, reject) {\n\n\t\t\t\tloader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n\t\t\t});\n\t\t}).then(function (texture) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif (isObjectURL === true) {\n\n\t\t\t\tURL.revokeObjectURL(sourceURI);\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif (textureDef.name !== undefined) texture.name = textureDef.name;\n\n\t\t\t// .format of dds texture is set in DDSLoader\n\t\t\tif (!textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n\n\t\t\t\ttexture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[textureDef.format] : THREE.RGBAFormat;\n\t\t\t}\n\n\t\t\tif (textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[textureDef.internalFormat]) {\n\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');\n\t\t\t}\n\n\t\t\ttexture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[textureDef.type] : THREE.UnsignedByteType;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[textureDef.sampler] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n\n\t\t\treturn texture;\n\t\t});\n\t};\n\n\t/**\n  * Asynchronously assigns a texture to the given material parameters.\n  * @param {Object} materialParams\n  * @param {string} textureName\n  * @param {number} textureIndex\n  * @return {Promise}\n  */\n\tGLTFParser.prototype.assignTexture = function (materialParams, textureName, textureIndex) {\n\n\t\treturn this.getDependency('texture', textureIndex).then(function (texture) {\n\n\t\t\tmaterialParams[textureName] = texture;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n  * @param {number} materialIndex\n  * @return {Promise<THREE.Material>}\n  */\n\tGLTFParser.prototype.loadMaterial = function (materialIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = this.json.materials[materialIndex];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n\n\t\t\tvar sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n\t\t\tmaterialType = sgExtension.getMaterialType(materialDef);\n\t\t\tpending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n\t\t} else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n\n\t\t\tvar kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n\t\t\tmaterialType = kmuExtension.getMaterialType(materialDef);\n\t\t\tpending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif (Array.isArray(metallicRoughness.baseColorFactor)) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray(array);\n\t\t\t\tmaterialParams.opacity = array[3];\n\t\t\t}\n\n\t\t\tif (metallicRoughness.baseColorTexture !== undefined) {\n\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif (metallicRoughness.metallicRoughnessTexture !== undefined) {\n\n\t\t\t\tvar textureIndex = metallicRoughness.metallicRoughnessTexture.index;\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'metalnessMap', textureIndex));\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'roughnessMap', textureIndex));\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.doubleSided === true) {\n\n\t\t\tmaterialParams.side = THREE.DoubleSide;\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif (alphaMode === ALPHA_MODES.BLEND) {\n\n\t\t\tmaterialParams.transparent = true;\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif (alphaMode === ALPHA_MODES.MASK) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture.index));\n\n\t\t\tmaterialParams.normalScale = new THREE.Vector2(1, 1);\n\n\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\n\t\t\t\tmaterialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture.index));\n\n\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tmaterialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n\t\t}\n\n\t\tif (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture.index));\n\t\t}\n\n\t\treturn Promise.all(pending).then(function () {\n\n\t\t\tvar material;\n\n\t\t\tif (materialType === THREE.ShaderMaterial) {\n\n\t\t\t\tmaterial = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType(materialParams);\n\t\t\t}\n\n\t\t\tif (materialDef.name !== undefined) material.name = materialDef.name;\n\n\t\t\t// Normal map textures use OpenGL conventions:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture\n\t\t\tif (material.normalScale) {\n\n\t\t\t\tmaterial.normalScale.y = -material.normalScale.y;\n\t\t\t}\n\n\t\t\t// emissiveTexture and baseColorTexture use sRGB encoding.\n\t\t\tif (material.map) material.map.encoding = THREE.sRGBEncoding;\n\t\t\tif (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\n\t\t\tif (materialDef.extras) material.userData = materialDef.extras;\n\n\t\t\treturn material;\n\t\t});\n\t};\n\n\t/**\n  * @param  {THREE.BufferGeometry} geometry\n  * @param  {GLTF.Primitive} primitiveDef\n  * @param  {Array<THREE.BufferAttribute>} accessors\n  */\n\tfunction addPrimitiveAttributes(geometry, primitiveDef, accessors) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tfor (var gltfAttributeName in attributes) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[gltfAttributeName];\n\t\t\tvar bufferAttribute = accessors[attributes[gltfAttributeName]];\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif (!threeAttributeName) continue;\n\t\t\tif (threeAttributeName in geometry.attributes) continue;\n\n\t\t\tgeometry.addAttribute(threeAttributeName, bufferAttribute);\n\t\t}\n\n\t\tif (primitiveDef.indices !== undefined && !geometry.index) {\n\n\t\t\tgeometry.setIndex(accessors[primitiveDef.indices]);\n\t\t}\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n  * @param {Array<Object>} primitives\n  * @return {Promise<Array<THREE.BufferGeometry>>}\n  */\n\tGLTFParser.prototype.loadGeometries = function (primitives) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\t\treturn this.getDependencies('accessor').then(function (accessors) {\n\n\t\t\tvar pending = [];\n\n\t\t\tfor (var i = 0, il = primitives.length; i < il; i++) {\n\n\t\t\t\tvar primitive = primitives[i];\n\n\t\t\t\t// See if we've already created this geometry\n\t\t\t\tvar cached = getCachedGeometry(cache, primitive);\n\n\t\t\t\tif (cached) {\n\n\t\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\t\tpending.push(cached);\n\t\t\t\t} else if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tvar geometryPromise = extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n\n\t\t\t\t\t\taddPrimitiveAttributes(geometry, primitive, accessors);\n\n\t\t\t\t\t\treturn geometry;\n\t\t\t\t\t});\n\n\t\t\t\t\tcache.push({ primitive: primitive, promise: geometryPromise });\n\n\t\t\t\t\tpending.push(geometryPromise);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\taddPrimitiveAttributes(geometry, primitive, accessors);\n\n\t\t\t\t\tvar geometryPromise = Promise.resolve(geometry);\n\n\t\t\t\t\t// Cache this geometry\n\t\t\t\t\tcache.push({\n\n\t\t\t\t\t\tprimitive: primitive,\n\t\t\t\t\t\tpromise: geometryPromise\n\n\t\t\t\t\t});\n\n\t\t\t\t\tpending.push(geometryPromise);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Promise.all(pending);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n  * @param {number} meshIndex\n  * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n  */\n\tGLTFParser.prototype.loadMesh = function (meshIndex) {\n\n\t\tvar scope = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = this.json.meshes[meshIndex];\n\n\t\treturn this.getMultiDependencies(['accessor', 'material']).then(function (dependencies) {\n\n\t\t\tvar group = new THREE.Group();\n\n\t\t\tvar primitives = meshDef.primitives;\n\n\t\t\treturn scope.loadGeometries(primitives).then(function (geometries) {\n\n\t\t\t\tfor (var i = 0, il = primitives.length; i < il; i++) {\n\n\t\t\t\t\tvar primitive = primitives[i];\n\t\t\t\t\tvar geometry = geometries[i];\n\n\t\t\t\t\tvar material = primitive.material === undefined ? createDefaultMaterial() : dependencies.materials[primitive.material];\n\n\t\t\t\t\tif (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n\n\t\t\t\t\t\tconsole.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n\t\t\t\t\t\tgeometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the material will be modified later on, clone it now.\n\t\t\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\t\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\t\t\t\tvar useSkinning = meshDef.isSkinnedMesh === true;\n\t\t\t\t\tvar useMorphTargets = primitive.targets !== undefined;\n\n\t\t\t\t\tif (useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n\n\t\t\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial) {\n\n\t\t\t\t\t\t\tvar specGlossExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n\t\t\t\t\t\t\tmaterial = specGlossExtension.cloneMaterial(material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = material.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useVertexColors) {\n\n\t\t\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useFlatShading) {\n\n\t\t\t\t\t\tmaterial.flatShading = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n\n\t\t\t\t\t\tif (useSkinning) {\n\n\t\t\t\t\t\t\tmesh = new THREE.SkinnedMesh(geometry, material);\n\t\t\t\t\t\t\tmaterial.skinning = true;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleStripDrawMode;\n\t\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleFanDrawMode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINES || primitive.mode === WEBGL_CONSTANTS.LINE_STRIP || primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n\n\t\t\t\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar lineMaterial = scope.cache.get(cacheKey);\n\n\t\t\t\t\t\tif (!lineMaterial) {\n\n\t\t\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(lineMaterial, material);\n\t\t\t\t\t\t\tlineMaterial.color.copy(material.color);\n\t\t\t\t\t\t\tlineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add(cacheKey, lineMaterial);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = lineMaterial;\n\n\t\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.LINES) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments(geometry, material);\n\t\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Line(geometry, material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineLoop(geometry, material);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n\n\t\t\t\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar pointsMaterial = scope.cache.get(cacheKey);\n\n\t\t\t\t\t\tif (!pointsMaterial) {\n\n\t\t\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(pointsMaterial, material);\n\t\t\t\t\t\t\tpointsMaterial.color.copy(material.color);\n\t\t\t\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\t\t\t\tpointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add(cacheKey, pointsMaterial);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = pointsMaterial;\n\n\t\t\t\t\t\tmesh = new THREE.Points(geometry, material);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || 'mesh_' + meshIndex;\n\n\t\t\t\t\tif (useMorphTargets) {\n\n\t\t\t\t\t\taddMorphTargets(mesh, meshDef, primitive, dependencies.accessors);\n\n\t\t\t\t\t\tmaterial.morphTargets = true;\n\n\t\t\t\t\t\tif (mesh.geometry.morphAttributes.normal !== undefined) material.morphNormals = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meshDef.extras !== undefined) mesh.userData = meshDef.extras;\n\t\t\t\t\tif (primitive.extras !== undefined) mesh.geometry.userData = primitive.extras;\n\n\t\t\t\t\t// for Specular-Glossiness.\n\t\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\tmesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (primitives.length > 1) {\n\n\t\t\t\t\t\tmesh.name += '_' + i;\n\n\t\t\t\t\t\tgroup.add(mesh);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn mesh;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n  * @param {number} cameraIndex\n  * @return {Promise<THREE.Camera>}\n  */\n\tGLTFParser.prototype.loadCamera = function (cameraIndex) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[cameraIndex];\n\t\tvar params = cameraDef[cameraDef.type];\n\n\t\tif (!params) {\n\n\t\t\tconsole.warn('THREE.GLTFLoader: Missing camera parameters.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (cameraDef.type === 'perspective') {\n\n\t\t\tcamera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n\t\t} else if (cameraDef.type === 'orthographic') {\n\n\t\t\tcamera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n\t\t}\n\n\t\tif (cameraDef.name !== undefined) camera.name = cameraDef.name;\n\t\tif (cameraDef.extras) camera.userData = cameraDef.extras;\n\n\t\treturn Promise.resolve(camera);\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n  * @param {number} skinIndex\n  * @return {Promise<Object>}\n  */\n\tGLTFParser.prototype.loadSkin = function (skinIndex) {\n\n\t\tvar skinDef = this.json.skins[skinIndex];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif (skinDef.inverseBindMatrices === undefined) {\n\n\t\t\treturn Promise.resolve(skinEntry);\n\t\t}\n\n\t\treturn this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n  * @param {number} animationIndex\n  * @return {Promise<THREE.AnimationClip>}\n  */\n\tGLTFParser.prototype.loadAnimation = function (animationIndex) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = this.json.animations[animationIndex];\n\n\t\treturn this.getMultiDependencies(['accessor', 'node']).then(function (dependencies) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor (var i = 0, il = animationDef.channels.length; i < il; i++) {\n\n\t\t\t\tvar channel = animationDef.channels[i];\n\t\t\t\tvar sampler = animationDef.samplers[channel.sampler];\n\n\t\t\t\tif (sampler) {\n\n\t\t\t\t\tvar target = channel.target;\n\t\t\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n\t\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n\n\t\t\t\t\tvar inputAccessor = dependencies.accessors[input];\n\t\t\t\t\tvar outputAccessor = dependencies.accessors[output];\n\n\t\t\t\t\tvar node = dependencies.nodes[name];\n\n\t\t\t\t\tif (node) {\n\n\t\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\t\t\tswitch (PATH_PROPERTIES[target.path]) {\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n\n\t\t\t\t\t\tvar targetNames = [];\n\n\t\t\t\t\t\tif (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n\n\t\t\t\t\t\t\t// node should be THREE.Group here but\n\t\t\t\t\t\t\t// PATH_PROPERTIES.weights(morphTargetInfluences) should be\n\t\t\t\t\t\t\t// the property of a mesh object under node.\n\t\t\t\t\t\t\t// So finding targets here.\n\n\t\t\t\t\t\t\tnode.traverse(function (object) {\n\n\t\t\t\t\t\t\t\tif (object.isMesh === true && object.material.morphTargets === true) {\n\n\t\t\t\t\t\t\t\t\ttargetNames.push(object.name ? object.name : object.uuid);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttargetNames.push(targetName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// KeyframeTrack.optimize() will modify given 'times' and 'values'\n\t\t\t\t\t\t// buffers before creating a truncated copy to keep. Because buffers may\n\t\t\t\t\t\t// be reused by other tracks, make copies here.\n\t\t\t\t\t\tfor (var j = 0, jl = targetNames.length; j < jl; j++) {\n\n\t\t\t\t\t\t\tvar track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation);\n\n\t\t\t\t\t\t\t// Here is the trick to enable custom interpolation.\n\t\t\t\t\t\t\t// Overrides .createInterpolant in a factory method which creates custom interpolation.\n\t\t\t\t\t\t\tif (sampler.interpolation === 'CUBICSPLINE') {\n\n\t\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n\n\t\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.\n\t\t\t\t\t\t\t\t// track.getInterpolation() doesn't return valid value for custom interpolant.\n\t\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttracks.push(track);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new THREE.AnimationClip(name, undefined, tracks);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n  * @param {number} nodeIndex\n  * @return {Promise<THREE.Object3D>}\n  */\n\tGLTFParser.prototype.loadNode = function (nodeIndex) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshReferences = this.json.meshReferences;\n\t\tvar meshUses = this.json.meshUses;\n\n\t\tvar nodeDef = this.json.nodes[nodeIndex];\n\n\t\treturn this.getMultiDependencies(['mesh', 'skin', 'camera', 'light']).then(function (dependencies) {\n\n\t\t\tvar node;\n\n\t\t\tif (nodeDef.isBone === true) {\n\n\t\t\t\tnode = new THREE.Bone();\n\t\t\t} else if (nodeDef.mesh !== undefined) {\n\n\t\t\t\tvar mesh = dependencies.meshes[nodeDef.mesh];\n\n\t\t\t\tnode = mesh.clone();\n\n\t\t\t\t// for Specular-Glossiness\n\t\t\t\tif (mesh.isGroup === true) {\n\n\t\t\t\t\tfor (var i = 0, il = mesh.children.length; i < il; i++) {\n\n\t\t\t\t\t\tvar child = mesh.children[i];\n\n\t\t\t\t\t\tif (child.material && child.material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\t\tnode.children[i].onBeforeRender = child.onBeforeRender;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (mesh.material && mesh.material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\tnode.onBeforeRender = mesh.onBeforeRender;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (meshReferences[nodeDef.mesh] > 1) {\n\n\t\t\t\t\tnode.name += '_instance_' + meshUses[nodeDef.mesh]++;\n\t\t\t\t}\n\t\t\t} else if (nodeDef.camera !== undefined) {\n\n\t\t\t\tnode = dependencies.cameras[nodeDef.camera];\n\t\t\t} else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n\n\t\t\t\tvar lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n\t\t\t\tnode = lights[nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light];\n\t\t\t} else {\n\n\t\t\t\tnode = new THREE.Object3D();\n\t\t\t}\n\n\t\t\tif (nodeDef.name !== undefined) {\n\n\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n\t\t\t}\n\n\t\t\tif (nodeDef.extras) node.userData = nodeDef.extras;\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.fromArray(nodeDef.matrix);\n\t\t\t\tnode.applyMatrix(matrix);\n\t\t\t} else {\n\n\t\t\t\tif (nodeDef.translation !== undefined) {\n\n\t\t\t\t\tnode.position.fromArray(nodeDef.translation);\n\t\t\t\t}\n\n\t\t\t\tif (nodeDef.rotation !== undefined) {\n\n\t\t\t\t\tnode.quaternion.fromArray(nodeDef.rotation);\n\t\t\t\t}\n\n\t\t\t\tif (nodeDef.scale !== undefined) {\n\n\t\t\t\t\tnode.scale.fromArray(nodeDef.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n  * @param {number} sceneIndex\n  * @return {Promise<THREE.Scene>}\n  */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy(nodeId, parentObject, json, allNodes, skins) {\n\n\t\t\tvar node = allNodes[nodeId];\n\t\t\tvar nodeDef = json.nodes[nodeId];\n\n\t\t\t// build skeleton here as well\n\n\t\t\tif (nodeDef.skin !== undefined) {\n\n\t\t\t\tvar meshes = node.isGroup === true ? node.children : [node];\n\n\t\t\t\tfor (var i = 0, il = meshes.length; i < il; i++) {\n\n\t\t\t\t\tvar mesh = meshes[i];\n\t\t\t\t\tvar skinEntry = skins[nodeDef.skin];\n\n\t\t\t\t\tvar bones = [];\n\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\tfor (var j = 0, jl = skinEntry.joints.length; j < jl; j++) {\n\n\t\t\t\t\t\tvar jointId = skinEntry.joints[j];\n\t\t\t\t\t\tvar jointNode = allNodes[jointId];\n\n\t\t\t\t\t\tif (jointNode) {\n\n\t\t\t\t\t\t\tbones.push(jointNode);\n\n\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\tif (skinEntry.inverseBindMatrices !== undefined) {\n\n\t\t\t\t\t\t\t\tmat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tboneInverses.push(mat);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', jointId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build node hierachy\n\n\t\t\tparentObject.add(node);\n\n\t\t\tif (nodeDef.children) {\n\n\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\tfor (var i = 0, il = children.length; i < il; i++) {\n\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tbuildNodeHierachy(child, node, json, allNodes, skins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn function loadScene(sceneIndex) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[sceneIndex];\n\n\t\t\treturn this.getMultiDependencies(['node', 'skin']).then(function (dependencies) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tif (sceneDef.name !== undefined) scene.name = sceneDef.name;\n\n\t\t\t\tif (sceneDef.extras) scene.userData = sceneDef.extras;\n\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\t\tfor (var i = 0, il = nodeIds.length; i < il; i++) {\n\n\t\t\t\t\tbuildNodeHierachy(nodeIds[i], scene, json, dependencies.nodes, dependencies.skins);\n\t\t\t\t}\n\n\t\t\t\t// Ambient lighting, if present, is always attached to the scene root.\n\t\t\t\tif (sceneDef.extensions && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS] && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n\n\t\t\t\t\tvar lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n\t\t\t\t\tscene.add(lights[sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light]);\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\t\t\t});\n\t\t};\n\t}();\n\n\treturn GLTFLoader;\n}();\n\nexports.default = GLTFLoader;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n */\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function RGBELoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\n// extend THREE.DataTextureLoader\nRGBELoader.prototype = Object.create(THREE.DataTextureLoader.prototype);\n\n// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\nRGBELoader.prototype._parser = function (buffer) {\n\n\tvar\n\t/* return codes for rgbe routines */\n\tRGBE_RETURN_SUCCESS = 0,\n\t    RGBE_RETURN_FAILURE = -1,\n\n\n\t/* default error routine.  change this to change error handling */\n\trgbe_read_error = 1,\n\t    rgbe_write_error = 2,\n\t    rgbe_format_error = 3,\n\t    rgbe_memory_error = 4,\n\t    rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n\n\t\tswitch (rgbe_error_code) {\n\n\t\t\tcase rgbe_read_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader Read Error: \" + (msg || ''));\n\t\t\t\tbreak;\n\t\t\tcase rgbe_write_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader Write Error: \" + (msg || ''));\n\t\t\t\tbreak;\n\t\t\tcase rgbe_format_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader Bad File Format: \" + (msg || ''));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase rgbe_memory_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader: Error: \" + (msg || ''));\n\n\t\t}\n\t\treturn RGBE_RETURN_FAILURE;\n\t},\n\n\n\t/* offsets to red, green, and blue components in a data (float) pixel */\n\tRGBE_DATA_RED = 0,\n\t    RGBE_DATA_GREEN = 1,\n\t    RGBE_DATA_BLUE = 2,\n\n\n\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\tRGBE_DATA_SIZE = 4,\n\n\n\t/* flags indicating which fields in an rgbe_header_info are valid */\n\tRGBE_VALID_PROGRAMTYPE = 1,\n\t    RGBE_VALID_FORMAT = 2,\n\t    RGBE_VALID_DIMENSIONS = 4,\n\t    NEWLINE = \"\\n\",\n\t    fgets = function fgets(buffer, lineLimit, consume) {\n\n\t\tlineLimit = !lineLimit ? 1024 : lineLimit;\n\t\tvar p = buffer.pos,\n\t\t    i = -1,\n\t\t    len = 0,\n\t\t    s = '',\n\t\t    chunkSize = 128,\n\t\t    chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\t\twhile (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n\n\t\t\ts += chunk;len += chunk.length;\n\t\t\tp += chunkSize;\n\t\t\tchunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\t\t}\n\n\t\tif (-1 < i) {\n\n\t\t\t/*for (i=l-1; i>=0; i--) {\n   \tbyteCode = m.charCodeAt(i);\n   \tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n   \telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n   \tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n   }*/\n\t\t\tif (false !== consume) buffer.pos += len + i + 1;\n\t\t\treturn s + chunk.slice(0, i);\n\t\t}\n\t\treturn false;\n\t},\n\n\n\t/* minimal header reading.  modify if you want to parse more information */\n\tRGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n\n\t\tvar line,\n\t\t    match,\n\n\n\t\t// regexes to parse header info fields\n\t\tmagic_token_re = /^#\\?(\\S+)$/,\n\t\t    gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t    exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t    format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t    dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\n\t\t// RGBE format header struct\n\t\theader = {\n\n\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\tstring: '', /* the actual header string */\n\n\t\t\tcomments: '', /* comments found in header */\n\n\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t};\n\n\t\tif (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n\n\t\t\treturn rgbe_error(rgbe_read_error, \"no header found\");\n\t\t}\n\t\t/* if you want to require the magic token then uncomment the next line */\n\t\tif (!(match = line.match(magic_token_re))) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"bad initial token\");\n\t\t}\n\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\theader.programtype = match[1];\n\t\theader.string += line + \"\\n\";\n\n\t\twhile (true) {\n\n\t\t\tline = fgets(buffer);\n\t\t\tif (false === line) break;\n\t\t\theader.string += line + \"\\n\";\n\n\t\t\tif ('#' === line.charAt(0)) {\n\n\t\t\t\theader.comments += line + \"\\n\";\n\t\t\t\tcontinue; // comment line\n\t\t\t}\n\n\t\t\tif (match = line.match(gamma_re)) {\n\n\t\t\t\theader.gamma = parseFloat(match[1], 10);\n\t\t\t}\n\t\t\tif (match = line.match(exposure_re)) {\n\n\t\t\t\theader.exposure = parseFloat(match[1], 10);\n\t\t\t}\n\t\t\tif (match = line.match(format_re)) {\n\n\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\theader.format = match[1]; //'32-bit_rle_rgbe';\n\t\t\t}\n\t\t\tif (match = line.match(dimensions_re)) {\n\n\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\theader.height = parseInt(match[1], 10);\n\t\t\t\theader.width = parseInt(match[2], 10);\n\t\t\t}\n\n\t\t\tif (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n\t\t}\n\n\t\tif (!(header.valid & RGBE_VALID_FORMAT)) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"missing format specifier\");\n\t\t}\n\t\tif (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"missing image size specifier\");\n\t\t}\n\n\t\treturn header;\n\t},\n\t    RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n\n\t\tvar data_rgba,\n\t\t    offset,\n\t\t    pos,\n\t\t    count,\n\t\t    byteValue,\n\t\t    scanline_buffer,\n\t\t    ptr,\n\t\t    ptr_end,\n\t\t    i,\n\t\t    l,\n\t\t    off,\n\t\t    isEncodedRun,\n\t\t    scanline_width = w,\n\t\t    num_scanlines = h,\n\t\t    rgbeStart;\n\n\t\tif (\n\t\t// run length encoding is not allowed so read flat\n\t\tscanline_width < 8 || scanline_width > 0x7fff ||\n\t\t// this file is not run length encoded\n\t\t2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n\n\t\t\t// return the flat buffer\n\t\t\treturn new Uint8Array(buffer);\n\t\t}\n\n\t\tif (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"wrong scanline width\");\n\t\t}\n\n\t\tdata_rgba = new Uint8Array(4 * w * h);\n\n\t\tif (!data_rgba || !data_rgba.length) {\n\n\t\t\treturn rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n\t\t}\n\n\t\toffset = 0;pos = 0;ptr_end = 4 * scanline_width;\n\t\trgbeStart = new Uint8Array(4);\n\t\tscanline_buffer = new Uint8Array(ptr_end);\n\n\t\t// read in each successive scanline\n\t\twhile (num_scanlines > 0 && pos < buffer.byteLength) {\n\n\t\t\tif (pos + 4 > buffer.byteLength) {\n\n\t\t\t\treturn rgbe_error(rgbe_read_error);\n\t\t\t}\n\n\t\t\trgbeStart[0] = buffer[pos++];\n\t\t\trgbeStart[1] = buffer[pos++];\n\t\t\trgbeStart[2] = buffer[pos++];\n\t\t\trgbeStart[3] = buffer[pos++];\n\n\t\t\tif (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n\n\t\t\t\treturn rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n\t\t\t}\n\n\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t// first red, then green, then blue, then exponent\n\t\t\tptr = 0;\n\t\t\twhile (ptr < ptr_end && pos < buffer.byteLength) {\n\n\t\t\t\tcount = buffer[pos++];\n\t\t\t\tisEncodedRun = count > 128;\n\t\t\t\tif (isEncodedRun) count -= 128;\n\n\t\t\t\tif (0 === count || ptr + count > ptr_end) {\n\n\t\t\t\t\treturn rgbe_error(rgbe_format_error, \"bad scanline data\");\n\t\t\t\t}\n\n\t\t\t\tif (isEncodedRun) {\n\n\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\tbyteValue = buffer[pos++];\n\t\t\t\t\tfor (i = 0; i < count; i++) {\n\n\t\t\t\t\t\tscanline_buffer[ptr++] = byteValue;\n\t\t\t\t\t}\n\t\t\t\t\t//ptr += count;\n\t\t\t\t} else {\n\n\t\t\t\t\t// a literal-run\n\t\t\t\t\tscanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n\t\t\t\t\tptr += count;pos += count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now convert data from buffer into rgba\n\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\tl = scanline_width; //scanline_buffer.byteLength;\n\t\t\tfor (i = 0; i < l; i++) {\n\n\t\t\t\toff = 0;\n\t\t\t\tdata_rgba[offset] = scanline_buffer[i + off];\n\t\t\t\toff += scanline_width; //1;\n\t\t\t\tdata_rgba[offset + 1] = scanline_buffer[i + off];\n\t\t\t\toff += scanline_width; //1;\n\t\t\t\tdata_rgba[offset + 2] = scanline_buffer[i + off];\n\t\t\t\toff += scanline_width; //1;\n\t\t\t\tdata_rgba[offset + 3] = scanline_buffer[i + off];\n\t\t\t\toffset += 4;\n\t\t\t}\n\n\t\t\tnum_scanlines--;\n\t\t}\n\n\t\treturn data_rgba;\n\t};\n\n\tvar byteArray = new Uint8Array(buffer),\n\t    byteLength = byteArray.byteLength;\n\tbyteArray.pos = 0;\n\tvar rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n\tif (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n\n\t\tvar w = rgbe_header_info.width,\n\t\t    h = rgbe_header_info.height,\n\t\t    image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\t\tif (RGBE_RETURN_FAILURE !== image_rgba_data) {\n\n\t\t\treturn {\n\t\t\t\twidth: w, height: h,\n\t\t\t\tdata: image_rgba_data,\n\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\tformat: THREE.RGBEFormat, // handled as THREE.RGBAFormat in shaders\n\t\t\t\ttype: THREE.UnsignedByteType\n\t\t\t};\n\t\t}\n\t}\n\treturn null;\n};\n\nexports.default = RGBELoader;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _global = __webpack_require__(8);\n\nvar _global2 = _interopRequireDefault(_global);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar window = _global2.default;\n\n/**\n  * @author Kai Salmen / https://kaisalmen.de\n  * Development repository: https://github.com/kaisalmen/WWOBJLoader\n  */\n\n'use strict';\n\n// if ( THREE.LoaderSupport === undefined ) { THREE.LoaderSupport = {} }\nvar LoaderSupport = {};\n\n/**\n * Validation functions.\n * @class\n */\nLoaderSupport.Validator = {\n\t/**\n  * If given input is null or undefined, false is returned otherwise true.\n  *\n  * @param input Can be anything\n  * @returns {boolean}\n  */\n\tisValid: function isValid(input) {\n\t\treturn input !== null && input !== undefined;\n\t},\n\t/**\n  * If given input is null or undefined, the defaultValue is returned otherwise the given input.\n  *\n  * @param input Can be anything\n  * @param defaultValue Can be anything\n  * @returns {*}\n  */\n\tverifyInput: function verifyInput(input, defaultValue) {\n\t\treturn input === null || input === undefined ? defaultValue : input;\n\t}\n};\n\n/**\n * Callbacks utilized by loaders and builders.\n * @class\n */\nLoaderSupport.Callbacks = function () {\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction Callbacks() {\n\t\tthis.onProgress = null;\n\t\tthis.onMeshAlter = null;\n\t\tthis.onLoad = null;\n\t\tthis.onLoadMaterials = null;\n\t}\n\n\t/**\n  * Register callback function that is invoked by internal function \"announceProgress\" to print feedback.\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnProgress Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnProgress = function (callbackOnProgress) {\n\t\tthis.onProgress = Validator.verifyInput(callbackOnProgress, this.onProgress);\n\t};\n\n\t/**\n  * Register callback function that is called every time a mesh was loaded.\n  * Use {@link THREE.LoaderSupport.LoadedMeshUserOverride} for alteration instructions (geometry, material or disregard mesh).\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnMeshAlter Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnMeshAlter = function (callbackOnMeshAlter) {\n\t\tthis.onMeshAlter = Validator.verifyInput(callbackOnMeshAlter, this.onMeshAlter);\n\t};\n\n\t/**\n  * Register callback function that is called once loading of the complete OBJ file is completed.\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnLoad Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnLoad = function (callbackOnLoad) {\n\t\tthis.onLoad = Validator.verifyInput(callbackOnLoad, this.onLoad);\n\t};\n\n\t/**\n  * Register callback function that is called when materials have been loaded.\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnLoadMaterials Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnLoadMaterials = function (callbackOnLoadMaterials) {\n\t\tthis.onLoadMaterials = Validator.verifyInput(callbackOnLoadMaterials, this.onLoadMaterials);\n\t};\n\n\treturn Callbacks;\n}();\n\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nLoaderSupport.LoadedMeshUserOverride = function () {\n\n\tfunction LoadedMeshUserOverride(disregardMesh, alteredMesh) {\n\t\tthis.disregardMesh = disregardMesh === true;\n\t\tthis.alteredMesh = alteredMesh === true;\n\t\tthis.meshes = [];\n\t}\n\n\t/**\n  * Add a mesh created within callback.\n  *\n  * @memberOf THREE.OBJLoader2.LoadedMeshUserOverride\n  *\n  * @param {THREE.Mesh} mesh\n  */\n\tLoadedMeshUserOverride.prototype.addMesh = function (mesh) {\n\t\tthis.meshes.push(mesh);\n\t\tthis.alteredMesh = true;\n\t};\n\n\t/**\n  * Answers if mesh shall be disregarded completely.\n  *\n  * @returns {boolean}\n  */\n\tLoadedMeshUserOverride.prototype.isDisregardMesh = function () {\n\t\treturn this.disregardMesh;\n\t};\n\n\t/**\n  * Answers if new mesh(es) were created.\n  *\n  * @returns {boolean}\n  */\n\tLoadedMeshUserOverride.prototype.providesAlteredMeshes = function () {\n\t\treturn this.alteredMesh;\n\t};\n\n\treturn LoadedMeshUserOverride;\n}();\n\n/**\n * A resource description used by {@link THREE.LoaderSupport.PrepData} and others.\n * @class\n *\n * @param {string} url URL to the file\n * @param {string} extension The file extension (type)\n */\nLoaderSupport.ResourceDescriptor = function () {\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction ResourceDescriptor(url, extension) {\n\t\tvar urlParts = url.split('/');\n\n\t\tif (urlParts.length < 2) {\n\n\t\t\tthis.path = null;\n\t\t\tthis.name = url;\n\t\t\tthis.url = url;\n\t\t} else {\n\n\t\t\tthis.path = Validator.verifyInput(urlParts.slice(0, urlParts.length - 1).join('/') + '/', null);\n\t\t\tthis.name = Validator.verifyInput(urlParts[urlParts.length - 1], null);\n\t\t\tthis.url = url;\n\t\t}\n\t\tthis.extension = Validator.verifyInput(extension, \"default\");\n\t\tthis.extension = this.extension.trim();\n\t\tthis.content = null;\n\t}\n\n\t/**\n  * Set the content of this resource\n  * @memberOf THREE.LoaderSupport.ResourceDescriptor\n  *\n  * @param {Object} content The file content as arraybuffer or text\n  */\n\tResourceDescriptor.prototype.setContent = function (content) {\n\t\tthis.content = Validator.verifyInput(content, null);\n\t};\n\n\treturn ResourceDescriptor;\n}();\n\n/**\n * Configuration instructions to be used by run method.\n * @class\n */\nLoaderSupport.PrepData = function () {\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction PrepData(modelName) {\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\t\tthis.modelName = Validator.verifyInput(modelName, '');\n\t\tthis.resources = [];\n\t\tthis.callbacks = new LoaderSupport.Callbacks();\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tPrepData.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t};\n\n\t/**\n  * Returns all callbacks as {@link THREE.LoaderSupport.Callbacks}\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @returns {THREE.LoaderSupport.Callbacks}\n  */\n\tPrepData.prototype.getCallbacks = function () {\n\t\treturn this.callbacks;\n\t};\n\n\t/**\n  * Add a resource description.\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @param {THREE.LoaderSupport.ResourceDescriptor} Adds a {@link THREE.LoaderSupport.ResourceDescriptor}\n  */\n\tPrepData.prototype.addResource = function (resource) {\n\t\tthis.resources.push(resource);\n\t};\n\n\t/**\n  * Clones this object and returns it afterwards. Callbacks and resources are not cloned deep (references!).\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @returns {@link THREE.LoaderSupport.PrepData}\n  */\n\tPrepData.prototype.clone = function () {\n\t\tvar clone = new LoaderSupport.PrepData(this.modelName);\n\t\tclone.logging.enabled = this.logging.enabled;\n\t\tclone.logging.debug = this.logging.debug;\n\t\tclone.resources = this.resources;\n\t\tclone.callbacks = this.callbacks;\n\n\t\tvar property, value;\n\t\tfor (property in this) {\n\n\t\t\tvalue = this[property];\n\t\t\tif (!clone.hasOwnProperty(property) && typeof this[property] !== 'function') {\n\n\t\t\t\tclone[property] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn clone;\n\t};\n\n\t/**\n  * Identify files or content of interest from an Array of {@link THREE.LoaderSupport.ResourceDescriptor}.\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @param {THREE.LoaderSupport.ResourceDescriptor[]} resources Array of {@link THREE.LoaderSupport.ResourceDescriptor}\n  * @param Object fileDesc Object describing which resources are of interest (ext, type (string or UInt8Array) and ignore (boolean))\n  * @returns {{}} Object with each \"ext\" and the corresponding {@link THREE.LoaderSupport.ResourceDescriptor}\n  */\n\tPrepData.prototype.checkResourceDescriptorFiles = function (resources, fileDesc) {\n\t\tvar resource, triple, i, found;\n\t\tvar result = {};\n\n\t\tfor (var index in resources) {\n\n\t\t\tresource = resources[index];\n\t\t\tfound = false;\n\t\t\tif (!Validator.isValid(resource.name)) continue;\n\t\t\tif (Validator.isValid(resource.content)) {\n\n\t\t\t\tfor (i = 0; i < fileDesc.length && !found; i++) {\n\n\t\t\t\t\ttriple = fileDesc[i];\n\t\t\t\t\tif (resource.extension.toLowerCase() === triple.ext.toLowerCase()) {\n\n\t\t\t\t\t\tif (triple.ignore) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t} else if (triple.type === \"ArrayBuffer\") {\n\n\t\t\t\t\t\t\t// fast-fail on bad type\n\t\t\t\t\t\t\tif (!(resource.content instanceof ArrayBuffer || resource.content instanceof Uint8Array)) throw 'Provided content is not of type ArrayBuffer! Aborting...';\n\t\t\t\t\t\t\tresult[triple.ext] = resource;\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t} else if (triple.type === \"String\") {\n\n\t\t\t\t\t\t\tif (!(typeof resource.content === 'string' || resource.content instanceof String)) throw 'Provided  content is not of type String! Aborting...';\n\t\t\t\t\t\t\tresult[triple.ext] = resource;\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url;\n\t\t\t} else {\n\n\t\t\t\t// fast-fail on bad type\n\t\t\t\tif (!(typeof resource.name === 'string' || resource.name instanceof String)) throw 'Provided file is not properly defined! Aborting...';\n\t\t\t\tfor (i = 0; i < fileDesc.length && !found; i++) {\n\n\t\t\t\t\ttriple = fileDesc[i];\n\t\t\t\t\tif (resource.extension.toLowerCase() === triple.ext.toLowerCase()) {\n\n\t\t\t\t\t\tif (!triple.ignore) result[triple.ext] = resource;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn PrepData;\n}();\n\n/**\n * Builds one or many THREE.Mesh from one raw set of Arraybuffers, materialGroup descriptions and further parameters.\n * Supports vertex, vertexColor, normal, uv and index buffers.\n * @class\n */\nLoaderSupport.MeshBuilder = function () {\n\n\tvar LOADER_MESH_BUILDER_VERSION = '1.2.0';\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction MeshBuilder() {\n\t\tconsole.info('Using THREE.LoaderSupport.MeshBuilder version: ' + LOADER_MESH_BUILDER_VERSION);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\tthis.callbacks = new LoaderSupport.Callbacks();\n\t\tthis.materials = [];\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tMeshBuilder.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t};\n\n\t/**\n  * Initializes the MeshBuilder (currently only default material initialisation).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  */\n\tMeshBuilder.prototype.init = function () {\n\t\tvar defaultMaterial = new THREE.MeshStandardMaterial({ color: 0xDCF1FF });\n\t\tdefaultMaterial.name = 'defaultMaterial';\n\n\t\tvar defaultVertexColorMaterial = new THREE.MeshStandardMaterial({ color: 0xDCF1FF });\n\t\tdefaultVertexColorMaterial.name = 'defaultVertexColorMaterial';\n\t\tdefaultVertexColorMaterial.vertexColors = THREE.VertexColors;\n\n\t\tvar defaultLineMaterial = new THREE.LineBasicMaterial();\n\t\tdefaultLineMaterial.name = 'defaultLineMaterial';\n\n\t\tvar defaultPointMaterial = new THREE.PointsMaterial({ size: 1 });\n\t\tdefaultPointMaterial.name = 'defaultPointMaterial';\n\n\t\tvar runtimeMaterials = {};\n\t\truntimeMaterials[defaultMaterial.name] = defaultMaterial;\n\t\truntimeMaterials[defaultVertexColorMaterial.name] = defaultVertexColorMaterial;\n\t\truntimeMaterials[defaultLineMaterial.name] = defaultLineMaterial;\n\t\truntimeMaterials[defaultPointMaterial.name] = defaultPointMaterial;\n\n\t\tthis.updateMaterials({\n\t\t\tcmd: 'materialData',\n\t\t\tmaterials: {\n\t\t\t\tmaterialCloneInstructions: null,\n\t\t\t\tserializedMaterials: null,\n\t\t\t\truntimeMaterials: runtimeMaterials\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n  * Set materials loaded by any supplier of an Array of {@link THREE.Material}.\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {THREE.Material[]} materials Array of {@link THREE.Material}\n  */\n\tMeshBuilder.prototype.setMaterials = function (materials) {\n\t\tvar payload = {\n\t\t\tcmd: 'materialData',\n\t\t\tmaterials: {\n\t\t\t\tmaterialCloneInstructions: null,\n\t\t\t\tserializedMaterials: null,\n\t\t\t\truntimeMaterials: Validator.isValid(this.callbacks.onLoadMaterials) ? this.callbacks.onLoadMaterials(materials) : materials\n\t\t\t}\n\t\t};\n\t\tthis.updateMaterials(payload);\n\t};\n\n\tMeshBuilder.prototype._setCallbacks = function (callbacks) {\n\t\tif (Validator.isValid(callbacks.onProgress)) this.callbacks.setCallbackOnProgress(callbacks.onProgress);\n\t\tif (Validator.isValid(callbacks.onMeshAlter)) this.callbacks.setCallbackOnMeshAlter(callbacks.onMeshAlter);\n\t\tif (Validator.isValid(callbacks.onLoad)) this.callbacks.setCallbackOnLoad(callbacks.onLoad);\n\t\tif (Validator.isValid(callbacks.onLoadMaterials)) this.callbacks.setCallbackOnLoadMaterials(callbacks.onLoadMaterials);\n\t};\n\n\t/**\n  * Delegates processing of the payload (mesh building or material update) to the corresponding functions (BW-compatibility).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {Object} payload Raw Mesh or Material descriptions.\n  * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh} or null in case of material update\n  */\n\tMeshBuilder.prototype.processPayload = function (payload) {\n\t\tif (payload.cmd === 'meshData') {\n\n\t\t\treturn this.buildMeshes(payload);\n\t\t} else if (payload.cmd === 'materialData') {\n\n\t\t\tthis.updateMaterials(payload);\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n  * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n  * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh}\n  */\n\tMeshBuilder.prototype.buildMeshes = function (meshPayload) {\n\t\tvar meshName = meshPayload.params.meshName;\n\n\t\tvar bufferGeometry = new THREE.BufferGeometry();\n\t\tbufferGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.vertices), 3));\n\t\tif (Validator.isValid(meshPayload.buffers.indices)) {\n\n\t\t\tbufferGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(meshPayload.buffers.indices), 1));\n\t\t}\n\t\tvar haveVertexColors = Validator.isValid(meshPayload.buffers.colors);\n\t\tif (haveVertexColors) {\n\n\t\t\tbufferGeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.colors), 3));\n\t\t}\n\t\tif (Validator.isValid(meshPayload.buffers.normals)) {\n\n\t\t\tbufferGeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.normals), 3));\n\t\t} else {\n\n\t\t\tbufferGeometry.computeVertexNormals();\n\t\t}\n\t\tif (Validator.isValid(meshPayload.buffers.uvs)) {\n\n\t\t\tbufferGeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.uvs), 2));\n\t\t}\n\n\t\tvar material, materialName, key;\n\t\tvar materialNames = meshPayload.materials.materialNames;\n\t\tvar createMultiMaterial = meshPayload.materials.multiMaterial;\n\t\tvar multiMaterials = [];\n\t\tfor (key in materialNames) {\n\n\t\t\tmaterialName = materialNames[key];\n\t\t\tmaterial = this.materials[materialName];\n\t\t\tif (createMultiMaterial) multiMaterials.push(material);\n\t\t}\n\t\tif (createMultiMaterial) {\n\n\t\t\tmaterial = multiMaterials;\n\t\t\tvar materialGroups = meshPayload.materials.materialGroups;\n\t\t\tvar materialGroup;\n\t\t\tfor (key in materialGroups) {\n\n\t\t\t\tmaterialGroup = materialGroups[key];\n\t\t\t\tbufferGeometry.addGroup(materialGroup.start, materialGroup.count, materialGroup.index);\n\t\t\t}\n\t\t}\n\n\t\tvar meshes = [];\n\t\tvar mesh;\n\t\tvar callbackOnMeshAlter = this.callbacks.onMeshAlter;\n\t\tvar callbackOnMeshAlterResult;\n\t\tvar useOrgMesh = true;\n\t\tvar geometryType = Validator.verifyInput(meshPayload.geometryType, 0);\n\t\tif (Validator.isValid(callbackOnMeshAlter)) {\n\n\t\t\tcallbackOnMeshAlterResult = callbackOnMeshAlter({\n\t\t\t\tdetail: {\n\t\t\t\t\tmeshName: meshName,\n\t\t\t\t\tbufferGeometry: bufferGeometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tgeometryType: geometryType\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (Validator.isValid(callbackOnMeshAlterResult)) {\n\n\t\t\t\tif (!callbackOnMeshAlterResult.isDisregardMesh() && callbackOnMeshAlterResult.providesAlteredMeshes()) {\n\n\t\t\t\t\tfor (var i in callbackOnMeshAlterResult.meshes) {\n\n\t\t\t\t\t\tmeshes.push(callbackOnMeshAlterResult.meshes[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuseOrgMesh = false;\n\t\t\t}\n\t\t}\n\t\tif (useOrgMesh) {\n\n\t\t\tif (meshPayload.computeBoundingSphere) bufferGeometry.computeBoundingSphere();\n\t\t\tif (geometryType === 0) {\n\n\t\t\t\tmesh = new THREE.Mesh(bufferGeometry, material);\n\t\t\t} else if (geometryType === 1) {\n\n\t\t\t\tmesh = new THREE.LineSegments(bufferGeometry, material);\n\t\t\t} else {\n\n\t\t\t\tmesh = new THREE.Points(bufferGeometry, material);\n\t\t\t}\n\t\t\tmesh.name = meshName;\n\t\t\tmeshes.push(mesh);\n\t\t}\n\n\t\tvar progressMessage;\n\t\tif (Validator.isValid(meshes) && meshes.length > 0) {\n\n\t\t\tvar meshNames = [];\n\t\t\tfor (var i in meshes) {\n\n\t\t\t\tmesh = meshes[i];\n\t\t\t\tmeshNames[i] = mesh.name;\n\t\t\t}\n\t\t\tprogressMessage = 'Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n\t\t} else {\n\n\t\t\tprogressMessage = 'Not adding mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n\t\t}\n\t\tvar callbackOnProgress = this.callbacks.onProgress;\n\t\tif (Validator.isValid(callbackOnProgress)) {\n\n\t\t\tvar event = new CustomEvent('MeshBuilderEvent', {\n\t\t\t\tdetail: {\n\t\t\t\t\ttype: 'progress',\n\t\t\t\t\tmodelName: meshPayload.params.meshName,\n\t\t\t\t\ttext: progressMessage,\n\t\t\t\t\tnumericalValue: meshPayload.progress.numericalValue\n\t\t\t\t}\n\t\t\t});\n\t\t\tcallbackOnProgress(event);\n\t\t}\n\n\t\treturn meshes;\n\t};\n\n\t/**\n  * Updates the materials with contained material objects (sync) or from alteration instructions (async).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {Object} materialPayload Material update instructions\n  */\n\tMeshBuilder.prototype.updateMaterials = function (materialPayload) {\n\t\tvar material, materialName;\n\t\tvar materialCloneInstructions = materialPayload.materials.materialCloneInstructions;\n\t\tif (Validator.isValid(materialCloneInstructions)) {\n\n\t\t\tvar materialNameOrg = materialCloneInstructions.materialNameOrg;\n\t\t\tvar materialOrg = this.materials[materialNameOrg];\n\n\t\t\tif (Validator.isValid(materialNameOrg)) {\n\n\t\t\t\tmaterial = materialOrg.clone();\n\n\t\t\t\tmaterialName = materialCloneInstructions.materialName;\n\t\t\t\tmaterial.name = materialName;\n\n\t\t\t\tvar materialProperties = materialCloneInstructions.materialProperties;\n\t\t\t\tfor (var key in materialProperties) {\n\n\t\t\t\t\tif (material.hasOwnProperty(key) && materialProperties.hasOwnProperty(key)) material[key] = materialProperties[key];\n\t\t\t\t}\n\t\t\t\tthis.materials[materialName] = material;\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('Requested material \"' + materialNameOrg + '\" is not available!');\n\t\t\t}\n\t\t}\n\n\t\tvar materials = materialPayload.materials.serializedMaterials;\n\t\tif (Validator.isValid(materials) && Object.keys(materials).length > 0) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tvar materialJson;\n\t\t\tfor (materialName in materials) {\n\n\t\t\t\tmaterialJson = materials[materialName];\n\t\t\t\tif (Validator.isValid(materialJson)) {\n\n\t\t\t\t\tmaterial = loader.parse(materialJson);\n\t\t\t\t\tif (this.logging.enabled) console.info('De-serialized material with name \"' + materialName + '\" will be added.');\n\t\t\t\t\tthis.materials[materialName] = material;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmaterials = materialPayload.materials.runtimeMaterials;\n\t\tif (Validator.isValid(materials) && Object.keys(materials).length > 0) {\n\n\t\t\tfor (materialName in materials) {\n\n\t\t\t\tmaterial = materials[materialName];\n\t\t\t\tif (this.logging.enabled) console.info('Material with name \"' + materialName + '\" will be added.');\n\t\t\t\tthis.materials[materialName] = material;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Returns the mapping object of material name and corresponding jsonified material.\n  *\n  * @returns {Object} Map of Materials in JSON representation\n  */\n\tMeshBuilder.prototype.getMaterialsJSON = function () {\n\t\tvar materialsJSON = {};\n\t\tvar material;\n\t\tfor (var materialName in this.materials) {\n\n\t\t\tmaterial = this.materials[materialName];\n\t\t\tmaterialsJSON[materialName] = material.toJSON();\n\t\t}\n\n\t\treturn materialsJSON;\n\t};\n\n\t/**\n  * Returns the mapping object of material name and corresponding material.\n  *\n  * @returns {Object} Map of {@link THREE.Material}\n  */\n\tMeshBuilder.prototype.getMaterials = function () {\n\t\treturn this.materials;\n\t};\n\n\treturn MeshBuilder;\n}();\n\n/**\n * Default implementation of the WorkerRunner responsible for creation and configuration of the parser within the worker.\n *\n * @class\n */\nLoaderSupport.WorkerRunnerRefImpl = function () {\n\n\tfunction WorkerRunnerRefImpl() {\n\t\tvar scope = this;\n\t\tvar scopedRunner = function scopedRunner(event) {\n\t\t\tscope.processMessage(event.data);\n\t\t};\n\t\tself.addEventListener('message', scopedRunner, false);\n\t}\n\n\t/**\n  * Applies values from parameter object via set functions or via direct assignment.\n  * @memberOf THREE.LoaderSupport.WorkerRunnerRefImpl\n  *\n  * @param {Object} parser The parser instance\n  * @param {Object} params The parameter object\n  */\n\tWorkerRunnerRefImpl.prototype.applyProperties = function (parser, params) {\n\t\tvar property, funcName, values;\n\t\tfor (property in params) {\n\t\t\tfuncName = 'set' + property.substring(0, 1).toLocaleUpperCase() + property.substring(1);\n\t\t\tvalues = params[property];\n\n\t\t\tif (typeof parser[funcName] === 'function') {\n\n\t\t\t\tparser[funcName](values);\n\t\t\t} else if (parser.hasOwnProperty(property)) {\n\n\t\t\t\tparser[property] = values;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Configures the Parser implementation according the supplied configuration object.\n  * @memberOf THREE.LoaderSupport.WorkerRunnerRefImpl\n  *\n  * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n  */\n\tWorkerRunnerRefImpl.prototype.processMessage = function (payload) {\n\t\tif (payload.cmd === 'run') {\n\n\t\t\tvar callbacks = {\n\t\t\t\tcallbackMeshBuilder: function callbackMeshBuilder(payload) {\n\t\t\t\t\tself.postMessage(payload);\n\t\t\t\t},\n\t\t\t\tcallbackProgress: function callbackProgress(text) {\n\t\t\t\t\tif (payload.logging.enabled && payload.logging.debug) console.debug('WorkerRunner: progress: ' + text);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Parser is expected to be named as such\n\t\t\tvar parser = new Parser();\n\t\t\tif (typeof parser['setLogging'] === 'function') parser.setLogging(payload.logging.enabled, payload.logging.debug);\n\t\t\tthis.applyProperties(parser, payload.params);\n\t\t\tthis.applyProperties(parser, payload.materials);\n\t\t\tthis.applyProperties(parser, callbacks);\n\t\t\tparser.workerScope = self;\n\t\t\tparser.parse(payload.data.input, payload.data.options);\n\n\t\t\tif (payload.logging.enabled) console.log('WorkerRunner: Run complete!');\n\n\t\t\tcallbacks.callbackMeshBuilder({\n\t\t\t\tcmd: 'complete',\n\t\t\t\tmsg: 'WorkerRunner completed run.'\n\t\t\t});\n\t\t} else {\n\n\t\t\tconsole.error('WorkerRunner: Received unknown command: ' + payload.cmd);\n\t\t}\n\t};\n\n\treturn WorkerRunnerRefImpl;\n}();\n\n/**\n * This class provides means to transform existing parser code into a web worker. It defines a simple communication protocol\n * which allows to configure the worker and receive raw mesh data during execution.\n * @class\n */\nLoaderSupport.WorkerSupport = function () {\n\n\tvar WORKER_SUPPORT_VERSION = '2.2.0';\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tvar LoaderWorker = function () {\n\n\t\tfunction LoaderWorker() {\n\t\t\tthis._reset();\n\t\t}\n\n\t\tLoaderWorker.prototype._reset = function () {\n\t\t\tthis.logging = {\n\t\t\t\tenabled: true,\n\t\t\t\tdebug: false\n\t\t\t};\n\t\t\tthis.worker = null;\n\t\t\tthis.runnerImplName = null;\n\t\t\tthis.callbacks = {\n\t\t\t\tmeshBuilder: null,\n\t\t\t\tonLoad: null\n\t\t\t};\n\t\t\tthis.terminateRequested = false;\n\t\t\tthis.queuedMessage = null;\n\t\t\tthis.started = false;\n\t\t\tthis.forceCopy = false;\n\t\t};\n\n\t\tLoaderWorker.prototype.setLogging = function (enabled, debug) {\n\t\t\tthis.logging.enabled = enabled === true;\n\t\t\tthis.logging.debug = debug === true;\n\t\t};\n\n\t\tLoaderWorker.prototype.setForceCopy = function (forceCopy) {\n\t\t\tthis.forceCopy = forceCopy === true;\n\t\t};\n\n\t\tLoaderWorker.prototype.initWorker = function (code, runnerImplName) {\n\t\t\tthis.runnerImplName = runnerImplName;\n\t\t\tvar blob = new Blob([code], { type: 'application/javascript' });\n\t\t\tthis.worker = new Worker(window.URL.createObjectURL(blob));\n\t\t\tthis.worker.onmessage = this._receiveWorkerMessage;\n\n\t\t\t// set referemce to this, then processing in worker scope within \"_receiveWorkerMessage\" can access members\n\t\t\tthis.worker.runtimeRef = this;\n\n\t\t\t// process stored queuedMessage\n\t\t\tthis._postMessage();\n\t\t};\n\n\t\t/**\n   * Executed in worker scope\n  \t */\n\t\tLoaderWorker.prototype._receiveWorkerMessage = function (e) {\n\t\t\tvar payload = e.data;\n\t\t\tswitch (payload.cmd) {\n\t\t\t\tcase 'meshData':\n\t\t\t\tcase 'materialData':\n\t\t\t\tcase 'imageData':\n\t\t\t\t\tthis.runtimeRef.callbacks.meshBuilder(payload);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'complete':\n\t\t\t\t\tthis.runtimeRef.queuedMessage = null;\n\t\t\t\t\tthis.started = false;\n\t\t\t\t\tthis.runtimeRef.callbacks.onLoad(payload.msg);\n\n\t\t\t\t\tif (this.runtimeRef.terminateRequested) {\n\n\t\t\t\t\t\tif (this.runtimeRef.logging.enabled) console.info('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run is complete. Terminating application on request!');\n\t\t\t\t\t\tthis.runtimeRef._terminate();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tconsole.error('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Reported error: ' + payload.msg);\n\t\t\t\t\tthis.runtimeRef.queuedMessage = null;\n\t\t\t\t\tthis.started = false;\n\t\t\t\t\tthis.runtimeRef.callbacks.onLoad(payload.msg);\n\n\t\t\t\t\tif (this.runtimeRef.terminateRequested) {\n\n\t\t\t\t\t\tif (this.runtimeRef.logging.enabled) console.info('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run reported error. Terminating application on request!');\n\t\t\t\t\t\tthis.runtimeRef._terminate();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Received unknown command: ' + payload.cmd);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t};\n\n\t\tLoaderWorker.prototype.setCallbacks = function (meshBuilder, onLoad) {\n\t\t\tthis.callbacks.meshBuilder = Validator.verifyInput(meshBuilder, this.callbacks.meshBuilder);\n\t\t\tthis.callbacks.onLoad = Validator.verifyInput(onLoad, this.callbacks.onLoad);\n\t\t};\n\n\t\tLoaderWorker.prototype.run = function (payload) {\n\t\t\tif (Validator.isValid(this.queuedMessage)) {\n\n\t\t\t\tconsole.warn('Already processing message. Rejecting new run instruction');\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tthis.queuedMessage = payload;\n\t\t\t\tthis.started = true;\n\t\t\t}\n\t\t\tif (!Validator.isValid(this.callbacks.meshBuilder)) throw 'Unable to run as no \"MeshBuilder\" callback is set.';\n\t\t\tif (!Validator.isValid(this.callbacks.onLoad)) throw 'Unable to run as no \"onLoad\" callback is set.';\n\t\t\tif (payload.cmd !== 'run') payload.cmd = 'run';\n\t\t\tif (Validator.isValid(payload.logging)) {\n\n\t\t\t\tpayload.logging.enabled = payload.logging.enabled === true;\n\t\t\t\tpayload.logging.debug = payload.logging.debug === true;\n\t\t\t} else {\n\n\t\t\t\tpayload.logging = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tdebug: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tthis._postMessage();\n\t\t};\n\n\t\tLoaderWorker.prototype._postMessage = function () {\n\t\t\tif (Validator.isValid(this.queuedMessage) && Validator.isValid(this.worker)) {\n\n\t\t\t\tif (this.queuedMessage.data.input instanceof ArrayBuffer) {\n\n\t\t\t\t\tvar content;\n\t\t\t\t\tif (this.forceCopy) {\n\n\t\t\t\t\t\tcontent = this.queuedMessage.data.input.slice(0);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontent = this.queuedMessage.data.input;\n\t\t\t\t\t}\n\t\t\t\t\tthis.worker.postMessage(this.queuedMessage, [content]);\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.worker.postMessage(this.queuedMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tLoaderWorker.prototype.setTerminateRequested = function (terminateRequested) {\n\t\t\tthis.terminateRequested = terminateRequested === true;\n\t\t\tif (this.terminateRequested && Validator.isValid(this.worker) && !Validator.isValid(this.queuedMessage) && this.started) {\n\n\t\t\t\tif (this.logging.enabled) console.info('Worker is terminated immediately as it is not running!');\n\t\t\t\tthis._terminate();\n\t\t\t}\n\t\t};\n\n\t\tLoaderWorker.prototype._terminate = function () {\n\t\t\tthis.worker.terminate();\n\t\t\tthis._reset();\n\t\t};\n\n\t\treturn LoaderWorker;\n\t}();\n\n\tfunction WorkerSupport() {\n\t\tconsole.info('Using THREE.LoaderSupport.WorkerSupport version: ' + WORKER_SUPPORT_VERSION);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\t// check worker support first\n\t\tif (window.Worker === undefined) throw \"This browser does not support web workers!\";\n\t\tif (window.Blob === undefined) throw \"This browser does not support Blob!\";\n\t\tif (typeof window.URL.createObjectURL !== 'function') throw \"This browser does not support Object creation from URL!\";\n\n\t\tthis.loaderWorker = new LoaderWorker();\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tWorkerSupport.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\tthis.loaderWorker.setLogging(this.logging.enabled, this.logging.debug);\n\t};\n\n\t/**\n  * Forces all ArrayBuffers to be transferred to worker to be copied.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {boolean} forceWorkerDataCopy True or false.\n  */\n\tWorkerSupport.prototype.setForceWorkerDataCopy = function (forceWorkerDataCopy) {\n\t\tthis.loaderWorker.setForceCopy(forceWorkerDataCopy);\n\t};\n\n\t/**\n  * Validate the status of worker code and the derived worker.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {Function} functionCodeBuilder Function that is invoked with funcBuildObject and funcBuildSingleton that allows stringification of objects and singletons.\n  * @param {String} parserName Name of the Parser object\n  * @param {String[]} libLocations URL of libraries that shall be added to worker code relative to libPath\n  * @param {String} libPath Base path used for loading libraries\n  * @param {THREE.LoaderSupport.WorkerRunnerRefImpl} runnerImpl The default worker parser wrapper implementation (communication and execution). An extended class could be passed here.\n  */\n\tWorkerSupport.prototype.validate = function (functionCodeBuilder, parserName, libLocations, libPath, runnerImpl) {\n\t\tif (Validator.isValid(this.loaderWorker.worker)) return;\n\n\t\tif (this.logging.enabled) {\n\n\t\t\tconsole.info('WorkerSupport: Building worker code...');\n\t\t\tconsole.time('buildWebWorkerCode');\n\t\t}\n\t\tif (Validator.isValid(runnerImpl)) {\n\n\t\t\tif (this.logging.enabled) console.info('WorkerSupport: Using \"' + runnerImpl.name + '\" as Runner class for worker.');\n\t\t} else {\n\n\t\t\trunnerImpl = LoaderSupport.WorkerRunnerRefImpl;\n\t\t\tif (this.logging.enabled) console.info('WorkerSupport: Using DEFAULT \"THREE.LoaderSupport.WorkerRunnerRefImpl\" as Runner class for worker.');\n\t\t}\n\n\t\tvar userWorkerCode = functionCodeBuilder(buildObject, buildSingleton);\n\t\tuserWorkerCode += 'var Parser = ' + parserName + ';\\n\\n';\n\t\tuserWorkerCode += buildSingleton(runnerImpl.name, runnerImpl);\n\t\tuserWorkerCode += 'new ' + runnerImpl.name + '();\\n\\n';\n\n\t\tvar scope = this;\n\t\tif (Validator.isValid(libLocations) && libLocations.length > 0) {\n\n\t\t\tvar libsContent = '';\n\t\t\tvar loadAllLibraries = function loadAllLibraries(path, locations) {\n\t\t\t\tif (locations.length === 0) {\n\n\t\t\t\t\tscope.loaderWorker.initWorker(libsContent + userWorkerCode, runnerImpl.name);\n\t\t\t\t\tif (scope.logging.enabled) console.timeEnd('buildWebWorkerCode');\n\t\t\t\t} else {\n\n\t\t\t\t\tvar loadedLib = function loadedLib(contentAsString) {\n\t\t\t\t\t\tlibsContent += contentAsString;\n\t\t\t\t\t\tloadAllLibraries(path, locations);\n\t\t\t\t\t};\n\n\t\t\t\t\tvar fileLoader = new THREE.FileLoader();\n\t\t\t\t\tfileLoader.setPath(path);\n\t\t\t\t\tfileLoader.setResponseType('text');\n\t\t\t\t\tfileLoader.load(locations[0], loadedLib);\n\t\t\t\t\tlocations.shift();\n\t\t\t\t}\n\t\t\t};\n\t\t\tloadAllLibraries(libPath, libLocations);\n\t\t} else {\n\n\t\t\tthis.loaderWorker.initWorker(userWorkerCode, runnerImpl.name);\n\t\t\tif (this.logging.enabled) console.timeEnd('buildWebWorkerCode');\n\t\t}\n\t};\n\n\t/**\n  * Specify functions that should be build when new raw mesh data becomes available and when the parser is finished.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {Function} meshBuilder The mesh builder function. Default is {@link THREE.LoaderSupport.MeshBuilder}.\n  * @param {Function} onLoad The function that is called when parsing is complete.\n  */\n\tWorkerSupport.prototype.setCallbacks = function (meshBuilder, onLoad) {\n\t\tthis.loaderWorker.setCallbacks(meshBuilder, onLoad);\n\t};\n\n\t/**\n  * Runs the parser with the provided configuration.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n  */\n\tWorkerSupport.prototype.run = function (payload) {\n\t\tthis.loaderWorker.run(payload);\n\t};\n\n\t/**\n  * Request termination of worker once parser is finished.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {boolean} terminateRequested True or false.\n  */\n\tWorkerSupport.prototype.setTerminateRequested = function (terminateRequested) {\n\t\tthis.loaderWorker.setTerminateRequested(terminateRequested);\n\t};\n\n\tvar buildObject = function buildObject(fullName, object) {\n\t\tvar objectString = fullName + ' = {\\n';\n\t\tvar part;\n\t\tfor (var name in object) {\n\n\t\t\tpart = object[name];\n\t\t\tif (typeof part === 'string' || part instanceof String) {\n\n\t\t\t\tpart = part.replace('\\n', '\\\\n');\n\t\t\t\tpart = part.replace('\\r', '\\\\r');\n\t\t\t\tobjectString += '\\t' + name + ': \"' + part + '\",\\n';\n\t\t\t} else if (part instanceof Array) {\n\n\t\t\t\tobjectString += '\\t' + name + ': [' + part + '],\\n';\n\t\t\t} else if (Number.isInteger(part)) {\n\n\t\t\t\tobjectString += '\\t' + name + ': ' + part + ',\\n';\n\t\t\t} else if (typeof part === 'function') {\n\n\t\t\t\tobjectString += '\\t' + name + ': ' + part + ',\\n';\n\t\t\t}\n\t\t}\n\t\tobjectString += '}\\n\\n';\n\n\t\treturn objectString;\n\t};\n\n\tvar buildSingleton = function buildSingleton(fullName, object, internalName, basePrototypeName, ignoreFunctions) {\n\t\tvar objectString = '';\n\t\tvar objectName = Validator.isValid(internalName) ? internalName : object.name;\n\n\t\tvar funcString, objectPart, constructorString;\n\t\tignoreFunctions = Validator.verifyInput(ignoreFunctions, []);\n\t\tfor (var name in object.prototype) {\n\n\t\t\tobjectPart = object.prototype[name];\n\t\t\tif (name === 'constructor') {\n\n\t\t\t\tfuncString = objectPart.toString();\n\t\t\t\tfuncString = funcString.replace('function', '');\n\t\t\t\tconstructorString = '\\tfunction ' + objectName + funcString + ';\\n\\n';\n\t\t\t} else if (typeof objectPart === 'function') {\n\n\t\t\t\tif (ignoreFunctions.indexOf(name) < 0) {\n\n\t\t\t\t\tfuncString = objectPart.toString();\n\t\t\t\t\tobjectString += '\\t' + objectName + '.prototype.' + name + ' = ' + funcString + ';\\n\\n';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tobjectString += '\\treturn ' + objectName + ';\\n';\n\t\tobjectString += '})();\\n\\n';\n\n\t\tvar inheritanceBlock = '';\n\t\tif (Validator.isValid(basePrototypeName)) {\n\n\t\t\tinheritanceBlock += '\\n';\n\t\t\tinheritanceBlock += objectName + '.prototype = Object.create( ' + basePrototypeName + '.prototype );\\n';\n\t\t\tinheritanceBlock += objectName + '.constructor = ' + objectName + ';\\n';\n\t\t\tinheritanceBlock += '\\n';\n\t\t}\n\t\tif (!Validator.isValid(constructorString)) {\n\n\t\t\tconstructorString = fullName + ' = (function () {\\n\\n';\n\t\t\tconstructorString += inheritanceBlock + '\\t' + object.prototype.constructor.toString() + '\\n\\n';\n\t\t\tobjectString = constructorString + objectString;\n\t\t} else {\n\n\t\t\tobjectString = fullName + ' = (function () {\\n\\n' + inheritanceBlock + constructorString + objectString;\n\t\t}\n\n\t\treturn objectString;\n\t};\n\n\treturn WorkerSupport;\n}();\n\n/**\n * Orchestrate loading of multiple OBJ files/data from an instruction queue with a configurable amount of workers (1-16).\n * Workflow:\n *   prepareWorkers\n *   enqueueForRun\n *   processQueue\n *   tearDown (to force stop)\n *\n * @class\n *\n * @param {string} classDef Class definition to be used for construction\n */\nLoaderSupport.WorkerDirector = function () {\n\n\tvar LOADER_WORKER_DIRECTOR_VERSION = '2.2.0';\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tvar MAX_WEB_WORKER = 16;\n\tvar MAX_QUEUE_SIZE = 8192;\n\n\tfunction WorkerDirector(classDef) {\n\t\tconsole.info('Using THREE.LoaderSupport.WorkerDirector version: ' + LOADER_WORKER_DIRECTOR_VERSION);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\tthis.maxQueueSize = MAX_QUEUE_SIZE;\n\t\tthis.maxWebWorkers = MAX_WEB_WORKER;\n\t\tthis.crossOrigin = null;\n\n\t\tif (!Validator.isValid(classDef)) throw 'Provided invalid classDef: ' + classDef;\n\n\t\tthis.workerDescription = {\n\t\t\tclassDef: classDef,\n\t\t\tglobalCallbacks: {},\n\t\t\tworkerSupports: {},\n\t\t\tforceWorkerDataCopy: true\n\t\t};\n\t\tthis.objectsCompleted = 0;\n\t\tthis.instructionQueue = [];\n\t\tthis.instructionQueuePointer = 0;\n\n\t\tthis.callbackOnFinishedProcessing = null;\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tWorkerDirector.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t};\n\n\t/**\n  * Returns the maximum length of the instruction queue.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @returns {number}\n  */\n\tWorkerDirector.prototype.getMaxQueueSize = function () {\n\t\treturn this.maxQueueSize;\n\t};\n\n\t/**\n  * Returns the maximum number of workers.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @returns {number}\n  */\n\tWorkerDirector.prototype.getMaxWebWorkers = function () {\n\t\treturn this.maxWebWorkers;\n\t};\n\n\t/**\n  * Sets the CORS string to be used.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {string} crossOrigin CORS value\n  */\n\tWorkerDirector.prototype.setCrossOrigin = function (crossOrigin) {\n\t\tthis.crossOrigin = crossOrigin;\n\t};\n\n\t/**\n  * Forces all ArrayBuffers to be transferred to worker to be copied.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {boolean} forceWorkerDataCopy True or false.\n  */\n\tWorkerDirector.prototype.setForceWorkerDataCopy = function (forceWorkerDataCopy) {\n\t\tthis.workerDescription.forceWorkerDataCopy = forceWorkerDataCopy === true;\n\t};\n\n\t/**\n  * Create or destroy workers according limits. Set the name and register callbacks for dynamically created web workers.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {THREE.OBJLoader2.WWOBJLoader2.PrepDataCallbacks} globalCallbacks  Register global callbacks used by all web workers\n  * @param {number} maxQueueSize Set the maximum size of the instruction queue (1-1024)\n  * @param {number} maxWebWorkers Set the maximum amount of workers (1-16)\n  */\n\tWorkerDirector.prototype.prepareWorkers = function (globalCallbacks, maxQueueSize, maxWebWorkers) {\n\t\tif (Validator.isValid(globalCallbacks)) this.workerDescription.globalCallbacks = globalCallbacks;\n\t\tthis.maxQueueSize = Math.min(maxQueueSize, MAX_QUEUE_SIZE);\n\t\tthis.maxWebWorkers = Math.min(maxWebWorkers, MAX_WEB_WORKER);\n\t\tthis.maxWebWorkers = Math.min(this.maxWebWorkers, this.maxQueueSize);\n\t\tthis.objectsCompleted = 0;\n\t\tthis.instructionQueue = [];\n\t\tthis.instructionQueuePointer = 0;\n\n\t\tfor (var instanceNo = 0; instanceNo < this.maxWebWorkers; instanceNo++) {\n\n\t\t\tvar workerSupport = new THREE.LoaderSupport.WorkerSupport();\n\t\t\tworkerSupport.setLogging(this.logging.enabled, this.logging.debug);\n\t\t\tworkerSupport.setForceWorkerDataCopy(this.workerDescription.forceWorkerDataCopy);\n\t\t\tthis.workerDescription.workerSupports[instanceNo] = {\n\t\t\t\tinstanceNo: instanceNo,\n\t\t\t\tinUse: false,\n\t\t\t\tterminateRequested: false,\n\t\t\t\tworkerSupport: workerSupport,\n\t\t\t\tloader: null\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n  * Store run instructions in internal instructionQueue.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {THREE.LoaderSupport.PrepData} prepData\n  */\n\tWorkerDirector.prototype.enqueueForRun = function (prepData) {\n\t\tif (this.instructionQueue.length < this.maxQueueSize) {\n\t\t\tthis.instructionQueue.push(prepData);\n\t\t}\n\t};\n\n\t/**\n  * Returns if any workers are running.\n  *\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  * @returns {boolean}\n  */\n\tWorkerDirector.prototype.isRunning = function () {\n\t\tvar wsKeys = Object.keys(this.workerDescription.workerSupports);\n\t\treturn this.instructionQueue.length > 0 && this.instructionQueuePointer < this.instructionQueue.length || wsKeys.length > 0;\n\t};\n\n\t/**\n  * Process the instructionQueue until it is depleted.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  */\n\tWorkerDirector.prototype.processQueue = function () {\n\t\tvar prepData, supportDesc;\n\t\tfor (var instanceNo in this.workerDescription.workerSupports) {\n\n\t\t\tsupportDesc = this.workerDescription.workerSupports[instanceNo];\n\t\t\tif (!supportDesc.inUse) {\n\n\t\t\t\tif (this.instructionQueuePointer < this.instructionQueue.length) {\n\n\t\t\t\t\tprepData = this.instructionQueue[this.instructionQueuePointer];\n\t\t\t\t\tthis._kickWorkerRun(prepData, supportDesc);\n\t\t\t\t\tthis.instructionQueuePointer++;\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._deregister(supportDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isRunning() && this.callbackOnFinishedProcessing !== null) {\n\n\t\t\tthis.callbackOnFinishedProcessing();\n\t\t\tthis.callbackOnFinishedProcessing = null;\n\t\t}\n\t};\n\n\tWorkerDirector.prototype._kickWorkerRun = function (prepData, supportDesc) {\n\t\tsupportDesc.inUse = true;\n\t\tsupportDesc.workerSupport.setTerminateRequested(supportDesc.terminateRequested);\n\n\t\tif (this.logging.enabled) console.info('\\nAssigning next item from queue to worker (queue length: ' + this.instructionQueue.length + ')\\n\\n');\n\n\t\tvar scope = this;\n\t\tvar prepDataCallbacks = prepData.getCallbacks();\n\t\tvar globalCallbacks = this.workerDescription.globalCallbacks;\n\t\tvar wrapperOnLoad = function wrapperOnLoad(event) {\n\t\t\tif (Validator.isValid(globalCallbacks.onLoad)) globalCallbacks.onLoad(event);\n\t\t\tif (Validator.isValid(prepDataCallbacks.onLoad)) prepDataCallbacks.onLoad(event);\n\t\t\tscope.objectsCompleted++;\n\t\t\tsupportDesc.inUse = false;\n\n\t\t\tscope.processQueue();\n\t\t};\n\n\t\tvar wrapperOnProgress = function wrapperOnProgress(event) {\n\t\t\tif (Validator.isValid(globalCallbacks.onProgress)) globalCallbacks.onProgress(event);\n\t\t\tif (Validator.isValid(prepDataCallbacks.onProgress)) prepDataCallbacks.onProgress(event);\n\t\t};\n\n\t\tvar wrapperOnMeshAlter = function wrapperOnMeshAlter(event) {\n\t\t\tif (Validator.isValid(globalCallbacks.onMeshAlter)) globalCallbacks.onMeshAlter(event);\n\t\t\tif (Validator.isValid(prepDataCallbacks.onMeshAlter)) prepDataCallbacks.onMeshAlter(event);\n\t\t};\n\n\t\tsupportDesc.loader = this._buildLoader(supportDesc.instanceNo);\n\n\t\tvar updatedCallbacks = new LoaderSupport.Callbacks();\n\t\tupdatedCallbacks.setCallbackOnLoad(wrapperOnLoad);\n\t\tupdatedCallbacks.setCallbackOnProgress(wrapperOnProgress);\n\t\tupdatedCallbacks.setCallbackOnMeshAlter(wrapperOnMeshAlter);\n\t\tprepData.callbacks = updatedCallbacks;\n\n\t\tsupportDesc.loader.run(prepData, supportDesc.workerSupport);\n\t};\n\n\tWorkerDirector.prototype._buildLoader = function (instanceNo) {\n\t\tvar classDef = this.workerDescription.classDef;\n\t\tvar loader = Object.create(classDef.prototype);\n\t\tclassDef.call(loader, THREE.DefaultLoadingManager);\n\n\t\t// verify that all required functions are implemented\n\t\tif (!loader.hasOwnProperty('instanceNo')) throw classDef.name + ' has no property \"instanceNo\".';\n\t\tloader.instanceNo = instanceNo;\n\n\t\tif (!loader.hasOwnProperty('workerSupport')) {\n\n\t\t\tthrow classDef.name + ' has no property \"workerSupport\".';\n\t\t}\n\t\tif (typeof loader.run !== 'function') throw classDef.name + ' has no function \"run\".';\n\t\tif (!loader.hasOwnProperty('callbacks') || !Validator.isValid(loader.callbacks)) {\n\n\t\t\tconsole.warn(classDef.name + ' has an invalid property \"callbacks\". Will change to \"THREE.LoaderSupport.Callbacks\"');\n\t\t\tloader.callbacks = new THREE.LoaderSupport.Callbacks();\n\t\t}\n\n\t\treturn loader;\n\t};\n\n\tWorkerDirector.prototype._deregister = function (supportDesc) {\n\t\tif (Validator.isValid(supportDesc)) {\n\n\t\t\tsupportDesc.workerSupport.setTerminateRequested(true);\n\t\t\tif (this.logging.enabled) console.info('Requested termination of worker #' + supportDesc.instanceNo + '.');\n\n\t\t\tvar loaderCallbacks = supportDesc.loader.callbacks;\n\t\t\tif (Validator.isValid(loaderCallbacks.onProgress)) loaderCallbacks.onProgress({ detail: { text: '' } });\n\t\t\tdelete this.workerDescription.workerSupports[supportDesc.instanceNo];\n\t\t}\n\t};\n\n\t/**\n  * Terminate all workers.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {callback} callbackOnFinishedProcessing Function called once all workers finished processing.\n  */\n\tWorkerDirector.prototype.tearDown = function (callbackOnFinishedProcessing) {\n\t\tif (this.logging.enabled) console.info('WorkerDirector received the deregister call. Terminating all workers!');\n\n\t\tthis.instructionQueuePointer = this.instructionQueue.length;\n\t\tthis.callbackOnFinishedProcessing = Validator.verifyInput(callbackOnFinishedProcessing, null);\n\n\t\tfor (var name in this.workerDescription.workerSupports) {\n\n\t\t\tthis.workerDescription.workerSupports[name].terminateRequested = true;\n\t\t}\n\t};\n\n\treturn WorkerDirector;\n}();\n\nexports.default = LoaderSupport;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n *\n * @author angelxuanchang\n */\n\nvar MTLLoader = function MTLLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nMTLLoader.prototype = {\n\n\tconstructor: MTLLoader,\n\n\t/**\n  * Loads and parses a MTL asset from a URL.\n  *\n  * @param {String} url - URL to the MTL file.\n  * @param {Function} [onLoad] - Callback invoked with the loaded object.\n  * @param {Function} [onProgress] - Callback for download progress.\n  * @param {Function} [onError] - Callback for download errors.\n  *\n  * @see setPath setTexturePath\n  *\n  * @note In order for relative texture references to resolve correctly\n  * you must call setPath and/or setTexturePath explicitly prior to load.\n  */\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setPath(this.path);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\t/**\n  * Set base path for resolving references.\n  * If set this path will be prepended to each loaded and found reference.\n  *\n  * @see setTexturePath\n  * @param {String} path\n  * @return {THREE.MTLLoader}\n  *\n  * @example\n  *     mtlLoader.setPath( 'assets/obj/' );\n  *     mtlLoader.load( 'my.mtl', ... );\n  */\n\tsetPath: function setPath(path) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\t},\n\n\t/**\n  * Set base path for resolving texture references.\n  * If set this path will be prepended found texture reference.\n  * If not set and setPath is, it will be used as texture base path.\n  *\n  * @see setPath\n  * @param {String} path\n  * @return {THREE.MTLLoader}\n  *\n  * @example\n  *     mtlLoader.setPath( 'assets/obj/' );\n  *     mtlLoader.setTexturePath( 'assets/textures/' );\n  *     mtlLoader.load( 'my.mtl', ... );\n  */\n\tsetTexturePath: function setTexturePath(path) {\n\n\t\tthis.texturePath = path;\n\t\treturn this;\n\t},\n\n\tsetBaseUrl: function setBaseUrl(path) {\n\n\t\tconsole.warn('THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.');\n\n\t\treturn this.setTexturePath(path);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\t},\n\n\tsetMaterialOptions: function setMaterialOptions(value) {\n\n\t\tthis.materialOptions = value;\n\t\treturn this;\n\t},\n\n\t/**\n  * Parses a MTL file.\n  *\n  * @param {String} text - Content of MTL file\n  * @return {MTLLoader.MaterialCreator}\n  *\n  * @see setPath setTexturePath\n  *\n  * @note In order for relative texture references to resolve correctly\n  * you must call setPath and/or setTexturePath explicitly prior to parse.\n  */\n\tparse: function parse(text) {\n\n\t\tvar lines = text.split('\\n');\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialsInfo = {};\n\n\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\tvar line = lines[i];\n\t\t\tline = line.trim();\n\n\t\t\tif (line.length === 0 || line.charAt(0) === '#') {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf(' ');\n\n\t\t\tvar key = pos >= 0 ? line.substring(0, pos) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = pos >= 0 ? line.substring(pos + 1) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif (key === 'newmtl') {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[value] = info;\n\t\t\t} else if (info) {\n\n\t\t\t\tif (key === 'ka' || key === 'kd' || key === 'ks') {\n\n\t\t\t\t\tvar ss = value.split(delimiter_pattern, 3);\n\t\t\t\t\tinfo[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar materialCreator = new MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);\n\t\tmaterialCreator.setCrossOrigin(this.crossOrigin);\n\t\tmaterialCreator.setManager(this.manager);\n\t\tmaterialCreator.setMaterials(materialsInfo);\n\t\treturn materialCreator;\n\t}\n\n};\n\n/**\n * Create a new THREE-MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nMTLLoader.MaterialCreator = function (baseUrl, options) {\n\n\tthis.baseUrl = baseUrl || '';\n\tthis.options = options;\n\tthis.materialsInfo = {};\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\n\tthis.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;\n\tthis.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;\n};\n\nMTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: MTLLoader.MaterialCreator,\n\n\tcrossOrigin: 'Anonymous',\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tsetManager: function setManager(value) {\n\n\t\tthis.manager = value;\n\t},\n\n\tsetMaterials: function setMaterials(materialsInfo) {\n\n\t\tthis.materialsInfo = this.convert(materialsInfo);\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\t},\n\n\tconvert: function convert(materialsInfo) {\n\n\t\tif (!this.options) return materialsInfo;\n\n\t\tvar converted = {};\n\n\t\tfor (var mn in materialsInfo) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[mn];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[mn] = covmat;\n\n\t\t\tfor (var prop in mat) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[prop];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch (lprop) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif (this.options && this.options.normalizeRGB) {\n\n\t\t\t\t\t\t\tvalue = [value[0] / 255, value[1] / 255, value[2] / 255];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.options && this.options.ignoreZeroRGBs) {\n\n\t\t\t\t\t\t\tif (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (save) {\n\n\t\t\t\t\tcovmat[lprop] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn converted;\n\t},\n\n\tpreload: function preload() {\n\n\t\tfor (var mn in this.materialsInfo) {\n\n\t\t\tthis.create(mn);\n\t\t}\n\t},\n\n\tgetIndex: function getIndex(materialName) {\n\n\t\treturn this.nameLookup[materialName];\n\t},\n\n\tgetAsArray: function getAsArray() {\n\n\t\tvar index = 0;\n\n\t\tfor (var mn in this.materialsInfo) {\n\n\t\t\tthis.materialsArray[index] = this.create(mn);\n\t\t\tthis.nameLookup[mn] = index;\n\t\t\tindex++;\n\t\t}\n\n\t\treturn this.materialsArray;\n\t},\n\n\tcreate: function create(materialName) {\n\n\t\tif (this.materials[materialName] === undefined) {\n\n\t\t\tthis.createMaterial_(materialName);\n\t\t}\n\n\t\treturn this.materials[materialName];\n\t},\n\n\tcreateMaterial_: function createMaterial_(materialName) {\n\n\t\t// Create material\n\n\t\tvar scope = this;\n\t\tvar mat = this.materialsInfo[materialName];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL(baseUrl, url) {\n\n\t\t\tif (typeof url !== 'string' || url === '') return '';\n\n\t\t\t// Absolute URL\n\t\t\tif (/^https?:\\/\\//i.test(url)) return url;\n\n\t\t\treturn baseUrl + url;\n\t\t}\n\n\t\tfunction setMapForType(mapType, value) {\n\n\t\t\tif (params[mapType]) return; // Keep the first encountered texture\n\n\t\t\tvar texParams = scope.getTextureParams(value, params);\n\t\t\tvar map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n\t\t\tmap.repeat.copy(texParams.scale);\n\t\t\tmap.offset.copy(texParams.offset);\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tparams[mapType] = map;\n\t\t}\n\n\t\tfor (var prop in mat) {\n\n\t\t\tvar value = mat[prop];\n\t\t\tvar n;\n\n\t\t\tif (value === '') continue;\n\n\t\t\tswitch (prop.toLowerCase()) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = new THREE.Color().fromArray(value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = new THREE.Color().fromArray(value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType(\"map\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType(\"specularMap\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'norm':\n\n\t\t\t\t\tsetMapForType(\"normalMap\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType(\"bumpMap\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat(value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tn = parseFloat(value);\n\n\t\t\t\t\tif (n < 1) {\n\n\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\tparams.transparent = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tr':\n\t\t\t\t\tn = parseFloat(value);\n\n\t\t\t\t\tif (this.options && this.options.invertTrProperty) n = 1 - n;\n\n\t\t\t\t\tif (n > 0) {\n\n\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\tparams.transparent = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\tthis.materials[materialName] = new THREE.MeshPhongMaterial(params);\n\t\treturn this.materials[materialName];\n\t},\n\n\tgetTextureParams: function getTextureParams(value, matParams) {\n\n\t\tvar texParams = {\n\n\t\t\tscale: new THREE.Vector2(1, 1),\n\t\t\toffset: new THREE.Vector2(0, 0)\n\n\t\t};\n\n\t\tvar items = value.split(/\\s+/);\n\t\tvar pos;\n\n\t\tpos = items.indexOf('-bm');\n\n\t\tif (pos >= 0) {\n\n\t\t\tmatParams.bumpScale = parseFloat(items[pos + 1]);\n\t\t\titems.splice(pos, 2);\n\t\t}\n\n\t\tpos = items.indexOf('-s');\n\n\t\tif (pos >= 0) {\n\n\t\t\ttexParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\n\t\t}\n\n\t\tpos = items.indexOf('-o');\n\n\t\tif (pos >= 0) {\n\n\t\t\ttexParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\n\t\t}\n\n\t\ttexParams.url = items.join(' ').trim();\n\t\treturn texParams;\n\t},\n\n\tloadTexture: function loadTexture(url, mapping, onLoad, onProgress, onError) {\n\n\t\tvar texture;\n\t\tvar loader = THREE.Loader.Handlers.get(url);\n\t\tvar manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;\n\n\t\tif (loader === null) {\n\n\t\t\tloader = new THREE.TextureLoader(manager);\n\t\t}\n\n\t\tif (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n\t\ttexture = loader.load(url, onLoad, onProgress, onError);\n\n\t\tif (mapping !== undefined) texture.mapping = mapping;\n\n\t\treturn texture;\n\t}\n\n};\n\nexports.default = MTLLoader;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * This class had been written to handle the output of the NRRD loader.\n * It contains a volume of data and informations about it.\n * For now it only handles 3 dimensional data.\n * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.\n * @class\n * @author Valentin Demeusy / https://github.com/stity\n * @param   {number}        xLength         Width of the volume\n * @param   {number}        yLength         Length of the volume\n * @param   {number}        zLength         Depth of the volume\n * @param   {string}        type            The type of data (uint8, uint16, ...)\n * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data\n */\nvar Volume = function Volume(xLength, yLength, zLength, type, arrayBuffer) {\n\n\tif (arguments.length > 0) {\n\n\t\t/**\n   * @member {number} xLength Width of the volume in the IJK coordinate system\n   */\n\t\tthis.xLength = Number(xLength) || 1;\n\t\t/**\n   * @member {number} yLength Height of the volume in the IJK coordinate system\n   */\n\t\tthis.yLength = Number(yLength) || 1;\n\t\t/**\n   * @member {number} zLength Depth of the volume in the IJK coordinate system\n   */\n\t\tthis.zLength = Number(zLength) || 1;\n\n\t\t/**\n   * @member {TypedArray} data Data of the volume\n   */\n\n\t\tswitch (type) {\n\n\t\t\tcase 'Uint8':\n\t\t\tcase 'uint8':\n\t\t\tcase 'uchar':\n\t\t\tcase 'unsigned char':\n\t\t\tcase 'uint8_t':\n\t\t\t\tthis.data = new Uint8Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Int8':\n\t\t\tcase 'int8':\n\t\t\tcase 'signed char':\n\t\t\tcase 'int8_t':\n\t\t\t\tthis.data = new Int8Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Int16':\n\t\t\tcase 'int16':\n\t\t\tcase 'short':\n\t\t\tcase 'short int':\n\t\t\tcase 'signed short':\n\t\t\tcase 'signed short int':\n\t\t\tcase 'int16_t':\n\t\t\t\tthis.data = new Int16Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Uint16':\n\t\t\tcase 'uint16':\n\t\t\tcase 'ushort':\n\t\t\tcase 'unsigned short':\n\t\t\tcase 'unsigned short int':\n\t\t\tcase 'uint16_t':\n\t\t\t\tthis.data = new Uint16Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Int32':\n\t\t\tcase 'int32':\n\t\t\tcase 'int':\n\t\t\tcase 'signed int':\n\t\t\tcase 'int32_t':\n\t\t\t\tthis.data = new Int32Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Uint32':\n\t\t\tcase 'uint32':\n\t\t\tcase 'uint':\n\t\t\tcase 'unsigned int':\n\t\t\tcase 'uint32_t':\n\t\t\t\tthis.data = new Uint32Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'longlong':\n\t\t\tcase 'long long':\n\t\t\tcase 'long long int':\n\t\t\tcase 'signed long long':\n\t\t\tcase 'signed long long int':\n\t\t\tcase 'int64':\n\t\t\tcase 'int64_t':\n\t\t\tcase 'ulonglong':\n\t\t\tcase 'unsigned long long':\n\t\t\tcase 'unsigned long long int':\n\t\t\tcase 'uint64':\n\t\t\tcase 'uint64_t':\n\t\t\t\tthrow 'Error in THREE.Volume constructor : this type is not supported in JavaScript';\n\t\t\t\tbreak;\n\t\t\tcase 'Float32':\n\t\t\tcase 'float32':\n\t\t\tcase 'float':\n\t\t\t\tthis.data = new Float32Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Float64':\n\t\t\tcase 'float64':\n\t\t\tcase 'double':\n\t\t\t\tthis.data = new Float64Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.data = new Uint8Array(arrayBuffer);\n\n\t\t}\n\n\t\tif (this.data.length !== this.xLength * this.yLength * this.zLength) {\n\n\t\t\tthrow 'Error in THREE.Volume constructor, lengths are not matching arrayBuffer size';\n\t\t}\n\t}\n\n\t/**\n  * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system\n  */\n\tthis.spacing = [1, 1, 1];\n\t/**\n  * @member {Array}  offset Offset of the volume in the RAS coordinate system\n  */\n\tthis.offset = [0, 0, 0];\n\t/**\n  * @member {THREE.Martrix3} matrix The IJK to RAS matrix\n  */\n\tthis.matrix = new THREE.Matrix3();\n\tthis.matrix.identity();\n\t/**\n  * @member {THREE.Martrix3} inverseMatrix The RAS to IJK matrix\n  */\n\t/**\n  * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.\n  *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n  */\n\tvar lowerThreshold = -Infinity;\n\tObject.defineProperty(this, 'lowerThreshold', {\n\t\tget: function get() {\n\n\t\t\treturn lowerThreshold;\n\t\t},\n\t\tset: function set(value) {\n\n\t\t\tlowerThreshold = value;\n\t\t\tthis.sliceList.forEach(function (slice) {\n\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t});\n\t\t}\n\t});\n\t/**\n  * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.\n  *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n  */\n\tvar upperThreshold = Infinity;\n\tObject.defineProperty(this, 'upperThreshold', {\n\t\tget: function get() {\n\n\t\t\treturn upperThreshold;\n\t\t},\n\t\tset: function set(value) {\n\n\t\t\tupperThreshold = value;\n\t\t\tthis.sliceList.forEach(function (slice) {\n\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t});\n\t\t}\n\t});\n\n\t/**\n  * @member {Array} sliceList The list of all the slices associated to this volume\n  */\n\tthis.sliceList = [];\n\n\t/**\n  * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space\n  */\n};\n\nVolume.prototype = {\n\n\tconstructor: Volume,\n\n\t/**\n  * @member {Function} getData Shortcut for data[access(i,j,k)]\n  * @memberof THREE.Volume\n  * @param {number} i    First coordinate\n  * @param {number} j    Second coordinate\n  * @param {number} k    Third coordinate\n  * @returns {number}  value in the data array\n  */\n\tgetData: function getData(i, j, k) {\n\n\t\treturn this.data[k * this.xLength * this.yLength + j * this.xLength + i];\n\t},\n\n\t/**\n  * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system\n  * @memberof THREE.Volume\n  * @param {number} i    First coordinate\n  * @param {number} j    Second coordinate\n  * @param {number} k    Third coordinate\n  * @returns {number}  index\n  */\n\taccess: function access(i, j, k) {\n\n\t\treturn k * this.xLength * this.yLength + j * this.xLength + i;\n\t},\n\n\t/**\n  * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data\n  * @memberof THREE.Volume\n  * @param {number} index index of the voxel\n  * @returns {Array}  [x,y,z]\n  */\n\treverseAccess: function reverseAccess(index) {\n\n\t\tvar z = Math.floor(index / (this.yLength * this.xLength));\n\t\tvar y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);\n\t\tvar x = index - z * this.yLength * this.xLength - y * this.xLength;\n\t\treturn [x, y, z];\n\t},\n\n\t/**\n  * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced\n  * @memberof THREE.Volume\n  * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :\n  *                                 value of the voxel\n  *                                 index of the voxel\n  *                                 the data (TypedArray)\n  * @param {Object}   context    You can specify a context in which call the function, default if this Volume\n  * @returns {THREE.Volume}   this\n  */\n\tmap: function map(functionToMap, context) {\n\n\t\tvar length = this.data.length;\n\t\tcontext = context || this;\n\n\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\tthis.data[i] = functionToMap.call(context, this.data[i], i, this.data);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n  * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\n  * @memberof THREE.Volume\n  * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n  * @param {number}            index the index of the slice\n  * @returns {Object} an object containing all the usefull information on the geometry of the slice\n  */\n\textractPerpendicularPlane: function extractPerpendicularPlane(axis, RASIndex) {\n\n\t\tvar iLength,\n\t\t    jLength,\n\t\t    sliceAccess,\n\t\t    planeMatrix = new THREE.Matrix4().identity(),\n\t\t    volume = this,\n\t\t    planeWidth,\n\t\t    planeHeight,\n\t\t    firstSpacing,\n\t\t    secondSpacing,\n\t\t    positionOffset,\n\t\t    IJKIndex;\n\n\t\tvar axisInIJK = new THREE.Vector3(),\n\t\t    firstDirection = new THREE.Vector3(),\n\t\t    secondDirection = new THREE.Vector3();\n\n\t\tvar dimensions = new THREE.Vector3(this.xLength, this.yLength, this.zLength);\n\n\t\tswitch (axis) {\n\n\t\t\tcase 'x':\n\t\t\t\taxisInIJK.set(1, 0, 0);\n\t\t\t\tfirstDirection.set(0, 0, -1);\n\t\t\t\tsecondDirection.set(0, -1, 0);\n\t\t\t\tfirstSpacing = this.spacing[2];\n\t\t\t\tsecondSpacing = this.spacing[1];\n\t\t\t\tIJKIndex = new THREE.Vector3(RASIndex, 0, 0);\n\n\t\t\t\tplaneMatrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI / 2));\n\t\t\t\tpositionOffset = (volume.RASDimensions[0] - 1) / 2;\n\t\t\t\tplaneMatrix.setPosition(new THREE.Vector3(RASIndex - positionOffset, 0, 0));\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\taxisInIJK.set(0, 1, 0);\n\t\t\t\tfirstDirection.set(1, 0, 0);\n\t\t\t\tsecondDirection.set(0, 0, 1);\n\t\t\t\tfirstSpacing = this.spacing[0];\n\t\t\t\tsecondSpacing = this.spacing[2];\n\t\t\t\tIJKIndex = new THREE.Vector3(0, RASIndex, 0);\n\n\t\t\t\tplaneMatrix.multiply(new THREE.Matrix4().makeRotationX(-Math.PI / 2));\n\t\t\t\tpositionOffset = (volume.RASDimensions[1] - 1) / 2;\n\t\t\t\tplaneMatrix.setPosition(new THREE.Vector3(0, RASIndex - positionOffset, 0));\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\tdefault:\n\t\t\t\taxisInIJK.set(0, 0, 1);\n\t\t\t\tfirstDirection.set(1, 0, 0);\n\t\t\t\tsecondDirection.set(0, -1, 0);\n\t\t\t\tfirstSpacing = this.spacing[0];\n\t\t\t\tsecondSpacing = this.spacing[1];\n\t\t\t\tIJKIndex = new THREE.Vector3(0, 0, RASIndex);\n\n\t\t\t\tpositionOffset = (volume.RASDimensions[2] - 1) / 2;\n\t\t\t\tplaneMatrix.setPosition(new THREE.Vector3(0, 0, RASIndex - positionOffset));\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfirstDirection.applyMatrix4(volume.inverseMatrix).normalize();\n\t\tfirstDirection.argVar = 'i';\n\t\tsecondDirection.applyMatrix4(volume.inverseMatrix).normalize();\n\t\tsecondDirection.argVar = 'j';\n\t\taxisInIJK.applyMatrix4(volume.inverseMatrix).normalize();\n\t\tiLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));\n\t\tjLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));\n\t\tplaneWidth = Math.abs(iLength * firstSpacing);\n\t\tplaneHeight = Math.abs(jLength * secondSpacing);\n\n\t\tIJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));\n\t\tvar base = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];\n\t\tvar iDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n\n\t\t\treturn Math.abs(x.dot(base[0])) > 0.9;\n\t\t});\n\t\tvar jDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n\n\t\t\treturn Math.abs(x.dot(base[1])) > 0.9;\n\t\t});\n\t\tvar kDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n\n\t\t\treturn Math.abs(x.dot(base[2])) > 0.9;\n\t\t});\n\t\tvar argumentsWithInversion = ['volume.xLength-1-', 'volume.yLength-1-', 'volume.zLength-1-'];\n\t\t// var arguments = [ 'i', 'j', 'k' ];\n\t\tvar argArray = [iDirection, jDirection, kDirection].map(function (direction, n) {\n\n\t\t\treturn (direction.dot(base[n]) > 0 ? '' : argumentsWithInversion[n]) + (direction === axisInIJK ? 'IJKIndex' : direction.argVar);\n\t\t});\n\t\tvar argString = argArray.join(',');\n\t\tsliceAccess = eval('(function sliceAccess (i,j) {return volume.access( ' + argString + ');})');\n\n\t\treturn {\n\t\t\tiLength: iLength,\n\t\t\tjLength: jLength,\n\t\t\tsliceAccess: sliceAccess,\n\t\t\tmatrix: planeMatrix,\n\t\t\tplaneWidth: planeWidth,\n\t\t\tplaneHeight: planeHeight\n\t\t};\n\t},\n\n\t/**\n  * @member {Function} extractSlice Returns a slice corresponding to the given axis and index\n  *                        The coordinate are given in the Right Anterior Superior coordinate format\n  * @memberof THREE.Volume\n  * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n  * @param {number}            index the index of the slice\n  * @returns {THREE.VolumeSlice} the extracted slice\n  */\n\textractSlice: function extractSlice(axis, index) {\n\n\t\tvar slice = new THREE.VolumeSlice(this, index, axis);\n\t\tthis.sliceList.push(slice);\n\t\treturn slice;\n\t},\n\n\t/**\n  * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume\n  * @see THREE.VolumeSlice.repaint\n  * @memberof THREE.Volume\n  * @returns {THREE.Volume} this\n  */\n\trepaintAllSlices: function repaintAllSlices() {\n\n\t\tthis.sliceList.forEach(function (slice) {\n\n\t\t\tslice.repaint();\n\t\t});\n\n\t\treturn this;\n\t},\n\n\t/**\n  * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume\n  * @memberof THREE.Volume\n  * @returns {Array} [min,max]\n  */\n\tcomputeMinMax: function computeMinMax() {\n\n\t\tvar min = Infinity;\n\t\tvar max = -Infinity;\n\n\t\t// buffer the length\n\t\tvar datasize = this.data.length;\n\n\t\tvar i = 0;\n\t\tfor (i = 0; i < datasize; i++) {\n\n\t\t\tif (!isNaN(this.data[i])) {\n\n\t\t\t\tvar value = this.data[i];\n\t\t\t\tmin = Math.min(min, value);\n\t\t\t\tmax = Math.max(max, value);\n\t\t\t}\n\t\t}\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t\treturn [min, max];\n\t}\n\n};\n\nexports.default = Volume;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nvar LuminosityShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"float l = linearToRelativeLuminance( texel.rgb );\", \"gl_FragColor = vec4( l, l, l, texel.w );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = LuminosityShader;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author miibond\n *\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n */\n\nvar ToneMapShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"averageLuminance\": { value: 1.0 },\n\t\t\"luminanceMap\": { value: null },\n\t\t\"maxLuminance\": { value: 16.0 },\n\t\t\"minLuminance\": { value: 0.01 },\n\t\t\"middleGrey\": { value: 0.6 }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform float middleGrey;\", \"uniform float minLuminance;\", \"uniform float maxLuminance;\", \"#ifdef ADAPTED_LUMINANCE\", \"uniform sampler2D luminanceMap;\", \"#else\", \"uniform float averageLuminance;\", \"#endif\", \"vec3 ToneMap( vec3 vColor ) {\", \"#ifdef ADAPTED_LUMINANCE\",\n\t// Get the calculated average luminance\n\t\"float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\", \"#else\", \"float fLumAvg = averageLuminance;\", \"#endif\",\n\n\t// Calculate the luminance of the current pixel\n\t\"float fLumPixel = linearToRelativeLuminance( vColor );\",\n\n\t// Apply the modified operator (Eq. 4)\n\t\"float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\", \"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\", \"return fLumCompressed * vColor;\", \"}\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ToneMapShader;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nvar ConvolutionShader = {\n\n\tdefines: {\n\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\"KERNEL_SIZE_INT\": \"25\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"uImageIncrement\": { value: new THREE.Vector2(0.001953125, 0.0) },\n\t\t\"cKernel\": { value: [] }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float cKernel[ KERNEL_SIZE_INT ];\", \"uniform sampler2D tDiffuse;\", \"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 imageCoord = vUv;\", \"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\", \"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\", \"imageCoord += uImageIncrement;\", \"}\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\"),\n\n\tbuildKernel: function buildKernel(sigma) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tfunction gauss(x, sigma) {\n\n\t\t\treturn Math.exp(-(x * x) / (2.0 * sigma * sigma));\n\t\t}\n\n\t\tvar i,\n\t\t    values,\n\t\t    sum,\n\t\t    halfWidth,\n\t\t    kMaxKernelSize = 25,\n\t\t    kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n\n\t\tif (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n\t\thalfWidth = (kernelSize - 1) * 0.5;\n\n\t\tvalues = new Array(kernelSize);\n\t\tsum = 0.0;\n\t\tfor (i = 0; i < kernelSize; ++i) {\n\n\t\t\tvalues[i] = gauss(i - halfWidth, sigma);\n\t\t\tsum += values[i];\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor (i = 0; i < kernelSize; ++i) {\n\t\t\tvalues[i] /= sum;\n\t\t}return values;\n\t}\n\n};\n\nexports.default = ConvolutionShader;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n */\n\nvar BokehShader = {\n\n\tdefines: {\n\t\t\"DEPTH_PACKING\": 1,\n\t\t\"PERSPECTIVE_CAMERA\": 1\n\t},\n\n\tuniforms: {\n\n\t\t\"tColor\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"focus\": { value: 1.0 },\n\t\t\"aspect\": { value: 1.0 },\n\t\t\"aperture\": { value: 0.025 },\n\t\t\"maxblur\": { value: 1.0 },\n\t\t\"nearClip\": { value: 1.0 },\n\t\t\"farClip\": { value: 1000.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"varying vec2 vUv;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"uniform float maxblur;\", // max blur amount\n\t\"uniform float aperture;\", // aperture - bigger values for shallower depth of field\n\n\t\"uniform float nearClip;\", \"uniform float farClip;\", \"uniform float focus;\", \"uniform float aspect;\", \"#include <packing>\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\", \"\t#endif\", \"}\", \"void main() {\", \"vec2 aspectcorrect = vec2( 1.0, aspect );\", \"float viewZ = getViewZ( getDepth( vUv ) );\", \"float factor = ( focus + viewZ );\", // viewZ is <= 0, so this is a difference equation\n\n\t\"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\", \"vec2 dofblur9 = dofblur * 0.9;\", \"vec2 dofblur7 = dofblur * 0.7;\", \"vec2 dofblur4 = dofblur * 0.4;\", \"vec4 col = vec4( 0.0 );\", \"col += texture2D( tColor, vUv.xy );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\", \"gl_FragColor = col / 41.0;\", \"gl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BokehShader;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nvar DotScreenShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tSize\": { value: new THREE.Vector2(256, 256) },\n\t\t\"center\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\"angle\": { value: 1.57 },\n\t\t\"scale\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform vec2 center;\", \"uniform float angle;\", \"uniform float scale;\", \"uniform vec2 tSize;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"float pattern() {\", \"float s = sin( angle ), c = cos( angle );\", \"vec2 tex = vUv * tSize - center;\", \"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\", \"return ( sin( point.x ) * sin( point.y ) ) * 4.0;\", \"}\", \"void main() {\", \"vec4 color = texture2D( tDiffuse, vUv );\", \"float average = ( color.r + color.g + color.b ) / 3.0;\", \"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = DotScreenShader;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nvar FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"time\": { value: 0.0 },\n\t\t\"nIntensity\": { value: 0.5 },\n\t\t\"sIntensity\": { value: 0.05 },\n\t\t\"sCount\": { value: 4096 },\n\t\t\"grayscale\": { value: 1 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\",\n\n\t// control parameter\n\t\"uniform float time;\", \"uniform bool grayscale;\",\n\n\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\"uniform float nIntensity;\",\n\n\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\"uniform float sIntensity;\",\n\n\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\"uniform float sCount;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\",\n\n\t// sample the source\n\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t// make some noise\n\t\"float dx = rand( vUv + time );\",\n\n\t// add noise\n\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t// get us a sine and cosine\n\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t// add scanlines\n\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t// interpolate between source and result by intensity\n\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t// convert to grayscale if desired\n\t\"if( grayscale ) {\", \"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\", \"}\", \"gl_FragColor =  vec4( cResult, cTextureScreen.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = FilmShader;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nvar DigitalGlitch = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }, //diffuse texture\n\t\t\"tDisp\": { value: null }, //displacement texture for digital glitch squares\n\t\t\"byp\": { value: 0 }, //apply the glitch ?\n\t\t\"amount\": { value: 0.08 },\n\t\t\"angle\": { value: 0.02 },\n\t\t\"seed\": { value: 0.02 },\n\t\t\"seed_x\": { value: 0.02 }, //-1,1\n\t\t\"seed_y\": { value: 0.02 }, //-1,1\n\t\t\"distortion_x\": { value: 0.5 },\n\t\t\"distortion_y\": { value: 0.6 },\n\t\t\"col_s\": { value: 0.05 }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform int byp;\", //should we apply the glitch ?\n\n\t\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDisp;\", \"uniform float amount;\", \"uniform float angle;\", \"uniform float seed;\", \"uniform float seed_x;\", \"uniform float seed_y;\", \"uniform float distortion_x;\", \"uniform float distortion_y;\", \"uniform float col_s;\", \"varying vec2 vUv;\", \"float rand(vec2 co){\", \"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\", \"}\", \"void main() {\", \"if(byp<1) {\", \"vec2 p = vUv;\", \"float xs = floor(gl_FragCoord.x / 0.5);\", \"float ys = floor(gl_FragCoord.y / 0.5);\",\n\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\"vec4 normal = texture2D (tDisp, p*seed*seed);\", \"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\", \"if(seed_x>0.){\", \"p.y = 1. - (p.y + distortion_y);\", \"}\", \"else {\", \"p.y = distortion_y;\", \"}\", \"}\", \"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\", \"if(seed_y>0.){\", \"p.x=distortion_x;\", \"}\", \"else {\", \"p.x = 1. - (p.x + distortion_x);\", \"}\", \"}\", \"p.x+=normal.x*seed_x*(seed/5.);\", \"p.y+=normal.y*seed_y*(seed/5.);\",\n\t//base from RGB shift shader\n\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\", \"vec4 cr = texture2D(tDiffuse, p + offset);\", \"vec4 cga = texture2D(tDiffuse, p);\", \"vec4 cb = texture2D(tDiffuse, p - offset);\", \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n\t//add noise\n\t\"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\", \"gl_FragColor = gl_FragColor+ snow;\", \"}\", \"else {\", \"gl_FragColor=texture2D (tDiffuse, vUv);\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = DigitalGlitch;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author meatbags / xavierburrow.com, github/meatbags\n *\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\n\nvar HalftoneShader = {\n\n\tuniforms: {\n\t\t\"tDiffuse\": { value: null },\n\t\t\"shape\": { value: 1 },\n\t\t\"radius\": { value: 4 },\n\t\t\"rotateR\": { value: Math.PI / 12 * 1 },\n\t\t\"rotateG\": { value: Math.PI / 12 * 2 },\n\t\t\"rotateB\": { value: Math.PI / 12 * 3 },\n\t\t\"scatter\": { value: 0 },\n\t\t\"width\": { value: 1 },\n\t\t\"height\": { value: 1 },\n\t\t\"blending\": { value: 1 },\n\t\t\"blendingMode\": { value: 1 },\n\t\t\"greyscale\": { value: false },\n\t\t\"disable\": { value: false }\n\t},\n\n\tvertexShader: [\"varying vec2 vUV;\", \"void main() {\", \"vUV = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#define SQRT2_MINUS_ONE 0.41421356\", \"#define SQRT2_HALF_MINUS_ONE 0.20710678\", \"#define PI2 6.28318531\", \"#define SHAPE_DOT 1\", \"#define SHAPE_ELLIPSE 2\", \"#define SHAPE_LINE 3\", \"#define SHAPE_SQUARE 4\", \"#define BLENDING_LINEAR 1\", \"#define BLENDING_MULTIPLY 2\", \"#define BLENDING_ADD 3\", \"#define BLENDING_LIGHTER 4\", \"#define BLENDING_DARKER 5\", \"uniform sampler2D tDiffuse;\", \"uniform float radius;\", \"uniform float rotateR;\", \"uniform float rotateG;\", \"uniform float rotateB;\", \"uniform float scatter;\", \"uniform float width;\", \"uniform float height;\", \"uniform int shape;\", \"uniform bool disable;\", \"uniform float blending;\", \"uniform int blendingMode;\", \"varying vec2 vUV;\", \"uniform bool greyscale;\", \"const int samples = 8;\", \"float blend( float a, float b, float t ) {\",\n\n\t// linear blend\n\t\"return a * ( 1.0 - t ) + b * t;\", \"}\", \"float hypot( float x, float y ) {\",\n\n\t// vector magnitude\n\t\"return sqrt( x * x + y * y );\", \"}\", \"float rand( vec2 seed ){\",\n\n\t// get pseudo-random number\n\t\"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\", \"}\", \"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\",\n\n\t// apply shape-specific transforms\n\t\"float dist = hypot( coord.x - p.x, coord.y - p.y );\", \"float rad = channel;\", \"if ( shape == SHAPE_DOT ) {\", \"rad = pow( abs( rad ), 1.125 ) * rad_max;\", \"} else if ( shape == SHAPE_ELLIPSE ) {\", \"rad = pow( abs( rad ), 1.125 ) * rad_max;\", \"if ( dist != 0.0 ) {\", \"float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\", \"dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\", \"}\", \"} else if ( shape == SHAPE_LINE ) {\", \"rad = pow( abs( rad ), 1.5) * rad_max;\", \"float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\", \"dist = hypot( normal.x * dot_p, normal.y * dot_p );\", \"} else if ( shape == SHAPE_SQUARE ) {\", \"float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\", \"float sin_t = abs( sin( theta ) );\", \"float cos_t = abs( cos( theta ) );\", \"rad = pow( abs( rad ), 1.4 );\", \"rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\", \"}\", \"return rad - dist;\", \"}\", \"struct Cell {\",\n\n\t// grid sample positions\n\t\"vec2 normal;\", \"vec2 p1;\", \"vec2 p2;\", \"vec2 p3;\", \"vec2 p4;\", \"float samp2;\", \"float samp1;\", \"float samp3;\", \"float samp4;\", \"};\", \"vec4 getSample( vec2 point ) {\",\n\n\t// multi-sampled point\n\t\"vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\", \"float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\", \"float step = PI2 / float( samples );\", \"float dist = radius * 0.66;\", \"for ( int i = 0; i < samples; ++i ) {\", \"float r = base + step * float( i );\", \"vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\", \"tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\", \"}\", \"tex /= float( samples ) + 1.0;\", \"return tex;\", \"}\", \"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\",\n\n\t// get colour for given point\n\t\"float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\", \"if ( channel == 0 ) {\", \"c.samp1 = getSample( c.p1 ).r;\", \"c.samp2 = getSample( c.p2 ).r;\", \"c.samp3 = getSample( c.p3 ).r;\", \"c.samp4 = getSample( c.p4 ).r;\", \"} else if (channel == 1) {\", \"c.samp1 = getSample( c.p1 ).g;\", \"c.samp2 = getSample( c.p2 ).g;\", \"c.samp3 = getSample( c.p3 ).g;\", \"c.samp4 = getSample( c.p4 ).g;\", \"} else {\", \"c.samp1 = getSample( c.p1 ).b;\", \"c.samp3 = getSample( c.p3 ).b;\", \"c.samp2 = getSample( c.p2 ).b;\", \"c.samp4 = getSample( c.p4 ).b;\", \"}\", \"dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\", \"dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\", \"dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\", \"dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\", \"res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\", \"res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\", \"res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\", \"res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\", \"res = clamp( res, 0.0, 1.0 );\", \"return res;\", \"}\", \"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\",\n\n\t// get containing cell\n\t\"Cell c;\",\n\n\t// calc grid\n\t\"vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\", \"float threshold = step * 0.5;\", \"float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\", \"float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\", \"vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\", \"float offset_normal = mod( hypot( offset.x, offset.y ), step );\", \"float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\", \"float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\", \"float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\", \"float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\", \"float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\",\n\n\t// get closest corner\n\t\"c.normal = n;\", \"c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\", \"c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\",\n\n\t// scatter\n\t\"if ( scatter != 0.0 ) {\", \"float off_mag = scatter * threshold * 0.5;\", \"float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\", \"c.p1.x += cos( off_angle ) * off_mag;\", \"c.p1.y += sin( off_angle ) * off_mag;\", \"}\",\n\n\t// find corners\n\t\"float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\", \"float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\", \"c.p2.x = c.p1.x - n.x * normal_step;\", \"c.p2.y = c.p1.y - n.y * normal_step;\", \"c.p3.x = c.p1.x + n.y * line_step;\", \"c.p3.y = c.p1.y - n.x * line_step;\", \"c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\", \"c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\", \"return c;\", \"}\", \"float blendColour( float a, float b, float t ) {\",\n\n\t// blend colours\n\t\"if ( blendingMode == BLENDING_LINEAR ) {\", \"return blend( a, b, 1.0 - t );\", \"} else if ( blendingMode == BLENDING_ADD ) {\", \"return blend( a, min( 1.0, a + b ), t );\", \"} else if ( blendingMode == BLENDING_MULTIPLY ) {\", \"return blend( a, max( 0.0, a * b ), t );\", \"} else if ( blendingMode == BLENDING_LIGHTER ) {\", \"return blend( a, max( a, b ), t );\", \"} else if ( blendingMode == BLENDING_DARKER ) {\", \"return blend( a, min( a, b ), t );\", \"} else {\", \"return blend( a, b, 1.0 - t );\", \"}\", \"}\", \"void main() {\", \"if ( ! disable ) {\",\n\n\t// setup\n\t\"vec2 p = vec2( vUV.x * width, vUV.y * height );\", \"vec2 origin = vec2( 0, 0 );\", \"float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\",\n\n\t// get channel samples\n\t\"Cell cell_r = getReferenceCell( p, origin, rotateR, radius );\", \"Cell cell_g = getReferenceCell( p, origin, rotateG, radius );\", \"Cell cell_b = getReferenceCell( p, origin, rotateB, radius );\", \"float r = getDotColour( cell_r, p, 0, rotateR, aa );\", \"float g = getDotColour( cell_g, p, 1, rotateG, aa );\", \"float b = getDotColour( cell_b, p, 2, rotateB, aa );\",\n\n\t// blend with original\n\t\"vec4 colour = texture2D( tDiffuse, vUV );\", \"r = blendColour( r, colour.r, blending );\", \"g = blendColour( g, colour.g, blending );\", \"b = blendColour( b, colour.b, blending );\", \"if ( greyscale ) {\", \"r = g = b = (r + b + g) / 3.0;\", \"}\", \"gl_FragColor = vec4( r, g, b, 1.0 );\", \"} else {\", \"gl_FragColor = texture2D( tDiffuse, vUV );\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HalftoneShader;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar SAOShader = {\n\tdefines: {\n\t\t'NUM_SAMPLES': 7,\n\t\t'NUM_RINGS': 4,\n\t\t'NORMAL_TEXTURE': 0,\n\t\t'DIFFUSE_TEXTURE': 0,\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\tuniforms: {\n\n\t\t'tDepth': { type: 't', value: null },\n\t\t'tDiffuse': { type: 't', value: null },\n\t\t'tNormal': { type: 't', value: null },\n\t\t'size': { type: 'v2', value: new THREE.Vector2(512, 512) },\n\n\t\t'cameraNear': { type: 'f', value: 1 },\n\t\t'cameraFar': { type: 'f', value: 100 },\n\t\t'cameraProjectionMatrix': { type: 'm4', value: new THREE.Matrix4() },\n\t\t'cameraInverseProjectionMatrix': { type: 'm4', value: new THREE.Matrix4() },\n\n\t\t'scale': { type: 'f', value: 1.0 },\n\t\t'intensity': { type: 'f', value: 0.1 },\n\t\t'bias': { type: 'f', value: 0.5 },\n\n\t\t'minResolution': { type: 'f', value: 0.0 },\n\t\t'kernelRadius': { type: 'f', value: 100.0 },\n\t\t'randomSeed': { type: 'f', value: 0.0 }\n\t},\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\tfragmentShader: [\"#include <common>\", \"varying vec2 vUv;\", \"#if DIFFUSE_TEXTURE == 1\", \"uniform sampler2D tDiffuse;\", \"#endif\", \"uniform sampler2D tDepth;\", \"#if NORMAL_TEXTURE == 1\", \"uniform sampler2D tNormal;\", \"#endif\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform mat4 cameraProjectionMatrix;\", \"uniform mat4 cameraInverseProjectionMatrix;\", \"uniform float scale;\", \"uniform float intensity;\", \"uniform float bias;\", \"uniform float kernelRadius;\", \"uniform float minResolution;\", \"uniform vec2 size;\", \"uniform float randomSeed;\", \"// RGBA depth\", \"#include <packing>\", \"vec4 getDefaultColor( const in vec2 screenPosition ) {\", \"\t#if DIFFUSE_TEXTURE == 1\", \"\treturn texture2D( tDiffuse, vUv );\", \"\t#else\", \"\treturn vec4( 1.0 );\", \"\t#endif\", \"}\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\", \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\", \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\", \"\tclipPosition *= clipW; // unprojection.\", \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\", \"}\", \"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\", \"\t#if NORMAL_TEXTURE == 1\", \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\", \"\t#else\", \"\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\", \"\t#endif\", \"}\", \"float scaleDividedByCameraFar;\", \"float minResolutionMultipliedByCameraFar;\", \"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\", \"\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\", \"\tfloat viewDistance = length( viewDelta );\", \"\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\", \"\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\", \"}\", \"// moving costly divides into consts\", \"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\", \"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\", \"float getAmbientOcclusion( const in vec3 centerViewPosition ) {\", \"\t// precompute some variables require in getOcclusion.\", \"\tscaleDividedByCameraFar = scale / cameraFar;\", \"\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\", \"\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\", \"\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\", \"\tfloat angle = rand( vUv + randomSeed ) * PI2;\", \"\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\", \"\tvec2 radiusStep = radius;\", \"\tfloat occlusionSum = 0.0;\", \"\tfloat weightSum = 0.0;\", \"\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\", \"\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\", \"\t\tradius += radiusStep;\", \"\t\tangle += ANGLE_STEP;\", \"\t\tfloat sampleDepth = getDepth( sampleUv );\", \"\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\", \"\t\t\tcontinue;\", \"\t\t}\", \"\t\tfloat sampleViewZ = getViewZ( sampleDepth );\", \"\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\", \"\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\", \"\t\tweightSum += 1.0;\", \"\t}\", \"\tif( weightSum == 0.0 ) discard;\", \"\treturn occlusionSum * ( intensity / weightSum );\", \"}\", \"void main() {\", \"\tfloat centerDepth = getDepth( vUv );\", \"\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = getViewZ( centerDepth );\", \"\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\", \"\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\", \"\tgl_FragColor = getDefaultColor( vUv );\", \"\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\", \"}\"].join(\"\\n\")\n};\n\nexports.default = SAOShader;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar DepthLimitedBlurShader = {\n\tdefines: {\n\t\t'KERNEL_RADIUS': 4,\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\tuniforms: {\n\t\t'tDiffuse': { type: 't', value: null },\n\t\t'size': { type: 'v2', value: new THREE.Vector2(512, 512) },\n\t\t'sampleUvOffsets': { type: 'v2v', value: [new THREE.Vector2(0, 0)] },\n\t\t'sampleWeights': { type: '1fv', value: [1.0] },\n\t\t'tDepth': { type: 't', value: null },\n\t\t'cameraNear': { type: 'f', value: 10 },\n\t\t'cameraFar': { type: 'f', value: 1000 },\n\t\t'depthCutoff': { type: 'f', value: 10 }\n\t},\n\tvertexShader: [\"#include <common>\", \"uniform vec2 size;\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"void main() {\", \"\tvUv = uv;\", \"\tvInvSize = 1.0 / size;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\tfragmentShader: [\"#include <common>\", \"#include <packing>\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform float depthCutoff;\", \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\", \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tif( depth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = -getViewZ( depth );\", \"\tbool rBreak = false, lBreak = false;\", \"\tfloat weightSum = sampleWeights[0];\", \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\", \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\", \"\t\tfloat sampleWeight = sampleWeights[i];\", \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\", \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\", \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\", \"\t\tif( ! rBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t\tsampleUv = vUv - sampleUvOffset;\", \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\", \"\t\tif( ! lBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = diffuseSum / weightSum;\", \"}\"].join(\"\\n\")\n};\n\nexports.default = DepthLimitedBlurShader;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nvar UnpackDepthRGBAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"#include <packing>\", \"void main() {\", \"float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\", \"gl_FragColor = vec4( vec3( depth ), opacity );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = UnpackDepthRGBAShader;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BlurShaderUtils = {\n\n  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {\n\n    var gaussian = function gaussian(x, stdDev) {\n\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n\n    var weights = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n\n  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {\n\n    var offsets = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n\n  configure: function configure(material, kernelRadius, stdDev, uvIncrement) {\n\n    material.defines['KERNEL_RADIUS'] = kernelRadius;\n    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    material.needsUpdate = true;\n  }\n\n};\n\nexports.default = BlurShaderUtils;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mpk / http://polko.me/\n *\n * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8\n * Preset: SMAA 1x Medium (with color edge detection)\n * https://github.com/iryoku/smaa/releases/tag/v2.8\n */\n\nvar SMAAShader = [{\n\n\tdefines: {\n\n\t\t\"SMAA_THRESHOLD\": \"0.1\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 3 ];\", \"void SMAAEdgeDetectionVS( vec2 texcoord ) {\", \"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\", // WebGL port note: Changed sign in W component\n\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\", // WebGL port note: Changed sign in W component\n\t\"vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\", // WebGL port note: Changed sign in W component\n\t\"}\", \"void main() {\", \"vUv = uv;\", \"SMAAEdgeDetectionVS( vUv );\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 3 ];\", \"vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\", \"vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\",\n\n\t// Calculate color deltas:\n\t\"vec4 delta;\", \"vec3 C = texture2D( colorTex, texcoord ).rgb;\", \"vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\", \"vec3 t = abs( C - Cleft );\", \"delta.x = max( max( t.r, t.g ), t.b );\", \"vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\", \"t = abs( C - Ctop );\", \"delta.y = max( max( t.r, t.g ), t.b );\",\n\n\t// We do the usual threshold:\n\t\"vec2 edges = step( threshold, delta.xy );\",\n\n\t// Then discard if there is no edge:\n\t\"if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\", \"discard;\",\n\n\t// Calculate right and bottom deltas:\n\t\"vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\", \"t = abs( C - Cright );\", \"delta.z = max( max( t.r, t.g ), t.b );\", \"vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\", \"t = abs( C - Cbottom );\", \"delta.w = max( max( t.r, t.g ), t.b );\",\n\n\t// Calculate the maximum delta in the direct neighborhood:\n\t\"float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\",\n\n\t// Calculate left-left and top-top deltas:\n\t\"vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\", \"t = abs( C - Cleftleft );\", \"delta.z = max( max( t.r, t.g ), t.b );\", \"vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\", \"t = abs( C - Ctoptop );\", \"delta.w = max( max( t.r, t.g ), t.b );\",\n\n\t// Calculate the final maximum delta:\n\t\"maxDelta = max( max( maxDelta, delta.z ), delta.w );\",\n\n\t// Local contrast adaptation in action:\n\t\"edges.xy *= step( 0.5 * maxDelta, delta.xy );\", \"return vec4( edges, 0.0, 0.0 );\", \"}\", \"void main() {\", \"gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\", \"}\"].join(\"\\n\")\n\n}, {\n\n\tdefines: {\n\n\t\t\"SMAA_MAX_SEARCH_STEPS\": \"8\",\n\t\t\"SMAA_AREATEX_MAX_DISTANCE\": \"16\",\n\t\t\"SMAA_AREATEX_PIXEL_SIZE\": \"( 1.0 / vec2( 160.0, 560.0 ) )\",\n\t\t\"SMAA_AREATEX_SUBTEX_SIZE\": \"( 1.0 / 7.0 )\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tArea\": { value: null },\n\t\t\"tSearch\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 3 ];\", \"varying vec2 vPixcoord;\", \"void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\", \"vPixcoord = texcoord / resolution;\",\n\n\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\", // WebGL port note: Changed sign in Y and W components\n\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\", // WebGL port note: Changed sign in Y and W components\n\n\t// And these for the searches, they indicate the ends of the loops:\n\t\"vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\", \"}\", \"void main() {\", \"vUv = uv;\", \"SMAABlendingWeightCalculationVS( vUv );\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tArea;\", \"uniform sampler2D tSearch;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[3];\", \"varying vec2 vPixcoord;\", \"vec2 round( vec2 x ) {\", \"return sign( x ) * floor( abs( x ) + 0.5 );\", \"}\", \"float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\",\n\t// Not required if searchTex accesses are set to point:\n\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\"e.r = bias + e.r * scale;\", \"return 255.0 * texture2D( searchTex, e, 0.0 ).r;\", \"}\", \"float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\",\n\t/**\n * @PSEUDO_GATHER4\n * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n * sample between edge, thus fetching four edges in a row.\n * Sampling with different offsets in each direction allows to disambiguate\n * which edges are active from the four fetched ones.\n */\n\t\"vec2 e = vec2( 0.0, 1.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord -= vec2( 2.0, 0.0 ) * resolution;\", \"if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\", \"}\",\n\n\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\"texcoord.x += 0.25 * resolution.x;\",\n\n\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\"texcoord.x += resolution.x;\",\n\n\t// Disambiguate the length added by the last step:\n\t\"texcoord.x += 2.0 * resolution.x;\", // Undo last step\n\t\"texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\", \"return texcoord.x;\", \"}\", \"float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\", \"vec2 e = vec2( 0.0, 1.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord += vec2( 2.0, 0.0 ) * resolution;\", \"if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\", \"}\", \"texcoord.x -= 0.25 * resolution.x;\", \"texcoord.x -= resolution.x;\", \"texcoord.x -= 2.0 * resolution.x;\", \"texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\", \"return texcoord.x;\", \"}\", \"float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\", \"vec2 e = vec2( 1.0, 0.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord += vec2( 0.0, 2.0 ) * resolution;\", // WebGL port note: Changed sign\n\t\"if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\", \"}\", \"texcoord.y -= 0.25 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y -= resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y -= 2.0 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\", // WebGL port note: Changed sign\n\n\t\"return texcoord.y;\", \"}\", \"float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\", \"vec2 e = vec2( 1.0, 0.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord -= vec2( 0.0, 2.0 ) * resolution;\", // WebGL port note: Changed sign\n\t\"if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\", \"}\", \"texcoord.y += 0.25 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y += resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y += 2.0 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\", // WebGL port note: Changed sign\n\n\t\"return texcoord.y;\", \"}\", \"vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\",\n\t// Rounding prevents precision errors of bilinear filtering:\n\t\"vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\",\n\n\t// We do a scale and bias for mapping to texel space:\n\t\"texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\",\n\n\t// Move to proper place, according to the subpixel offset:\n\t\"texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\", \"return texture2D( areaTex, texcoord, 0.0 ).rg;\", \"}\", \"vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\", \"vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"vec2 e = texture2D( edgesTex, texcoord ).rg;\", \"if ( e.g > 0.0 ) {\", // Edge at north\n\t\"vec2 d;\",\n\n\t// Find the distance to the left:\n\t\"vec2 coords;\", \"coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\", \"coords.y = offset[ 1 ].y;\", // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\"d.x = coords.x;\",\n\n\t// Now fetch the left crossing edges, two at a time using bilinear\n\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t// discern what value each edge has:\n\t\"float e1 = texture2D( edgesTex, coords, 0.0 ).r;\",\n\n\t// Find the distance to the right:\n\t\"coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\", \"d.y = coords.x;\",\n\n\t// We want the distances to be in pixel units (doing this here allow to\n\t// better interleave arithmetic and memory accesses):\n\t\"d = d / resolution.x - pixcoord.x;\",\n\n\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t// quadratically:\n\t\"vec2 sqrt_d = sqrt( abs( d ) );\",\n\n\t// Fetch the right crossing edges:\n\t\"coords.y -= 1.0 * resolution.y;\", // WebGL port note: Added\n\t\"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\",\n\n\t// Ok, we know how this pattern looks like, now it is time for getting\n\t// the actual area:\n\t\"weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\", \"}\", \"if ( e.r > 0.0 ) {\", // Edge at west\n\t\"vec2 d;\",\n\n\t// Find the distance to the top:\n\t\"vec2 coords;\", \"coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\", \"coords.x = offset[ 0 ].x;\", // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\"d.x = coords.y;\",\n\n\t// Fetch the top crossing edges:\n\t\"float e1 = texture2D( edgesTex, coords, 0.0 ).g;\",\n\n\t// Find the distance to the bottom:\n\t\"coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\", \"d.y = coords.y;\",\n\n\t// We want the distances to be in pixel units:\n\t\"d = d / resolution.y - pixcoord.y;\",\n\n\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t// quadratically:\n\t\"vec2 sqrt_d = sqrt( abs( d ) );\",\n\n\t// Fetch the bottom crossing edges:\n\t\"coords.y -= 1.0 * resolution.y;\", // WebGL port note: Added\n\t\"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\",\n\n\t// Get the area for this direction:\n\t\"weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\", \"}\", \"return weights;\", \"}\", \"void main() {\", \"gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\", \"}\"].join(\"\\n\")\n\n}, {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tColor\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 2 ];\", \"void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\", \"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\", // WebGL port note: Changed sign in W component\n\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\", // WebGL port note: Changed sign in W component\n\t\"}\", \"void main() {\", \"vUv = uv;\", \"SMAANeighborhoodBlendingVS( vUv );\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tColor;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 2 ];\", \"vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\",\n\t// Fetch the blending weights for current pixel:\n\t\"vec4 a;\", \"a.xz = texture2D( blendTex, texcoord ).xz;\", \"a.y = texture2D( blendTex, offset[ 1 ].zw ).g;\", \"a.w = texture2D( blendTex, offset[ 1 ].xy ).a;\",\n\n\t// Is there any blending weight with a value greater than 0.0?\n\t\"if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\", \"return texture2D( colorTex, texcoord, 0.0 );\", \"} else {\",\n\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t// favor blending by choosing the line with the maximum weight for each\n\t// direction:\n\t\"vec2 offset;\", \"offset.x = a.a > a.b ? a.a : -a.b;\", // left vs. right\n\t\"offset.y = a.g > a.r ? -a.g : a.r;\", // top vs. bottom // WebGL port note: Changed signs\n\n\t// Then we go in the direction that has the maximum weight:\n\t\"if ( abs( offset.x ) > abs( offset.y )) {\", // horizontal vs. vertical\n\t\"offset.y = 0.0;\", \"} else {\", \"offset.x = 0.0;\", \"}\",\n\n\t// Fetch the opposite color and lerp by hand:\n\t\"vec4 C = texture2D( colorTex, texcoord, 0.0 );\", \"texcoord += sign( offset ) * resolution;\", \"vec4 Cop = texture2D( colorTex, texcoord, 0.0 );\", \"float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\",\n\n\t// WebGL port note: Added gamma correction\n\t\"C.xyz = pow(C.xyz, vec3(2.2));\", \"Cop.xyz = pow(Cop.xyz, vec3(2.2));\", \"vec4 mixed = mix(C, Cop, s);\", \"mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\", \"return mixed;\", \"}\", \"}\", \"void main() {\", \"gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\", \"}\"].join(\"\\n\")\n\n}];\n\nexports.default = SMAAShader;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n*\n* Supersample Anti-Aliasing Render Pass\n*\n* @author bhouston / http://clara.io/\n*\n* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n*\n* References: https://en.wikipedia.org/wiki/Supersampling\n*\n*/\n\nvar SSAARenderPass = function SSAARenderPass(scene, camera, clearColor, clearAlpha) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\tthis.unbiased = true;\n\n\t// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\tthis.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.SSAARenderPass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\n\tthis.copyMaterial = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tpremultipliedAlpha: true,\n\t\ttransparent: true,\n\t\tblending: THREE.AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\t});\n\n\tthis.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene2 = new THREE.Scene();\n\tthis.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.copyMaterial);\n\tthis.quad2.frustumCulled = false; // Avoid getting clipped\n\tthis.scene2.add(this.quad2);\n};\n\nSSAARenderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: SSAARenderPass,\n\n\tdispose: function dispose() {\n\n\t\tif (this.sampleRenderTarget) {\n\n\t\t\tthis.sampleRenderTarget.dispose();\n\t\t\tthis.sampleRenderTarget = null;\n\t\t}\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tif (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n\t},\n\n\trender: function render(renderer, writeBuffer, readBuffer) {\n\n\t\tif (!this.sampleRenderTarget) {\n\n\t\t\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });\n\t\t\tthis.sampleRenderTarget.texture.name = \"SSAARenderPass.sample\";\n\t\t}\n\n\t\tvar jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n\n\t\tvar autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tvar oldClearColor = renderer.getClearColor().getHex();\n\t\tvar oldClearAlpha = renderer.getClearAlpha();\n\n\t\tvar baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\tvar roundingRange = 1 / 32;\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n\n\t\tvar width = readBuffer.width,\n\t\t    height = readBuffer.height;\n\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\tfor (var i = 0; i < jitterOffsets.length; i++) {\n\n\t\t\tvar jitterOffset = jitterOffsets[i];\n\n\t\t\tif (this.camera.setViewOffset) {\n\n\t\t\t\tthis.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\twidth, height);\n\t\t\t}\n\n\t\t\tvar sampleWeight = baseSampleWeight;\n\n\t\t\tif (this.unbiased) {\n\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\tvar uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n\t\t\t\tsampleWeight += roundingRange * uniformCenteredDistribution;\n\t\t\t}\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = sampleWeight;\n\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\trenderer.render(this.scene, this.camera, this.sampleRenderTarget, true);\n\n\t\t\tif (i === 0) {\n\n\t\t\t\trenderer.setClearColor(0x000000, 0.0);\n\t\t\t}\n\n\t\t\trenderer.render(this.scene2, this.camera2, this.renderToScreen ? null : writeBuffer, i === 0);\n\t\t}\n\n\t\tif (this.camera.clearViewOffset) this.camera.clearViewOffset();\n\n\t\trenderer.autoClear = autoClear;\n\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t}\n\n});\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\n\nexports.default = SSAARenderPass;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Screen-space ambient occlusion shader\n * - ported from\n *   SSAO GLSL shader v1.2\n *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\n *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n * - modifications\n * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\n * - refactoring and optimizations\n */\n\nvar SSAOShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"size\": { value: new THREE.Vector2(512, 512) },\n\t\t\"cameraNear\": { value: 1 },\n\t\t\"cameraFar\": { value: 100 },\n\t\t\"radius\": { value: 32 },\n\t\t\"onlyAO\": { value: 0 },\n\t\t\"aoClamp\": { value: 0.25 },\n\t\t\"lumInfluence\": { value: 0.7 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float cameraNear;\", \"uniform float cameraFar;\", \"#ifdef USE_LOGDEPTHBUF\", \"uniform float logDepthBufFC;\", \"#endif\", \"uniform float radius;\", // ao radius\n\t\"uniform bool onlyAO;\", // use only ambient occlusion pass?\n\n\t\"uniform vec2 size;\", // texture width, height\n\t\"uniform float aoClamp;\", // depth clamp - reduces haloing at screen edges\n\n\t\"uniform float lumInfluence;\", // how much luminance affects occlusion\n\n\t\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"varying vec2 vUv;\",\n\n\t// \"#define PI 3.14159265\",\n\t\"#define DL 2.399963229728653\", // PI * ( 3.0 - sqrt( 5.0 ) )\n\t\"#define EULER 2.718281828459045\",\n\n\t// user variables\n\n\t\"const int samples = 64;\", // ao sample count\n\n\t\"const bool useNoise = true;\", // use noise instead of pattern for sample dithering\n\t\"const float noiseAmount = 0.0004;\", // dithering amount\n\n\t\"const float diffArea = 0.4;\", // self-shadowing reduction\n\t\"const float gDisplace = 0.4;\", // gauss bell center\n\n\n\t// RGBA depth\n\n\t\"#include <packing>\",\n\n\t// generating noise / pattern texture for dithering\n\n\t\"vec2 rand( const vec2 coord ) {\", \"vec2 noise;\", \"if ( useNoise ) {\", \"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\", \"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\", \"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\", \"} else {\", \"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\", \"float gg = fract( coord.t * ( size.y / 2.0 ) );\", \"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\", \"}\", \"return ( noise * 2.0  - 1.0 ) * noiseAmount;\", \"}\", \"float readDepth( const in vec2 coord ) {\", \"float cameraFarPlusNear = cameraFar + cameraNear;\", \"float cameraFarMinusNear = cameraFar - cameraNear;\", \"float cameraCoef = 2.0 * cameraNear;\", \"#ifdef USE_LOGDEPTHBUF\", \"float logz = unpackRGBAToDepth( texture2D( tDepth, coord ) );\", \"float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\", \"float z = (logz / w) + 1.0;\", \"#else\", \"float z = unpackRGBAToDepth( texture2D( tDepth, coord ) );\", \"#endif\", \"return cameraCoef / ( cameraFarPlusNear - z * cameraFarMinusNear );\", \"}\", \"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\", \"float garea = 8.0;\", // gauss bell width\n\t\"float diff = ( depth1 - depth2 ) * 100.0;\", // depth difference (0-100)\n\n\t// reduce left bell width to avoid self-shadowing\n\n\t\"if ( diff < gDisplace ) {\", \"garea = diffArea;\", \"} else {\", \"far = 1;\", \"}\", \"float dd = diff - gDisplace;\", \"float gauss = pow( EULER, -2.0 * ( dd * dd ) / ( garea * garea ) );\", \"return gauss;\", \"}\", \"float calcAO( float depth, float dw, float dh ) {\", \"vec2 vv = vec2( dw, dh );\", \"vec2 coord1 = vUv + radius * vv;\", \"vec2 coord2 = vUv - radius * vv;\", \"float temp1 = 0.0;\", \"float temp2 = 0.0;\", \"int far = 0;\", \"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\n\n\t// DEPTH EXTRAPOLATION\n\n\t\"if ( far > 0 ) {\", \"temp2 = compareDepths( readDepth( coord2 ), depth, far );\", \"temp1 += ( 1.0 - temp1 ) * temp2;\", \"}\", \"return temp1;\", \"}\", \"void main() {\", \"vec2 noise = rand( vUv );\", \"float depth = readDepth( vUv );\", \"float tt = clamp( depth, aoClamp, 1.0 );\", \"float w = ( 1.0 / size.x ) / tt + ( noise.x * ( 1.0 - noise.x ) );\", \"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );\", \"float ao = 0.0;\", \"float dz = 1.0 / float( samples );\", \"float l = 0.0;\", \"float z = 1.0 - dz / 2.0;\", \"for ( int i = 0; i <= samples; i ++ ) {\", \"float r = sqrt( 1.0 - z );\", \"float pw = cos( l ) * r;\", \"float ph = sin( l ) * r;\", \"ao += calcAO( depth, pw * w, ph * h );\", \"z = z - dz;\", \"l = l + DL;\", \"}\", \"ao /= float( samples );\", \"ao = 1.0 - ao;\", \"vec3 color = texture2D( tDiffuse, vUv ).rgb;\", \"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\", \"float lum = dot( color.rgb, lumcoeff );\", \"vec3 luminance = vec3( lum );\", \"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // mix( color * ao, white, luminance )\n\n\t\"if ( onlyAO ) {\", \"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // ambient occlusion only\n\n\t\"}\", \"gl_FragColor = vec4( final, 1.0 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = SSAOShader;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author bhouston / http://clara.io/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nvar LuminosityHighPassShader = {\n\n\tshaderID: \"luminosityHighPass\",\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"luminosityThreshold\": { type: \"f\", value: 1.0 },\n\t\t\"smoothWidth\": { type: \"f\", value: 1.0 },\n\t\t\"defaultColor\": { type: \"c\", value: new THREE.Color(0x000000) },\n\t\t\"defaultOpacity\": { type: \"f\", value: 0.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 defaultColor;\", \"uniform float defaultOpacity;\", \"uniform float luminosityThreshold;\", \"uniform float smoothWidth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\", \"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\", \"gl_FragColor = mix( outputColor, texel, alpha );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = LuminosityHighPassShader;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _controls = __webpack_require__(28);\n\nObject.keys(_controls).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _controls[key];\n    }\n  });\n});\n\nvar _exporters = __webpack_require__(40);\n\nObject.keys(_exporters).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _exporters[key];\n    }\n  });\n});\n\nvar _loaders = __webpack_require__(48);\n\nObject.keys(_loaders).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _loaders[key];\n    }\n  });\n});\n\nvar _postprocessing = __webpack_require__(90);\n\nObject.keys(_postprocessing).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _postprocessing[key];\n    }\n  });\n});\n\nvar _shaders = __webpack_require__(112);\n\nObject.keys(_shaders).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _shaders[key];\n    }\n  });\n});\n\nvar _uncategories = __webpack_require__(144);\n\nObject.keys(_uncategories).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _uncategories[key];\n    }\n  });\n});\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VRControls = exports.TransformControls = exports.TrackballControls = exports.PointerLockControls = exports.OrthographicTrackballControls = exports.OrbitControls = exports.FlyControls = exports.FirstPersonControls = exports.EditorControls = exports.DragControls = exports.DeviceOrientationControls = undefined;\n\nvar _DeviceOrientationControls = __webpack_require__(29);\n\nvar _DeviceOrientationControls2 = _interopRequireDefault(_DeviceOrientationControls);\n\nvar _DragControls = __webpack_require__(30);\n\nvar _DragControls2 = _interopRequireDefault(_DragControls);\n\nvar _EditorControls = __webpack_require__(31);\n\nvar _EditorControls2 = _interopRequireDefault(_EditorControls);\n\nvar _FirstPersonControls = __webpack_require__(32);\n\nvar _FirstPersonControls2 = _interopRequireDefault(_FirstPersonControls);\n\nvar _FlyControls = __webpack_require__(33);\n\nvar _FlyControls2 = _interopRequireDefault(_FlyControls);\n\nvar _OrbitControls = __webpack_require__(34);\n\nvar _OrbitControls2 = _interopRequireDefault(_OrbitControls);\n\nvar _OrthographicTrackballControls = __webpack_require__(35);\n\nvar _OrthographicTrackballControls2 = _interopRequireDefault(_OrthographicTrackballControls);\n\nvar _PointerLockControls = __webpack_require__(36);\n\nvar _PointerLockControls2 = _interopRequireDefault(_PointerLockControls);\n\nvar _TrackballControls = __webpack_require__(37);\n\nvar _TrackballControls2 = _interopRequireDefault(_TrackballControls);\n\nvar _TransformControls = __webpack_require__(38);\n\nvar _TransformControls2 = _interopRequireDefault(_TransformControls);\n\nvar _VRControls = __webpack_require__(39);\n\nvar _VRControls2 = _interopRequireDefault(_VRControls);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.DeviceOrientationControls = _DeviceOrientationControls2.default;\nexports.DragControls = _DragControls2.default;\nexports.EditorControls = _EditorControls2.default;\nexports.FirstPersonControls = _FirstPersonControls2.default;\nexports.FlyControls = _FlyControls2.default;\nexports.OrbitControls = _OrbitControls2.default;\nexports.OrthographicTrackballControls = _OrthographicTrackballControls2.default;\nexports.PointerLockControls = _PointerLockControls2.default;\nexports.TrackballControls = _TrackballControls2.default;\nexports.TransformControls = _TransformControls2.default;\nexports.VRControls = _VRControls2.default;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author richt / http://richt.me\n * @author WestLangley / http://github.com/WestLangley\n *\n * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\n */\n\nvar DeviceOrientationControls = function DeviceOrientationControls(object) {\n\n\tvar scope = this;\n\n\tthis.object = object;\n\tthis.object.rotation.reorder('YXZ');\n\n\tthis.enabled = true;\n\n\tthis.deviceOrientation = {};\n\tthis.screenOrientation = 0;\n\n\tthis.alphaOffset = 0; // radians\n\n\tvar onDeviceOrientationChangeEvent = function onDeviceOrientationChangeEvent(event) {\n\n\t\tscope.deviceOrientation = event;\n\t};\n\n\tvar onScreenOrientationChangeEvent = function onScreenOrientationChangeEvent() {\n\n\t\tscope.screenOrientation = window.orientation || 0;\n\t};\n\n\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\n\n\tvar setObjectQuaternion = function () {\n\n\t\tvar zee = new THREE.Vector3(0, 0, 1);\n\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar q0 = new THREE.Quaternion();\n\n\t\tvar q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis\n\n\t\treturn function (quaternion, alpha, beta, gamma, orient) {\n\n\t\t\teuler.set(beta, alpha, -gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us\n\n\t\t\tquaternion.setFromEuler(euler); // orient the device\n\n\t\t\tquaternion.multiply(q1); // camera looks out the back of the device, not the top\n\n\t\t\tquaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation\n\t\t};\n\t}();\n\n\tthis.connect = function () {\n\n\t\tonScreenOrientationChangeEvent(); // run once on load\n\n\t\twindow.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);\n\t\twindow.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);\n\n\t\tscope.enabled = true;\n\t};\n\n\tthis.disconnect = function () {\n\n\t\twindow.removeEventListener('orientationchange', onScreenOrientationChangeEvent, false);\n\t\twindow.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);\n\n\t\tscope.enabled = false;\n\t};\n\n\tthis.update = function () {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tvar device = scope.deviceOrientation;\n\n\t\tif (device) {\n\n\t\t\tvar alpha = device.alpha ? THREE.Math.degToRad(device.alpha) + scope.alphaOffset : 0; // Z\n\n\t\t\tvar beta = device.beta ? THREE.Math.degToRad(device.beta) : 0; // X'\n\n\t\t\tvar gamma = device.gamma ? THREE.Math.degToRad(device.gamma) : 0; // Y''\n\n\t\t\tvar orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0; // O\n\n\t\t\tsetObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);\n\t\t}\n\t};\n\n\tthis.dispose = function () {\n\n\t\tscope.disconnect();\n\t};\n\n\tthis.connect();\n};\n\nexports.default = DeviceOrientationControls;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author zz85 / https://github.com/zz85\n * @author mrdoob / http://mrdoob.com\n * Running this will allow you to drag three.js objects around the screen.\n */\n\nvar DragControls = function DragControls(_objects, _camera, _domElement) {\n\n\tif (_objects instanceof THREE.Camera) {\n\n\t\tconsole.warn('THREE.DragControls: Constructor now expects ( objects, camera, domElement )');\n\t\tvar temp = _objects;_objects = _camera;_camera = temp;\n\t}\n\n\tvar _plane = new THREE.Plane();\n\tvar _raycaster = new THREE.Raycaster();\n\n\tvar _mouse = new THREE.Vector2();\n\tvar _offset = new THREE.Vector3();\n\tvar _intersection = new THREE.Vector3();\n\n\tvar _selected = null,\n\t    _hovered = null;\n\n\t//\n\n\tvar scope = this;\n\n\tfunction activate() {\n\n\t\t_domElement.addEventListener('mousemove', onDocumentMouseMove, false);\n\t\t_domElement.addEventListener('mousedown', onDocumentMouseDown, false);\n\t\t_domElement.addEventListener('mouseup', onDocumentMouseCancel, false);\n\t\t_domElement.addEventListener('mouseleave', onDocumentMouseCancel, false);\n\t\t_domElement.addEventListener('touchmove', onDocumentTouchMove, false);\n\t\t_domElement.addEventListener('touchstart', onDocumentTouchStart, false);\n\t\t_domElement.addEventListener('touchend', onDocumentTouchEnd, false);\n\t}\n\n\tfunction deactivate() {\n\n\t\t_domElement.removeEventListener('mousemove', onDocumentMouseMove, false);\n\t\t_domElement.removeEventListener('mousedown', onDocumentMouseDown, false);\n\t\t_domElement.removeEventListener('mouseup', onDocumentMouseCancel, false);\n\t\t_domElement.removeEventListener('mouseleave', onDocumentMouseCancel, false);\n\t\t_domElement.removeEventListener('touchmove', onDocumentTouchMove, false);\n\t\t_domElement.removeEventListener('touchstart', onDocumentTouchStart, false);\n\t\t_domElement.removeEventListener('touchend', onDocumentTouchEnd, false);\n\t}\n\n\tfunction dispose() {\n\n\t\tdeactivate();\n\t}\n\n\tfunction onDocumentMouseMove(event) {\n\n\t\tevent.preventDefault();\n\n\t\tvar rect = _domElement.getBoundingClientRect();\n\n\t\t_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n\t\t_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tif (_selected && scope.enabled) {\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_selected.position.copy(_intersection.sub(_offset));\n\t\t\t}\n\n\t\t\tscope.dispatchEvent({ type: 'drag', object: _selected });\n\n\t\t\treturn;\n\t\t}\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tvar intersects = _raycaster.intersectObjects(_objects);\n\n\t\tif (intersects.length > 0) {\n\n\t\t\tvar object = intersects[0].object;\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), object.position);\n\n\t\t\tif (_hovered !== object) {\n\n\t\t\t\tscope.dispatchEvent({ type: 'hoveron', object: object });\n\n\t\t\t\t_domElement.style.cursor = 'pointer';\n\t\t\t\t_hovered = object;\n\t\t\t}\n\t\t} else {\n\n\t\t\tif (_hovered !== null) {\n\n\t\t\t\tscope.dispatchEvent({ type: 'hoveroff', object: _hovered });\n\n\t\t\t\t_domElement.style.cursor = 'auto';\n\t\t\t\t_hovered = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onDocumentMouseDown(event) {\n\n\t\tevent.preventDefault();\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tvar intersects = _raycaster.intersectObjects(_objects);\n\n\t\tif (intersects.length > 0) {\n\n\t\t\t_selected = intersects[0].object;\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_offset.copy(_intersection).sub(_selected.position);\n\t\t\t}\n\n\t\t\t_domElement.style.cursor = 'move';\n\n\t\t\tscope.dispatchEvent({ type: 'dragstart', object: _selected });\n\t\t}\n\t}\n\n\tfunction onDocumentMouseCancel(event) {\n\n\t\tevent.preventDefault();\n\n\t\tif (_selected) {\n\n\t\t\tscope.dispatchEvent({ type: 'dragend', object: _selected });\n\n\t\t\t_selected = null;\n\t\t}\n\n\t\t_domElement.style.cursor = 'auto';\n\t}\n\n\tfunction onDocumentTouchMove(event) {\n\n\t\tevent.preventDefault();\n\t\tevent = event.changedTouches[0];\n\n\t\tvar rect = _domElement.getBoundingClientRect();\n\n\t\t_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n\t\t_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tif (_selected && scope.enabled) {\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_selected.position.copy(_intersection.sub(_offset));\n\t\t\t}\n\n\t\t\tscope.dispatchEvent({ type: 'drag', object: _selected });\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction onDocumentTouchStart(event) {\n\n\t\tevent.preventDefault();\n\t\tevent = event.changedTouches[0];\n\n\t\tvar rect = _domElement.getBoundingClientRect();\n\n\t\t_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n\t\t_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tvar intersects = _raycaster.intersectObjects(_objects);\n\n\t\tif (intersects.length > 0) {\n\n\t\t\t_selected = intersects[0].object;\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), _selected.position);\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_offset.copy(_intersection).sub(_selected.position);\n\t\t\t}\n\n\t\t\t_domElement.style.cursor = 'move';\n\n\t\t\tscope.dispatchEvent({ type: 'dragstart', object: _selected });\n\t\t}\n\t}\n\n\tfunction onDocumentTouchEnd(event) {\n\n\t\tevent.preventDefault();\n\n\t\tif (_selected) {\n\n\t\t\tscope.dispatchEvent({ type: 'dragend', object: _selected });\n\n\t\t\t_selected = null;\n\t\t}\n\n\t\t_domElement.style.cursor = 'auto';\n\t}\n\n\tactivate();\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.activate = activate;\n\tthis.deactivate = deactivate;\n\tthis.dispose = dispose;\n\n\t// Backward compatibility\n\n\tthis.setObjects = function () {\n\n\t\tconsole.error('THREE.DragControls: setObjects() has been removed.');\n\t};\n\n\tthis.on = function (type, listener) {\n\n\t\tconsole.warn('THREE.DragControls: on() has been deprecated. Use addEventListener() instead.');\n\t\tscope.addEventListener(type, listener);\n\t};\n\n\tthis.off = function (type, listener) {\n\n\t\tconsole.warn('THREE.DragControls: off() has been deprecated. Use removeEventListener() instead.');\n\t\tscope.removeEventListener(type, listener);\n\t};\n\n\tthis.notify = function (type) {\n\n\t\tconsole.error('THREE.DragControls: notify() has been deprecated. Use dispatchEvent() instead.');\n\t\tscope.dispatchEvent({ type: type });\n\t};\n};\n\nDragControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nDragControls.prototype.constructor = DragControls;\n\nexports.default = DragControls;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nvar EditorControls = function EditorControls(object, domElement) {\n\n\tdomElement = domElement !== undefined ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\tthis.center = new THREE.Vector3();\n\tthis.panSpeed = 0.001;\n\tthis.zoomSpeed = 0.001;\n\tthis.rotationSpeed = 0.005;\n\n\t// internals\n\n\tvar scope = this;\n\tvar vector = new THREE.Vector3();\n\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };\n\tvar state = STATE.NONE;\n\n\tvar center = this.center;\n\tvar normalMatrix = new THREE.Matrix3();\n\tvar pointer = new THREE.Vector2();\n\tvar pointerOld = new THREE.Vector2();\n\tvar spherical = new THREE.Spherical();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\n\tthis.focus = function (target) {\n\n\t\tvar box = new THREE.Box3().setFromObject(target);\n\n\t\tvar distance;\n\n\t\tif (box.isEmpty() === false) {\n\n\t\t\tcenter.copy(box.getCenter());\n\t\t\tdistance = box.getBoundingSphere().radius;\n\t\t} else {\n\n\t\t\t// Focusing on an Group, AmbientLight, etc\n\n\t\t\tcenter.setFromMatrixPosition(target.matrixWorld);\n\t\t\tdistance = 0.1;\n\t\t}\n\n\t\tvar delta = new THREE.Vector3(0, 0, 1);\n\t\tdelta.applyQuaternion(object.quaternion);\n\t\tdelta.multiplyScalar(distance * 4);\n\n\t\tobject.position.copy(center).add(delta);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\tthis.pan = function (delta) {\n\n\t\tvar distance = object.position.distanceTo(center);\n\n\t\tdelta.multiplyScalar(distance * scope.panSpeed);\n\t\tdelta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));\n\n\t\tobject.position.add(delta);\n\t\tcenter.add(delta);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\tthis.zoom = function (delta) {\n\n\t\tvar distance = object.position.distanceTo(center);\n\n\t\tdelta.multiplyScalar(distance * scope.zoomSpeed);\n\n\t\tif (delta.length() > distance) return;\n\n\t\tdelta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));\n\n\t\tobject.position.add(delta);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\tthis.rotate = function (delta) {\n\n\t\tvector.copy(object.position).sub(center);\n\n\t\tspherical.setFromVector3(vector);\n\n\t\tspherical.theta += delta.x;\n\t\tspherical.phi += delta.y;\n\n\t\tspherical.makeSafe();\n\n\t\tvector.setFromSpherical(spherical);\n\n\t\tobject.position.copy(center).add(vector);\n\n\t\tobject.lookAt(center);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\t// mouse\n\n\tfunction onMouseDown(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tif (event.button === 0) {\n\n\t\t\tstate = STATE.ROTATE;\n\t\t} else if (event.button === 1) {\n\n\t\t\tstate = STATE.ZOOM;\n\t\t} else if (event.button === 2) {\n\n\t\t\tstate = STATE.PAN;\n\t\t}\n\n\t\tpointerOld.set(event.clientX, event.clientY);\n\n\t\tdomElement.addEventListener('mousemove', onMouseMove, false);\n\t\tdomElement.addEventListener('mouseup', onMouseUp, false);\n\t\tdomElement.addEventListener('mouseout', onMouseUp, false);\n\t\tdomElement.addEventListener('dblclick', onMouseUp, false);\n\t}\n\n\tfunction onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tpointer.set(event.clientX, event.clientY);\n\n\t\tvar movementX = pointer.x - pointerOld.x;\n\t\tvar movementY = pointer.y - pointerOld.y;\n\n\t\tif (state === STATE.ROTATE) {\n\n\t\t\tscope.rotate(new THREE.Vector3(-movementX * scope.rotationSpeed, -movementY * scope.rotationSpeed, 0));\n\t\t} else if (state === STATE.ZOOM) {\n\n\t\t\tscope.zoom(new THREE.Vector3(0, 0, movementY));\n\t\t} else if (state === STATE.PAN) {\n\n\t\t\tscope.pan(new THREE.Vector3(-movementX, movementY, 0));\n\t\t}\n\n\t\tpointerOld.set(event.clientX, event.clientY);\n\t}\n\n\tfunction onMouseUp(event) {\n\n\t\tdomElement.removeEventListener('mousemove', onMouseMove, false);\n\t\tdomElement.removeEventListener('mouseup', onMouseUp, false);\n\t\tdomElement.removeEventListener('mouseout', onMouseUp, false);\n\t\tdomElement.removeEventListener('dblclick', onMouseUp, false);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onMouseWheel(event) {\n\n\t\tevent.preventDefault();\n\n\t\t// if ( scope.enabled === false ) return;\n\n\t\tscope.zoom(new THREE.Vector3(0, 0, event.deltaY));\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tdomElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tdomElement.removeEventListener('mousedown', onMouseDown, false);\n\t\tdomElement.removeEventListener('wheel', onMouseWheel, false);\n\n\t\tdomElement.removeEventListener('mousemove', onMouseMove, false);\n\t\tdomElement.removeEventListener('mouseup', onMouseUp, false);\n\t\tdomElement.removeEventListener('mouseout', onMouseUp, false);\n\t\tdomElement.removeEventListener('dblclick', onMouseUp, false);\n\n\t\tdomElement.removeEventListener('touchstart', touchStart, false);\n\t\tdomElement.removeEventListener('touchmove', touchMove, false);\n\t};\n\n\tdomElement.addEventListener('contextmenu', contextmenu, false);\n\tdomElement.addEventListener('mousedown', onMouseDown, false);\n\tdomElement.addEventListener('wheel', onMouseWheel, false);\n\n\t// touch\n\n\tvar touches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n\tvar prevTouches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n\n\tvar prevDistance = null;\n\n\tfunction touchStart(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);\n\t\t\t\tprevDistance = touches[0].distanceTo(touches[1]);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tprevTouches[0].copy(touches[0]);\n\t\tprevTouches[1].copy(touches[1]);\n\t}\n\n\tfunction touchMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tfunction getClosest(touch, touches) {\n\n\t\t\tvar closest = touches[0];\n\n\t\t\tfor (var i in touches) {\n\n\t\t\t\tif (closest.distanceTo(touch) > touches[i].distanceTo(touch)) closest = touches[i];\n\t\t\t}\n\n\t\t\treturn closest;\n\t\t}\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\tscope.rotate(touches[0].sub(getClosest(touches[0], prevTouches)).multiplyScalar(-scope.rotationSpeed));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);\n\t\t\t\tvar distance = touches[0].distanceTo(touches[1]);\n\t\t\t\tscope.zoom(new THREE.Vector3(0, 0, prevDistance - distance));\n\t\t\t\tprevDistance = distance;\n\n\t\t\t\tvar offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));\n\t\t\t\tvar offset1 = touches[1].clone().sub(getClosest(touches[1], prevTouches));\n\t\t\t\toffset0.x = -offset0.x;\n\t\t\t\toffset1.x = -offset1.x;\n\n\t\t\t\tscope.pan(offset0.add(offset1).multiplyScalar(0.5));\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tprevTouches[0].copy(touches[0]);\n\t\tprevTouches[1].copy(touches[1]);\n\t}\n\n\tdomElement.addEventListener('touchstart', touchStart, false);\n\tdomElement.addEventListener('touchmove', touchMove, false);\n};\n\nEditorControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nEditorControls.prototype.constructor = EditorControls;\n\nexports.default = EditorControls;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author paulirish / http://paulirish.com/\n */\n\nvar FirstPersonControls = function FirstPersonControls(object, domElement) {\n\n\tthis.object = object;\n\tthis.target = new THREE.Vector3(0, 0, 0);\n\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\tthis.enabled = true;\n\n\tthis.movementSpeed = 1.0;\n\tthis.lookSpeed = 0.005;\n\n\tthis.lookVertical = true;\n\tthis.autoForward = false;\n\n\tthis.activeLook = true;\n\n\tthis.heightSpeed = false;\n\tthis.heightCoef = 1.0;\n\tthis.heightMin = 0.0;\n\tthis.heightMax = 1.0;\n\n\tthis.constrainVertical = false;\n\tthis.verticalMin = 0;\n\tthis.verticalMax = Math.PI;\n\n\tthis.autoSpeedFactor = 0.0;\n\n\tthis.mouseX = 0;\n\tthis.mouseY = 0;\n\n\tthis.lat = 0;\n\tthis.lon = 0;\n\tthis.phi = 0;\n\tthis.theta = 0;\n\n\tthis.moveForward = false;\n\tthis.moveBackward = false;\n\tthis.moveLeft = false;\n\tthis.moveRight = false;\n\n\tthis.mouseDragOn = false;\n\n\tthis.viewHalfX = 0;\n\tthis.viewHalfY = 0;\n\n\tif (this.domElement !== document) {\n\n\t\tthis.domElement.setAttribute('tabindex', -1);\n\t}\n\n\t//\n\n\tthis.handleResize = function () {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.viewHalfX = window.innerWidth / 2;\n\t\t\tthis.viewHalfY = window.innerHeight / 2;\n\t\t} else {\n\n\t\t\tthis.viewHalfX = this.domElement.offsetWidth / 2;\n\t\t\tthis.viewHalfY = this.domElement.offsetHeight / 2;\n\t\t}\n\t};\n\n\tthis.onMouseDown = function (event) {\n\n\t\tif (this.domElement !== document) {\n\n\t\t\tthis.domElement.focus();\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.activeLook) {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveForward = true;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveBackward = true;break;\n\n\t\t\t}\n\t\t}\n\n\t\tthis.mouseDragOn = true;\n\t};\n\n\tthis.onMouseUp = function (event) {\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.activeLook) {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveForward = false;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveBackward = false;break;\n\n\t\t\t}\n\t\t}\n\n\t\tthis.mouseDragOn = false;\n\t};\n\n\tthis.onMouseMove = function (event) {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.mouseX = event.pageX - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.viewHalfY;\n\t\t} else {\n\n\t\t\tthis.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\n\t\t}\n\t};\n\n\tthis.onKeyDown = function (event) {\n\n\t\t//event.preventDefault();\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveForward = true;break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveLeft = true;break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveBackward = true;break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveRight = true;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveUp = true;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveDown = true;break;\n\n\t\t}\n\t};\n\n\tthis.onKeyUp = function (event) {\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveForward = false;break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveLeft = false;break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveBackward = false;break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveRight = false;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveUp = false;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveDown = false;break;\n\n\t\t}\n\t};\n\n\tthis.update = function (delta) {\n\n\t\tif (this.enabled === false) return;\n\n\t\tif (this.heightSpeed) {\n\n\t\t\tvar y = THREE.Math.clamp(this.object.position.y, this.heightMin, this.heightMax);\n\t\t\tvar heightDelta = y - this.heightMin;\n\n\t\t\tthis.autoSpeedFactor = delta * (heightDelta * this.heightCoef);\n\t\t} else {\n\n\t\t\tthis.autoSpeedFactor = 0.0;\n\t\t}\n\n\t\tvar actualMoveSpeed = delta * this.movementSpeed;\n\n\t\tif (this.moveForward || this.autoForward && !this.moveBackward) this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));\n\t\tif (this.moveBackward) this.object.translateZ(actualMoveSpeed);\n\n\t\tif (this.moveLeft) this.object.translateX(-actualMoveSpeed);\n\t\tif (this.moveRight) this.object.translateX(actualMoveSpeed);\n\n\t\tif (this.moveUp) this.object.translateY(actualMoveSpeed);\n\t\tif (this.moveDown) this.object.translateY(-actualMoveSpeed);\n\n\t\tvar actualLookSpeed = delta * this.lookSpeed;\n\n\t\tif (!this.activeLook) {\n\n\t\t\tactualLookSpeed = 0;\n\t\t}\n\n\t\tvar verticalLookRatio = 1;\n\n\t\tif (this.constrainVertical) {\n\n\t\t\tverticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);\n\t\t}\n\n\t\tthis.lon += this.mouseX * actualLookSpeed;\n\t\tif (this.lookVertical) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;\n\n\t\tthis.lat = Math.max(-85, Math.min(85, this.lat));\n\t\tthis.phi = THREE.Math.degToRad(90 - this.lat);\n\n\t\tthis.theta = THREE.Math.degToRad(this.lon);\n\n\t\tif (this.constrainVertical) {\n\n\t\t\tthis.phi = THREE.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax);\n\t\t}\n\n\t\tvar targetPosition = this.target,\n\t\t    position = this.object.position;\n\n\t\ttargetPosition.x = position.x + 100 * Math.sin(this.phi) * Math.cos(this.theta);\n\t\ttargetPosition.y = position.y + 100 * Math.cos(this.phi);\n\t\ttargetPosition.z = position.z + 100 * Math.sin(this.phi) * Math.sin(this.theta);\n\n\t\tthis.object.lookAt(targetPosition);\n\t};\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', _onMouseDown, false);\n\t\tthis.domElement.removeEventListener('mousemove', _onMouseMove, false);\n\t\tthis.domElement.removeEventListener('mouseup', _onMouseUp, false);\n\n\t\twindow.removeEventListener('keydown', _onKeyDown, false);\n\t\twindow.removeEventListener('keyup', _onKeyUp, false);\n\t};\n\n\tvar _onMouseMove = bind(this, this.onMouseMove);\n\tvar _onMouseDown = bind(this, this.onMouseDown);\n\tvar _onMouseUp = bind(this, this.onMouseUp);\n\tvar _onKeyDown = bind(this, this.onKeyDown);\n\tvar _onKeyUp = bind(this, this.onKeyUp);\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\tthis.domElement.addEventListener('mousemove', _onMouseMove, false);\n\tthis.domElement.addEventListener('mousedown', _onMouseDown, false);\n\tthis.domElement.addEventListener('mouseup', _onMouseUp, false);\n\n\twindow.addEventListener('keydown', _onKeyDown, false);\n\twindow.addEventListener('keyup', _onKeyUp, false);\n\n\tfunction bind(scope, fn) {\n\n\t\treturn function () {\n\n\t\t\tfn.apply(scope, arguments);\n\t\t};\n\t}\n\n\tthis.handleResize();\n};\n\nexports.default = FirstPersonControls;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author James Baicoianu / http://www.baicoianu.com/\n */\n\nvar FlyControls = function FlyControls(object, domElement) {\n\n\tthis.object = object;\n\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\tif (domElement) this.domElement.setAttribute('tabindex', -1);\n\n\t// API\n\n\tthis.movementSpeed = 1.0;\n\tthis.rollSpeed = 0.005;\n\n\tthis.dragToLook = false;\n\tthis.autoForward = false;\n\n\t// disable default target object behavior\n\n\t// internals\n\n\tthis.tmpQuaternion = new THREE.Quaternion();\n\n\tthis.mouseStatus = 0;\n\n\tthis.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };\n\tthis.moveVector = new THREE.Vector3(0, 0, 0);\n\tthis.rotationVector = new THREE.Vector3(0, 0, 0);\n\n\tthis.handleEvent = function (event) {\n\n\t\tif (typeof this[event.type] == 'function') {\n\n\t\t\tthis[event.type](event);\n\t\t}\n\t};\n\n\tthis.keydown = function (event) {\n\n\t\tif (event.altKey) {\n\n\t\t\treturn;\n\t\t}\n\n\t\t//event.preventDefault();\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 16:\n\t\t\t\t/* shift */this.movementSpeedMultiplier = .1;break;\n\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveState.forward = 1;break;\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveState.back = 1;break;\n\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveState.left = 1;break;\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveState.right = 1;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveState.up = 1;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveState.down = 1;break;\n\n\t\t\tcase 38:\n\t\t\t\t/*up*/this.moveState.pitchUp = 1;break;\n\t\t\tcase 40:\n\t\t\t\t/*down*/this.moveState.pitchDown = 1;break;\n\n\t\t\tcase 37:\n\t\t\t\t/*left*/this.moveState.yawLeft = 1;break;\n\t\t\tcase 39:\n\t\t\t\t/*right*/this.moveState.yawRight = 1;break;\n\n\t\t\tcase 81:\n\t\t\t\t/*Q*/this.moveState.rollLeft = 1;break;\n\t\t\tcase 69:\n\t\t\t\t/*E*/this.moveState.rollRight = 1;break;\n\n\t\t}\n\n\t\tthis.updateMovementVector();\n\t\tthis.updateRotationVector();\n\t};\n\n\tthis.keyup = function (event) {\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 16:\n\t\t\t\t/* shift */this.movementSpeedMultiplier = 1;break;\n\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveState.forward = 0;break;\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveState.back = 0;break;\n\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveState.left = 0;break;\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveState.right = 0;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveState.up = 0;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveState.down = 0;break;\n\n\t\t\tcase 38:\n\t\t\t\t/*up*/this.moveState.pitchUp = 0;break;\n\t\t\tcase 40:\n\t\t\t\t/*down*/this.moveState.pitchDown = 0;break;\n\n\t\t\tcase 37:\n\t\t\t\t/*left*/this.moveState.yawLeft = 0;break;\n\t\t\tcase 39:\n\t\t\t\t/*right*/this.moveState.yawRight = 0;break;\n\n\t\t\tcase 81:\n\t\t\t\t/*Q*/this.moveState.rollLeft = 0;break;\n\t\t\tcase 69:\n\t\t\t\t/*E*/this.moveState.rollRight = 0;break;\n\n\t\t}\n\n\t\tthis.updateMovementVector();\n\t\tthis.updateRotationVector();\n\t};\n\n\tthis.mousedown = function (event) {\n\n\t\tif (this.domElement !== document) {\n\n\t\t\tthis.domElement.focus();\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.dragToLook) {\n\n\t\t\tthis.mouseStatus++;\n\t\t} else {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveState.forward = 1;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveState.back = 1;break;\n\n\t\t\t}\n\n\t\t\tthis.updateMovementVector();\n\t\t}\n\t};\n\n\tthis.mousemove = function (event) {\n\n\t\tif (!this.dragToLook || this.mouseStatus > 0) {\n\n\t\t\tvar container = this.getContainerDimensions();\n\t\t\tvar halfWidth = container.size[0] / 2;\n\t\t\tvar halfHeight = container.size[1] / 2;\n\n\t\t\tthis.moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;\n\t\t\tthis.moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;\n\n\t\t\tthis.updateRotationVector();\n\t\t}\n\t};\n\n\tthis.mouseup = function (event) {\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.dragToLook) {\n\n\t\t\tthis.mouseStatus--;\n\n\t\t\tthis.moveState.yawLeft = this.moveState.pitchDown = 0;\n\t\t} else {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveState.forward = 0;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveState.back = 0;break;\n\n\t\t\t}\n\n\t\t\tthis.updateMovementVector();\n\t\t}\n\n\t\tthis.updateRotationVector();\n\t};\n\n\tthis.update = function (delta) {\n\n\t\tvar moveMult = delta * this.movementSpeed;\n\t\tvar rotMult = delta * this.rollSpeed;\n\n\t\tthis.object.translateX(this.moveVector.x * moveMult);\n\t\tthis.object.translateY(this.moveVector.y * moveMult);\n\t\tthis.object.translateZ(this.moveVector.z * moveMult);\n\n\t\tthis.tmpQuaternion.set(this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1).normalize();\n\t\tthis.object.quaternion.multiply(this.tmpQuaternion);\n\n\t\t// expose the rotation vector for convenience\n\t\tthis.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);\n\t};\n\n\tthis.updateMovementVector = function () {\n\n\t\tvar forward = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;\n\n\t\tthis.moveVector.x = -this.moveState.left + this.moveState.right;\n\t\tthis.moveVector.y = -this.moveState.down + this.moveState.up;\n\t\tthis.moveVector.z = -forward + this.moveState.back;\n\n\t\t//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );\n\t};\n\n\tthis.updateRotationVector = function () {\n\n\t\tthis.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp;\n\t\tthis.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft;\n\t\tthis.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft;\n\n\t\t//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );\n\t};\n\n\tthis.getContainerDimensions = function () {\n\n\t\tif (this.domElement != document) {\n\n\t\t\treturn {\n\t\t\t\tsize: [this.domElement.offsetWidth, this.domElement.offsetHeight],\n\t\t\t\toffset: [this.domElement.offsetLeft, this.domElement.offsetTop]\n\t\t\t};\n\t\t} else {\n\n\t\t\treturn {\n\t\t\t\tsize: [window.innerWidth, window.innerHeight],\n\t\t\t\toffset: [0, 0]\n\t\t\t};\n\t\t}\n\t};\n\n\tfunction bind(scope, fn) {\n\n\t\treturn function () {\n\n\t\t\tfn.apply(scope, arguments);\n\t\t};\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', _mousedown, false);\n\t\tthis.domElement.removeEventListener('mousemove', _mousemove, false);\n\t\tthis.domElement.removeEventListener('mouseup', _mouseup, false);\n\n\t\twindow.removeEventListener('keydown', _keydown, false);\n\t\twindow.removeEventListener('keyup', _keyup, false);\n\t};\n\n\tvar _mousemove = bind(this, this.mousemove);\n\tvar _mousedown = bind(this, this.mousedown);\n\tvar _mouseup = bind(this, this.mouseup);\n\tvar _keydown = bind(this, this.keydown);\n\tvar _keyup = bind(this, this.keyup);\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\n\tthis.domElement.addEventListener('mousemove', _mousemove, false);\n\tthis.domElement.addEventListener('mousedown', _mousedown, false);\n\tthis.domElement.addEventListener('mouseup', _mouseup, false);\n\n\twindow.addEventListener('keydown', _keydown, false);\n\twindow.addEventListener('keyup', _keyup, false);\n\n\tthis.updateMovementVector();\n\tthis.updateRotationVector();\n};\n\nexports.default = FlyControls;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: two-finger move\n\nvar OrbitControls = function OrbitControls(object, domElement) {\n\n\tthis.object = object;\n\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new THREE.Vector3();\n\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = -Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.25;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.panSpeed = 1.0;\n\tthis.screenSpacePanning = false; // if true, pan in screen-space\n\tthis.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// Mouse buttons\n\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t//\n\t// public methods\n\t//\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn spherical.phi;\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn spherical.theta;\n\t};\n\n\tthis.saveState = function () {\n\n\t\tscope.target0.copy(scope.target);\n\t\tscope.position0.copy(scope.object.position);\n\t\tscope.zoom0 = scope.object.zoom;\n\t};\n\n\tthis.reset = function () {\n\n\t\tscope.target.copy(scope.target0);\n\t\tscope.object.position.copy(scope.position0);\n\t\tscope.object.zoom = scope.zoom0;\n\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent(changeEvent);\n\n\t\tscope.update();\n\n\t\tstate = STATE.NONE;\n\t};\n\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n\t\tvar quatInverse = quat.clone().inverse();\n\n\t\tvar lastPosition = new THREE.Vector3();\n\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\treturn function update() {\n\n\t\t\tvar position = scope.object.position;\n\n\t\t\toffset.copy(position).sub(scope.target);\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion(quat);\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3(offset);\n\n\t\t\tif (scope.autoRotate && state === STATE.NONE) {\n\n\t\t\t\trotateLeft(getAutoRotationAngle());\n\t\t\t}\n\n\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t// restrict theta to be between desired limits\n\t\t\tspherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n\n\t\t\tspherical.makeSafe();\n\n\t\t\tspherical.radius *= scale;\n\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n\n\t\t\t// move target to panned location\n\t\t\tscope.target.add(panOffset);\n\n\t\t\toffset.setFromSpherical(spherical);\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion(quatInverse);\n\n\t\t\tposition.copy(scope.target).add(offset);\n\n\t\t\tscope.object.lookAt(scope.target);\n\n\t\t\tif (scope.enableDamping === true) {\n\n\t\t\t\tsphericalDelta.theta *= 1 - scope.dampingFactor;\n\t\t\t\tsphericalDelta.phi *= 1 - scope.dampingFactor;\n\n\t\t\t\tpanOffset.multiplyScalar(1 - scope.dampingFactor);\n\t\t\t} else {\n\n\t\t\t\tsphericalDelta.set(0, 0, 0);\n\n\t\t\t\tpanOffset.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tscale = 1;\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\n\t\t\t\tlastPosition.copy(scope.object.position);\n\t\t\t\tlastQuaternion.copy(scope.object.quaternion);\n\t\t\t\tzoomChanged = false;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\t}();\n\n\tthis.dispose = function () {\n\n\t\tscope.domElement.removeEventListener('contextmenu', onContextMenu, false);\n\t\tscope.domElement.removeEventListener('mousedown', onMouseDown, false);\n\t\tscope.domElement.removeEventListener('wheel', onMouseWheel, false);\n\n\t\tscope.domElement.removeEventListener('touchstart', onTouchStart, false);\n\t\tscope.domElement.removeEventListener('touchend', onTouchEnd, false);\n\t\tscope.domElement.removeEventListener('touchmove', onTouchMove, false);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\twindow.removeEventListener('keydown', onKeyDown, false);\n\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\t};\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\tvar STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };\n\n\tvar state = STATE.NONE;\n\n\tvar EPS = 0.000001;\n\n\t// current position in spherical coordinates\n\tvar spherical = new THREE.Spherical();\n\tvar sphericalDelta = new THREE.Spherical();\n\n\tvar scale = 1;\n\tvar panOffset = new THREE.Vector3();\n\tvar zoomChanged = false;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow(0.95, scope.zoomSpeed);\n\t}\n\n\tfunction rotateLeft(angle) {\n\n\t\tsphericalDelta.theta -= angle;\n\t}\n\n\tfunction rotateUp(angle) {\n\n\t\tsphericalDelta.phi -= angle;\n\t}\n\n\tvar panLeft = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panLeft(distance, objectMatrix) {\n\n\t\t\tv.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\t\t\tv.multiplyScalar(-distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t}();\n\n\tvar panUp = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panUp(distance, objectMatrix) {\n\n\t\t\tif (scope.screenSpacePanning === true) {\n\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 1);\n\t\t\t} else {\n\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 0);\n\t\t\t\tv.crossVectors(scope.object.up, v);\n\t\t\t}\n\n\t\t\tv.multiplyScalar(distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t}();\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tvar pan = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\treturn function pan(deltaX, deltaY) {\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\toffset.copy(position).sub(scope.target);\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\tpanLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n\t\t\t\tpanUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n\t\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n\t\t\t\tpanUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\t\t\t\tscope.enablePan = false;\n\t\t\t}\n\t\t};\n\t}();\n\n\tfunction dollyIn(dollyScale) {\n\n\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\tscale /= dollyScale;\n\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\tfunction dollyOut(dollyScale) {\n\n\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\tscale *= dollyScale;\n\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\tfunction handleMouseDownRotate(event) {\n\n\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\trotateStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownDolly(event) {\n\n\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\tdollyStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownPan(event) {\n\n\t\t//console.log( 'handleMouseDownPan' );\n\n\t\tpanStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseMoveRotate(event) {\n\n\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\trotateEnd.set(event.clientX, event.clientY);\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMoveDolly(event) {\n\n\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\tdollyEnd.set(event.clientX, event.clientY);\n\n\t\tdollyDelta.subVectors(dollyEnd, dollyStart);\n\n\t\tif (dollyDelta.y > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\t\t} else if (dollyDelta.y < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\t\t}\n\n\t\tdollyStart.copy(dollyEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMovePan(event) {\n\n\t\t//console.log( 'handleMouseMovePan' );\n\n\t\tpanEnd.set(event.clientX, event.clientY);\n\n\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseUp(event) {\n\n\t\t// console.log( 'handleMouseUp' );\n\n\t}\n\n\tfunction handleMouseWheel(event) {\n\n\t\t// console.log( 'handleMouseWheel' );\n\n\t\tif (event.deltaY < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\t\t} else if (event.deltaY > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\t\t}\n\n\t\tscope.update();\n\t}\n\n\tfunction handleKeyDown(event) {\n\n\t\t//console.log( 'handleKeyDown' );\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tpan(0, scope.keyPanSpeed);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tpan(0, -scope.keyPanSpeed);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tpan(scope.keyPanSpeed, 0);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tpan(-scope.keyPanSpeed, 0);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tfunction handleTouchStartRotate(event) {\n\n\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\trotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\t}\n\n\tfunction handleTouchStartDollyPan(event) {\n\n\t\t//console.log( 'handleTouchStartDollyPan' );\n\n\t\tif (scope.enableZoom) {\n\n\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\tdollyStart.set(0, distance);\n\t\t}\n\n\t\tif (scope.enablePan) {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanStart.set(x, y);\n\t\t}\n\t}\n\n\tfunction handleTouchMoveRotate(event) {\n\n\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\trotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleTouchMoveDollyPan(event) {\n\n\t\t//console.log( 'handleTouchMoveDollyPan' );\n\n\t\tif (scope.enableZoom) {\n\n\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\tdollyEnd.set(0, distance);\n\n\t\t\tdollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n\t\t\tdollyIn(dollyDelta.y);\n\n\t\t\tdollyStart.copy(dollyEnd);\n\t\t}\n\n\t\tif (scope.enablePan) {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanEnd.set(x, y);\n\n\t\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\t\tpan(panDelta.x, panDelta.y);\n\n\t\t\tpanStart.copy(panEnd);\n\t\t}\n\n\t\tscope.update();\n\t}\n\n\tfunction handleTouchEnd(event) {}\n\n\t//console.log( 'handleTouchEnd' );\n\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\n\tfunction onMouseDown(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (event.button) {\n\n\t\t\tcase scope.mouseButtons.ORBIT:\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleMouseDownRotate(event);\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.ZOOM:\n\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleMouseDownDolly(event);\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.PAN:\n\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleMouseDownPan(event);\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tdocument.addEventListener('mousemove', onMouseMove, false);\n\t\t\tdocument.addEventListener('mouseup', onMouseUp, false);\n\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (state) {\n\n\t\t\tcase STATE.ROTATE:\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleMouseMoveRotate(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.DOLLY:\n\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleMouseMoveDolly(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.PAN:\n\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleMouseMovePan(event);\n\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tfunction onMouseUp(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleMouseUp(event);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onMouseWheel(event) {\n\n\t\tif (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tscope.dispatchEvent(startEvent);\n\n\t\thandleMouseWheel(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\t}\n\n\tfunction onKeyDown(event) {\n\n\t\tif (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n\t\thandleKeyDown(event);\n\t}\n\n\tfunction onTouchStart(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t// one-fingered touch: rotate\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleTouchStartRotate(event);\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t// two-fingered touch: dolly-pan\n\n\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\n\t\t\t\thandleTouchStartDollyPan(event);\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onTouchMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t// one-fingered touch: rotate\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\t\t\t\tif (state !== STATE.TOUCH_ROTATE) return; // is this needed?\n\n\t\t\t\thandleTouchMoveRotate(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t// two-fingered touch: dolly-pan\n\n\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\t\t\t\tif (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?\n\n\t\t\t\thandleTouchMoveDollyPan(event);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\t}\n\n\tfunction onTouchEnd(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleTouchEnd(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onContextMenu(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t}\n\n\t//\n\n\tscope.domElement.addEventListener('contextmenu', onContextMenu, false);\n\n\tscope.domElement.addEventListener('mousedown', onMouseDown, false);\n\tscope.domElement.addEventListener('wheel', onMouseWheel, false);\n\n\tscope.domElement.addEventListener('touchstart', onTouchStart, false);\n\tscope.domElement.addEventListener('touchend', onTouchEnd, false);\n\tscope.domElement.addEventListener('touchmove', onTouchMove, false);\n\n\twindow.addEventListener('keydown', onKeyDown, false);\n\n\t// force an update at start\n\n\tthis.update();\n};\n\nOrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nOrbitControls.prototype.constructor = OrbitControls;\n\nObject.defineProperties(OrbitControls.prototype, {\n\n\tcenter: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .center has been renamed to .target');\n\t\t\treturn this.target;\n\t\t}\n\n\t},\n\n\t// backward compatibility\n\n\tnoZoom: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n\t\t\treturn !this.enableZoom;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n\t\t\tthis.enableZoom = !value;\n\t\t}\n\n\t},\n\n\tnoRotate: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n\t\t\treturn !this.enableRotate;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n\t\t\tthis.enableRotate = !value;\n\t\t}\n\n\t},\n\n\tnoPan: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n\t\t\treturn !this.enablePan;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n\t\t\tthis.enablePan = !value;\n\t\t}\n\n\t},\n\n\tnoKeys: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n\t\t\treturn !this.enableKeys;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n\t\t\tthis.enableKeys = !value;\n\t\t}\n\n\t},\n\n\tstaticMoving: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n\t\t\treturn !this.enableDamping;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n\t\t\tthis.enableDamping = !value;\n\t\t}\n\n\t},\n\n\tdynamicDampingFactor: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n\t\t\treturn this.dampingFactor;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n\t\t\tthis.dampingFactor = value;\n\t\t}\n\n\t}\n\n});\n\nexports.default = OrbitControls;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n * @author Patrick Fuller / http://patrick-fuller.com\n * @author Max Smolens / https://github.com/msmolens\n */\n\nvar OrthographicTrackballControls = function OrthographicTrackballControls(object, domElement) {\n\n\tvar _this = this;\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\n\n\tthis.object = object;\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\n\n\tthis.radius = 0;\n\n\tthis.rotateSpeed = 1.0;\n\tthis.zoomSpeed = 1.2;\n\n\tthis.noRotate = false;\n\tthis.noZoom = false;\n\tthis.noPan = false;\n\tthis.noRoll = false;\n\n\tthis.staticMoving = false;\n\tthis.dynamicDampingFactor = 0.2;\n\n\tthis.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n\n\t// internals\n\n\tthis.target = new THREE.Vector3();\n\n\tvar EPS = 0.000001;\n\n\tvar _changed = true;\n\n\tvar _state = STATE.NONE,\n\t    _prevState = STATE.NONE,\n\t    _eye = new THREE.Vector3(),\n\t    _rotateStart = new THREE.Vector3(),\n\t    _rotateEnd = new THREE.Vector3(),\n\t    _zoomStart = new THREE.Vector2(),\n\t    _zoomEnd = new THREE.Vector2(),\n\t    _touchZoomDistanceStart = 0,\n\t    _touchZoomDistanceEnd = 0,\n\t    _panStart = new THREE.Vector2(),\n\t    _panEnd = new THREE.Vector2();\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.up0 = this.object.up.clone();\n\n\tthis.left0 = this.object.left;\n\tthis.right0 = this.object.right;\n\tthis.top0 = this.object.top;\n\tthis.bottom0 = this.object.bottom;\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\t// methods\n\n\tthis.handleResize = function () {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.screen.left = 0;\n\t\t\tthis.screen.top = 0;\n\t\t\tthis.screen.width = window.innerWidth;\n\t\t\tthis.screen.height = window.innerHeight;\n\t\t} else {\n\n\t\t\tvar box = this.domElement.getBoundingClientRect();\n\t\t\t// adjustments come from similar code in the jquery offset() function\n\t\t\tvar d = this.domElement.ownerDocument.documentElement;\n\t\t\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\n\t\t\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\n\t\t\tthis.screen.width = box.width;\n\t\t\tthis.screen.height = box.height;\n\t\t}\n\n\t\tthis.radius = 0.5 * Math.min(this.screen.width, this.screen.height);\n\n\t\tthis.left0 = this.object.left;\n\t\tthis.right0 = this.object.right;\n\t\tthis.top0 = this.object.top;\n\t\tthis.bottom0 = this.object.bottom;\n\t};\n\n\tthis.handleEvent = function (event) {\n\n\t\tif (typeof this[event.type] == 'function') {\n\n\t\t\tthis[event.type](event);\n\t\t}\n\t};\n\n\tvar getMouseOnScreen = function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnScreen(pageX, pageY) {\n\n\t\t\tvector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tvar getMouseProjectionOnBall = function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar objectUp = new THREE.Vector3();\n\t\tvar mouseOnBall = new THREE.Vector3();\n\n\t\treturn function getMouseProjectionOnBall(pageX, pageY) {\n\n\t\t\tmouseOnBall.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / _this.radius, (_this.screen.height * 0.5 + _this.screen.top - pageY) / _this.radius, 0.0);\n\n\t\t\tvar length = mouseOnBall.length();\n\n\t\t\tif (_this.noRoll) {\n\n\t\t\t\tif (length < Math.SQRT1_2) {\n\n\t\t\t\t\tmouseOnBall.z = Math.sqrt(1.0 - length * length);\n\t\t\t\t} else {\n\n\t\t\t\t\tmouseOnBall.z = .5 / length;\n\t\t\t\t}\n\t\t\t} else if (length > 1.0) {\n\n\t\t\t\tmouseOnBall.normalize();\n\t\t\t} else {\n\n\t\t\t\tmouseOnBall.z = Math.sqrt(1.0 - length * length);\n\t\t\t}\n\n\t\t\t_eye.copy(_this.object.position).sub(_this.target);\n\n\t\t\tvector.copy(_this.object.up).setLength(mouseOnBall.y);\n\t\t\tvector.add(objectUp.copy(_this.object.up).cross(_eye).setLength(mouseOnBall.x));\n\t\t\tvector.add(_eye.setLength(mouseOnBall.z));\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tthis.rotateCamera = function () {\n\n\t\tvar axis = new THREE.Vector3(),\n\t\t    quaternion = new THREE.Quaternion();\n\n\t\treturn function rotateCamera() {\n\n\t\t\tvar angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());\n\n\t\t\tif (angle) {\n\n\t\t\t\taxis.crossVectors(_rotateStart, _rotateEnd).normalize();\n\n\t\t\t\tangle *= _this.rotateSpeed;\n\n\t\t\t\tquaternion.setFromAxisAngle(axis, -angle);\n\n\t\t\t\t_eye.applyQuaternion(quaternion);\n\t\t\t\t_this.object.up.applyQuaternion(quaternion);\n\n\t\t\t\t_rotateEnd.applyQuaternion(quaternion);\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_rotateStart.copy(_rotateEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\tquaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));\n\t\t\t\t\t_rotateStart.applyQuaternion(quaternion);\n\t\t\t\t}\n\n\t\t\t\t_changed = true;\n\t\t\t}\n\t\t};\n\t}();\n\n\tthis.zoomCamera = function () {\n\n\t\tif (_state === STATE.TOUCH_ZOOM_PAN) {\n\n\t\t\tvar factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\n\n\t\t\t_this.object.zoom *= factor;\n\n\t\t\t_changed = true;\n\t\t} else {\n\n\t\t\tvar factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;\n\n\t\t\tif (Math.abs(factor - 1.0) > EPS && factor > 0.0) {\n\n\t\t\t\t_this.object.zoom /= factor;\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\t_zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;\n\t\t\t\t}\n\n\t\t\t\t_changed = true;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.panCamera = function () {\n\n\t\tvar mouseChange = new THREE.Vector2(),\n\t\t    objectUp = new THREE.Vector3(),\n\t\t    pan = new THREE.Vector3();\n\n\t\treturn function panCamera() {\n\n\t\t\tmouseChange.copy(_panEnd).sub(_panStart);\n\n\t\t\tif (mouseChange.lengthSq()) {\n\n\t\t\t\t// Scale movement to keep clicked/dragged position under cursor\n\t\t\t\tvar scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;\n\t\t\t\tvar scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;\n\t\t\t\tmouseChange.x *= scale_x;\n\t\t\t\tmouseChange.y *= scale_y;\n\n\t\t\t\tpan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);\n\t\t\t\tpan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));\n\n\t\t\t\t_this.object.position.add(pan);\n\t\t\t\t_this.target.add(pan);\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_panStart.copy(_panEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\t_panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));\n\t\t\t\t}\n\n\t\t\t\t_changed = true;\n\t\t\t}\n\t\t};\n\t}();\n\n\tthis.update = function () {\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\tif (!_this.noRotate) {\n\n\t\t\t_this.rotateCamera();\n\t\t}\n\n\t\tif (!_this.noZoom) {\n\n\t\t\t_this.zoomCamera();\n\n\t\t\tif (_changed) {\n\n\t\t\t\t_this.object.updateProjectionMatrix();\n\t\t\t}\n\t\t}\n\n\t\tif (!_this.noPan) {\n\n\t\t\t_this.panCamera();\n\t\t}\n\n\t\t_this.object.position.addVectors(_this.target, _eye);\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\tif (_changed) {\n\n\t\t\t_this.dispatchEvent(changeEvent);\n\n\t\t\t_changed = false;\n\t\t}\n\t};\n\n\tthis.reset = function () {\n\n\t\t_state = STATE.NONE;\n\t\t_prevState = STATE.NONE;\n\n\t\t_this.target.copy(_this.target0);\n\t\t_this.object.position.copy(_this.position0);\n\t\t_this.object.up.copy(_this.up0);\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\t_this.object.left = _this.left0;\n\t\t_this.object.right = _this.right0;\n\t\t_this.object.top = _this.top0;\n\t\t_this.object.bottom = _this.bottom0;\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\t_this.dispatchEvent(changeEvent);\n\n\t\t_changed = false;\n\t};\n\n\t// listeners\n\n\tfunction keydown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\twindow.removeEventListener('keydown', keydown);\n\n\t\t_prevState = _state;\n\n\t\tif (_state !== STATE.NONE) {\n\n\t\t\treturn;\n\t\t} else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {\n\n\t\t\t_state = STATE.ROTATE;\n\t\t} else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {\n\n\t\t\t_state = STATE.ZOOM;\n\t\t} else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {\n\n\t\t\t_state = STATE.PAN;\n\t\t}\n\t}\n\n\tfunction keyup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\t_state = _prevState;\n\n\t\twindow.addEventListener('keydown', keydown, false);\n\t}\n\n\tfunction mousedown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.NONE) {\n\n\t\t\t_state = event.button;\n\t\t}\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_rotateStart.copy(getMouseProjectionOnBall(event.pageX, event.pageY));\n\t\t\t_rotateEnd.copy(_rotateStart);\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_zoomEnd.copy(_zoomStart);\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_panEnd.copy(_panStart);\n\t\t}\n\n\t\tdocument.addEventListener('mousemove', mousemove, false);\n\t\tdocument.addEventListener('mouseup', mouseup, false);\n\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction mousemove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_rotateEnd.copy(getMouseProjectionOnBall(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t}\n\t}\n\n\tfunction mouseup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_state = STATE.NONE;\n\n\t\tdocument.removeEventListener('mousemove', mousemove);\n\t\tdocument.removeEventListener('mouseup', mouseup);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction mousewheel(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_zoomStart.y += event.deltaY * 0.01;\n\t\t_this.dispatchEvent(startEvent);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction touchstart(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_rotateStart.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_rotateEnd.copy(_rotateStart);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_state = STATE.TOUCH_ZOOM_PAN;\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panStart.copy(getMouseOnScreen(x, y));\n\t\t\t\t_panEnd.copy(_panStart);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction touchmove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panEnd.copy(getMouseOnScreen(x, y));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\t}\n\n\tfunction touchend(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_rotateStart.copy(_rotateEnd);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panEnd.copy(getMouseOnScreen(x, y));\n\t\t\t\t_panStart.copy(_panEnd);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_state = STATE.NONE;\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', mousedown, false);\n\t\tthis.domElement.removeEventListener('wheel', mousewheel, false);\n\n\t\tthis.domElement.removeEventListener('touchstart', touchstart, false);\n\t\tthis.domElement.removeEventListener('touchend', touchend, false);\n\t\tthis.domElement.removeEventListener('touchmove', touchmove, false);\n\n\t\tdocument.removeEventListener('mousemove', mousemove, false);\n\t\tdocument.removeEventListener('mouseup', mouseup, false);\n\n\t\twindow.removeEventListener('keydown', keydown, false);\n\t\twindow.removeEventListener('keyup', keyup, false);\n\t};\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\tthis.domElement.addEventListener('mousedown', mousedown, false);\n\tthis.domElement.addEventListener('wheel', mousewheel, false);\n\n\tthis.domElement.addEventListener('touchstart', touchstart, false);\n\tthis.domElement.addEventListener('touchend', touchend, false);\n\tthis.domElement.addEventListener('touchmove', touchmove, false);\n\n\twindow.addEventListener('keydown', keydown, false);\n\twindow.addEventListener('keyup', keyup, false);\n\n\tthis.handleResize();\n\n\t// force an update at start\n\tthis.update();\n};\n\nOrthographicTrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nOrthographicTrackballControls.prototype.constructor = OrthographicTrackballControls;\n\nexports.default = OrthographicTrackballControls;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar PointerLockControls = function PointerLockControls(camera) {\n\n\tvar scope = this;\n\n\tcamera.rotation.set(0, 0, 0);\n\n\tvar pitchObject = new THREE.Object3D();\n\tpitchObject.add(camera);\n\n\tvar yawObject = new THREE.Object3D();\n\tyawObject.position.y = 10;\n\tyawObject.add(pitchObject);\n\n\tvar PI_2 = Math.PI / 2;\n\n\tvar onMouseMove = function onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tvar movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\n\t\tvar movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n\n\t\tyawObject.rotation.y -= movementX * 0.002;\n\t\tpitchObject.rotation.x -= movementY * 0.002;\n\n\t\tpitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));\n\t};\n\n\tthis.dispose = function () {\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t};\n\n\tdocument.addEventListener('mousemove', onMouseMove, false);\n\n\tthis.enabled = false;\n\n\tthis.getObject = function () {\n\n\t\treturn yawObject;\n\t};\n\n\tthis.getDirection = function () {\n\n\t\t// assumes the camera itself is not rotated\n\n\t\tvar direction = new THREE.Vector3(0, 0, -1);\n\t\tvar rotation = new THREE.Euler(0, 0, 0, 'YXZ');\n\n\t\treturn function (v) {\n\n\t\t\trotation.set(pitchObject.rotation.x, yawObject.rotation.y, 0);\n\n\t\t\tv.copy(direction).applyEuler(rotation);\n\n\t\t\treturn v;\n\t\t};\n\t}();\n};\n\nexports.default = PointerLockControls;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n * @author Simone Manini / http://daron1337.github.io\n * @author Luca Antiga \t/ http://lantiga.github.io\n */\n\nvar TrackballControls = function TrackballControls(object, domElement) {\n\n\tvar _this = this;\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\n\n\tthis.object = object;\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\n\n\tthis.rotateSpeed = 1.0;\n\tthis.zoomSpeed = 1.2;\n\tthis.panSpeed = 0.3;\n\n\tthis.noRotate = false;\n\tthis.noZoom = false;\n\tthis.noPan = false;\n\n\tthis.staticMoving = false;\n\tthis.dynamicDampingFactor = 0.2;\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\tthis.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n\n\t// internals\n\n\tthis.target = new THREE.Vector3();\n\n\tvar EPS = 0.000001;\n\n\tvar lastPosition = new THREE.Vector3();\n\n\tvar _state = STATE.NONE,\n\t    _prevState = STATE.NONE,\n\t    _eye = new THREE.Vector3(),\n\t    _movePrev = new THREE.Vector2(),\n\t    _moveCurr = new THREE.Vector2(),\n\t    _lastAxis = new THREE.Vector3(),\n\t    _lastAngle = 0,\n\t    _zoomStart = new THREE.Vector2(),\n\t    _zoomEnd = new THREE.Vector2(),\n\t    _touchZoomDistanceStart = 0,\n\t    _touchZoomDistanceEnd = 0,\n\t    _panStart = new THREE.Vector2(),\n\t    _panEnd = new THREE.Vector2();\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.up0 = this.object.up.clone();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\t// methods\n\n\tthis.handleResize = function () {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.screen.left = 0;\n\t\t\tthis.screen.top = 0;\n\t\t\tthis.screen.width = window.innerWidth;\n\t\t\tthis.screen.height = window.innerHeight;\n\t\t} else {\n\n\t\t\tvar box = this.domElement.getBoundingClientRect();\n\t\t\t// adjustments come from similar code in the jquery offset() function\n\t\t\tvar d = this.domElement.ownerDocument.documentElement;\n\t\t\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\n\t\t\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\n\t\t\tthis.screen.width = box.width;\n\t\t\tthis.screen.height = box.height;\n\t\t}\n\t};\n\n\tthis.handleEvent = function (event) {\n\n\t\tif (typeof this[event.type] == 'function') {\n\n\t\t\tthis[event.type](event);\n\t\t}\n\t};\n\n\tvar getMouseOnScreen = function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnScreen(pageX, pageY) {\n\n\t\t\tvector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tvar getMouseOnCircle = function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnCircle(pageX, pageY) {\n\n\t\t\tvector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width // screen.width intentional\n\t\t\t);\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tthis.rotateCamera = function () {\n\n\t\tvar axis = new THREE.Vector3(),\n\t\t    quaternion = new THREE.Quaternion(),\n\t\t    eyeDirection = new THREE.Vector3(),\n\t\t    objectUpDirection = new THREE.Vector3(),\n\t\t    objectSidewaysDirection = new THREE.Vector3(),\n\t\t    moveDirection = new THREE.Vector3(),\n\t\t    angle;\n\n\t\treturn function rotateCamera() {\n\n\t\t\tmoveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);\n\t\t\tangle = moveDirection.length();\n\n\t\t\tif (angle) {\n\n\t\t\t\t_eye.copy(_this.object.position).sub(_this.target);\n\n\t\t\t\teyeDirection.copy(_eye).normalize();\n\t\t\t\tobjectUpDirection.copy(_this.object.up).normalize();\n\t\t\t\tobjectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();\n\n\t\t\t\tobjectUpDirection.setLength(_moveCurr.y - _movePrev.y);\n\t\t\t\tobjectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);\n\n\t\t\t\tmoveDirection.copy(objectUpDirection.add(objectSidewaysDirection));\n\n\t\t\t\taxis.crossVectors(moveDirection, _eye).normalize();\n\n\t\t\t\tangle *= _this.rotateSpeed;\n\t\t\t\tquaternion.setFromAxisAngle(axis, angle);\n\n\t\t\t\t_eye.applyQuaternion(quaternion);\n\t\t\t\t_this.object.up.applyQuaternion(quaternion);\n\n\t\t\t\t_lastAxis.copy(axis);\n\t\t\t\t_lastAngle = angle;\n\t\t\t} else if (!_this.staticMoving && _lastAngle) {\n\n\t\t\t\t_lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);\n\t\t\t\t_eye.copy(_this.object.position).sub(_this.target);\n\t\t\t\tquaternion.setFromAxisAngle(_lastAxis, _lastAngle);\n\t\t\t\t_eye.applyQuaternion(quaternion);\n\t\t\t\t_this.object.up.applyQuaternion(quaternion);\n\t\t\t}\n\n\t\t\t_movePrev.copy(_moveCurr);\n\t\t};\n\t}();\n\n\tthis.zoomCamera = function () {\n\n\t\tvar factor;\n\n\t\tif (_state === STATE.TOUCH_ZOOM_PAN) {\n\n\t\t\tfactor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\n\t\t\t_eye.multiplyScalar(factor);\n\t\t} else {\n\n\t\t\tfactor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;\n\n\t\t\tif (factor !== 1.0 && factor > 0.0) {\n\n\t\t\t\t_eye.multiplyScalar(factor);\n\t\t\t}\n\n\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t} else {\n\n\t\t\t\t_zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.panCamera = function () {\n\n\t\tvar mouseChange = new THREE.Vector2(),\n\t\t    objectUp = new THREE.Vector3(),\n\t\t    pan = new THREE.Vector3();\n\n\t\treturn function panCamera() {\n\n\t\t\tmouseChange.copy(_panEnd).sub(_panStart);\n\n\t\t\tif (mouseChange.lengthSq()) {\n\n\t\t\t\tmouseChange.multiplyScalar(_eye.length() * _this.panSpeed);\n\n\t\t\t\tpan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);\n\t\t\t\tpan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));\n\n\t\t\t\t_this.object.position.add(pan);\n\t\t\t\t_this.target.add(pan);\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_panStart.copy(_panEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\t_panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}();\n\n\tthis.checkDistances = function () {\n\n\t\tif (!_this.noZoom || !_this.noPan) {\n\n\t\t\tif (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {\n\n\t\t\t\t_this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));\n\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t}\n\n\t\t\tif (_eye.lengthSq() < _this.minDistance * _this.minDistance) {\n\n\t\t\t\t_this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));\n\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.update = function () {\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\tif (!_this.noRotate) {\n\n\t\t\t_this.rotateCamera();\n\t\t}\n\n\t\tif (!_this.noZoom) {\n\n\t\t\t_this.zoomCamera();\n\t\t}\n\n\t\tif (!_this.noPan) {\n\n\t\t\t_this.panCamera();\n\t\t}\n\n\t\t_this.object.position.addVectors(_this.target, _eye);\n\n\t\t_this.checkDistances();\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\tif (lastPosition.distanceToSquared(_this.object.position) > EPS) {\n\n\t\t\t_this.dispatchEvent(changeEvent);\n\n\t\t\tlastPosition.copy(_this.object.position);\n\t\t}\n\t};\n\n\tthis.reset = function () {\n\n\t\t_state = STATE.NONE;\n\t\t_prevState = STATE.NONE;\n\n\t\t_this.target.copy(_this.target0);\n\t\t_this.object.position.copy(_this.position0);\n\t\t_this.object.up.copy(_this.up0);\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\t_this.dispatchEvent(changeEvent);\n\n\t\tlastPosition.copy(_this.object.position);\n\t};\n\n\t// listeners\n\n\tfunction keydown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\twindow.removeEventListener('keydown', keydown);\n\n\t\t_prevState = _state;\n\n\t\tif (_state !== STATE.NONE) {\n\n\t\t\treturn;\n\t\t} else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {\n\n\t\t\t_state = STATE.ROTATE;\n\t\t} else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {\n\n\t\t\t_state = STATE.ZOOM;\n\t\t} else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {\n\n\t\t\t_state = STATE.PAN;\n\t\t}\n\t}\n\n\tfunction keyup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\t_state = _prevState;\n\n\t\twindow.addEventListener('keydown', keydown, false);\n\t}\n\n\tfunction mousedown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.NONE) {\n\n\t\t\t_state = event.button;\n\t\t}\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n\t\t\t_movePrev.copy(_moveCurr);\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_zoomEnd.copy(_zoomStart);\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_panEnd.copy(_panStart);\n\t\t}\n\n\t\tdocument.addEventListener('mousemove', mousemove, false);\n\t\tdocument.addEventListener('mouseup', mouseup, false);\n\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction mousemove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t_moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t}\n\t}\n\n\tfunction mouseup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_state = STATE.NONE;\n\n\t\tdocument.removeEventListener('mousemove', mousemove);\n\t\tdocument.removeEventListener('mouseup', mouseup);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction mousewheel(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tif (_this.noZoom === true) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.deltaMode) {\n\n\t\t\tcase 2:\n\t\t\t\t// Zoom in pages\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.025;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t// Zoom in lines\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.01;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// undefined, 0, assume pixels\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.00025;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent(startEvent);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction touchstart(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// 2 or more\n\t\t\t\t_state = STATE.TOUCH_ZOOM_PAN;\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panStart.copy(getMouseOnScreen(x, y));\n\t\t\t\t_panEnd.copy(_panStart);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction touchmove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t\t_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// 2 or more\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panEnd.copy(getMouseOnScreen(x, y));\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tfunction touchend(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 0:\n\t\t\t\t_state = STATE.NONE;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', mousedown, false);\n\t\tthis.domElement.removeEventListener('wheel', mousewheel, false);\n\n\t\tthis.domElement.removeEventListener('touchstart', touchstart, false);\n\t\tthis.domElement.removeEventListener('touchend', touchend, false);\n\t\tthis.domElement.removeEventListener('touchmove', touchmove, false);\n\n\t\tdocument.removeEventListener('mousemove', mousemove, false);\n\t\tdocument.removeEventListener('mouseup', mouseup, false);\n\n\t\twindow.removeEventListener('keydown', keydown, false);\n\t\twindow.removeEventListener('keyup', keyup, false);\n\t};\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\tthis.domElement.addEventListener('mousedown', mousedown, false);\n\tthis.domElement.addEventListener('wheel', mousewheel, false);\n\n\tthis.domElement.addEventListener('touchstart', touchstart, false);\n\tthis.domElement.addEventListener('touchend', touchend, false);\n\tthis.domElement.addEventListener('touchmove', touchmove, false);\n\n\twindow.addEventListener('keydown', keydown, false);\n\twindow.addEventListener('keyup', keyup, false);\n\n\tthis.handleResize();\n\n\t// force an update at start\n\tthis.update();\n};\n\nTrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nTrackballControls.prototype.constructor = TrackballControls;\n\nexports.default = TrackballControls;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author arodic / https://github.com/arodic\n */\n\nexports.default = function () {\n\n\t'use strict';\n\n\tvar GizmoMaterial = function GizmoMaterial(parameters) {\n\n\t\tTHREE.MeshBasicMaterial.call(this);\n\n\t\tthis.depthTest = false;\n\t\tthis.depthWrite = false;\n\t\tthis.fog = false;\n\t\tthis.side = THREE.FrontSide;\n\t\tthis.transparent = true;\n\n\t\tthis.setValues(parameters);\n\n\t\tthis.oldColor = this.color.clone();\n\t\tthis.oldOpacity = this.opacity;\n\n\t\tthis.highlight = function (highlighted) {\n\n\t\t\tif (highlighted) {\n\n\t\t\t\tthis.color.setRGB(1, 1, 0);\n\t\t\t\tthis.opacity = 1;\n\t\t\t} else {\n\n\t\t\t\tthis.color.copy(this.oldColor);\n\t\t\t\tthis.opacity = this.oldOpacity;\n\t\t\t}\n\t\t};\n\t};\n\n\tGizmoMaterial.prototype = Object.create(THREE.MeshBasicMaterial.prototype);\n\tGizmoMaterial.prototype.constructor = GizmoMaterial;\n\n\tvar GizmoLineMaterial = function GizmoLineMaterial(parameters) {\n\n\t\tTHREE.LineBasicMaterial.call(this);\n\n\t\tthis.depthTest = false;\n\t\tthis.depthWrite = false;\n\t\tthis.fog = false;\n\t\tthis.transparent = true;\n\t\tthis.linewidth = 1;\n\n\t\tthis.setValues(parameters);\n\n\t\tthis.oldColor = this.color.clone();\n\t\tthis.oldOpacity = this.opacity;\n\n\t\tthis.highlight = function (highlighted) {\n\n\t\t\tif (highlighted) {\n\n\t\t\t\tthis.color.setRGB(1, 1, 0);\n\t\t\t\tthis.opacity = 1;\n\t\t\t} else {\n\n\t\t\t\tthis.color.copy(this.oldColor);\n\t\t\t\tthis.opacity = this.oldOpacity;\n\t\t\t}\n\t\t};\n\t};\n\n\tGizmoLineMaterial.prototype = Object.create(THREE.LineBasicMaterial.prototype);\n\tGizmoLineMaterial.prototype.constructor = GizmoLineMaterial;\n\n\tvar pickerMaterial = new GizmoMaterial({ visible: false, transparent: false });\n\n\tvar TransformGizmo = function TransformGizmo() {\n\n\t\tthis.init = function () {\n\n\t\t\tTHREE.Object3D.call(this);\n\n\t\t\tthis.handles = new THREE.Object3D();\n\t\t\tthis.pickers = new THREE.Object3D();\n\t\t\tthis.planes = new THREE.Object3D();\n\n\t\t\tthis.add(this.handles);\n\t\t\tthis.add(this.pickers);\n\t\t\tthis.add(this.planes);\n\n\t\t\t//// PLANES\n\n\t\t\tvar planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 2, 2);\n\t\t\tvar planeMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });\n\n\t\t\tvar planes = {\n\t\t\t\t\"XY\": new THREE.Mesh(planeGeometry, planeMaterial),\n\t\t\t\t\"YZ\": new THREE.Mesh(planeGeometry, planeMaterial),\n\t\t\t\t\"XZ\": new THREE.Mesh(planeGeometry, planeMaterial),\n\t\t\t\t\"XYZE\": new THREE.Mesh(planeGeometry, planeMaterial)\n\t\t\t};\n\n\t\t\tthis.activePlane = planes[\"XYZE\"];\n\n\t\t\tplanes[\"YZ\"].rotation.set(0, Math.PI / 2, 0);\n\t\t\tplanes[\"XZ\"].rotation.set(-Math.PI / 2, 0, 0);\n\n\t\t\tfor (var i in planes) {\n\n\t\t\t\tplanes[i].name = i;\n\t\t\t\tthis.planes.add(planes[i]);\n\t\t\t\tthis.planes[i] = planes[i];\n\t\t\t}\n\n\t\t\t//// HANDLES AND PICKERS\n\n\t\t\tvar setupGizmos = function setupGizmos(gizmoMap, parent) {\n\n\t\t\t\tfor (var name in gizmoMap) {\n\n\t\t\t\t\tfor (i = gizmoMap[name].length; i--;) {\n\n\t\t\t\t\t\tvar object = gizmoMap[name][i][0];\n\t\t\t\t\t\tvar position = gizmoMap[name][i][1];\n\t\t\t\t\t\tvar rotation = gizmoMap[name][i][2];\n\n\t\t\t\t\t\tobject.name = name;\n\n\t\t\t\t\t\tobject.renderOrder = Infinity; // avoid being hidden by other transparent objects\n\n\t\t\t\t\t\tif (position) object.position.set(position[0], position[1], position[2]);\n\t\t\t\t\t\tif (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);\n\n\t\t\t\t\t\tparent.add(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tsetupGizmos(this.handleGizmos, this.handles);\n\t\t\tsetupGizmos(this.pickerGizmos, this.pickers);\n\n\t\t\t// reset Transformations\n\n\t\t\tthis.traverse(function (child) {\n\n\t\t\t\tif (child instanceof THREE.Mesh) {\n\n\t\t\t\t\tchild.updateMatrix();\n\n\t\t\t\t\tvar tempGeometry = child.geometry.clone();\n\t\t\t\t\ttempGeometry.applyMatrix(child.matrix);\n\t\t\t\t\tchild.geometry = tempGeometry;\n\n\t\t\t\t\tchild.position.set(0, 0, 0);\n\t\t\t\t\tchild.rotation.set(0, 0, 0);\n\t\t\t\t\tchild.scale.set(1, 1, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tthis.highlight = function (axis) {\n\n\t\t\tthis.traverse(function (child) {\n\n\t\t\t\tif (child.material && child.material.highlight) {\n\n\t\t\t\t\tif (child.name === axis) {\n\n\t\t\t\t\t\tchild.material.highlight(true);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tchild.material.highlight(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n\n\tTransformGizmo.prototype = Object.create(THREE.Object3D.prototype);\n\tTransformGizmo.prototype.constructor = TransformGizmo;\n\n\tTransformGizmo.prototype.update = function (rotation, eye) {\n\n\t\tvar vec1 = new THREE.Vector3(0, 0, 0);\n\t\tvar vec2 = new THREE.Vector3(0, 1, 0);\n\t\tvar lookAtMatrix = new THREE.Matrix4();\n\n\t\tthis.traverse(function (child) {\n\n\t\t\tif (child.name.search(\"E\") !== -1) {\n\n\t\t\t\tchild.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));\n\t\t\t} else if (child.name.search(\"X\") !== -1 || child.name.search(\"Y\") !== -1 || child.name.search(\"Z\") !== -1) {\n\n\t\t\t\tchild.quaternion.setFromEuler(rotation);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar TransformGizmoTranslate = function TransformGizmoTranslate() {\n\n\t\tTransformGizmo.call(this);\n\n\t\tvar arrowGeometry = new THREE.Geometry();\n\t\tvar mesh = new THREE.Mesh(new THREE.CylinderGeometry(0, 0.05, 0.2, 12, 1, false));\n\t\tmesh.position.y = 0.5;\n\t\tmesh.updateMatrix();\n\n\t\tarrowGeometry.merge(mesh.geometry, mesh.matrix);\n\n\t\tvar lineXGeometry = new THREE.BufferGeometry();\n\t\tlineXGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));\n\n\t\tvar lineYGeometry = new THREE.BufferGeometry();\n\t\tlineYGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n\t\tvar lineZGeometry = new THREE.BufferGeometry();\n\t\tlineZGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n\n\t\tthis.handleGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n\t\t\tY: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n\t\t\tZ: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]]],\n\n\t\t\tXY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]]],\n\n\t\t\tYZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],\n\n\t\t\tXZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]\n\n\t\t};\n\n\t\tthis.pickerGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n\n\t\t\tY: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],\n\n\t\t\tZ: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(0.2, 0), pickerMaterial)]],\n\n\t\t\tXY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0.2, 0]]],\n\n\t\t\tYZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],\n\n\t\t\tXZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]\n\n\t\t};\n\n\t\tthis.setActivePlane = function (axis, eye) {\n\n\t\t\tvar tempMatrix = new THREE.Matrix4();\n\t\t\teye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes[\"XY\"].matrixWorld)));\n\n\t\t\tif (axis === \"X\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\n\t\t\t\tif (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes[\"XZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Y\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Z\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XZ\"];\n\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"XYZ\") this.activePlane = this.planes[\"XYZE\"];\n\n\t\t\tif (axis === \"XY\") this.activePlane = this.planes[\"XY\"];\n\n\t\t\tif (axis === \"YZ\") this.activePlane = this.planes[\"YZ\"];\n\n\t\t\tif (axis === \"XZ\") this.activePlane = this.planes[\"XZ\"];\n\t\t};\n\n\t\tthis.init();\n\t};\n\n\tTransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);\n\tTransformGizmoTranslate.prototype.constructor = TransformGizmoTranslate;\n\n\tvar TransformGizmoRotate = function TransformGizmoRotate() {\n\n\t\tTransformGizmo.call(this);\n\n\t\tvar CircleGeometry = function CircleGeometry(radius, facing, arc) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar vertices = [];\n\t\t\tarc = arc ? arc : 1;\n\n\t\t\tfor (var i = 0; i <= 64 * arc; ++i) {\n\n\t\t\t\tif (facing === 'x') vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);\n\t\t\t\tif (facing === 'y') vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);\n\t\t\t\tif (facing === 'z') vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\t\treturn geometry;\n\t\t};\n\n\t\tthis.handleGizmos = {\n\n\t\t\tX: [[new THREE.Line(new CircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n\t\t\tY: [[new THREE.Line(new CircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n\t\t\tZ: [[new THREE.Line(new CircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n\t\t\tE: [[new THREE.Line(new CircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0xcccc00 }))]],\n\n\t\t\tXYZE: [[new THREE.Line(new CircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0x787878 }))]]\n\n\t\t};\n\n\t\tthis.pickerGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],\n\n\t\t\tY: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [Math.PI / 2, 0, 0]]],\n\n\t\t\tZ: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, 0, -Math.PI / 2]]],\n\n\t\t\tE: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1.25, 0.12, 2, 24), pickerMaterial)]],\n\n\t\t\tXYZE: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 2, 24), pickerMaterial)]]\n\n\t\t};\n\n\t\tthis.pickerGizmos.XYZE[0][0].visible = false; // disable XYZE picker gizmo\n\n\t\tthis.setActivePlane = function (axis) {\n\n\t\t\tif (axis === \"E\") this.activePlane = this.planes[\"XYZE\"];\n\n\t\t\tif (axis === \"X\") this.activePlane = this.planes[\"YZ\"];\n\n\t\t\tif (axis === \"Y\") this.activePlane = this.planes[\"XZ\"];\n\n\t\t\tif (axis === \"Z\") this.activePlane = this.planes[\"XY\"];\n\t\t};\n\n\t\tthis.update = function (rotation, eye2) {\n\n\t\t\tTransformGizmo.prototype.update.apply(this, arguments);\n\n\t\t\tvar tempMatrix = new THREE.Matrix4();\n\t\t\tvar worldRotation = new THREE.Euler(0, 0, 1);\n\t\t\tvar tempQuaternion = new THREE.Quaternion();\n\t\t\tvar unitX = new THREE.Vector3(1, 0, 0);\n\t\t\tvar unitY = new THREE.Vector3(0, 1, 0);\n\t\t\tvar unitZ = new THREE.Vector3(0, 0, 1);\n\t\t\tvar quaternionX = new THREE.Quaternion();\n\t\t\tvar quaternionY = new THREE.Quaternion();\n\t\t\tvar quaternionZ = new THREE.Quaternion();\n\t\t\tvar eye = eye2.clone();\n\n\t\t\tworldRotation.copy(this.planes[\"XY\"].rotation);\n\t\t\ttempQuaternion.setFromEuler(worldRotation);\n\n\t\t\ttempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);\n\t\t\teye.applyMatrix4(tempMatrix);\n\n\t\t\tthis.traverse(function (child) {\n\n\t\t\t\ttempQuaternion.setFromEuler(worldRotation);\n\n\t\t\t\tif (child.name === \"X\") {\n\n\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n\t\t\t\t\tchild.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\n\t\t\t\tif (child.name === \"Y\") {\n\n\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);\n\t\t\t\t\tchild.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\n\t\t\t\tif (child.name === \"Z\") {\n\n\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);\n\t\t\t\t\tchild.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tthis.init();\n\t};\n\n\tTransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);\n\tTransformGizmoRotate.prototype.constructor = TransformGizmoRotate;\n\n\tvar TransformGizmoScale = function TransformGizmoScale() {\n\n\t\tTransformGizmo.call(this);\n\n\t\tvar arrowGeometry = new THREE.Geometry();\n\t\tvar mesh = new THREE.Mesh(new THREE.BoxGeometry(0.125, 0.125, 0.125));\n\t\tmesh.position.y = 0.5;\n\t\tmesh.updateMatrix();\n\n\t\tarrowGeometry.merge(mesh.geometry, mesh.matrix);\n\n\t\tvar lineXGeometry = new THREE.BufferGeometry();\n\t\tlineXGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));\n\n\t\tvar lineYGeometry = new THREE.BufferGeometry();\n\t\tlineYGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n\t\tvar lineZGeometry = new THREE.BufferGeometry();\n\t\tlineZGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n\n\t\tthis.handleGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n\t\t\tY: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n\t\t\tZ: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]]\n\n\t\t};\n\n\t\tthis.pickerGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n\n\t\t\tY: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],\n\n\t\t\tZ: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.4, 0.4, 0.4), pickerMaterial)]]\n\n\t\t};\n\n\t\tthis.setActivePlane = function (axis, eye) {\n\n\t\t\tvar tempMatrix = new THREE.Matrix4();\n\t\t\teye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes[\"XY\"].matrixWorld)));\n\n\t\t\tif (axis === \"X\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\t\t\t\tif (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes[\"XZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Y\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Z\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XZ\"];\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"XYZ\") this.activePlane = this.planes[\"XYZE\"];\n\t\t};\n\n\t\tthis.init();\n\t};\n\n\tTransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);\n\tTransformGizmoScale.prototype.constructor = TransformGizmoScale;\n\n\tvar TransformControls = function TransformControls(camera, domElement) {\n\n\t\t// TODO: Make non-uniform scale and rotate play nice in hierarchies\n\t\t// TODO: ADD RXYZ contol\n\n\t\tTHREE.Object3D.call(this);\n\n\t\tdomElement = domElement !== undefined ? domElement : document;\n\n\t\tthis.object = undefined;\n\t\tthis.visible = false;\n\t\tthis.translationSnap = null;\n\t\tthis.rotationSnap = null;\n\t\tthis.space = \"world\";\n\t\tthis.size = 1;\n\t\tthis.axis = null;\n\n\t\tvar scope = this;\n\n\t\tvar _mode = \"translate\";\n\t\tvar _dragging = false;\n\t\tvar _gizmo = {\n\n\t\t\t\"translate\": new TransformGizmoTranslate(),\n\t\t\t\"rotate\": new TransformGizmoRotate(),\n\t\t\t\"scale\": new TransformGizmoScale()\n\t\t};\n\n\t\tfor (var type in _gizmo) {\n\n\t\t\tvar gizmoObj = _gizmo[type];\n\n\t\t\tgizmoObj.visible = type === _mode;\n\t\t\tthis.add(gizmoObj);\n\t\t}\n\n\t\tvar changeEvent = { type: \"change\" };\n\t\tvar mouseDownEvent = { type: \"mouseDown\" };\n\t\tvar mouseUpEvent = { type: \"mouseUp\", mode: _mode };\n\t\tvar objectChangeEvent = { type: \"objectChange\" };\n\n\t\tvar ray = new THREE.Raycaster();\n\t\tvar pointerVector = new THREE.Vector2();\n\n\t\tvar point = new THREE.Vector3();\n\t\tvar offset = new THREE.Vector3();\n\n\t\tvar rotation = new THREE.Vector3();\n\t\tvar offsetRotation = new THREE.Vector3();\n\t\tvar scale = 1;\n\n\t\tvar lookAtMatrix = new THREE.Matrix4();\n\t\tvar eye = new THREE.Vector3();\n\n\t\tvar tempMatrix = new THREE.Matrix4();\n\t\tvar tempVector = new THREE.Vector3();\n\t\tvar tempQuaternion = new THREE.Quaternion();\n\t\tvar unitX = new THREE.Vector3(1, 0, 0);\n\t\tvar unitY = new THREE.Vector3(0, 1, 0);\n\t\tvar unitZ = new THREE.Vector3(0, 0, 1);\n\n\t\tvar quaternionXYZ = new THREE.Quaternion();\n\t\tvar quaternionX = new THREE.Quaternion();\n\t\tvar quaternionY = new THREE.Quaternion();\n\t\tvar quaternionZ = new THREE.Quaternion();\n\t\tvar quaternionE = new THREE.Quaternion();\n\n\t\tvar oldPosition = new THREE.Vector3();\n\t\tvar oldScale = new THREE.Vector3();\n\t\tvar oldRotationMatrix = new THREE.Matrix4();\n\n\t\tvar parentRotationMatrix = new THREE.Matrix4();\n\t\tvar parentScale = new THREE.Vector3();\n\n\t\tvar worldPosition = new THREE.Vector3();\n\t\tvar worldRotation = new THREE.Euler();\n\t\tvar worldRotationMatrix = new THREE.Matrix4();\n\t\tvar camPosition = new THREE.Vector3();\n\t\tvar camRotation = new THREE.Euler();\n\n\t\tdomElement.addEventListener(\"mousedown\", onPointerDown, false);\n\t\tdomElement.addEventListener(\"touchstart\", onPointerDown, false);\n\n\t\tdomElement.addEventListener(\"mousemove\", onPointerHover, false);\n\t\tdomElement.addEventListener(\"touchmove\", onPointerHover, false);\n\n\t\tdomElement.addEventListener(\"mousemove\", onPointerMove, false);\n\t\tdomElement.addEventListener(\"touchmove\", onPointerMove, false);\n\n\t\tdomElement.addEventListener(\"mouseup\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"mouseout\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"touchend\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"touchcancel\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"touchleave\", onPointerUp, false);\n\n\t\tthis.dispose = function () {\n\n\t\t\tdomElement.removeEventListener(\"mousedown\", onPointerDown);\n\t\t\tdomElement.removeEventListener(\"touchstart\", onPointerDown);\n\n\t\t\tdomElement.removeEventListener(\"mousemove\", onPointerHover);\n\t\t\tdomElement.removeEventListener(\"touchmove\", onPointerHover);\n\n\t\t\tdomElement.removeEventListener(\"mousemove\", onPointerMove);\n\t\t\tdomElement.removeEventListener(\"touchmove\", onPointerMove);\n\n\t\t\tdomElement.removeEventListener(\"mouseup\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"mouseout\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"touchend\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"touchcancel\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"touchleave\", onPointerUp);\n\t\t};\n\n\t\tthis.attach = function (object) {\n\n\t\t\tthis.object = object;\n\t\t\tthis.visible = true;\n\t\t\tthis.update();\n\t\t};\n\n\t\tthis.detach = function () {\n\n\t\t\tthis.object = undefined;\n\t\t\tthis.visible = false;\n\t\t\tthis.axis = null;\n\t\t};\n\n\t\tthis.getMode = function () {\n\n\t\t\treturn _mode;\n\t\t};\n\n\t\tthis.setMode = function (mode) {\n\n\t\t\t_mode = mode ? mode : _mode;\n\n\t\t\tif (_mode === \"scale\") scope.space = \"local\";\n\n\t\t\tfor (var type in _gizmo) {\n\t\t\t\t_gizmo[type].visible = type === _mode;\n\t\t\t}this.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t};\n\n\t\tthis.setTranslationSnap = function (translationSnap) {\n\n\t\t\tscope.translationSnap = translationSnap;\n\t\t};\n\n\t\tthis.setRotationSnap = function (rotationSnap) {\n\n\t\t\tscope.rotationSnap = rotationSnap;\n\t\t};\n\n\t\tthis.setSize = function (size) {\n\n\t\t\tscope.size = size;\n\t\t\tthis.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t};\n\n\t\tthis.setSpace = function (space) {\n\n\t\t\tscope.space = space;\n\t\t\tthis.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t};\n\n\t\tthis.update = function () {\n\n\t\t\tif (scope.object === undefined) return;\n\n\t\t\tscope.object.updateMatrixWorld();\n\t\t\tworldPosition.setFromMatrixPosition(scope.object.matrixWorld);\n\t\t\tworldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tcamPosition.setFromMatrixPosition(camera.matrixWorld);\n\t\t\tcamRotation.setFromRotationMatrix(tempMatrix.extractRotation(camera.matrixWorld));\n\n\t\t\tscale = worldPosition.distanceTo(camPosition) / 6 * scope.size;\n\t\t\tthis.position.copy(worldPosition);\n\t\t\tthis.scale.set(scale, scale, scale);\n\n\t\t\tif (camera instanceof THREE.PerspectiveCamera) {\n\n\t\t\t\teye.copy(camPosition).sub(worldPosition).normalize();\n\t\t\t} else if (camera instanceof THREE.OrthographicCamera) {\n\n\t\t\t\teye.copy(camPosition).normalize();\n\t\t\t}\n\n\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t_gizmo[_mode].update(worldRotation, eye);\n\t\t\t} else if (scope.space === \"world\") {\n\n\t\t\t\t_gizmo[_mode].update(new THREE.Euler(), eye);\n\t\t\t}\n\n\t\t\t_gizmo[_mode].highlight(scope.axis);\n\t\t};\n\n\t\tfunction onPointerHover(event) {\n\n\t\t\tif (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[0] : event;\n\n\t\t\tvar intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);\n\n\t\t\tvar axis = null;\n\n\t\t\tif (intersect) {\n\n\t\t\t\taxis = intersect.object.name;\n\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\tif (scope.axis !== axis) {\n\n\t\t\t\tscope.axis = axis;\n\t\t\t\tscope.update();\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\t\t\t}\n\t\t}\n\n\t\tfunction onPointerDown(event) {\n\n\t\t\tif (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[0] : event;\n\n\t\t\tif (pointer.button === 0 || pointer.button === undefined) {\n\n\t\t\t\tvar intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);\n\n\t\t\t\tif (intersect) {\n\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopPropagation();\n\n\t\t\t\t\tscope.axis = intersect.object.name;\n\n\t\t\t\t\tscope.dispatchEvent(mouseDownEvent);\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\teye.copy(camPosition).sub(worldPosition).normalize();\n\n\t\t\t\t\t_gizmo[_mode].setActivePlane(scope.axis, eye);\n\n\t\t\t\t\tvar planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);\n\n\t\t\t\t\tif (planeIntersect) {\n\n\t\t\t\t\t\toldPosition.copy(scope.object.position);\n\t\t\t\t\t\toldScale.copy(scope.object.scale);\n\n\t\t\t\t\t\toldRotationMatrix.extractRotation(scope.object.matrix);\n\t\t\t\t\t\tworldRotationMatrix.extractRotation(scope.object.matrixWorld);\n\n\t\t\t\t\t\tparentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);\n\t\t\t\t\t\tparentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));\n\n\t\t\t\t\t\toffset.copy(planeIntersect.point);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_dragging = true;\n\t\t}\n\n\t\tfunction onPointerMove(event) {\n\n\t\t\tif (scope.object === undefined || scope.axis === null || _dragging === false || event.button !== undefined && event.button !== 0) return;\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[0] : event;\n\n\t\t\tvar planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);\n\n\t\t\tif (planeIntersect === false) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tpoint.copy(planeIntersect.point);\n\n\t\t\tif (_mode === \"translate\") {\n\n\t\t\t\tpoint.sub(offset);\n\t\t\t\tpoint.multiply(parentScale);\n\n\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\tif (scope.axis.search(\"X\") === -1) point.x = 0;\n\t\t\t\t\tif (scope.axis.search(\"Y\") === -1) point.y = 0;\n\t\t\t\t\tif (scope.axis.search(\"Z\") === -1) point.z = 0;\n\n\t\t\t\t\tpoint.applyMatrix4(oldRotationMatrix);\n\n\t\t\t\t\tscope.object.position.copy(oldPosition);\n\t\t\t\t\tscope.object.position.add(point);\n\t\t\t\t}\n\n\t\t\t\tif (scope.space === \"world\" || scope.axis.search(\"XYZ\") !== -1) {\n\n\t\t\t\t\tif (scope.axis.search(\"X\") === -1) point.x = 0;\n\t\t\t\t\tif (scope.axis.search(\"Y\") === -1) point.y = 0;\n\t\t\t\t\tif (scope.axis.search(\"Z\") === -1) point.z = 0;\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));\n\n\t\t\t\t\tscope.object.position.copy(oldPosition);\n\t\t\t\t\tscope.object.position.add(point);\n\t\t\t\t}\n\n\t\t\t\tif (scope.translationSnap !== null) {\n\n\t\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\t\tscope.object.position.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scope.axis.search(\"X\") !== -1) scope.object.position.x = Math.round(scope.object.position.x / scope.translationSnap) * scope.translationSnap;\n\t\t\t\t\tif (scope.axis.search(\"Y\") !== -1) scope.object.position.y = Math.round(scope.object.position.y / scope.translationSnap) * scope.translationSnap;\n\t\t\t\t\tif (scope.axis.search(\"Z\") !== -1) scope.object.position.z = Math.round(scope.object.position.z / scope.translationSnap) * scope.translationSnap;\n\n\t\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\t\tscope.object.position.applyMatrix4(worldRotationMatrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (_mode === \"scale\") {\n\n\t\t\t\tpoint.sub(offset);\n\t\t\t\tpoint.multiply(parentScale);\n\n\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\tif (scope.axis === \"XYZ\") {\n\n\t\t\t\t\t\tscale = 1 + point.y / Math.max(oldScale.x, oldScale.y, oldScale.z);\n\n\t\t\t\t\t\tscope.object.scale.x = oldScale.x * scale;\n\t\t\t\t\t\tscope.object.scale.y = oldScale.y * scale;\n\t\t\t\t\t\tscope.object.scale.z = oldScale.z * scale;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\t\tif (scope.axis === \"X\") scope.object.scale.x = oldScale.x * (1 + point.x / oldScale.x);\n\t\t\t\t\t\tif (scope.axis === \"Y\") scope.object.scale.y = oldScale.y * (1 + point.y / oldScale.y);\n\t\t\t\t\t\tif (scope.axis === \"Z\") scope.object.scale.z = oldScale.z * (1 + point.z / oldScale.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (_mode === \"rotate\") {\n\n\t\t\t\tpoint.sub(worldPosition);\n\t\t\t\tpoint.multiply(parentScale);\n\t\t\t\ttempVector.copy(offset).sub(worldPosition);\n\t\t\t\ttempVector.multiply(parentScale);\n\n\t\t\t\tif (scope.axis === \"E\") {\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));\n\t\t\t\t\ttempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));\n\n\t\t\t\t\trotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));\n\t\t\t\t\toffsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));\n\n\t\t\t\t\ttempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\n\t\t\t\t\tquaternionE.setFromAxisAngle(eye, rotation.z - offsetRotation.z);\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(tempQuaternion);\n\t\t\t\t} else if (scope.axis === \"XYZE\") {\n\n\t\t\t\t\tquaternionE.setFromEuler(point.clone().cross(tempVector).normalize()); // rotation axis\n\n\t\t\t\t\ttempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\t\t\t\t\tquaternionX.setFromAxisAngle(quaternionE, -point.clone().angleTo(tempVector));\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(tempQuaternion);\n\t\t\t\t} else if (scope.space === \"local\") {\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\ttempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\trotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));\n\t\t\t\t\toffsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));\n\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(oldRotationMatrix);\n\n\t\t\t\t\tif (scope.rotationSnap !== null) {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scope.axis === \"X\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);\n\t\t\t\t\tif (scope.axis === \"Y\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);\n\t\t\t\t\tif (scope.axis === \"Z\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(quaternionXYZ);\n\t\t\t\t} else if (scope.space === \"world\") {\n\n\t\t\t\t\trotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));\n\t\t\t\t\toffsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));\n\n\t\t\t\t\ttempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\n\t\t\t\t\tif (scope.rotationSnap !== null) {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n\t\t\t\t\tif (scope.axis === \"X\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n\t\t\t\t\tif (scope.axis === \"Y\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);\n\t\t\t\t\tif (scope.axis === \"Z\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);\n\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscope.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t\tscope.dispatchEvent(objectChangeEvent);\n\t\t}\n\n\t\tfunction onPointerUp(event) {\n\n\t\t\tevent.preventDefault(); // Prevent MouseEvent on mobile\n\n\t\t\tif (event.button !== undefined && event.button !== 0) return;\n\n\t\t\tif (_dragging && scope.axis !== null) {\n\n\t\t\t\tmouseUpEvent.mode = _mode;\n\t\t\t\tscope.dispatchEvent(mouseUpEvent);\n\t\t\t}\n\n\t\t\t_dragging = false;\n\n\t\t\tif ('TouchEvent' in window && event instanceof TouchEvent) {\n\n\t\t\t\t// Force \"rollover\"\n\n\t\t\t\tscope.axis = null;\n\t\t\t\tscope.update();\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\t\t\t} else {\n\n\t\t\t\tonPointerHover(event);\n\t\t\t}\n\t\t}\n\n\t\tfunction intersectObjects(pointer, objects) {\n\n\t\t\tvar rect = domElement.getBoundingClientRect();\n\t\t\tvar x = (pointer.clientX - rect.left) / rect.width;\n\t\t\tvar y = (pointer.clientY - rect.top) / rect.height;\n\n\t\t\tpointerVector.set(x * 2 - 1, -(y * 2) + 1);\n\t\t\tray.setFromCamera(pointerVector, camera);\n\n\t\t\tvar intersections = ray.intersectObjects(objects, true);\n\t\t\treturn intersections[0] ? intersections[0] : false;\n\t\t}\n\t};\n\n\tTransformControls.prototype = Object.create(THREE.Object3D.prototype);\n\tTransformControls.prototype.constructor = TransformControls;\n\n\treturn TransformControls;\n}();\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author dmarcos / https://github.com/dmarcos\n * @author mrdoob / http://mrdoob.com\n */\n\nvar VRControls = function VRControls(object, onError) {\n\n\tvar scope = this;\n\n\tvar vrDisplay, vrDisplays;\n\n\tvar standingMatrix = new THREE.Matrix4();\n\n\tvar frameData = null;\n\n\tif ('VRFrameData' in window) {\n\n\t\tframeData = new VRFrameData();\n\t}\n\n\tfunction gotVRDisplays(displays) {\n\n\t\tvrDisplays = displays;\n\n\t\tif (displays.length > 0) {\n\n\t\t\tvrDisplay = displays[0];\n\t\t} else {\n\n\t\t\tif (onError) onError('VR input not available.');\n\t\t}\n\t}\n\n\tif (navigator.getVRDisplays) {\n\n\t\tnavigator.getVRDisplays().then(gotVRDisplays).catch(function () {\n\n\t\t\tconsole.warn('THREE.VRControls: Unable to get VR Displays');\n\t\t});\n\t}\n\n\t// the Rift SDK returns the position in meters\n\t// this scale factor allows the user to define how meters\n\t// are converted to scene units.\n\n\tthis.scale = 1;\n\n\t// If true will use \"standing space\" coordinate system where y=0 is the\n\t// floor and x=0, z=0 is the center of the room.\n\tthis.standing = false;\n\n\t// Distance from the users eyes to the floor in meters. Used when\n\t// standing=true but the VRDisplay doesn't provide stageParameters.\n\tthis.userHeight = 1.6;\n\n\tthis.getVRDisplay = function () {\n\n\t\treturn vrDisplay;\n\t};\n\n\tthis.setVRDisplay = function (value) {\n\n\t\tvrDisplay = value;\n\t};\n\n\tthis.getVRDisplays = function () {\n\n\t\tconsole.warn('THREE.VRControls: getVRDisplays() is being deprecated.');\n\t\treturn vrDisplays;\n\t};\n\n\tthis.getStandingMatrix = function () {\n\n\t\treturn standingMatrix;\n\t};\n\n\tthis.update = function () {\n\n\t\tif (vrDisplay) {\n\n\t\t\tvar pose;\n\n\t\t\tif (vrDisplay.getFrameData) {\n\n\t\t\t\tvrDisplay.getFrameData(frameData);\n\t\t\t\tpose = frameData.pose;\n\t\t\t} else if (vrDisplay.getPose) {\n\n\t\t\t\tpose = vrDisplay.getPose();\n\t\t\t}\n\n\t\t\tif (pose.orientation !== null) {\n\n\t\t\t\tobject.quaternion.fromArray(pose.orientation);\n\t\t\t}\n\n\t\t\tif (pose.position !== null) {\n\n\t\t\t\tobject.position.fromArray(pose.position);\n\t\t\t} else {\n\n\t\t\t\tobject.position.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tif (this.standing) {\n\n\t\t\t\tif (vrDisplay.stageParameters) {\n\n\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\tstandingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);\n\t\t\t\t\tobject.applyMatrix(standingMatrix);\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.position.setY(object.position.y + this.userHeight);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobject.position.multiplyScalar(scope.scale);\n\t\t}\n\t};\n\n\tthis.dispose = function () {\n\n\t\tvrDisplay = null;\n\t};\n};\n\nexports.default = VRControls;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypedGeometryExporter = exports.STLExporter = exports.STLBinaryExporter = exports.PLYExporter = exports.OBJExporter = exports.MMDExporter = exports.GLTFExporter = undefined;\n\nvar _GLTFExporter = __webpack_require__(41);\n\nvar _GLTFExporter2 = _interopRequireDefault(_GLTFExporter);\n\nvar _MMDExporter = __webpack_require__(42);\n\nvar _MMDExporter2 = _interopRequireDefault(_MMDExporter);\n\nvar _OBJExporter = __webpack_require__(43);\n\nvar _OBJExporter2 = _interopRequireDefault(_OBJExporter);\n\nvar _PLYExporter = __webpack_require__(44);\n\nvar _PLYExporter2 = _interopRequireDefault(_PLYExporter);\n\nvar _STLBinaryExporter = __webpack_require__(45);\n\nvar _STLBinaryExporter2 = _interopRequireDefault(_STLBinaryExporter);\n\nvar _STLExporter = __webpack_require__(46);\n\nvar _STLExporter2 = _interopRequireDefault(_STLExporter);\n\nvar _TypedGeometryExporter = __webpack_require__(47);\n\nvar _TypedGeometryExporter2 = _interopRequireDefault(_TypedGeometryExporter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.GLTFExporter = _GLTFExporter2.default;\nexports.MMDExporter = _MMDExporter2.default;\nexports.OBJExporter = _OBJExporter2.default;\nexports.PLYExporter = _PLYExporter2.default;\nexports.STLBinaryExporter = _STLBinaryExporter2.default;\nexports.STLExporter = _STLExporter2.default;\nexports.TypedGeometryExporter = _TypedGeometryExporter2.default;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author fernandojsg / http://fernandojsg.com\n * @author Don McCurdy / https://www.donmccurdy.com\n * @author Takahiro / https://github.com/takahirox\n */\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\nvar WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tUNSIGNED_BYTE: 0x1401,\n\tUNSIGNED_SHORT: 0x1403,\n\tFLOAT: 0x1406,\n\tUNSIGNED_INT: 0x1405,\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703\n};\n\nvar THREE_TO_WEBGL = {\n\t// @TODO Replace with computed property name [THREE.*] when available on es6\n\t1003: WEBGL_CONSTANTS.NEAREST,\n\t1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,\n\t1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,\n\t1006: WEBGL_CONSTANTS.LINEAR,\n\t1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,\n\t1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\n};\n\nvar PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\n//------------------------------------------------------------------------------\n// GLTF Exporter\n//------------------------------------------------------------------------------\nvar GLTFExporter = function GLTFExporter() {};\n\nGLTFExporter.prototype = {\n\n\tconstructor: GLTFExporter,\n\n\t/**\n  * Parse scenes and generate GLTF output\n  * @param  {THREE.Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes\n  * @param  {Function} onDone  Callback on completed\n  * @param  {Object} options options\n  */\n\tparse: function parse(input, onDone, options) {\n\n\t\tvar DEFAULT_OPTIONS = {\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\ttruncateDrawRange: true,\n\t\t\tembedImages: true,\n\t\t\tanimations: [],\n\t\t\tforceIndices: false,\n\t\t\tforcePowerOfTwoTextures: false\n\t\t};\n\n\t\toptions = Object.assign({}, DEFAULT_OPTIONS, options);\n\n\t\tif (options.animations.length > 0) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\toptions.trs = true;\n\t\t}\n\n\t\tvar outputJSON = {\n\n\t\t\tasset: {\n\n\t\t\t\tversion: \"2.0\",\n\t\t\t\tgenerator: \"THREE.GLTFExporter\"\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar byteOffset = 0;\n\t\tvar buffers = [];\n\t\tvar pending = [];\n\t\tvar nodeMap = new Map();\n\t\tvar skins = [];\n\t\tvar extensionsUsed = {};\n\t\tvar cachedData = {\n\n\t\t\tattributes: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map()\n\n\t\t};\n\n\t\tvar cachedCanvas;\n\n\t\t/**\n   * Compare two arrays\n   */\n\t\t/**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\t\tfunction equalArray(array1, array2) {\n\n\t\t\treturn array1.length === array2.length && array1.every(function (element, index) {\n\n\t\t\t\treturn element === array2[index];\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\t\tfunction stringToArrayBuffer(text) {\n\n\t\t\tif (window.TextEncoder !== undefined) {\n\n\t\t\t\treturn new TextEncoder().encode(text).buffer;\n\t\t\t}\n\n\t\t\tvar array = new Uint8Array(new ArrayBuffer(text.length));\n\n\t\t\tfor (var i = 0, il = text.length; i < il; i++) {\n\n\t\t\t\tvar value = text.charCodeAt(i);\n\n\t\t\t\t// Replacing multi-byte character with space(0x20).\n\t\t\t\tarray[i] = value > 0xFF ? 0x20 : value;\n\t\t\t}\n\n\t\t\treturn array.buffer;\n\t\t}\n\n\t\t/**\n   * Get the min and max vectors from the given attribute\n   * @param  {THREE.BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n   * @param  {Integer} start\n   * @param  {Integer} count\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n   */\n\t\tfunction getMinMax(attribute, start, count) {\n\n\t\t\tvar output = {\n\n\t\t\t\tmin: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n\t\t\t\tmax: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n\n\t\t\t};\n\n\t\t\tfor (var i = start; i < start + count; i++) {\n\n\t\t\t\tfor (var a = 0; a < attribute.itemSize; a++) {\n\n\t\t\t\t\tvar value = attribute.array[i * attribute.itemSize + a];\n\t\t\t\t\toutput.min[a] = Math.min(output.min[a], value);\n\t\t\t\t\toutput.max[a] = Math.max(output.max[a], value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n   * Checks if image size is POT.\n   *\n   * @param {Image} image The image to be checked.\n   * @returns {Boolean} Returns true if image size is POT.\n   *\n   */\n\t\tfunction isPowerOfTwo(image) {\n\n\t\t\treturn THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);\n\t\t}\n\n\t\t/**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {THREE.BufferAttribute} normal\n   * @returns {Boolean}\n   *\n   */\n\t\tfunction isNormalizedNormalAttribute(normal) {\n\n\t\t\tif (cachedData.attributes.has(normal)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\tfor (var i = 0, il = normal.count; i < il; i++) {\n\n\t\t\t\t// 0.0005 is from glTF-validator\n\t\t\t\tif (Math.abs(v.fromArray(normal.array, i * 3).length() - 1.0) > 0.0005) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {THREE.BufferAttribute} normal\n   * @returns {THREE.BufferAttribute}\n   *\n   */\n\t\tfunction createNormalizedNormalAttribute(normal) {\n\n\t\t\tif (cachedData.attributes.has(normal)) {\n\n\t\t\t\treturn cachedData.textures.get(normal);\n\t\t\t}\n\n\t\t\tvar attribute = normal.clone();\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\tfor (var i = 0, il = attribute.count; i < il; i++) {\n\n\t\t\t\tv.fromArray(attribute.array, i * 3);\n\n\t\t\t\tif (v.x === 0 && v.y === 0 && v.z === 0) {\n\n\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\t\tv.setX(1.0);\n\t\t\t\t} else {\n\n\t\t\t\t\tv.normalize();\n\t\t\t\t}\n\n\t\t\t\tv.toArray(attribute.array, i * 3);\n\t\t\t}\n\n\t\t\tcachedData.attributes.set(normal, attribute);\n\n\t\t\treturn attribute;\n\t\t}\n\n\t\t/**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   *\n   * @param {Integer} bufferSize The size the original buffer.\n   * @returns {Integer} new buffer size with required padding.\n   *\n   */\n\t\tfunction getPaddedBufferSize(bufferSize) {\n\n\t\t\treturn Math.ceil(bufferSize / 4) * 4;\n\t\t}\n\n\t\t/**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\t\tfunction getPaddedArrayBuffer(arrayBuffer, paddingByte) {\n\n\t\t\tpaddingByte = paddingByte || 0;\n\n\t\t\tvar paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n\t\t\tif (paddedLength !== arrayBuffer.byteLength) {\n\n\t\t\t\tvar array = new Uint8Array(paddedLength);\n\t\t\t\tarray.set(new Uint8Array(arrayBuffer));\n\n\t\t\t\tif (paddingByte !== 0) {\n\n\t\t\t\t\tfor (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n\n\t\t\t\t\t\tarray[i] = paddingByte;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn array.buffer;\n\t\t\t}\n\n\t\t\treturn arrayBuffer;\n\t\t}\n\n\t\t/**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n\t\tfunction processBuffer(buffer) {\n\n\t\t\tif (!outputJSON.buffers) {\n\n\t\t\t\toutputJSON.buffers = [{ byteLength: 0 }];\n\t\t\t}\n\n\t\t\t// All buffers are merged before export.\n\t\t\tbuffers.push(buffer);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/**\n   * Process and generate a BufferView\n   * @param  {THREE.BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n\t\tfunction processBufferView(attribute, componentType, start, count, target) {\n\n\t\t\tif (!outputJSON.bufferViews) {\n\n\t\t\t\toutputJSON.bufferViews = [];\n\t\t\t}\n\n\t\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\t\tvar componentSize;\n\n\t\t\tif (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n\n\t\t\t\tcomponentSize = 1;\n\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n\n\t\t\t\tcomponentSize = 2;\n\t\t\t} else {\n\n\t\t\t\tcomponentSize = 4;\n\t\t\t}\n\n\t\t\tvar byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n\t\t\tvar dataView = new DataView(new ArrayBuffer(byteLength));\n\t\t\tvar offset = 0;\n\n\t\t\tfor (var i = start; i < start + count; i++) {\n\n\t\t\t\tfor (var a = 0; a < attribute.itemSize; a++) {\n\n\t\t\t\t\t// @TODO Fails on InterleavedBufferAttribute, and could probably be\n\t\t\t\t\t// optimized for normal BufferAttribute.\n\t\t\t\t\tvar value = attribute.array[i * attribute.itemSize + a];\n\n\t\t\t\t\tif (componentType === WEBGL_CONSTANTS.FLOAT) {\n\n\t\t\t\t\t\tdataView.setFloat32(offset, value, true);\n\t\t\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n\n\t\t\t\t\t\tdataView.setUint32(offset, value, true);\n\t\t\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n\n\t\t\t\t\t\tdataView.setUint16(offset, value, true);\n\t\t\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n\n\t\t\t\t\t\tdataView.setUint8(offset, value);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += componentSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar gltfBufferView = {\n\n\t\t\t\tbuffer: processBuffer(dataView.buffer),\n\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\tbyteLength: byteLength\n\n\t\t\t};\n\n\t\t\tif (target !== undefined) gltfBufferView.target = target;\n\n\t\t\tif (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n\n\t\t\t\t// Only define byteStride for vertex attributes.\n\t\t\t\tgltfBufferView.byteStride = attribute.itemSize * componentSize;\n\t\t\t}\n\n\t\t\tbyteOffset += byteLength;\n\n\t\t\toutputJSON.bufferViews.push(gltfBufferView);\n\n\t\t\t// @TODO Merge bufferViews where possible.\n\t\t\tvar output = {\n\n\t\t\t\tid: outputJSON.bufferViews.length - 1,\n\t\t\t\tbyteLength: 0\n\n\t\t\t};\n\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n\t\tfunction processBufferViewImage(blob) {\n\n\t\t\tif (!outputJSON.bufferViews) {\n\n\t\t\t\toutputJSON.bufferViews = [];\n\t\t\t}\n\n\t\t\treturn new Promise(function (resolve) {\n\n\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tvar buffer = getPaddedArrayBuffer(reader.result);\n\n\t\t\t\t\tvar bufferView = {\n\t\t\t\t\t\tbuffer: processBuffer(buffer),\n\t\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t\t};\n\n\t\t\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t\t\t\toutputJSON.bufferViews.push(bufferView);\n\n\t\t\t\t\tresolve(outputJSON.bufferViews.length - 1);\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Process attribute to generate an accessor\n   * @param  {THREE.BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer}           Index of the processed accessor on the \"accessors\" array\n   */\n\t\tfunction processAccessor(attribute, geometry, start, count) {\n\n\t\t\tvar types = {\n\n\t\t\t\t1: 'SCALAR',\n\t\t\t\t2: 'VEC2',\n\t\t\t\t3: 'VEC3',\n\t\t\t\t4: 'VEC4',\n\t\t\t\t16: 'MAT4'\n\n\t\t\t};\n\n\t\t\tvar componentType;\n\n\t\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\t\tif (attribute.array.constructor === Float32Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\t\t\t} else if (attribute.array.constructor === Uint32Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\t\t\t} else if (attribute.array.constructor === Uint16Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\t\t\t} else if (attribute.array.constructor === Uint8Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n\t\t\t}\n\n\t\t\tif (start === undefined) start = 0;\n\t\t\tif (count === undefined) count = attribute.count;\n\n\t\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\t\tif (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n\n\t\t\t\tvar end = start + count;\n\t\t\t\tvar end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\t\tstart = Math.max(start, geometry.drawRange.start);\n\t\t\t\tcount = Math.min(end, end2) - start;\n\n\t\t\t\tif (count < 0) count = 0;\n\t\t\t}\n\n\t\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\t\tif (count === 0) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar minMax = getMinMax(attribute, start, count);\n\n\t\t\tvar bufferViewTarget;\n\n\t\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t\t// animation samplers, target must not be set.\n\t\t\tif (geometry !== undefined) {\n\n\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\t\t\t}\n\n\t\t\tvar bufferView = processBufferView(attribute, componentType, start, count, bufferViewTarget);\n\n\t\t\tvar gltfAccessor = {\n\n\t\t\t\tbufferView: bufferView.id,\n\t\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\t\tcomponentType: componentType,\n\t\t\t\tcount: count,\n\t\t\t\tmax: minMax.max,\n\t\t\t\tmin: minMax.min,\n\t\t\t\ttype: types[attribute.itemSize]\n\n\t\t\t};\n\n\t\t\tif (!outputJSON.accessors) {\n\n\t\t\t\toutputJSON.accessors = [];\n\t\t\t}\n\n\t\t\toutputJSON.accessors.push(gltfAccessor);\n\n\t\t\treturn outputJSON.accessors.length - 1;\n\t\t}\n\n\t\t/**\n   * Process image\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n\t\tfunction processImage(map) {\n\n\t\t\t// @TODO Cache\n\n\t\t\tif (!outputJSON.images) {\n\n\t\t\t\toutputJSON.images = [];\n\t\t\t}\n\n\t\t\tvar mimeType = map.format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\t\tvar gltfImage = { mimeType: mimeType };\n\n\t\t\tif (options.embedImages) {\n\n\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n\n\t\t\t\tcanvas.width = map.image.width;\n\t\t\t\tcanvas.height = map.image.height;\n\n\t\t\t\tif (options.forcePowerOfTwoTextures && !isPowerOfTwo(map.image)) {\n\n\t\t\t\t\tconsole.warn('GLTFExporter: Resized non-power-of-two image.', map.image);\n\n\t\t\t\t\tcanvas.width = THREE.Math.floorPowerOfTwo(canvas.width);\n\t\t\t\t\tcanvas.height = THREE.Math.floorPowerOfTwo(canvas.height);\n\t\t\t\t}\n\n\t\t\t\tvar ctx = canvas.getContext('2d');\n\n\t\t\t\tif (map.flipY === true) {\n\n\t\t\t\t\tctx.translate(0, canvas.height);\n\t\t\t\t\tctx.scale(1, -1);\n\t\t\t\t}\n\n\t\t\t\tctx.drawImage(map.image, 0, 0, canvas.width, canvas.height);\n\n\t\t\t\tif (options.binary === true) {\n\n\t\t\t\t\tpending.push(new Promise(function (resolve) {\n\n\t\t\t\t\t\tcanvas.toBlob(function (blob) {\n\n\t\t\t\t\t\t\tprocessBufferViewImage(blob).then(function (bufferViewIndex) {\n\n\t\t\t\t\t\t\t\tgltfImage.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, mimeType);\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfImage.uri = canvas.toDataURL(mimeType);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tgltfImage.uri = map.image.src;\n\t\t\t}\n\n\t\t\toutputJSON.images.push(gltfImage);\n\n\t\t\treturn outputJSON.images.length - 1;\n\t\t}\n\n\t\t/**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n\t\tfunction processSampler(map) {\n\n\t\t\tif (!outputJSON.samplers) {\n\n\t\t\t\toutputJSON.samplers = [];\n\t\t\t}\n\n\t\t\tvar gltfSampler = {\n\n\t\t\t\tmagFilter: THREE_TO_WEBGL[map.magFilter],\n\t\t\t\tminFilter: THREE_TO_WEBGL[map.minFilter],\n\t\t\t\twrapS: THREE_TO_WEBGL[map.wrapS],\n\t\t\t\twrapT: THREE_TO_WEBGL[map.wrapT]\n\n\t\t\t};\n\n\t\t\toutputJSON.samplers.push(gltfSampler);\n\n\t\t\treturn outputJSON.samplers.length - 1;\n\t\t}\n\n\t\t/**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer}     Index of the processed texture in the \"textures\" array\n   */\n\t\tfunction processTexture(map) {\n\n\t\t\tif (cachedData.textures.has(map)) {\n\n\t\t\t\treturn cachedData.textures.get(map);\n\t\t\t}\n\n\t\t\tif (!outputJSON.textures) {\n\n\t\t\t\toutputJSON.textures = [];\n\t\t\t}\n\n\t\t\tvar gltfTexture = {\n\n\t\t\t\tsampler: processSampler(map),\n\t\t\t\tsource: processImage(map)\n\n\t\t\t};\n\n\t\t\toutputJSON.textures.push(gltfTexture);\n\n\t\t\tvar index = outputJSON.textures.length - 1;\n\t\t\tcachedData.textures.set(map, index);\n\n\t\t\treturn index;\n\t\t}\n\n\t\t/**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer}      Index of the processed material in the \"materials\" array\n   */\n\t\tfunction processMaterial(material) {\n\n\t\t\tif (cachedData.materials.has(material)) {\n\n\t\t\t\treturn cachedData.materials.get(material);\n\t\t\t}\n\n\t\t\tif (!outputJSON.materials) {\n\n\t\t\t\toutputJSON.materials = [];\n\t\t\t}\n\n\t\t\tif (material.isShaderMaterial) {\n\n\t\t\t\tconsole.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\t\tvar gltfMaterial = {\n\n\t\t\t\tpbrMetallicRoughness: {}\n\n\t\t\t};\n\n\t\t\tif (material.isMeshBasicMaterial) {\n\n\t\t\t\tgltfMaterial.extensions = { KHR_materials_unlit: {} };\n\n\t\t\t\textensionsUsed['KHR_materials_unlit'] = true;\n\t\t\t} else if (!material.isMeshStandardMaterial) {\n\n\t\t\t\tconsole.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.baseColorFactor\n\t\t\tvar color = material.color.toArray().concat([material.opacity]);\n\n\t\t\tif (!equalArray(color, [1, 1, 1, 1])) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\n\t\t\t}\n\n\t\t\tif (material.isMeshStandardMaterial) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\t\t\t} else if (material.isMeshBasicMaterial) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\n\t\t\t} else {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\t\tif (material.metalnessMap || material.roughnessMap) {\n\n\t\t\t\tif (material.metalnessMap === material.roughnessMap) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = {\n\n\t\t\t\t\t\tindex: processTexture(material.metalnessMap)\n\n\t\t\t\t\t};\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.baseColorTexture\n\t\t\tif (material.map) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorTexture = {\n\n\t\t\t\t\tindex: processTexture(material.map)\n\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (material.isMeshBasicMaterial || material.isLineBasicMaterial || material.isPointsMaterial) {} else {\n\n\t\t\t\t// emissiveFactor\n\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\n\n\t\t\t\tif (!equalArray(emissive, [0, 0, 0])) {\n\n\t\t\t\t\tgltfMaterial.emissiveFactor = emissive;\n\t\t\t\t}\n\n\t\t\t\t// emissiveTexture\n\t\t\t\tif (material.emissiveMap) {\n\n\t\t\t\t\tgltfMaterial.emissiveTexture = {\n\n\t\t\t\t\t\tindex: processTexture(material.emissiveMap)\n\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// normalTexture\n\t\t\tif (material.normalMap) {\n\n\t\t\t\tgltfMaterial.normalTexture = {\n\n\t\t\t\t\tindex: processTexture(material.normalMap)\n\n\t\t\t\t};\n\n\t\t\t\tif (material.normalScale.x !== -1) {\n\n\t\t\t\t\tif (material.normalScale.x !== material.normalScale.y) {\n\n\t\t\t\t\t\tconsole.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMaterial.normalTexture.scale = material.normalScale.x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// occlusionTexture\n\t\t\tif (material.aoMap) {\n\n\t\t\t\tgltfMaterial.occlusionTexture = {\n\n\t\t\t\t\tindex: processTexture(material.aoMap)\n\n\t\t\t\t};\n\n\t\t\t\tif (material.aoMapIntensity !== 1.0) {\n\n\t\t\t\t\tgltfMaterial.occlusionTexture.strength = material.aoMapIntensity;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// alphaMode\n\t\t\tif (material.transparent || material.alphaTest > 0.0) {\n\n\t\t\t\tgltfMaterial.alphaMode = material.opacity < 1.0 ? 'BLEND' : 'MASK';\n\n\t\t\t\t// Write alphaCutoff if it's non-zero and different from the default (0.5).\n\t\t\t\tif (material.alphaTest > 0.0 && material.alphaTest !== 0.5) {\n\n\t\t\t\t\tgltfMaterial.alphaCutoff = material.alphaTest;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// doubleSided\n\t\t\tif (material.side === THREE.DoubleSide) {\n\n\t\t\t\tgltfMaterial.doubleSided = true;\n\t\t\t}\n\n\t\t\tif (material.name !== '') {\n\n\t\t\t\tgltfMaterial.name = material.name;\n\t\t\t}\n\n\t\t\toutputJSON.materials.push(gltfMaterial);\n\n\t\t\tvar index = outputJSON.materials.length - 1;\n\t\t\tcachedData.materials.set(material, index);\n\n\t\t\treturn index;\n\t\t}\n\n\t\t/**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer}      Index of the processed mesh in the \"meshes\" array\n   */\n\t\tfunction processMesh(mesh) {\n\n\t\t\tvar geometry = mesh.geometry;\n\n\t\t\tvar mode;\n\n\t\t\t// Use the correct mode\n\t\t\tif (mesh.isLineSegments) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\t\t\t} else if (mesh.isLineLoop) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\t\t\t} else if (mesh.isLine) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\t\t\t} else if (mesh.isPoints) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\t\t\t} else {\n\n\t\t\t\tif (!geometry.isBufferGeometry) {\n\n\t\t\t\t\tvar geometryTemp = new THREE.BufferGeometry();\n\t\t\t\t\tgeometryTemp.fromGeometry(geometry);\n\t\t\t\t\tgeometry = geometryTemp;\n\t\t\t\t}\n\n\t\t\t\tif (mesh.drawMode === THREE.TriangleFanDrawMode) {\n\n\t\t\t\t\tconsole.warn('GLTFExporter: TriangleFanDrawMode and wireframe incompatible.');\n\t\t\t\t\tmode = WEBGL_CONSTANTS.TRIANGLE_FAN;\n\t\t\t\t} else if (mesh.drawMode === THREE.TriangleStripDrawMode) {\n\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;\n\t\t\t\t} else {\n\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar gltfMesh = {};\n\n\t\t\tvar attributes = {};\n\t\t\tvar primitives = [];\n\t\t\tvar targets = [];\n\n\t\t\t// Conversion between attributes names in threejs and gltf spec\n\t\t\tvar nameConversion = {\n\n\t\t\t\tuv: 'TEXCOORD_0',\n\t\t\t\tuv2: 'TEXCOORD_1',\n\t\t\t\tcolor: 'COLOR_0',\n\t\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\t\tskinIndex: 'JOINTS_0'\n\n\t\t\t};\n\n\t\t\tvar originalNormal = geometry.getAttribute('normal');\n\n\t\t\tif (originalNormal !== undefined && !isNormalizedNormalAttribute(originalNormal)) {\n\n\t\t\t\tconsole.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n\n\t\t\t\tgeometry.addAttribute('normal', createNormalizedNormalAttribute(originalNormal));\n\t\t\t}\n\n\t\t\t// @QUESTION Detect if .vertexColors = THREE.VertexColors?\n\t\t\t// For every attribute create an accessor\n\t\t\tfor (var attributeName in geometry.attributes) {\n\n\t\t\t\tvar attribute = geometry.attributes[attributeName];\n\t\t\t\tattributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n\n\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tif (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n\n\t\t\t\t\tconsole.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n\t\t\t\t\tattribute = new THREE.BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n\t\t\t\t}\n\n\t\t\t\tif (attributeName.substr(0, 5) !== 'MORPH') {\n\n\t\t\t\t\tvar accessor = processAccessor(attribute, geometry);\n\t\t\t\t\tif (accessor !== null) {\n\n\t\t\t\t\t\tattributes[attributeName] = accessor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (originalNormal !== undefined) geometry.addAttribute('normal', originalNormal);\n\n\t\t\t// Skip if no exportable attributes found\n\t\t\tif (Object.keys(attributes).length === 0) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Morph targets\n\t\t\tif (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n\n\t\t\t\tvar weights = [];\n\t\t\t\tvar targetNames = [];\n\t\t\t\tvar reverseDictionary = {};\n\n\t\t\t\tif (mesh.morphTargetDictionary !== undefined) {\n\n\t\t\t\t\tfor (var key in mesh.morphTargetDictionary) {\n\n\t\t\t\t\t\treverseDictionary[mesh.morphTargetDictionary[key]] = key;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n\n\t\t\t\t\tvar target = {};\n\n\t\t\t\t\tvar warned = false;\n\n\t\t\t\t\tfor (var attributeName in geometry.morphAttributes) {\n\n\t\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\t\tif (attributeName !== 'position' && attributeName !== 'normal') {\n\n\t\t\t\t\t\t\tif (!warned) {\n\n\t\t\t\t\t\t\t\tconsole.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n\t\t\t\t\t\t\t\twarned = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar attribute = geometry.morphAttributes[attributeName][i];\n\n\t\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\t\tvar baseAttribute = geometry.attributes[attributeName];\n\t\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\n\n\t\t\t\t\t\tfor (var j = 0, jl = attribute.count; j < jl; j++) {\n\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget[attributeName.toUpperCase()] = processAccessor(relativeAttribute, geometry);\n\t\t\t\t\t}\n\n\t\t\t\t\ttargets.push(target);\n\n\t\t\t\t\tweights.push(mesh.morphTargetInfluences[i]);\n\t\t\t\t\tif (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n\t\t\t\t}\n\n\t\t\t\tgltfMesh.weights = weights;\n\n\t\t\t\tif (targetNames.length > 0) {\n\n\t\t\t\t\tgltfMesh.extras = {};\n\t\t\t\t\tgltfMesh.extras.targetNames = targetNames;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar forceIndices = options.forceIndices;\n\t\t\tvar isMultiMaterial = Array.isArray(mesh.material);\n\n\t\t\tif (isMultiMaterial && mesh.geometry.groups.length === 0) return null;\n\n\t\t\tif (!forceIndices && geometry.index === null && isMultiMaterial) {\n\n\t\t\t\t// temporal workaround.\n\t\t\t\tconsole.warn('THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.');\n\t\t\t\tforceIndices = true;\n\t\t\t}\n\n\t\t\tvar didForceIndices = false;\n\n\t\t\tif (geometry.index === null && forceIndices) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor (var i = 0, il = geometry.attributes.position.count; i < il; i++) {\n\n\t\t\t\t\tindices[i] = i;\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex(indices);\n\n\t\t\t\tdidForceIndices = true;\n\t\t\t}\n\n\t\t\tvar materials = isMultiMaterial ? mesh.material : [mesh.material];\n\t\t\tvar groups = isMultiMaterial ? mesh.geometry.groups : [{ materialIndex: 0, start: undefined, count: undefined }];\n\n\t\t\tfor (var i = 0, il = groups.length; i < il; i++) {\n\n\t\t\t\tvar primitive = {\n\t\t\t\t\tmode: mode,\n\t\t\t\t\tattributes: attributes\n\t\t\t\t};\n\n\t\t\t\tif (targets.length > 0) primitive.targets = targets;\n\n\t\t\t\tif (geometry.index !== null) {\n\n\t\t\t\t\tprimitive.indices = processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n\t\t\t\t}\n\n\t\t\t\tvar material = processMaterial(materials[groups[i].materialIndex]);\n\n\t\t\t\tif (material !== null) {\n\n\t\t\t\t\tprimitive.material = material;\n\t\t\t\t}\n\n\t\t\t\tprimitives.push(primitive);\n\t\t\t}\n\n\t\t\tif (didForceIndices) {\n\n\t\t\t\tgeometry.setIndex(null);\n\t\t\t}\n\n\t\t\tgltfMesh.primitives = primitives;\n\n\t\t\tif (!outputJSON.meshes) {\n\n\t\t\t\toutputJSON.meshes = [];\n\t\t\t}\n\n\t\t\toutputJSON.meshes.push(gltfMesh);\n\n\t\t\treturn outputJSON.meshes.length - 1;\n\t\t}\n\n\t\t/**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n\t\tfunction processCamera(camera) {\n\n\t\t\tif (!outputJSON.cameras) {\n\n\t\t\t\toutputJSON.cameras = [];\n\t\t\t}\n\n\t\t\tvar isOrtho = camera.isOrthographicCamera;\n\n\t\t\tvar gltfCamera = {\n\n\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\n\t\t\t};\n\n\t\t\tif (isOrtho) {\n\n\t\t\t\tgltfCamera.orthographic = {\n\n\t\t\t\t\txmag: camera.right * 2,\n\t\t\t\t\tymag: camera.top * 2,\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t};\n\t\t\t} else {\n\n\t\t\t\tgltfCamera.perspective = {\n\n\t\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\t\tyfov: THREE.Math.degToRad(camera.fov) / camera.aspect,\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (camera.name !== '') {\n\n\t\t\t\tgltfCamera.name = camera.type;\n\t\t\t}\n\n\t\t\toutputJSON.cameras.push(gltfCamera);\n\n\t\t\treturn outputJSON.cameras.length - 1;\n\t\t}\n\n\t\t/**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number}\n   */\n\t\tfunction processAnimation(clip, root) {\n\n\t\t\tif (!outputJSON.animations) {\n\n\t\t\t\toutputJSON.animations = [];\n\t\t\t}\n\n\t\t\tvar channels = [];\n\t\t\tvar samplers = [];\n\n\t\t\tfor (var i = 0; i < clip.tracks.length; ++i) {\n\n\t\t\t\tvar track = clip.tracks[i];\n\t\t\t\tvar trackBinding = THREE.PropertyBinding.parseTrackName(track.name);\n\t\t\t\tvar trackNode = THREE.PropertyBinding.findNode(root, trackBinding.nodeName);\n\t\t\t\tvar trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n\t\t\t\tif (trackBinding.objectName === 'bones') {\n\n\t\t\t\t\tif (trackNode.isSkinnedMesh === true) {\n\n\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttrackNode = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!trackNode || !trackProperty) {\n\n\t\t\t\t\tconsole.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tvar inputItemSize = 1;\n\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\n\n\t\t\t\tif (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n\n\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\t\t\t\t}\n\n\t\t\t\tvar interpolation;\n\n\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t\t// valid value from .getInterpolation().\n\t\t\t\tif (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n\n\t\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\t\toutputItemSize /= 3;\n\t\t\t\t} else if (track.getInterpolation() === THREE.InterpolateDiscrete) {\n\n\t\t\t\t\tinterpolation = 'STEP';\n\t\t\t\t} else {\n\n\t\t\t\t\tinterpolation = 'LINEAR';\n\t\t\t\t}\n\n\t\t\t\tsamplers.push({\n\n\t\t\t\t\tinput: processAccessor(new THREE.BufferAttribute(track.times, inputItemSize)),\n\t\t\t\t\toutput: processAccessor(new THREE.BufferAttribute(track.values, outputItemSize)),\n\t\t\t\t\tinterpolation: interpolation\n\n\t\t\t\t});\n\n\t\t\t\tchannels.push({\n\n\t\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\t\ttarget: {\n\t\t\t\t\t\tnode: nodeMap.get(trackNode),\n\t\t\t\t\t\tpath: trackProperty\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\n\t\t\toutputJSON.animations.push({\n\n\t\t\t\tname: clip.name || 'clip_' + outputJSON.animations.length,\n\t\t\t\tsamplers: samplers,\n\t\t\t\tchannels: channels\n\n\t\t\t});\n\n\t\t\treturn outputJSON.animations.length - 1;\n\t\t}\n\n\t\tfunction processSkin(object) {\n\n\t\t\tvar node = outputJSON.nodes[nodeMap.get(object)];\n\n\t\t\tvar skeleton = object.skeleton;\n\t\t\tvar rootJoint = object.skeleton.bones[0];\n\n\t\t\tif (rootJoint === undefined) return null;\n\n\t\t\tvar joints = [];\n\t\t\tvar inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n\n\t\t\tfor (var i = 0; i < skeleton.bones.length; ++i) {\n\n\t\t\t\tjoints.push(nodeMap.get(skeleton.bones[i]));\n\n\t\t\t\tskeleton.boneInverses[i].toArray(inverseBindMatrices, i * 16);\n\t\t\t}\n\n\t\t\tif (outputJSON.skins === undefined) {\n\n\t\t\t\toutputJSON.skins = [];\n\t\t\t}\n\n\t\t\toutputJSON.skins.push({\n\n\t\t\t\tinverseBindMatrices: processAccessor(new THREE.BufferAttribute(inverseBindMatrices, 16)),\n\t\t\t\tjoints: joints,\n\t\t\t\tskeleton: nodeMap.get(rootJoint)\n\n\t\t\t});\n\n\t\t\tvar skinIndex = node.skin = outputJSON.skins.length - 1;\n\n\t\t\treturn skinIndex;\n\t\t}\n\n\t\t/**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer}      Index of the node in the nodes list\n   */\n\t\tfunction processNode(object) {\n\n\t\t\tif (object.isLight) {\n\n\t\t\t\tconsole.warn('GLTFExporter: Unsupported node type:', object.constructor.name);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!outputJSON.nodes) {\n\n\t\t\t\toutputJSON.nodes = [];\n\t\t\t}\n\n\t\t\tvar gltfNode = {};\n\n\t\t\tif (options.trs) {\n\n\t\t\t\tvar rotation = object.quaternion.toArray();\n\t\t\t\tvar position = object.position.toArray();\n\t\t\t\tvar scale = object.scale.toArray();\n\n\t\t\t\tif (!equalArray(rotation, [0, 0, 0, 1])) {\n\n\t\t\t\t\tgltfNode.rotation = rotation;\n\t\t\t\t}\n\n\t\t\t\tif (!equalArray(position, [0, 0, 0])) {\n\n\t\t\t\t\tgltfNode.translation = position;\n\t\t\t\t}\n\n\t\t\t\tif (!equalArray(scale, [1, 1, 1])) {\n\n\t\t\t\t\tgltfNode.scale = scale;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tobject.updateMatrix();\n\t\t\t\tif (!equalArray(object.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])) {\n\n\t\t\t\t\tgltfNode.matrix = object.matrix.elements;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\t\tif (object.name !== '') {\n\n\t\t\t\tgltfNode.name = String(object.name);\n\t\t\t}\n\n\t\t\tif (object.userData && Object.keys(object.userData).length > 0) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tgltfNode.extras = JSON.parse(JSON.stringify(object.userData));\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tthrow new Error('THREE.GLTFExporter: userData can\\'t be serialized');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (object.isMesh || object.isLine || object.isPoints) {\n\n\t\t\t\tvar mesh = processMesh(object);\n\n\t\t\t\tif (mesh !== null) {\n\n\t\t\t\t\tgltfNode.mesh = mesh;\n\t\t\t\t}\n\t\t\t} else if (object.isCamera) {\n\n\t\t\t\tgltfNode.camera = processCamera(object);\n\t\t\t}\n\n\t\t\tif (object.isSkinnedMesh) {\n\n\t\t\t\tskins.push(object);\n\t\t\t}\n\n\t\t\tif (object.children.length > 0) {\n\n\t\t\t\tvar children = [];\n\n\t\t\t\tfor (var i = 0, l = object.children.length; i < l; i++) {\n\n\t\t\t\t\tvar child = object.children[i];\n\n\t\t\t\t\tif (child.visible || options.onlyVisible === false) {\n\n\t\t\t\t\t\tvar node = processNode(child);\n\n\t\t\t\t\t\tif (node !== null) {\n\n\t\t\t\t\t\t\tchildren.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (children.length > 0) {\n\n\t\t\t\t\tgltfNode.children = children;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutputJSON.nodes.push(gltfNode);\n\n\t\t\tvar nodeIndex = outputJSON.nodes.length - 1;\n\t\t\tnodeMap.set(object, nodeIndex);\n\n\t\t\treturn nodeIndex;\n\t\t}\n\n\t\t/**\n   * Process Scene\n   * @param  {THREE.Scene} node Scene to process\n   */\n\t\tfunction processScene(scene) {\n\n\t\t\tif (!outputJSON.scenes) {\n\n\t\t\t\toutputJSON.scenes = [];\n\t\t\t\toutputJSON.scene = 0;\n\t\t\t}\n\n\t\t\tvar gltfScene = {\n\n\t\t\t\tnodes: []\n\n\t\t\t};\n\n\t\t\tif (scene.name !== '') {\n\n\t\t\t\tgltfScene.name = scene.name;\n\t\t\t}\n\n\t\t\toutputJSON.scenes.push(gltfScene);\n\n\t\t\tvar nodes = [];\n\n\t\t\tfor (var i = 0, l = scene.children.length; i < l; i++) {\n\n\t\t\t\tvar child = scene.children[i];\n\n\t\t\t\tif (child.visible || options.onlyVisible === false) {\n\n\t\t\t\t\tvar node = processNode(child);\n\n\t\t\t\t\tif (node !== null) {\n\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nodes.length > 0) {\n\n\t\t\t\tgltfScene.nodes = nodes;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Creates a THREE.Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n\t\tfunction processObjects(objects) {\n\n\t\t\tvar scene = new THREE.Scene();\n\t\t\tscene.name = 'AuxScene';\n\n\t\t\tfor (var i = 0; i < objects.length; i++) {\n\n\t\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\t\tscene.children.push(objects[i]);\n\t\t\t}\n\n\t\t\tprocessScene(scene);\n\t\t}\n\n\t\tfunction processInput(input) {\n\n\t\t\tinput = input instanceof Array ? input : [input];\n\n\t\t\tvar objectsWithoutScene = [];\n\n\t\t\tfor (var i = 0; i < input.length; i++) {\n\n\t\t\t\tif (input[i] instanceof THREE.Scene) {\n\n\t\t\t\t\tprocessScene(input[i]);\n\t\t\t\t} else {\n\n\t\t\t\t\tobjectsWithoutScene.push(input[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (objectsWithoutScene.length > 0) {\n\n\t\t\t\tprocessObjects(objectsWithoutScene);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < skins.length; ++i) {\n\n\t\t\t\tprocessSkin(skins[i]);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < options.animations.length; ++i) {\n\n\t\t\t\tprocessAnimation(options.animations[i], input[0]);\n\t\t\t}\n\t\t}\n\n\t\tprocessInput(input);\n\n\t\tPromise.all(pending).then(function () {\n\n\t\t\t// Merge buffers.\n\t\t\tvar blob = new Blob(buffers, { type: 'application/octet-stream' });\n\n\t\t\t// Declare extensions.\n\t\t\tvar extensionsUsedList = Object.keys(extensionsUsed);\n\t\t\tif (extensionsUsedList.length > 0) outputJSON.extensionsUsed = extensionsUsedList;\n\n\t\t\tif (outputJSON.buffers && outputJSON.buffers.length > 0) {\n\n\t\t\t\t// Update bytelength of the single buffer.\n\t\t\t\toutputJSON.buffers[0].byteLength = blob.size;\n\n\t\t\t\tvar reader = new window.FileReader();\n\n\t\t\t\tif (options.binary === true) {\n\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\t\tvar GLB_HEADER_BYTES = 12;\n\t\t\t\t\tvar GLB_HEADER_MAGIC = 0x46546C67;\n\t\t\t\t\tvar GLB_VERSION = 2;\n\n\t\t\t\t\tvar GLB_CHUNK_PREFIX_BYTES = 8;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n\t\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t// Binary chunk.\n\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer(reader.result);\n\t\t\t\t\t\tvar binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n\n\t\t\t\t\t\t// JSON chunk.\n\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(outputJSON)), 0x20);\n\t\t\t\t\t\tvar jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n\t\t\t\t\t\tjsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n\t\t\t\t\t\tjsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n\n\t\t\t\t\t\t// GLB header.\n\t\t\t\t\t\tvar header = new ArrayBuffer(GLB_HEADER_BYTES);\n\t\t\t\t\t\tvar headerView = new DataView(header);\n\t\t\t\t\t\theaderView.setUint32(0, GLB_HEADER_MAGIC, true);\n\t\t\t\t\t\theaderView.setUint32(4, GLB_VERSION, true);\n\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\t\theaderView.setUint32(8, totalByteLength, true);\n\n\t\t\t\t\t\tvar glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], { type: 'application/octet-stream' });\n\n\t\t\t\t\t\tvar glbReader = new window.FileReader();\n\t\t\t\t\t\tglbReader.readAsArrayBuffer(glbBlob);\n\t\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\t\tonDone(glbReader.result);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t} else {\n\n\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\tvar base64data = reader.result;\n\t\t\t\t\t\toutputJSON.buffers[0].uri = base64data;\n\t\t\t\t\t\tonDone(outputJSON);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tonDone(outputJSON);\n\t\t\t}\n\t\t});\n\t}\n\n};\n\nexports.default = GLTFExporter;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _mmdParser = __webpack_require__(4);\n\nvar MMDParser = _interopRequireWildcard(_mmdParser);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author takahiro / http://github.com/takahirox\n *\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nvar MMDExporter = function MMDExporter() {\n\n\t// Unicode to Shift_JIS table\n\tvar u2sTable;\n\n\tfunction unicodeToShiftjis(str) {\n\n\t\tif (u2sTable === undefined) {\n\n\t\t\tvar encoder = new MMDParser.CharsetEncoder();\n\t\t\tvar table = encoder.s2uTable;\n\t\t\tu2sTable = {};\n\n\t\t\tvar keys = Object.keys(table);\n\n\t\t\tfor (var i = 0, il = keys.length; i < il; i++) {\n\n\t\t\t\tvar key = keys[i];\n\n\t\t\t\tvar value = table[key];\n\t\t\t\tkey = parseInt(key);\n\n\t\t\t\tu2sTable[value] = key;\n\t\t\t}\n\t\t}\n\n\t\tvar array = [];\n\n\t\tfor (var i = 0, il = str.length; i < il; i++) {\n\n\t\t\tvar code = str.charCodeAt(i);\n\n\t\t\tvar value = u2sTable[code];\n\n\t\t\tif (value === undefined) {\n\n\t\t\t\tthrow 'cannot convert charcode 0x' + code.toString(16);\n\t\t\t} else if (value > 0xff) {\n\n\t\t\t\tarray.push(value >> 8 & 0xff);\n\t\t\t\tarray.push(value & 0xff);\n\t\t\t} else {\n\n\t\t\t\tarray.push(value & 0xff);\n\t\t\t}\n\t\t}\n\n\t\treturn new Uint8Array(array);\n\t}\n\n\tfunction getBindBones(skin) {\n\n\t\t// any more efficient ways?\n\t\tvar poseSkin = skin.clone();\n\t\tposeSkin.pose();\n\t\treturn poseSkin.skeleton.bones;\n\t}\n\n\t/* TODO: implement\n // mesh -> pmd\n this.parsePmd = function ( object ) {\n \t};\n */\n\n\t/* TODO: implement\n // mesh -> pmx\n this.parsePmx = function ( object ) {\n \t};\n */\n\n\t/*\n  * skeleton -> vpd\n  * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n  */\n\tthis.parseVpd = function (skin, outputShiftJis, useOriginalBones) {\n\n\t\tif (skin.isSkinnedMesh !== true) {\n\n\t\t\tconsole.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.');\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction toStringsFromNumber(num) {\n\n\t\t\tif (Math.abs(num) < 1e-6) num = 0;\n\n\t\t\tvar a = num.toString();\n\n\t\t\tif (a.indexOf('.') === -1) {\n\n\t\t\t\ta += '.';\n\t\t\t}\n\n\t\t\ta += '000000';\n\n\t\t\tvar index = a.indexOf('.');\n\n\t\t\tvar d = a.slice(0, index);\n\t\t\tvar p = a.slice(index + 1, index + 7);\n\n\t\t\treturn d + '.' + p;\n\t\t}\n\n\t\tfunction toStringsFromArray(array) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0, il = array.length; i < il; i++) {\n\n\t\t\t\ta.push(toStringsFromNumber(array[i]));\n\t\t\t}\n\n\t\t\treturn a.join(',');\n\t\t}\n\n\t\tskin.updateMatrixWorld(true);\n\n\t\tvar bones = skin.skeleton.bones;\n\t\tvar bones2 = getBindBones(skin);\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar quaternion2 = new THREE.Quaternion();\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\tvar array = [];\n\t\tarray.push('Vocaloid Pose Data file');\n\t\tarray.push('');\n\t\tarray.push((skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin') + '.osm;');\n\t\tarray.push(bones.length + ';');\n\t\tarray.push('');\n\n\t\tfor (var i = 0, il = bones.length; i < il; i++) {\n\n\t\t\tvar bone = bones[i];\n\t\t\tvar bone2 = bones2[i];\n\n\t\t\t/*\n    * use the bone matrix saved before solving IK.\n    * see CCDIKSolver for the detail.\n    */\n\t\t\tif (useOriginalBones === true && bone.userData.ik !== undefined && bone.userData.ik.originalMatrix !== undefined) {\n\n\t\t\t\tmatrix.fromArray(bone.userData.ik.originalMatrix);\n\t\t\t} else {\n\n\t\t\t\tmatrix.copy(bone.matrix);\n\t\t\t}\n\n\t\t\tposition.setFromMatrixPosition(matrix);\n\t\t\tquaternion.setFromRotationMatrix(matrix);\n\n\t\t\tvar pArray = position.sub(bone2.position).toArray();\n\t\t\tvar qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();\n\n\t\t\t// right to left\n\t\t\tpArray[2] = -pArray[2];\n\t\t\tqArray[0] = -qArray[0];\n\t\t\tqArray[1] = -qArray[1];\n\n\t\t\tarray.push('Bone' + i + '{' + bone.name);\n\t\t\tarray.push('  ' + toStringsFromArray(pArray) + ';');\n\t\t\tarray.push('  ' + toStringsFromArray(qArray) + ';');\n\t\t\tarray.push('}');\n\t\t\tarray.push('');\n\t\t}\n\n\t\tarray.push('');\n\n\t\tvar lines = array.join('\\n');\n\n\t\treturn outputShiftJis === true ? unicodeToShiftjis(lines) : lines;\n\t};\n\n\t/* TODO: implement\n // animation + skeleton -> vmd\n this.parseVmd = function ( object ) {\n \t};\n */\n};\n\nexports.default = MMDExporter;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar OBJExporter = function OBJExporter() {};\n\nOBJExporter.prototype = {\n\n\tconstructor: OBJExporter,\n\n\tparse: function parse(object) {\n\n\t\tvar output = '';\n\n\t\tvar indexVertex = 0;\n\t\tvar indexVertexUvs = 0;\n\t\tvar indexNormals = 0;\n\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\n\t\tvar i,\n\t\t    j,\n\t\t    k,\n\t\t    l,\n\t\t    m,\n\t\t    face = [];\n\n\t\tvar parseMesh = function parseMesh(mesh) {\n\n\t\t\tvar nbVertex = 0;\n\t\t\tvar nbNormals = 0;\n\t\t\tvar nbVertexUvs = 0;\n\n\t\t\tvar geometry = mesh.geometry;\n\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject(mesh);\n\t\t\t}\n\n\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t// shortcuts\n\t\t\t\tvar vertices = geometry.getAttribute('position');\n\t\t\t\tvar normals = geometry.getAttribute('normal');\n\t\t\t\tvar uvs = geometry.getAttribute('uv');\n\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t// name of the mesh object\n\t\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t\t// name of the mesh material\n\t\t\t\tif (mesh.material && mesh.material.name) {\n\n\t\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\t\t\t\t}\n\n\t\t\t\t// vertices\n\n\t\t\t\tif (vertices !== undefined) {\n\n\t\t\t\t\tfor (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX(i);\n\t\t\t\t\t\tvertex.y = vertices.getY(i);\n\t\t\t\t\t\tvertex.z = vertices.getZ(i);\n\n\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\tvertex.applyMatrix4(mesh.matrixWorld);\n\n\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// uvs\n\n\t\t\t\tif (uvs !== undefined) {\n\n\t\t\t\t\tfor (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n\n\t\t\t\t\t\tuv.x = uvs.getX(i);\n\t\t\t\t\t\tuv.y = uvs.getY(i);\n\n\t\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// normals\n\n\t\t\t\tif (normals !== undefined) {\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n\t\t\t\t\tfor (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n\n\t\t\t\t\t\tnormal.x = normals.getX(i);\n\t\t\t\t\t\tnormal.y = normals.getY(i);\n\t\t\t\t\t\tnormal.z = normals.getZ(i);\n\n\t\t\t\t\t\t// transfrom the normal to world space\n\t\t\t\t\t\tnormal.applyMatrix3(normalMatrixWorld);\n\n\t\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// faces\n\n\t\t\t\tif (indices !== null) {\n\n\t\t\t\t\tfor (i = 0, l = indices.count; i < l; i += 3) {\n\n\t\t\t\t\t\tfor (m = 0; m < 3; m++) {\n\n\t\t\t\t\t\t\tj = indices.getX(i + m) + 1;\n\n\t\t\t\t\t\t\tface[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\toutput += 'f ' + face.join(' ') + \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tfor (i = 0, l = vertices.count; i < l; i += 3) {\n\n\t\t\t\t\t\tfor (m = 0; m < 3; m++) {\n\n\t\t\t\t\t\t\tj = i + m + 1;\n\n\t\t\t\t\t\t\tface[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\toutput += 'f ' + face.join(' ') + \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry);\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\tindexNormals += nbNormals;\n\t\t};\n\n\t\tvar parseLine = function parseLine(line) {\n\n\t\t\tvar nbVertex = 0;\n\n\t\t\tvar geometry = line.geometry;\n\t\t\tvar type = line.type;\n\n\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject(line);\n\t\t\t}\n\n\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t// shortcuts\n\t\t\t\tvar vertices = geometry.getAttribute('position');\n\n\t\t\t\t// name of the line object\n\t\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\t\tif (vertices !== undefined) {\n\n\t\t\t\t\tfor (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX(i);\n\t\t\t\t\t\tvertex.y = vertices.getY(i);\n\t\t\t\t\t\tvertex.z = vertices.getZ(i);\n\n\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\tvertex.applyMatrix4(line.matrixWorld);\n\n\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (type === 'Line') {\n\n\t\t\t\t\toutput += 'l ';\n\n\t\t\t\t\tfor (j = 1, l = vertices.count; j <= l; j++) {\n\n\t\t\t\t\t\toutput += indexVertex + j + ' ';\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '\\n';\n\t\t\t\t}\n\n\t\t\t\tif (type === 'LineSegments') {\n\n\t\t\t\t\tfor (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n\n\t\t\t\t\t\toutput += 'l ' + (indexVertex + j) + ' ' + (indexVertex + k) + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('THREE.OBJExporter.parseLine(): geometry type unsupported', geometry);\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t};\n\n\t\tobject.traverse(function (child) {\n\n\t\t\tif (child instanceof THREE.Mesh) {\n\n\t\t\t\tparseMesh(child);\n\t\t\t}\n\n\t\t\tif (child instanceof THREE.Line) {\n\n\t\t\t\tparseLine(child);\n\t\t\t}\n\t\t});\n\n\t\treturn output;\n\t}\n\n};\n\nexports.default = OBJExporter;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Garrett Johnson / http://gkjohnson.github.io/\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  var exporter = new THREE.PLYExporter();\n *\n *  // second argument is an array of attributes to\n *  // exclude from the format ('color', 'uv', 'normal')\n *  var data = exporter.parse(mesh, [ 'color' ]);\n *\n * Format Definition:\n *  http://paulbourke.net/dataformats/ply/\n */\n\nvar PLYExporter = function PLYExporter() {};\n\nPLYExporter.prototype = {\n\n\tconstructor: PLYExporter,\n\n\tparse: function parse(object, excludeProperties) {\n\n\t\tif (Array.isArray(excludeProperties) !== true) {\n\n\t\t\texcludeProperties = [];\n\t\t}\n\n\t\tvar includeNormals = excludeProperties.indexOf('normal') === -1;\n\t\tvar includeColors = excludeProperties.indexOf('color') === -1;\n\t\tvar includeUVs = excludeProperties.indexOf('uv') === -1;\n\n\t\t// count the number of vertices\n\t\tvar vertexCount = 0;\n\t\tvar faceCount = 0;\n\t\tvar vertexList = '';\n\t\tvar faceList = '';\n\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\t\tobject.traverse(function (child) {\n\n\t\t\tif (child instanceof THREE.Mesh) {\n\n\t\t\t\tvar mesh = child;\n\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject(mesh);\n\t\t\t\t}\n\n\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute('position');\n\t\t\t\t\tvar normals = geometry.getAttribute('normal');\n\t\t\t\t\tvar uvs = geometry.getAttribute('uv');\n\t\t\t\t\tvar colors = geometry.getAttribute('color');\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n\t\t\t\t\tif (vertices === undefined) {\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// form each line\n\t\t\t\t\tfor (var i = 0, l = vertices.count; i < l; i++) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX(i);\n\t\t\t\t\t\tvertex.y = vertices.getY(i);\n\t\t\t\t\t\tvertex.z = vertices.getZ(i);\n\n\t\t\t\t\t\tvertex.applyMatrix4(mesh.matrixWorld);\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\tvar line = vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif (includeNormals === true) {\n\n\t\t\t\t\t\t\tif (normals !== undefined) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX(i);\n\t\t\t\t\t\t\t\tvertex.y = normals.getY(i);\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ(i);\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3(normalMatrixWorld);\n\n\t\t\t\t\t\t\t\tline += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 0 0 0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif (includeUVs === true) {\n\n\t\t\t\t\t\t\tif (uvs !== undefined) {\n\n\t\t\t\t\t\t\t\tline += ' ' + uvs.getX(i) + ' ' + uvs.getY(i);\n\t\t\t\t\t\t\t} else if (includeUVs !== false) {\n\n\t\t\t\t\t\t\t\tline += ' 0 0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif (includeColors === true) {\n\n\t\t\t\t\t\t\tif (colors !== undefined) {\n\n\t\t\t\t\t\t\t\tline += ' ' + Math.floor(colors.getX(i)) + ' ' + Math.floor(colors.getY(i)) + ' ' + Math.floor(colors.getZ(i));\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 255 255 255';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexList += line + '\\n';\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the face list\n\t\t\t\t\tif (indices !== null) {\n\n\t\t\t\t\t\tfor (i = 0, l = indices.count; i < l; i += 3) {\n\n\t\t\t\t\t\t\tfaceList += '3 ' + (indices.getX(i + 0) + vertexCount);\n\t\t\t\t\t\t\tfaceList += ' ' + (indices.getX(i + 1) + vertexCount);\n\t\t\t\t\t\t\tfaceList += ' ' + (indices.getX(i + 2) + vertexCount) + '\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor (var i = 0, l = vertices.count; i < l; i += 3) {\n\n\t\t\t\t\t\t\tfaceList += '3 ' + (vertexCount + i) + ' ' + (vertexCount + i + 1) + ' ' + (vertexCount + i + 2) + '\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvertexCount += vertices.count;\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar output = 'ply\\n' + 'format ascii 1.0\\n' + ('element vertex ' + vertexCount + '\\n') +\n\n\t\t// position\n\t\t'property float x\\n' + 'property float y\\n' + 'property float z\\n';\n\n\t\tif (includeNormals === true) {\n\n\t\t\t// normal\n\t\t\toutput += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n\t\t}\n\n\t\tif (includeUVs === true) {\n\n\t\t\t// uvs\n\t\t\toutput += 'property float s\\n' + 'property float t\\n';\n\t\t}\n\n\t\tif (includeColors === true) {\n\n\t\t\t// colors\n\t\t\toutput += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n\t\t}\n\n\t\t// faces\n\t\toutput += 'element face ' + faceCount + '\\n' + 'property list uchar int vertex_index\\n' + 'end_header\\n' + (vertexList + '\\n') + (faceList + '\\n');\n\n\t\treturn output;\n\t}\n\n};\n\nexports.default = PLYExporter;\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author kovacsv / http://kovacsv.hu/\n * @author mrdoob / http://mrdoob.com/\n * @author mudcube / http://mudcu.be/\n */\n\nvar STLBinaryExporter = function STLBinaryExporter() {};\n\nSTLBinaryExporter.prototype = {\n\n\tconstructor: STLBinaryExporter,\n\n\tparse: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\treturn function parse(scene) {\n\n\t\t\t// We collect objects first, as we may need to convert from BufferGeometry to Geometry\n\t\t\tvar objects = [];\n\t\t\tvar triangles = 0;\n\t\t\tscene.traverse(function (object) {\n\n\t\t\t\tif (!(object instanceof THREE.Mesh)) return;\n\n\t\t\t\tvar geometry = object.geometry;\n\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry(geometry);\n\t\t\t\t}\n\n\t\t\t\tif (!(geometry instanceof THREE.Geometry)) return;\n\t\t\t\ttriangles += geometry.faces.length;\n\n\t\t\t\tobjects.push({\n\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmatrix: object.matrixWorld\n\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tvar offset = 80; // skip header\n\t\t\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\tvar arrayBuffer = new ArrayBuffer(bufferLength);\n\t\t\tvar output = new DataView(arrayBuffer);\n\t\t\toutput.setUint32(offset, triangles, true);offset += 4;\n\n\t\t\t// Traversing our collected objects\n\t\t\tobjects.forEach(function (object) {\n\n\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\tvar faces = object.geometry.faces;\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix(object.matrix);\n\n\t\t\t\tfor (var i = 0, l = faces.length; i < l; i++) {\n\n\t\t\t\t\tvar face = faces[i];\n\n\t\t\t\t\tvector.copy(face.normal).applyMatrix3(normalMatrixWorld).normalize();\n\n\t\t\t\t\toutput.setFloat32(offset, vector.x, true);offset += 4; // normal\n\t\t\t\t\toutput.setFloat32(offset, vector.y, true);offset += 4;\n\t\t\t\t\toutput.setFloat32(offset, vector.z, true);offset += 4;\n\n\t\t\t\t\tvar indices = [face.a, face.b, face.c];\n\n\t\t\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\t\t\tvector.copy(vertices[indices[j]]).applyMatrix4(object.matrix);\n\n\t\t\t\t\t\toutput.setFloat32(offset, vector.x, true);offset += 4; // vertices\n\t\t\t\t\t\toutput.setFloat32(offset, vector.y, true);offset += 4;\n\t\t\t\t\t\toutput.setFloat32(offset, vector.z, true);offset += 4;\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.setUint16(offset, 0, true);offset += 2; // attribute byte count\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn output;\n\t\t};\n\t}()\n\n};\n\nexports.default = STLBinaryExporter;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author kovacsv / http://kovacsv.hu/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar STLExporter = function STLExporter() {};\n\nSTLExporter.prototype = {\n\n\tconstructor: STLExporter,\n\n\tparse: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\treturn function parse(scene) {\n\n\t\t\tvar output = '';\n\n\t\t\toutput += 'solid exported\\n';\n\n\t\t\tscene.traverse(function (object) {\n\n\t\t\t\tif (object instanceof THREE.Mesh) {\n\n\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry(geometry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix(matrixWorld);\n\n\t\t\t\t\t\tfor (var i = 0, l = faces.length; i < l; i++) {\n\n\t\t\t\t\t\t\tvar face = faces[i];\n\n\t\t\t\t\t\t\tvector.copy(face.normal).applyMatrix3(normalMatrixWorld).normalize();\n\n\t\t\t\t\t\t\toutput += '\\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\t\t\t\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t\t\t\t\tvar indices = [face.a, face.b, face.c];\n\n\t\t\t\t\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\t\t\t\t\tvector.copy(vertices[indices[j]]).applyMatrix4(matrixWorld);\n\n\t\t\t\t\t\t\t\toutput += '\\t\\t\\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\t\t\t\toutput += '\\tendfacet\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toutput += 'endsolid exported\\n';\n\n\t\t\treturn output;\n\t\t};\n\t}()\n\n};\n\nexports.default = STLExporter;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar TypedGeometryExporter = function TypedGeometryExporter() {};\n\nTypedGeometryExporter.prototype = {\n\n\tconstructor: TypedGeometryExporter,\n\n\tparse: function parse(geometry) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.0,\n\t\t\t\ttype: 'TypedGeometry',\n\t\t\t\tgenerator: 'TypedGeometryExporter'\n\t\t\t}\n\t\t};\n\n\t\tvar attributes = ['vertices', 'normals', 'uvs'];\n\n\t\tfor (var key in attributes) {\n\n\t\t\tvar attribute = attributes[key];\n\n\t\t\tvar typedArray = geometry[attribute];\n\t\t\tvar array = [];\n\n\t\t\tfor (var i = 0, l = typedArray.length; i < l; i++) {\n\n\t\t\t\tarray[i] = typedArray[i];\n\t\t\t}\n\n\t\t\toutput[attribute] = array;\n\t\t}\n\n\t\tvar boundingSphere = geometry.boundingSphere;\n\n\t\tif (boundingSphere !== null) {\n\n\t\t\toutput.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\t\t}\n\n\t\treturn output;\n\t}\n\n};\n\nexports.default = TypedGeometryExporter;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XLoader = exports.VTKLoader = exports.UTF8Loader = exports.VRMLoader = exports.VRMLLoader = exports.TTFLoader = exports.TGALoader = exports.TDSLoader = exports.SVGLoader = exports.STLLoader = exports.RGBELoader = exports.PVRLoader = exports.PRWMLoader = exports.PLYLoader = exports.PlayCanvasLoader = exports.PDBLoader = exports.PCDLoader = exports.OBJLoader2 = exports.OBJLoader = exports.NRRDLoader = exports.NodeMaterialLoader = exports.MTLLoader = exports.MMDLoader = exports.MD2Loader = exports.LoaderSupport = exports.KTXLoader = exports.KMZLoader = exports.HDRCubeTextureLoader = exports.GLTFLoader = exports.GCodeLoader = exports.FBXLoader = exports.EXRLoader = exports.EquiangularToCubeGenerator = exports.DRACOLoader = exports.DDSLoader = exports.ColladaLoader = exports.BVHLoader = exports.BinaryLoader = exports.BabylonLoader = exports.AWDLoader = exports.AssimpLoader = exports.AssimpJSONLoader = exports.AMFLoader = exports.ThreeMFLoader = undefined;\n\nvar _MFLoader = __webpack_require__(49);\n\nvar _MFLoader2 = _interopRequireDefault(_MFLoader);\n\nvar _AMFLoader = __webpack_require__(50);\n\nvar _AMFLoader2 = _interopRequireDefault(_AMFLoader);\n\nvar _AssimpJSONLoader = __webpack_require__(51);\n\nvar _AssimpJSONLoader2 = _interopRequireDefault(_AssimpJSONLoader);\n\nvar _AssimpLoader = __webpack_require__(52);\n\nvar _AssimpLoader2 = _interopRequireDefault(_AssimpLoader);\n\nvar _AWDLoader = __webpack_require__(53);\n\nvar _AWDLoader2 = _interopRequireDefault(_AWDLoader);\n\nvar _BabylonLoader = __webpack_require__(54);\n\nvar _BabylonLoader2 = _interopRequireDefault(_BabylonLoader);\n\nvar _BinaryLoader = __webpack_require__(55);\n\nvar _BinaryLoader2 = _interopRequireDefault(_BinaryLoader);\n\nvar _BVHLoader = __webpack_require__(56);\n\nvar _BVHLoader2 = _interopRequireDefault(_BVHLoader);\n\nvar _ColladaLoader = __webpack_require__(57);\n\nvar _ColladaLoader2 = _interopRequireDefault(_ColladaLoader);\n\nvar _DDSLoader = __webpack_require__(58);\n\nvar _DDSLoader2 = _interopRequireDefault(_DDSLoader);\n\nvar _DRACOLoader = __webpack_require__(59);\n\nvar _DRACOLoader2 = _interopRequireDefault(_DRACOLoader);\n\nvar _EquiangularToCubeGenerator = __webpack_require__(60);\n\nvar _EquiangularToCubeGenerator2 = _interopRequireDefault(_EquiangularToCubeGenerator);\n\nvar _EXRLoader = __webpack_require__(61);\n\nvar _EXRLoader2 = _interopRequireDefault(_EXRLoader);\n\nvar _FBXLoader = __webpack_require__(62);\n\nvar _FBXLoader2 = _interopRequireDefault(_FBXLoader);\n\nvar _GCodeLoader = __webpack_require__(63);\n\nvar _GCodeLoader2 = _interopRequireDefault(_GCodeLoader);\n\nvar _GLTFLoader = __webpack_require__(5);\n\nvar _GLTFLoader2 = _interopRequireDefault(_GLTFLoader);\n\nvar _HDRCubeTextureLoader = __webpack_require__(64);\n\nvar _HDRCubeTextureLoader2 = _interopRequireDefault(_HDRCubeTextureLoader);\n\nvar _KMZLoader = __webpack_require__(65);\n\nvar _KMZLoader2 = _interopRequireDefault(_KMZLoader);\n\nvar _KTXLoader = __webpack_require__(66);\n\nvar _KTXLoader2 = _interopRequireDefault(_KTXLoader);\n\nvar _LoaderSupport = __webpack_require__(7);\n\nvar _LoaderSupport2 = _interopRequireDefault(_LoaderSupport);\n\nvar _MD2Loader = __webpack_require__(68);\n\nvar _MD2Loader2 = _interopRequireDefault(_MD2Loader);\n\nvar _MMDLoader = __webpack_require__(69);\n\nvar _MMDLoader2 = _interopRequireDefault(_MMDLoader);\n\nvar _MTLLoader = __webpack_require__(9);\n\nvar _MTLLoader2 = _interopRequireDefault(_MTLLoader);\n\nvar _NodeMaterialLoader = __webpack_require__(70);\n\nvar _NodeMaterialLoader2 = _interopRequireDefault(_NodeMaterialLoader);\n\nvar _NRRDLoader = __webpack_require__(71);\n\nvar _NRRDLoader2 = _interopRequireDefault(_NRRDLoader);\n\nvar _OBJLoader = __webpack_require__(72);\n\nvar _OBJLoader2 = _interopRequireDefault(_OBJLoader);\n\nvar _OBJLoader3 = __webpack_require__(73);\n\nvar _OBJLoader4 = _interopRequireDefault(_OBJLoader3);\n\nvar _PCDLoader = __webpack_require__(74);\n\nvar _PCDLoader2 = _interopRequireDefault(_PCDLoader);\n\nvar _PDBLoader = __webpack_require__(75);\n\nvar _PDBLoader2 = _interopRequireDefault(_PDBLoader);\n\nvar _PlayCanvasLoader = __webpack_require__(76);\n\nvar _PlayCanvasLoader2 = _interopRequireDefault(_PlayCanvasLoader);\n\nvar _PLYLoader = __webpack_require__(77);\n\nvar _PLYLoader2 = _interopRequireDefault(_PLYLoader);\n\nvar _PRWMLoader = __webpack_require__(78);\n\nvar _PRWMLoader2 = _interopRequireDefault(_PRWMLoader);\n\nvar _PVRLoader = __webpack_require__(79);\n\nvar _PVRLoader2 = _interopRequireDefault(_PVRLoader);\n\nvar _RGBELoader = __webpack_require__(6);\n\nvar _RGBELoader2 = _interopRequireDefault(_RGBELoader);\n\nvar _STLLoader = __webpack_require__(80);\n\nvar _STLLoader2 = _interopRequireDefault(_STLLoader);\n\nvar _SVGLoader = __webpack_require__(81);\n\nvar _SVGLoader2 = _interopRequireDefault(_SVGLoader);\n\nvar _TDSLoader = __webpack_require__(82);\n\nvar _TDSLoader2 = _interopRequireDefault(_TDSLoader);\n\nvar _TGALoader = __webpack_require__(83);\n\nvar _TGALoader2 = _interopRequireDefault(_TGALoader);\n\nvar _TTFLoader = __webpack_require__(84);\n\nvar _TTFLoader2 = _interopRequireDefault(_TTFLoader);\n\nvar _VRMLLoader = __webpack_require__(85);\n\nvar _VRMLLoader2 = _interopRequireDefault(_VRMLLoader);\n\nvar _VRMLoader = __webpack_require__(86);\n\nvar _VRMLoader2 = _interopRequireDefault(_VRMLoader);\n\nvar _UTF8Loader = __webpack_require__(87);\n\nvar _UTF8Loader2 = _interopRequireDefault(_UTF8Loader);\n\nvar _VTKLoader = __webpack_require__(88);\n\nvar _VTKLoader2 = _interopRequireDefault(_VTKLoader);\n\nvar _XLoader = __webpack_require__(89);\n\nvar _XLoader2 = _interopRequireDefault(_XLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.ThreeMFLoader = _MFLoader2.default;\nexports.AMFLoader = _AMFLoader2.default;\nexports.AssimpJSONLoader = _AssimpJSONLoader2.default;\nexports.AssimpLoader = _AssimpLoader2.default;\nexports.AWDLoader = _AWDLoader2.default;\nexports.BabylonLoader = _BabylonLoader2.default;\nexports.BinaryLoader = _BinaryLoader2.default;\nexports.BVHLoader = _BVHLoader2.default;\nexports.ColladaLoader = _ColladaLoader2.default;\nexports.DDSLoader = _DDSLoader2.default;\nexports.DRACOLoader = _DRACOLoader2.default;\nexports.EquiangularToCubeGenerator = _EquiangularToCubeGenerator2.default;\nexports.EXRLoader = _EXRLoader2.default;\nexports.FBXLoader = _FBXLoader2.default;\nexports.GCodeLoader = _GCodeLoader2.default;\nexports.GLTFLoader = _GLTFLoader2.default;\nexports.HDRCubeTextureLoader = _HDRCubeTextureLoader2.default;\nexports.KMZLoader = _KMZLoader2.default;\nexports.KTXLoader = _KTXLoader2.default;\nexports.LoaderSupport = _LoaderSupport2.default;\nexports.MD2Loader = _MD2Loader2.default;\nexports.MMDLoader = _MMDLoader2.default;\nexports.MTLLoader = _MTLLoader2.default;\nexports.NodeMaterialLoader = _NodeMaterialLoader2.default;\nexports.NRRDLoader = _NRRDLoader2.default;\nexports.OBJLoader = _OBJLoader2.default;\nexports.OBJLoader2 = _OBJLoader4.default;\nexports.PCDLoader = _PCDLoader2.default;\nexports.PDBLoader = _PDBLoader2.default;\nexports.PlayCanvasLoader = _PlayCanvasLoader2.default;\nexports.PLYLoader = _PLYLoader2.default;\nexports.PRWMLoader = _PRWMLoader2.default;\nexports.PVRLoader = _PVRLoader2.default;\nexports.RGBELoader = _RGBELoader2.default;\nexports.STLLoader = _STLLoader2.default;\nexports.SVGLoader = _SVGLoader2.default;\nexports.TDSLoader = _TDSLoader2.default;\nexports.TGALoader = _TGALoader2.default;\nexports.TTFLoader = _TTFLoader2.default;\nexports.VRMLLoader = _VRMLLoader2.default;\nexports.VRMLoader = _VRMLoader2.default;\nexports.UTF8Loader = _UTF8Loader2.default;\nexports.VTKLoader = _VTKLoader2.default;\nexports.XLoader = _XLoader2.default;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author technohippy / https://github.com/technohippy\n */\n\nvar ThreeMFLoader = function ThreeMFLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.availableExtensions = [];\n};\n\nThreeMFLoader.prototype = {\n\n\tconstructor: ThreeMFLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tvar scope = this;\n\n\t\tfunction loadDocument(data) {\n\n\t\t\tvar zip = null;\n\t\t\tvar file = null;\n\n\t\t\tvar relsName;\n\t\t\tvar modelPartNames = [];\n\t\t\tvar printTicketPartNames = [];\n\t\t\tvar texturesPartNames = [];\n\t\t\tvar otherPartNames = [];\n\n\t\t\tvar rels;\n\t\t\tvar modelParts = {};\n\t\t\tvar printTicketParts = {};\n\t\t\tvar texturesParts = {};\n\t\t\tvar otherParts = {};\n\n\t\t\ttry {\n\n\t\t\t\tzip = new JSZip(data); // eslint-disable-line no-undef\n\t\t\t} catch (e) {\n\n\t\t\t\tif (e instanceof ReferenceError) {\n\n\t\t\t\t\tconsole.error('THREE.ThreeMFLoader: jszip missing and file is compressed.');\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (file in zip.files) {\n\n\t\t\t\tif (file.match(/\\.rels$/)) {\n\n\t\t\t\t\trelsName = file;\n\t\t\t\t} else if (file.match(/^3D\\/.*\\.model$/)) {\n\n\t\t\t\t\tmodelPartNames.push(file);\n\t\t\t\t} else if (file.match(/^3D\\/Metadata\\/.*\\.xml$/)) {\n\n\t\t\t\t\tprintTicketPartNames.push(file);\n\t\t\t\t} else if (file.match(/^3D\\/Textures\\/.*/)) {\n\n\t\t\t\t\ttexturesPartNames.push(file);\n\t\t\t\t} else if (file.match(/^3D\\/Other\\/.*/)) {\n\n\t\t\t\t\totherPartNames.push(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar relsView = new Uint8Array(zip.file(relsName).asArrayBuffer());\n\t\t\tvar relsFileText = THREE.LoaderUtils.decodeText(relsView);\n\t\t\trels = parseRelsXml(relsFileText);\n\n\t\t\tfor (var i = 0; i < modelPartNames.length; i++) {\n\n\t\t\t\tvar modelPart = modelPartNames[i];\n\t\t\t\tvar view = new Uint8Array(zip.file(modelPart).asArrayBuffer());\n\n\t\t\t\tvar fileText = THREE.LoaderUtils.decodeText(view);\n\t\t\t\tvar xmlData = new DOMParser().parseFromString(fileText, 'application/xml');\n\n\t\t\t\tif (xmlData.documentElement.nodeName.toLowerCase() !== 'model') {\n\n\t\t\t\t\tconsole.error('THREE.ThreeMFLoader: Error loading 3MF - no 3MF document found: ', modelPart);\n\t\t\t\t}\n\n\t\t\t\tvar modelNode = xmlData.querySelector('model');\n\t\t\t\tvar extensions = {};\n\n\t\t\t\tfor (var i = 0; i < modelNode.attributes.length; i++) {\n\n\t\t\t\t\tvar attr = modelNode.attributes[i];\n\t\t\t\t\tif (attr.name.match(/^xmlns:(.+)$/)) {\n\n\t\t\t\t\t\textensions[attr.value] = RegExp.$1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar modelData = parseModelNode(modelNode);\n\t\t\t\tmodelData['xml'] = modelNode;\n\n\t\t\t\tif (0 < Object.keys(extensions).length) {\n\n\t\t\t\t\tmodelData['extensions'] = extensions;\n\t\t\t\t}\n\n\t\t\t\tmodelParts[modelPart] = modelData;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < texturesPartNames.length; i++) {\n\n\t\t\t\tvar texturesPartName = texturesPartNames[i];\n\t\t\t\ttexturesParts[texturesPartName] = zip.file(texturesPartName).asBinary();\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\trels: rels,\n\t\t\t\tmodel: modelParts,\n\t\t\t\tprintTicket: printTicketParts,\n\t\t\t\ttexture: texturesParts,\n\t\t\t\tother: otherParts\n\t\t\t};\n\t\t}\n\n\t\tfunction parseRelsXml(relsFileText) {\n\n\t\t\tvar relsXmlData = new DOMParser().parseFromString(relsFileText, 'application/xml');\n\t\t\tvar relsNode = relsXmlData.querySelector('Relationship');\n\t\t\tvar target = relsNode.getAttribute('Target');\n\t\t\tvar id = relsNode.getAttribute('Id');\n\t\t\tvar type = relsNode.getAttribute('Type');\n\n\t\t\treturn {\n\t\t\t\ttarget: target,\n\t\t\t\tid: id,\n\t\t\t\ttype: type\n\t\t\t};\n\t\t}\n\n\t\tfunction parseMetadataNodes(metadataNodes) {\n\n\t\t\tvar metadataData = {};\n\n\t\t\tfor (var i = 0; i < metadataNodes.length; i++) {\n\n\t\t\t\tvar metadataNode = metadataNodes[i];\n\t\t\t\tvar name = metadataNode.getAttribute('name');\n\t\t\t\tvar validNames = ['Title', 'Designer', 'Description', 'Copyright', 'LicenseTerms', 'Rating', 'CreationDate', 'ModificationDate'];\n\n\t\t\t\tif (0 <= validNames.indexOf(name)) {\n\n\t\t\t\t\tmetadataData[name] = metadataNode.textContent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn metadataData;\n\t\t}\n\n\t\tfunction parseBasematerialsNode(basematerialsNode) {}\n\n\t\tfunction parseMeshNode(meshNode, extensions) {\n\n\t\t\tvar meshData = {};\n\n\t\t\tvar vertices = [];\n\t\t\tvar vertexNodes = meshNode.querySelectorAll('vertices vertex');\n\n\t\t\tfor (var i = 0; i < vertexNodes.length; i++) {\n\n\t\t\t\tvar vertexNode = vertexNodes[i];\n\t\t\t\tvar x = vertexNode.getAttribute('x');\n\t\t\t\tvar y = vertexNode.getAttribute('y');\n\t\t\t\tvar z = vertexNode.getAttribute('z');\n\n\t\t\t\tvertices.push(parseFloat(x), parseFloat(y), parseFloat(z));\n\t\t\t}\n\n\t\t\tmeshData['vertices'] = new Float32Array(vertices.length);\n\n\t\t\tfor (var i = 0; i < vertices.length; i++) {\n\n\t\t\t\tmeshData['vertices'][i] = vertices[i];\n\t\t\t}\n\n\t\t\tvar triangleProperties = [];\n\t\t\tvar triangles = [];\n\t\t\tvar triangleNodes = meshNode.querySelectorAll('triangles triangle');\n\n\t\t\tfor (var i = 0; i < triangleNodes.length; i++) {\n\n\t\t\t\tvar triangleNode = triangleNodes[i];\n\t\t\t\tvar v1 = triangleNode.getAttribute('v1');\n\t\t\t\tvar v2 = triangleNode.getAttribute('v2');\n\t\t\t\tvar v3 = triangleNode.getAttribute('v3');\n\t\t\t\tvar p1 = triangleNode.getAttribute('p1');\n\t\t\t\tvar p2 = triangleNode.getAttribute('p2');\n\t\t\t\tvar p3 = triangleNode.getAttribute('p3');\n\t\t\t\tvar pid = triangleNode.getAttribute('pid');\n\n\t\t\t\ttriangles.push(parseInt(v1, 10), parseInt(v2, 10), parseInt(v3, 10));\n\n\t\t\t\tvar triangleProperty = {};\n\n\t\t\t\tif (p1) {\n\n\t\t\t\t\ttriangleProperty['p1'] = parseInt(p1, 10);\n\t\t\t\t}\n\n\t\t\t\tif (p2) {\n\n\t\t\t\t\ttriangleProperty['p2'] = parseInt(p2, 10);\n\t\t\t\t}\n\n\t\t\t\tif (p3) {\n\n\t\t\t\t\ttriangleProperty['p3'] = parseInt(p3, 10);\n\t\t\t\t}\n\n\t\t\t\tif (pid) {\n\n\t\t\t\t\ttriangleProperty['pid'] = pid;\n\t\t\t\t}\n\n\t\t\t\tif (0 < Object.keys(triangleProperty).length) {\n\n\t\t\t\t\ttriangleProperties.push(triangleProperty);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmeshData['triangleProperties'] = triangleProperties;\n\t\t\tmeshData['triangles'] = new Uint32Array(triangles.length);\n\n\t\t\tfor (var i = 0; i < triangles.length; i++) {\n\n\t\t\t\tmeshData['triangles'][i] = triangles[i];\n\t\t\t}\n\n\t\t\treturn meshData;\n\t\t}\n\n\t\tfunction parseComponentsNode(componentsNode) {}\n\n\t\tfunction parseObjectNode(objectNode) {\n\n\t\t\tvar objectData = {\n\t\t\t\ttype: objectNode.getAttribute('type')\n\t\t\t};\n\n\t\t\tvar id = objectNode.getAttribute('id');\n\n\t\t\tif (id) {\n\n\t\t\t\tobjectData['id'] = id;\n\t\t\t}\n\n\t\t\tvar pid = objectNode.getAttribute('pid');\n\n\t\t\tif (pid) {\n\n\t\t\t\tobjectData['pid'] = pid;\n\t\t\t}\n\n\t\t\tvar pindex = objectNode.getAttribute('pindex');\n\n\t\t\tif (pindex) {\n\n\t\t\t\tobjectData['pindex'] = pindex;\n\t\t\t}\n\n\t\t\tvar thumbnail = objectNode.getAttribute('thumbnail');\n\n\t\t\tif (thumbnail) {\n\n\t\t\t\tobjectData['thumbnail'] = thumbnail;\n\t\t\t}\n\n\t\t\tvar partnumber = objectNode.getAttribute('partnumber');\n\n\t\t\tif (partnumber) {\n\n\t\t\t\tobjectData['partnumber'] = partnumber;\n\t\t\t}\n\n\t\t\tvar name = objectNode.getAttribute('name');\n\n\t\t\tif (name) {\n\n\t\t\t\tobjectData['name'] = name;\n\t\t\t}\n\n\t\t\tvar meshNode = objectNode.querySelector('mesh');\n\n\t\t\tif (meshNode) {\n\n\t\t\t\tobjectData['mesh'] = parseMeshNode(meshNode);\n\t\t\t}\n\n\t\t\tvar componentsNode = objectNode.querySelector('components');\n\n\t\t\tif (componentsNode) {\n\n\t\t\t\tobjectData['components'] = parseComponentsNode(componentsNode);\n\t\t\t}\n\n\t\t\treturn objectData;\n\t\t}\n\n\t\tfunction parseResourcesNode(resourcesNode) {\n\n\t\t\tvar resourcesData = {};\n\t\t\tvar basematerialsNode = resourcesNode.querySelector('basematerials');\n\n\t\t\tif (basematerialsNode) {\n\n\t\t\t\tresourcesData['basematerial'] = parseBasematerialsNode(basematerialsNode);\n\t\t\t}\n\n\t\t\tresourcesData['object'] = {};\n\t\t\tvar objectNodes = resourcesNode.querySelectorAll('object');\n\n\t\t\tfor (var i = 0; i < objectNodes.length; i++) {\n\n\t\t\t\tvar objectNode = objectNodes[i];\n\t\t\t\tvar objectData = parseObjectNode(objectNode);\n\t\t\t\tresourcesData['object'][objectData['id']] = objectData;\n\t\t\t}\n\n\t\t\treturn resourcesData;\n\t\t}\n\n\t\tfunction parseBuildNode(buildNode) {\n\n\t\t\tvar buildData = [];\n\t\t\tvar itemNodes = buildNode.querySelectorAll('item');\n\n\t\t\tfor (var i = 0; i < itemNodes.length; i++) {\n\n\t\t\t\tvar itemNode = itemNodes[i];\n\t\t\t\tvar buildItem = {\n\t\t\t\t\tobjectid: itemNode.getAttribute('objectid')\n\t\t\t\t};\n\t\t\t\tvar transform = itemNode.getAttribute('transform');\n\n\t\t\t\tif (transform) {\n\n\t\t\t\t\tvar t = [];\n\t\t\t\t\ttransform.split(' ').forEach(function (s) {\n\n\t\t\t\t\t\tt.push(parseFloat(s));\n\t\t\t\t\t});\n\t\t\t\t\tvar mat4 = new THREE.Matrix4();\n\t\t\t\t\tbuildItem['transform'] = mat4.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0.0, 0.0, 0.0, 1.0);\n\t\t\t\t}\n\n\t\t\t\tbuildData.push(buildItem);\n\t\t\t}\n\n\t\t\treturn buildData;\n\t\t}\n\n\t\tfunction parseModelNode(modelNode) {\n\n\t\t\tvar modelData = { unit: modelNode.getAttribute('unit') || 'millimeter' };\n\t\t\tvar metadataNodes = modelNode.querySelectorAll('metadata');\n\n\t\t\tif (metadataNodes) {\n\n\t\t\t\tmodelData['metadata'] = parseMetadataNodes(metadataNodes);\n\t\t\t}\n\n\t\t\tvar resourcesNode = modelNode.querySelector('resources');\n\n\t\t\tif (resourcesNode) {\n\n\t\t\t\tmodelData['resources'] = parseResourcesNode(resourcesNode);\n\t\t\t}\n\n\t\t\tvar buildNode = modelNode.querySelector('build');\n\n\t\t\tif (buildNode) {\n\n\t\t\t\tmodelData['build'] = parseBuildNode(buildNode);\n\t\t\t}\n\n\t\t\treturn modelData;\n\t\t}\n\n\t\tfunction buildMesh(meshData, data3mf) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tgeometry.setIndex(new THREE.BufferAttribute(meshData['triangles'], 1));\n\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(meshData['vertices'], 3));\n\n\t\t\tif (meshData['colors']) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.BufferAttribute(meshData['colors'], 3));\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tvar materialOpts = {\n\t\t\t\tflatShading: true\n\t\t\t};\n\n\t\t\tif (meshData['colors'] && 0 < meshData['colors'].length) {\n\n\t\t\t\tmaterialOpts['vertexColors'] = THREE.VertexColors;\n\t\t\t} else {\n\n\t\t\t\tmaterialOpts['color'] = 0xaaaaff;\n\t\t\t}\n\n\t\t\tvar material = new THREE.MeshPhongMaterial(materialOpts);\n\t\t\treturn new THREE.Mesh(geometry, material);\n\t\t}\n\n\t\tfunction applyExtensions(extensions, meshData, modelXml, data3mf) {\n\n\t\t\tif (!extensions) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar availableExtensions = [];\n\t\t\tvar keys = Object.keys(extensions);\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\n\t\t\t\tvar ns = keys[i];\n\n\t\t\t\tfor (var j = 0; j < scope.availableExtensions.length; j++) {\n\n\t\t\t\t\tvar extension = scope.availableExtensions[j];\n\n\t\t\t\t\tif (extension.ns === ns) {\n\n\t\t\t\t\t\tavailableExtensions.push(extension);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < availableExtensions.length; i++) {\n\n\t\t\t\tvar extension = availableExtensions[i];\n\t\t\t\textension.apply(modelXml, extensions[extension['ns']], meshData);\n\t\t\t}\n\t\t}\n\n\t\tfunction buildMeshes(data3mf) {\n\n\t\t\tvar modelsData = data3mf.model;\n\t\t\tvar meshes = {};\n\t\t\tvar modelsKeys = Object.keys(modelsData);\n\n\t\t\tfor (var i = 0; i < modelsKeys.length; i++) {\n\n\t\t\t\tvar modelsKey = modelsKeys[i];\n\t\t\t\tvar modelData = modelsData[modelsKey];\n\t\t\t\tvar modelXml = modelData['xml'];\n\t\t\t\tvar extensions = modelData['extensions'];\n\n\t\t\t\tvar objectIds = Object.keys(modelData['resources']['object']);\n\n\t\t\t\tfor (var j = 0; j < objectIds.length; j++) {\n\n\t\t\t\t\tvar objectId = objectIds[j];\n\t\t\t\t\tvar objectData = modelData['resources']['object'][objectId];\n\t\t\t\t\tvar meshData = objectData['mesh'];\n\t\t\t\t\tapplyExtensions(extensions, meshData, modelXml, data3mf);\n\t\t\t\t\tmeshes[objectId] = buildMesh(meshData, data3mf);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn meshes;\n\t\t}\n\n\t\tfunction build(meshes, refs, data3mf) {\n\n\t\t\tvar group = new THREE.Group();\n\t\t\tvar buildData = data3mf.model[refs['target'].substring(1)]['build'];\n\n\t\t\tfor (var i = 0; i < buildData.length; i++) {\n\n\t\t\t\tvar buildItem = buildData[i];\n\t\t\t\tvar mesh = meshes[buildItem['objectid']];\n\n\t\t\t\tif (buildItem['transform']) {\n\n\t\t\t\t\tmesh.geometry.applyMatrix(buildItem['transform']);\n\t\t\t\t}\n\n\t\t\t\tgroup.add(mesh);\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\n\t\tvar data3mf = loadDocument(data);\n\t\tvar meshes = buildMeshes(data3mf);\n\n\t\treturn build(meshes, data3mf['rels'], data3mf);\n\t},\n\n\taddExtension: function addExtension(extension) {\n\n\t\tthis.availableExtensions.push(extension);\n\t}\n\n};\n\nexports.default = ThreeMFLoader;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author tamarintech / https://tamarintech.com\n *\n * Description: Early release of an AMF Loader following the pattern of the\n * example loaders in the three.js project.\n *\n * More information about the AMF format: http://amf.wikispaces.com\n *\n * Usage:\n *\tvar loader = new AMFLoader();\n *\tloader.load('/path/to/project.amf', function(objecttree) {\n *\t\tscene.add(objecttree);\n *\t});\n *\n * Materials now supported, material colors supported\n * Zip support, requires jszip\n * No constellation support (yet)!\n *\n */\n\nvar AMFLoader = function AMFLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nAMFLoader.prototype = {\n\n\tconstructor: AMFLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction loadDocument(data) {\n\n\t\t\tvar view = new DataView(data);\n\t\t\tvar magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));\n\n\t\t\tif (magic === 'PK') {\n\n\t\t\t\tvar zip = null;\n\t\t\t\tvar file = null;\n\n\t\t\t\tconsole.log('THREE.AMFLoader: Loading Zip');\n\n\t\t\t\ttry {\n\n\t\t\t\t\tzip = new JSZip(data); // eslint-disable-line no-undef\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tif (e instanceof ReferenceError) {\n\n\t\t\t\t\t\tconsole.log('THREE.AMFLoader: jszip missing and file is compressed.');\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (file in zip.files) {\n\n\t\t\t\t\tif (file.toLowerCase().substr(-4) === '.amf') {\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconsole.log('THREE.AMFLoader: Trying to load file asset: ' + file);\n\t\t\t\tview = new DataView(zip.file(file).asArrayBuffer());\n\t\t\t}\n\n\t\t\tvar fileText = THREE.LoaderUtils.decodeText(view);\n\t\t\tvar xmlData = new DOMParser().parseFromString(fileText, 'application/xml');\n\n\t\t\tif (xmlData.documentElement.nodeName.toLowerCase() !== 'amf') {\n\n\t\t\t\tconsole.log('THREE.AMFLoader: Error loading AMF - no AMF document found.');\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn xmlData;\n\t\t}\n\n\t\tfunction loadDocumentScale(node) {\n\n\t\t\tvar scale = 1.0;\n\t\t\tvar unit = 'millimeter';\n\n\t\t\tif (node.documentElement.attributes.unit !== undefined) {\n\n\t\t\t\tunit = node.documentElement.attributes.unit.value.toLowerCase();\n\t\t\t}\n\n\t\t\tvar scaleUnits = {\n\t\t\t\tmillimeter: 1.0,\n\t\t\t\tinch: 25.4,\n\t\t\t\tfeet: 304.8,\n\t\t\t\tmeter: 1000.0,\n\t\t\t\tmicron: 0.001\n\t\t\t};\n\n\t\t\tif (scaleUnits[unit] !== undefined) {\n\n\t\t\t\tscale = scaleUnits[unit];\n\t\t\t}\n\n\t\t\tconsole.log('THREE.AMFLoader: Unit scale: ' + scale);\n\t\t\treturn scale;\n\t\t}\n\n\t\tfunction loadMaterials(node) {\n\n\t\t\tvar matName = 'AMF Material';\n\t\t\tvar matId = node.attributes.id.textContent;\n\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\tvar loadedMaterial = null;\n\n\t\t\tfor (var i = 0; i < node.childNodes.length; i++) {\n\n\t\t\t\tvar matChildEl = node.childNodes[i];\n\n\t\t\t\tif (matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined) {\n\n\t\t\t\t\tif (matChildEl.attributes.type.value === 'name') {\n\n\t\t\t\t\t\tmatName = matChildEl.textContent;\n\t\t\t\t\t}\n\t\t\t\t} else if (matChildEl.nodeName === 'color') {\n\n\t\t\t\t\tcolor = loadColor(matChildEl);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tloadedMaterial = new THREE.MeshPhongMaterial({\n\t\t\t\tflatShading: true,\n\t\t\t\tcolor: new THREE.Color(color.r, color.g, color.b),\n\t\t\t\tname: matName\n\t\t\t});\n\n\t\t\tif (color.a !== 1.0) {\n\n\t\t\t\tloadedMaterial.transparent = true;\n\t\t\t\tloadedMaterial.opacity = color.a;\n\t\t\t}\n\n\t\t\treturn { id: matId, material: loadedMaterial };\n\t\t}\n\n\t\tfunction loadColor(node) {\n\n\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\tfor (var i = 0; i < node.childNodes.length; i++) {\n\n\t\t\t\tvar matColor = node.childNodes[i];\n\n\t\t\t\tif (matColor.nodeName === 'r') {\n\n\t\t\t\t\tcolor.r = matColor.textContent;\n\t\t\t\t} else if (matColor.nodeName === 'g') {\n\n\t\t\t\t\tcolor.g = matColor.textContent;\n\t\t\t\t} else if (matColor.nodeName === 'b') {\n\n\t\t\t\t\tcolor.b = matColor.textContent;\n\t\t\t\t} else if (matColor.nodeName === 'a') {\n\n\t\t\t\t\tcolor.a = matColor.textContent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn color;\n\t\t}\n\n\t\tfunction loadMeshVolume(node) {\n\n\t\t\tvar volume = { name: '', triangles: [], materialid: null };\n\n\t\t\tvar currVolumeNode = node.firstElementChild;\n\n\t\t\tif (node.attributes.materialid !== undefined) {\n\n\t\t\t\tvolume.materialId = node.attributes.materialid.nodeValue;\n\t\t\t}\n\n\t\t\twhile (currVolumeNode) {\n\n\t\t\t\tif (currVolumeNode.nodeName === 'metadata') {\n\n\t\t\t\t\tif (currVolumeNode.attributes.type !== undefined) {\n\n\t\t\t\t\t\tif (currVolumeNode.attributes.type.value === 'name') {\n\n\t\t\t\t\t\t\tvolume.name = currVolumeNode.textContent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (currVolumeNode.nodeName === 'triangle') {\n\n\t\t\t\t\tvar v1 = currVolumeNode.getElementsByTagName('v1')[0].textContent;\n\t\t\t\t\tvar v2 = currVolumeNode.getElementsByTagName('v2')[0].textContent;\n\t\t\t\t\tvar v3 = currVolumeNode.getElementsByTagName('v3')[0].textContent;\n\n\t\t\t\t\tvolume.triangles.push(v1, v2, v3);\n\t\t\t\t}\n\n\t\t\t\tcurrVolumeNode = currVolumeNode.nextElementSibling;\n\t\t\t}\n\n\t\t\treturn volume;\n\t\t}\n\n\t\tfunction loadMeshVertices(node) {\n\n\t\t\tvar vertArray = [];\n\t\t\tvar normalArray = [];\n\t\t\tvar currVerticesNode = node.firstElementChild;\n\n\t\t\twhile (currVerticesNode) {\n\n\t\t\t\tif (currVerticesNode.nodeName === 'vertex') {\n\n\t\t\t\t\tvar vNode = currVerticesNode.firstElementChild;\n\n\t\t\t\t\twhile (vNode) {\n\n\t\t\t\t\t\tif (vNode.nodeName === 'coordinates') {\n\n\t\t\t\t\t\t\tvar x = vNode.getElementsByTagName('x')[0].textContent;\n\t\t\t\t\t\t\tvar y = vNode.getElementsByTagName('y')[0].textContent;\n\t\t\t\t\t\t\tvar z = vNode.getElementsByTagName('z')[0].textContent;\n\n\t\t\t\t\t\t\tvertArray.push(x, y, z);\n\t\t\t\t\t\t} else if (vNode.nodeName === 'normal') {\n\n\t\t\t\t\t\t\tvar nx = vNode.getElementsByTagName('nx')[0].textContent;\n\t\t\t\t\t\t\tvar ny = vNode.getElementsByTagName('ny')[0].textContent;\n\t\t\t\t\t\t\tvar nz = vNode.getElementsByTagName('nz')[0].textContent;\n\n\t\t\t\t\t\t\tnormalArray.push(nx, ny, nz);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvNode = vNode.nextElementSibling;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrVerticesNode = currVerticesNode.nextElementSibling;\n\t\t\t}\n\n\t\t\treturn { 'vertices': vertArray, 'normals': normalArray };\n\t\t}\n\n\t\tfunction loadObject(node) {\n\n\t\t\tvar objId = node.attributes.id.textContent;\n\t\t\tvar loadedObject = { name: 'amfobject', meshes: [] };\n\t\t\tvar currColor = null;\n\t\t\tvar currObjNode = node.firstElementChild;\n\n\t\t\twhile (currObjNode) {\n\n\t\t\t\tif (currObjNode.nodeName === 'metadata') {\n\n\t\t\t\t\tif (currObjNode.attributes.type !== undefined) {\n\n\t\t\t\t\t\tif (currObjNode.attributes.type.value === 'name') {\n\n\t\t\t\t\t\t\tloadedObject.name = currObjNode.textContent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (currObjNode.nodeName === 'color') {\n\n\t\t\t\t\tcurrColor = loadColor(currObjNode);\n\t\t\t\t} else if (currObjNode.nodeName === 'mesh') {\n\n\t\t\t\t\tvar currMeshNode = currObjNode.firstElementChild;\n\t\t\t\t\tvar mesh = { vertices: [], normals: [], volumes: [], color: currColor };\n\n\t\t\t\t\twhile (currMeshNode) {\n\n\t\t\t\t\t\tif (currMeshNode.nodeName === 'vertices') {\n\n\t\t\t\t\t\t\tvar loadedVertices = loadMeshVertices(currMeshNode);\n\n\t\t\t\t\t\t\tmesh.normals = mesh.normals.concat(loadedVertices.normals);\n\t\t\t\t\t\t\tmesh.vertices = mesh.vertices.concat(loadedVertices.vertices);\n\t\t\t\t\t\t} else if (currMeshNode.nodeName === 'volume') {\n\n\t\t\t\t\t\t\tmesh.volumes.push(loadMeshVolume(currMeshNode));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrMeshNode = currMeshNode.nextElementSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\tloadedObject.meshes.push(mesh);\n\t\t\t\t}\n\n\t\t\t\tcurrObjNode = currObjNode.nextElementSibling;\n\t\t\t}\n\n\t\t\treturn { 'id': objId, 'obj': loadedObject };\n\t\t}\n\n\t\tvar xmlData = loadDocument(data);\n\t\tvar amfName = '';\n\t\tvar amfAuthor = '';\n\t\tvar amfScale = loadDocumentScale(xmlData);\n\t\tvar amfMaterials = {};\n\t\tvar amfObjects = {};\n\t\tvar childNodes = xmlData.documentElement.childNodes;\n\n\t\tvar i, j;\n\n\t\tfor (i = 0; i < childNodes.length; i++) {\n\n\t\t\tvar child = childNodes[i];\n\n\t\t\tif (child.nodeName === 'metadata') {\n\n\t\t\t\tif (child.attributes.type !== undefined) {\n\n\t\t\t\t\tif (child.attributes.type.value === 'name') {\n\n\t\t\t\t\t\tamfName = child.textContent;\n\t\t\t\t\t} else if (child.attributes.type.value === 'author') {\n\n\t\t\t\t\t\tamfAuthor = child.textContent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (child.nodeName === 'material') {\n\n\t\t\t\tvar loadedMaterial = loadMaterials(child);\n\n\t\t\t\tamfMaterials[loadedMaterial.id] = loadedMaterial.material;\n\t\t\t} else if (child.nodeName === 'object') {\n\n\t\t\t\tvar loadedObject = loadObject(child);\n\n\t\t\t\tamfObjects[loadedObject.id] = loadedObject.obj;\n\t\t\t}\n\t\t}\n\n\t\tvar sceneObject = new THREE.Group();\n\t\tvar defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaff, flatShading: true });\n\n\t\tsceneObject.name = amfName;\n\t\tsceneObject.userData.author = amfAuthor;\n\t\tsceneObject.userData.loader = 'AMF';\n\n\t\tfor (var id in amfObjects) {\n\n\t\t\tvar part = amfObjects[id];\n\t\t\tvar meshes = part.meshes;\n\t\t\tvar newObject = new THREE.Group();\n\t\t\tnewObject.name = part.name || '';\n\n\t\t\tfor (i = 0; i < meshes.length; i++) {\n\n\t\t\t\tvar objDefaultMaterial = defaultMaterial;\n\t\t\t\tvar mesh = meshes[i];\n\t\t\t\tvar vertices = new THREE.Float32BufferAttribute(mesh.vertices, 3);\n\t\t\t\tvar normals = null;\n\n\t\t\t\tif (mesh.normals.length) {\n\n\t\t\t\t\tnormals = new THREE.Float32BufferAttribute(mesh.normals, 3);\n\t\t\t\t}\n\n\t\t\t\tif (mesh.color) {\n\n\t\t\t\t\tvar color = mesh.color;\n\n\t\t\t\t\tobjDefaultMaterial = defaultMaterial.clone();\n\t\t\t\t\tobjDefaultMaterial.color = new THREE.Color(color.r, color.g, color.b);\n\n\t\t\t\t\tif (color.a !== 1.0) {\n\n\t\t\t\t\t\tobjDefaultMaterial.transparent = true;\n\t\t\t\t\t\tobjDefaultMaterial.opacity = color.a;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar volumes = mesh.volumes;\n\n\t\t\t\tfor (j = 0; j < volumes.length; j++) {\n\n\t\t\t\t\tvar volume = volumes[j];\n\t\t\t\t\tvar newGeometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar material = objDefaultMaterial;\n\n\t\t\t\t\tnewGeometry.setIndex(volume.triangles);\n\t\t\t\t\tnewGeometry.addAttribute('position', vertices.clone());\n\n\t\t\t\t\tif (normals) {\n\n\t\t\t\t\t\tnewGeometry.addAttribute('normal', normals.clone());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (amfMaterials[volume.materialId] !== undefined) {\n\n\t\t\t\t\t\tmaterial = amfMaterials[volume.materialId];\n\t\t\t\t\t}\n\n\t\t\t\t\tnewGeometry.scale(amfScale, amfScale, amfScale);\n\t\t\t\t\tnewObject.add(new THREE.Mesh(newGeometry, material.clone()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsceneObject.add(newObject);\n\t\t}\n\n\t\treturn sceneObject;\n\t}\n\n};\n\nexports.default = AMFLoader;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Alexander Gessler / http://www.greentoken.de/\n * https://github.com/acgessler\n *\n * Loader for models imported with Open Asset Import Library (http://assimp.sf.net)\n * through assimp2json (https://github.com/acgessler/assimp2json).\n *\n * Supports any input format that assimp supports, including 3ds, obj, dae, blend,\n * fbx, x, ms3d, lwo (and many more).\n *\n * See webgl_loader_assimp2json example.\n */\n\nvar AssimpJSONLoader = function AssimpJSONLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nAssimpJSONLoader.prototype = {\n\n\tconstructor: AssimpJSONLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = THREE.LoaderUtils.extractUrlBase(url);\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tvar json = JSON.parse(text);\n\t\t\tvar metadata = json.__metadata__;\n\n\t\t\t// check if __metadata__ meta header is present\n\t\t\t// this header is used to disambiguate between different JSON-based file formats\n\n\t\t\tif (typeof metadata !== 'undefined') {\n\n\t\t\t\t// check if assimp2json at all\n\n\t\t\t\tif (metadata.format !== 'assimp2json') {\n\n\t\t\t\t\tonError('THREE.AssimpJSONLoader: Not an assimp2json scene.');\n\t\t\t\t\treturn;\n\n\t\t\t\t\t// check major format version\n\t\t\t\t} else if (metadata.version < 100 && metadata.version >= 200) {\n\n\t\t\t\t\tonError('THREE.AssimpJSONLoader: Unsupported assimp2json file format version.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tonLoad(scope.parse(json, path));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(json, path) {\n\n\t\tfunction parseList(json, handler) {\n\n\t\t\tvar meshes = new Array(json.length);\n\n\t\t\tfor (var i = 0; i < json.length; ++i) {\n\n\t\t\t\tmeshes[i] = handler.call(this, json[i]);\n\t\t\t}\n\n\t\t\treturn meshes;\n\t\t}\n\n\t\tfunction parseMesh(json) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar i, l, face;\n\n\t\t\tvar indices = [];\n\n\t\t\tvar vertices = json.vertices || [];\n\t\t\tvar normals = json.normals || [];\n\t\t\tvar uvs = json.texturecoords || [];\n\t\t\tvar colors = json.colors || [];\n\n\t\t\tuvs = uvs[0] || []; // only support for a single set of uvs\n\n\t\t\tfor (i = 0, l = json.faces.length; i < l; i++) {\n\n\t\t\t\tface = json.faces[i];\n\t\t\t\tindices.push(face[0], face[1], face[2]);\n\t\t\t}\n\n\t\t\tgeometry.setIndex(indices);\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n\t\t\tif (normals.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n\t\t\t}\n\n\t\t\tif (uvs.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\t\t\t}\n\n\t\t\tif (colors.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseMaterial(json) {\n\n\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\tfor (var i in json.properties) {\n\n\t\t\t\tvar property = json.properties[i];\n\t\t\t\tvar key = property.key;\n\t\t\t\tvar value = property.value;\n\n\t\t\t\tswitch (key) {\n\n\t\t\t\t\tcase '$tex.file':\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tvar semantic = property.semantic;\n\n\t\t\t\t\t\t\t// prop.semantic gives the type of the texture\n\t\t\t\t\t\t\t// 1: diffuse\n\t\t\t\t\t\t\t// 2: specular mao\n\t\t\t\t\t\t\t// 5: height map (bumps)\n\t\t\t\t\t\t\t// 6: normal map\n\t\t\t\t\t\t\t// more values (i.e. emissive, environment) are known by assimp and may be relevant\n\n\t\t\t\t\t\t\tif (semantic === 1 || semantic === 2 || semantic === 5 || semantic === 6) {\n\n\t\t\t\t\t\t\t\tvar keyname;\n\n\t\t\t\t\t\t\t\tswitch (semantic) {\n\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'map';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'specularMap';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'bumpMap';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'normalMap';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar texture = textureLoader.load(value);\n\n\t\t\t\t\t\t\t\t// TODO: read texture settings from assimp.\n\t\t\t\t\t\t\t\t// Wrapping is the default, though.\n\n\t\t\t\t\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t\t\t\tmaterial[keyname] = texture;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcase '?mat.name':\n\t\t\t\t\t\tmaterial.name = value;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$clr.diffuse':\n\t\t\t\t\t\tmaterial.color.fromArray(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$clr.specular':\n\t\t\t\t\t\tmaterial.specular.fromArray(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$clr.emissive':\n\t\t\t\t\t\tmaterial.emissive.fromArray(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$mat.shininess':\n\t\t\t\t\t\tmaterial.shininess = value;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$mat.shadingm':\n\t\t\t\t\t\t// aiShadingMode_Flat\n\t\t\t\t\t\tmaterial.flatShading = value === 1 ? true : false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$mat.opacity':\n\t\t\t\t\t\tif (value < 1) {\n\t\t\t\t\t\t\tmaterial.opacity = value;\n\t\t\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction parseObject(json, node, meshes, materials) {\n\n\t\t\tvar obj = new THREE.Object3D(),\n\t\t\t    i,\n\t\t\t    idx;\n\n\t\t\tobj.name = node.name || '';\n\t\t\tobj.matrix = new THREE.Matrix4().fromArray(node.transformation).transpose();\n\t\t\tobj.matrix.decompose(obj.position, obj.quaternion, obj.scale);\n\n\t\t\tfor (i = 0; node.meshes && i < node.meshes.length; i++) {\n\n\t\t\t\tidx = node.meshes[i];\n\t\t\t\tobj.add(new THREE.Mesh(meshes[idx], materials[json.meshes[idx].materialindex]));\n\t\t\t}\n\n\t\t\tfor (i = 0; node.children && i < node.children.length; i++) {\n\n\t\t\t\tobj.add(parseObject(json, node.children[i], meshes, materials));\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}\n\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setPath(path).setCrossOrigin(this.crossOrigin);\n\n\t\tvar meshes = parseList(json.meshes, parseMesh);\n\t\tvar materials = parseList(json.materials, parseMaterial);\n\t\treturn parseObject(json, json.rootnode, meshes, materials);\n\t}\n\n};\n\nexports.default = AssimpJSONLoader;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Virtulous / https://virtulo.us/\n */\n\nvar AssimpLoader = function AssimpLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nAssimpLoader.prototype = {\n\n\tconstructor: AssimpLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = THREE.LoaderUtils.extractUrlBase(url);\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer, path));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(buffer, path) {\n\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setPath(path).setCrossOrigin(this.crossOrigin);\n\n\t\tvar Virtulous = {};\n\n\t\tVirtulous.KeyFrame = function (time, matrix) {\n\n\t\t\tthis.time = time;\n\t\t\tthis.matrix = matrix.clone();\n\t\t\tthis.position = new THREE.Vector3();\n\t\t\tthis.quaternion = new THREE.Quaternion();\n\t\t\tthis.scale = new THREE.Vector3(1, 1, 1);\n\t\t\tthis.matrix.decompose(this.position, this.quaternion, this.scale);\n\t\t\tthis.clone = function () {\n\n\t\t\t\tvar n = new Virtulous.KeyFrame(this.time, this.matrix);\n\t\t\t\treturn n;\n\t\t\t};\n\t\t\tthis.lerp = function (nextKey, time) {\n\n\t\t\t\ttime -= this.time;\n\t\t\t\tvar dist = nextKey.time - this.time;\n\t\t\t\tvar l = time / dist;\n\t\t\t\tvar l2 = 1 - l;\n\t\t\t\tvar keypos = this.position;\n\t\t\t\tvar keyrot = this.quaternion;\n\t\t\t\t//      var keyscl =  key.parentspaceScl || key.scl;\n\t\t\t\tvar key2pos = nextKey.position;\n\t\t\t\tvar key2rot = nextKey.quaternion;\n\t\t\t\t//  var key2scl =  key2.parentspaceScl || key2.scl;\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n\t\t\t\t//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n\t\t\t\t//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n\t\t\t\t//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\t\t\t\tVirtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n\t\t\t\tVirtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n\t\t\t\treturn Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n\t\t\t};\n\t\t};\n\n\t\tVirtulous.KeyFrame.tempAniPos = new THREE.Vector3();\n\t\tVirtulous.KeyFrame.tempAniQuat = new THREE.Quaternion();\n\t\tVirtulous.KeyFrame.tempAniScale = new THREE.Vector3(1, 1, 1);\n\t\tVirtulous.KeyFrame.tempAniMatrix = new THREE.Matrix4();\n\t\tVirtulous.KeyFrameTrack = function () {\n\n\t\t\tthis.keys = [];\n\t\t\tthis.target = null;\n\t\t\tthis.time = 0;\n\t\t\tthis.length = 0;\n\t\t\tthis._accelTable = {};\n\t\t\tthis.fps = 20;\n\t\t\tthis.addKey = function (key) {\n\n\t\t\t\tthis.keys.push(key);\n\t\t\t};\n\t\t\tthis.init = function () {\n\n\t\t\t\tthis.sortKeys();\n\n\t\t\t\tif (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n\n\t\t\t\tif (!this.fps) return;\n\n\t\t\t\tfor (var j = 0; j < this.length * this.fps; j++) {\n\n\t\t\t\t\tfor (var i = 0; i < this.keys.length; i++) {\n\n\t\t\t\t\t\tif (this.keys[i].time == j) {\n\n\t\t\t\t\t\t\tthis._accelTable[j] = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n\n\t\t\t\t\t\t\tthis._accelTable[j] = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.parseFromThree = function (data) {\n\n\t\t\t\tvar fps = data.fps;\n\t\t\t\tthis.target = data.node;\n\t\t\t\tvar track = data.hierarchy[0].keys;\n\t\t\t\tfor (var i = 0; i < track.length; i++) {\n\n\t\t\t\t\tthis.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n\t\t\t\t}\n\t\t\t\tthis.init();\n\t\t\t};\n\n\t\t\tthis.parseFromCollada = function (data) {\n\n\t\t\t\tvar track = data.keys;\n\t\t\t\tvar fps = this.fps;\n\n\t\t\t\tfor (var i = 0; i < track.length; i++) {\n\n\t\t\t\t\tthis.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n\t\t\t\t}\n\n\t\t\t\tthis.init();\n\t\t\t};\n\n\t\t\tthis.sortKeys = function () {\n\n\t\t\t\tthis.keys.sort(this.keySortFunc);\n\t\t\t};\n\n\t\t\tthis.keySortFunc = function (a, b) {\n\n\t\t\t\treturn a.time - b.time;\n\t\t\t};\n\n\t\t\tthis.clone = function () {\n\n\t\t\t\tvar t = new Virtulous.KeyFrameTrack();\n\t\t\t\tt.target = this.target;\n\t\t\t\tt.time = this.time;\n\t\t\t\tt.length = this.length;\n\n\t\t\t\tfor (var i = 0; i < this.keys.length; i++) {\n\n\t\t\t\t\tt.addKey(this.keys[i].clone());\n\t\t\t\t}\n\n\t\t\t\tt.init();\n\t\t\t\treturn t;\n\t\t\t};\n\n\t\t\tthis.reTarget = function (root, compareitor) {\n\n\t\t\t\tif (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\tthis.target = compareitor(root, this.target);\n\t\t\t};\n\n\t\t\tthis.keySearchAccel = function (time) {\n\n\t\t\t\ttime *= this.fps;\n\t\t\t\ttime = Math.floor(time);\n\t\t\t\treturn this._accelTable[time] || 0;\n\t\t\t};\n\n\t\t\tthis.setTime = function (time) {\n\n\t\t\t\ttime = Math.abs(time);\n\t\t\t\tif (this.length) time = time % this.length + .05;\n\t\t\t\tvar key0 = null;\n\t\t\t\tvar key1 = null;\n\n\t\t\t\tfor (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\n\n\t\t\t\t\tif (this.keys[i].time == time) {\n\n\t\t\t\t\t\tkey0 = this.keys[i];\n\t\t\t\t\t\tkey1 = this.keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n\n\t\t\t\t\t\tkey0 = this.keys[i];\n\t\t\t\t\t\tkey1 = this.keys[i + 1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (this.keys[i].time < time && i == this.keys.length - 1) {\n\n\t\t\t\t\t\tkey0 = this.keys[i];\n\t\t\t\t\t\tkey1 = this.keys[0].clone();\n\t\t\t\t\t\tkey1.time += this.length + .05;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (key0 && key1 && key0 !== key1) {\n\n\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\tthis.target.matrix.copy(key0.lerp(key1, time));\n\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key0 && key1 && key0 == key1) {\n\n\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\tthis.target.matrix.copy(key0.matrix);\n\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tVirtulous.TrackTargetNodeNameCompare = function (root, target) {\n\n\t\t\tfunction find(node, name) {\n\n\t\t\t\tif (node.name == name) return node;\n\n\t\t\t\tfor (var i = 0; i < node.children.length; i++) {\n\n\t\t\t\t\tvar r = find(node.children[i], name);\n\t\t\t\t\tif (r) return r;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn find(root, target.name);\n\t\t};\n\n\t\tVirtulous.Animation = function () {\n\n\t\t\tthis.tracks = [];\n\t\t\tthis.length = 0;\n\n\t\t\tthis.addTrack = function (track) {\n\n\t\t\t\tthis.tracks.push(track);\n\t\t\t\tthis.length = Math.max(track.length, this.length);\n\t\t\t};\n\n\t\t\tthis.setTime = function (time) {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tfor (var i = 0; i < this.tracks.length; i++) {\n\t\t\t\t\tthis.tracks[i].setTime(time);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.clone = function (target, compareitor) {\n\n\t\t\t\tif (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\tvar n = new Virtulous.Animation();\n\t\t\t\tn.target = target;\n\t\t\t\tfor (var i = 0; i < this.tracks.length; i++) {\n\n\t\t\t\t\tvar track = this.tracks[i].clone();\n\t\t\t\t\ttrack.reTarget(target, compareitor);\n\t\t\t\t\tn.addTrack(track);\n\t\t\t\t}\n\n\t\t\t\treturn n;\n\t\t\t};\n\t\t};\n\n\t\tvar ASSBIN_CHUNK_AICAMERA = 0x1234;\n\t\tvar ASSBIN_CHUNK_AILIGHT = 0x1235;\n\t\tvar ASSBIN_CHUNK_AITEXTURE = 0x1236;\n\t\tvar ASSBIN_CHUNK_AIMESH = 0x1237;\n\t\tvar ASSBIN_CHUNK_AINODEANIM = 0x1238;\n\t\tvar ASSBIN_CHUNK_AISCENE = 0x1239;\n\t\tvar ASSBIN_CHUNK_AIBONE = 0x123a;\n\t\tvar ASSBIN_CHUNK_AIANIMATION = 0x123b;\n\t\tvar ASSBIN_CHUNK_AINODE = 0x123c;\n\t\tvar ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n\t\tvar ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n\t\tvar ASSBIN_MESH_HAS_POSITIONS = 0x1;\n\t\tvar ASSBIN_MESH_HAS_NORMALS = 0x2;\n\t\tvar ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n\t\tvar ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n\t\tvar ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n\t\tvar AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n\t\tvar AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n\t\tvar aiLightSource_UNDEFINED = 0x0;\n\t\t//! A directional light source has a well-defined direction\n\t\t//! but is infinitely far away. That's quite a good\n\t\t//! approximation for sun light.\n\t\tvar aiLightSource_DIRECTIONAL = 0x1;\n\t\t//! A point light source has a well-defined position\n\t\t//! in space but no direction - it emits light in all\n\t\t//! directions. A normal bulb is a point light.\n\t\tvar aiLightSource_POINT = 0x2;\n\t\t//! A spot light source emits light in a specific\n\t\t//! angle. It has a position and a direction it is pointing to.\n\t\t//! A good example for a spot light is a light spot in\n\t\t//! sport arenas.\n\t\tvar aiLightSource_SPOT = 0x3;\n\t\t//! The generic light level of the world, including the bounces\n\t\t//! of all other lightsources.\n\t\t//! Typically, there's at most one ambient light in a scene.\n\t\t//! This light type doesn't have a valid position, direction, or\n\t\t//! other properties, just a color.\n\t\tvar aiLightSource_AMBIENT = 0x4;\n\t\t/** Flat shading. Shading is done on per-face base,\n   *  diffuse only. Also known as 'faceted shading'.\n   */\n\t\tvar aiShadingMode_Flat = 0x1;\n\t\t/** Simple Gouraud shading.\n   */\n\t\tvar aiShadingMode_Gouraud = 0x2;\n\t\t/** Phong-Shading -\n   */\n\t\tvar aiShadingMode_Phong = 0x3;\n\t\t/** Phong-Blinn-Shading\n   */\n\t\tvar aiShadingMode_Blinn = 0x4;\n\t\t/** Toon-Shading per pixel\n   *\n   *  Also known as 'comic' shader.\n   */\n\t\tvar aiShadingMode_Toon = 0x5;\n\t\t/** OrenNayar-Shading per pixel\n   *\n   *  Extension to standard Lambertian shading, taking the\n   *  roughness of the material into account\n   */\n\t\tvar aiShadingMode_OrenNayar = 0x6;\n\t\t/** Minnaert-Shading per pixel\n   *\n   *  Extension to standard Lambertian shading, taking the\n   *  \"darkness\" of the material into account\n   */\n\t\tvar aiShadingMode_Minnaert = 0x7;\n\t\t/** CookTorrance-Shading per pixel\n   *\n   *  Special shader for metallic surfaces.\n   */\n\t\tvar aiShadingMode_CookTorrance = 0x8;\n\t\t/** No shading at all. Constant light influence of 1.0.\n   */\n\t\tvar aiShadingMode_NoShading = 0x9;\n\t\t/** Fresnel shading\n   */\n\t\tvar aiShadingMode_Fresnel = 0xa;\n\t\tvar aiTextureType_NONE = 0x0;\n\t\t/** The texture is combined with the result of the diffuse\n   *  lighting equation.\n   */\n\t\tvar aiTextureType_DIFFUSE = 0x1;\n\t\t/** The texture is combined with the result of the specular\n   *  lighting equation.\n   */\n\t\tvar aiTextureType_SPECULAR = 0x2;\n\t\t/** The texture is combined with the result of the ambient\n   *  lighting equation.\n   */\n\t\tvar aiTextureType_AMBIENT = 0x3;\n\t\t/** The texture is added to the result of the lighting\n   *  calculation. It isn't influenced by incoming light.\n   */\n\t\tvar aiTextureType_EMISSIVE = 0x4;\n\t\t/** The texture is a height map.\n   *\n   *  By convention, higher gray-scale values stand for\n   *  higher elevations from the base height.\n   */\n\t\tvar aiTextureType_HEIGHT = 0x5;\n\t\t/** The texture is a (tangent space) normal-map.\n   *\n   *  Again, there are several conventions for tangent-space\n   *  normal maps. Assimp does (intentionally) not\n   *  distinguish here.\n   */\n\t\tvar aiTextureType_NORMALS = 0x6;\n\t\t/** The texture defines the glossiness of the material.\n   *\n   *  The glossiness is in fact the exponent of the specular\n   *  (phong) lighting equation. Usually there is a conversion\n   *  function defined to map the linear color values in the\n   *  texture to a suitable exponent. Have fun.\n   */\n\t\tvar aiTextureType_SHININESS = 0x7;\n\t\t/** The texture defines per-pixel opacity.\n   *\n   *  Usually 'white' means opaque and 'black' means\n   *  'transparency'. Or quite the opposite. Have fun.\n   */\n\t\tvar aiTextureType_OPACITY = 0x8;\n\t\t/** Displacement texture\n   *\n   *  The exact purpose and format is application-dependent.\n   *  Higher color values stand for higher vertex displacements.\n   */\n\t\tvar aiTextureType_DISPLACEMENT = 0x9;\n\t\t/** Lightmap texture (aka Ambient Occlusion)\n   *\n   *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n   *  covered by this material property. The texture contains a\n   *  scaling value for the final color value of a pixel. Its\n   *  intensity is not affected by incoming light.\n   */\n\t\tvar aiTextureType_LIGHTMAP = 0xA;\n\t\t/** Reflection texture\n   *\n   * Contains the color of a perfect mirror reflection.\n   * Rarely used, almost never for real-time applications.\n   */\n\t\tvar aiTextureType_REFLECTION = 0xB;\n\t\t/** Unknown texture\n   *\n   *  A texture reference that does not match any of the definitions\n   *  above is considered to be 'unknown'. It is still imported,\n   *  but is excluded from any further postprocessing.\n   */\n\t\tvar aiTextureType_UNKNOWN = 0xC;\n\t\tvar BONESPERVERT = 4;\n\n\t\tfunction ASSBIN_MESH_HAS_TEXCOORD(n) {\n\n\t\t\treturn ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n\t\t}\n\n\t\tfunction ASSBIN_MESH_HAS_COLOR(n) {\n\n\t\t\treturn ASSBIN_MESH_HAS_COLOR_BASE << n;\n\t\t}\n\n\t\tfunction markBones(scene) {\n\n\t\t\tfor (var i in scene.mMeshes) {\n\n\t\t\t\tvar mesh = scene.mMeshes[i];\n\t\t\t\tfor (var k in mesh.mBones) {\n\n\t\t\t\t\tvar boneNode = scene.findNode(mesh.mBones[k].mName);\n\t\t\t\t\tif (boneNode) boneNode.isBone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction cloneTreeToBones(root, scene) {\n\n\t\t\tvar rootBone = new THREE.Bone();\n\t\t\trootBone.matrix.copy(root.matrix);\n\t\t\trootBone.matrixWorld.copy(root.matrixWorld);\n\t\t\trootBone.position.copy(root.position);\n\t\t\trootBone.quaternion.copy(root.quaternion);\n\t\t\trootBone.scale.copy(root.scale);\n\t\t\tscene.nodeCount++;\n\t\t\trootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n\n\t\t\tif (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n\t\t\tscene.nodeToBoneMap[root.name].push(rootBone);\n\t\t\tfor (var i in root.children) {\n\n\t\t\t\tvar child = cloneTreeToBones(root.children[i], scene);\n\t\t\t\tif (child) rootBone.add(child);\n\t\t\t}\n\n\t\t\treturn rootBone;\n\t\t}\n\n\t\tfunction sortWeights(indexes, weights) {\n\n\t\t\tvar pairs = [];\n\n\t\t\tfor (var i = 0; i < indexes.length; i++) {\n\n\t\t\t\tpairs.push({\n\t\t\t\t\ti: indexes[i],\n\t\t\t\t\tw: weights[i]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tpairs.sort(function (a, b) {\n\n\t\t\t\treturn b.w - a.w;\n\t\t\t});\n\n\t\t\twhile (pairs.length < 4) {\n\n\t\t\t\tpairs.push({\n\t\t\t\t\ti: 0,\n\t\t\t\t\tw: 0\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (pairs.length > 4) pairs.length = 4;\n\t\t\tvar sum = 0;\n\n\t\t\tfor (var i = 0; i < 4; i++) {\n\n\t\t\t\tsum += pairs[i].w * pairs[i].w;\n\t\t\t}\n\n\t\t\tsum = Math.sqrt(sum);\n\n\t\t\tfor (var i = 0; i < 4; i++) {\n\n\t\t\t\tpairs[i].w = pairs[i].w / sum;\n\t\t\t\tindexes[i] = pairs[i].i;\n\t\t\t\tweights[i] = pairs[i].w;\n\t\t\t}\n\t\t}\n\n\t\tfunction findMatchingBone(root, name) {\n\n\t\t\tif (root.name.indexOf(\"bone_\" + name) == 0) return root;\n\n\t\t\tfor (var i in root.children) {\n\n\t\t\t\tvar ret = findMatchingBone(root.children[i], name);\n\n\t\t\t\tif (ret) return ret;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction aiMesh() {\n\n\t\t\tthis.mPrimitiveTypes = 0;\n\t\t\tthis.mNumVertices = 0;\n\t\t\tthis.mNumFaces = 0;\n\t\t\tthis.mNumBones = 0;\n\t\t\tthis.mMaterialIndex = 0;\n\t\t\tthis.mVertices = [];\n\t\t\tthis.mNormals = [];\n\t\t\tthis.mTangents = [];\n\t\t\tthis.mBitangents = [];\n\t\t\tthis.mColors = [[]];\n\t\t\tthis.mTextureCoords = [[]];\n\t\t\tthis.mFaces = [];\n\t\t\tthis.mBones = [];\n\t\t\tthis.hookupSkeletons = function (scene, threeScene) {\n\n\t\t\t\tif (this.mBones.length == 0) return;\n\n\t\t\t\tvar allBones = [];\n\t\t\t\tvar offsetMatrix = [];\n\t\t\t\tvar skeletonRoot = scene.findNode(this.mBones[0].mName);\n\n\t\t\t\twhile (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n\n\t\t\t\t\tskeletonRoot = skeletonRoot.mParent;\n\t\t\t\t}\n\n\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n\t\t\t\tthis.threeNode.add(threeSkeletonRootBone);\n\n\t\t\t\tfor (var i = 0; i < this.mBones.length; i++) {\n\n\t\t\t\t\tvar bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\n\t\t\t\t\tif (bone) {\n\n\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\tallBones.push(tbone);\n\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\toffsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar skeletonRoot = scene.findNode(this.mBones[i].mName);\n\t\t\t\t\t\tif (!skeletonRoot) return;\n\t\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n\t\t\t\t\t\tvar threeSkeletonRootParent = threeSkeletonRoot.parent;\n\t\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n\t\t\t\t\t\tthis.threeNode.add(threeSkeletonRootBone);\n\t\t\t\t\t\tvar bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\tallBones.push(tbone);\n\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\toffsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar skeleton = new THREE.Skeleton(allBones, offsetMatrix);\n\n\t\t\t\tthis.threeNode.bind(skeleton, new THREE.Matrix4());\n\t\t\t\tthis.threeNode.material.skinning = true;\n\t\t\t};\n\n\t\t\tthis.toTHREE = function (scene) {\n\n\t\t\t\tif (this.threeNode) return this.threeNode;\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tvar mat;\n\t\t\t\tif (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new THREE.MeshLambertMaterial();\n\t\t\t\tgeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(this.mVertexBuffer, 3));\n\t\t\t\tif (this.mNormalBuffer && this.mNormalBuffer.length > 0) geometry.addAttribute('normal', new THREE.BufferAttribute(this.mNormalBuffer, 3));\n\t\t\t\tif (this.mColorBuffer && this.mColorBuffer.length > 0) geometry.addAttribute('color', new THREE.BufferAttribute(this.mColorBuffer, 4));\n\t\t\t\tif (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n\t\t\t\tif (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) geometry.addAttribute('uv1', new THREE.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n\t\t\t\tif (this.mTangentBuffer && this.mTangentBuffer.length > 0) geometry.addAttribute('tangents', new THREE.BufferAttribute(this.mTangentBuffer, 3));\n\t\t\t\tif (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) geometry.addAttribute('bitangents', new THREE.BufferAttribute(this.mBitangentBuffer, 3));\n\t\t\t\tif (this.mBones.length > 0) {\n\n\t\t\t\t\tvar weights = [];\n\t\t\t\t\tvar bones = [];\n\n\t\t\t\t\tfor (var i = 0; i < this.mBones.length; i++) {\n\n\t\t\t\t\t\tfor (var j = 0; j < this.mBones[i].mWeights.length; j++) {\n\n\t\t\t\t\t\t\tvar weight = this.mBones[i].mWeights[j];\n\t\t\t\t\t\t\tif (weight) {\n\n\t\t\t\t\t\t\t\tif (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n\t\t\t\t\t\t\t\tif (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n\t\t\t\t\t\t\t\tweights[weight.mVertexId].push(weight.mWeight);\n\t\t\t\t\t\t\t\tbones[weight.mVertexId].push(parseInt(i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i in bones) {\n\n\t\t\t\t\t\tsortWeights(bones[i], weights[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _weights = [];\n\t\t\t\t\tvar _bones = [];\n\n\t\t\t\t\tfor (var i = 0; i < weights.length; i++) {\n\n\t\t\t\t\t\tfor (var j = 0; j < 4; j++) {\n\n\t\t\t\t\t\t\tif (weights[i] && bones[i]) {\n\n\t\t\t\t\t\t\t\t_weights.push(weights[i][j]);\n\t\t\t\t\t\t\t\t_bones.push(bones[i][j]);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_weights.push(0);\n\t\t\t\t\t\t\t\t_bones.push(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute('skinWeight', new THREE.BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n\t\t\t\t\tgeometry.addAttribute('skinIndex', new THREE.BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n\t\t\t\t}\n\n\t\t\t\tvar mesh;\n\n\t\t\t\tif (this.mBones.length == 0) mesh = new THREE.Mesh(geometry, mat);\n\n\t\t\t\tif (this.mBones.length > 0) mesh = new THREE.SkinnedMesh(geometry, mat);\n\n\t\t\t\tthis.threeNode = mesh;\n\t\t\t\t//mesh.matrixAutoUpdate = false;\n\t\t\t\treturn mesh;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiFace() {\n\n\t\t\tthis.mNumIndices = 0;\n\t\t\tthis.mIndices = [];\n\t\t}\n\n\t\tfunction aiVector3D() {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Vector3(this.x, this.y, this.z);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVector2D() {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Vector2(this.x, this.y);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVector4D() {\n\n\t\t\tthis.w = 0;\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Vector4(this.w, this.x, this.y, this.z);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiColor4D() {\n\n\t\t\tthis.r = 0;\n\t\t\tthis.g = 0;\n\t\t\tthis.b = 0;\n\t\t\tthis.a = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Color(this.r, this.g, this.b, this.a);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiColor3D() {\n\n\t\t\tthis.r = 0;\n\t\t\tthis.g = 0;\n\t\t\tthis.b = 0;\n\t\t\tthis.a = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Color(this.r, this.g, this.b, 1);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiQuaternion() {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Quaternion(this.x, this.y, this.z, this.w);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVertexWeight() {\n\n\t\t\tthis.mVertexId = 0;\n\t\t\tthis.mWeight = 0;\n\t\t}\n\n\t\tfunction aiString() {\n\n\t\t\tthis.data = [];\n\t\t\tthis.toString = function () {\n\n\t\t\t\tvar str = '';\n\t\t\t\tthis.data.forEach(function (i) {\n\n\t\t\t\t\tstr += String.fromCharCode(i);\n\t\t\t\t});\n\t\t\t\treturn str.replace(/[^\\x20-\\x7E]+/g, '');\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVectorKey() {\n\n\t\t\tthis.mTime = 0;\n\t\t\tthis.mValue = null;\n\t\t}\n\n\t\tfunction aiQuatKey() {\n\n\t\t\tthis.mTime = 0;\n\t\t\tthis.mValue = null;\n\t\t}\n\n\t\tfunction aiNode() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mTransformation = [];\n\t\t\tthis.mNumChildren = 0;\n\t\t\tthis.mNumMeshes = 0;\n\t\t\tthis.mMeshes = [];\n\t\t\tthis.mChildren = [];\n\t\t\tthis.toTHREE = function (scene) {\n\n\t\t\t\tif (this.threeNode) return this.threeNode;\n\t\t\t\tvar o = new THREE.Object3D();\n\t\t\t\to.name = this.mName;\n\t\t\t\to.matrix = this.mTransformation.toTHREE();\n\n\t\t\t\tfor (var i = 0; i < this.mChildren.length; i++) {\n\n\t\t\t\t\to.add(this.mChildren[i].toTHREE(scene));\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < this.mMeshes.length; i++) {\n\n\t\t\t\t\to.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n\t\t\t\t}\n\n\t\t\t\tthis.threeNode = o;\n\t\t\t\t//o.matrixAutoUpdate = false;\n\t\t\t\to.matrix.decompose(o.position, o.quaternion, o.scale);\n\t\t\t\treturn o;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiBone() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mNumWeights = 0;\n\t\t\tthis.mOffsetMatrix = 0;\n\t\t}\n\n\t\tfunction aiMaterialProperty() {\n\n\t\t\tthis.mKey = \"\";\n\t\t\tthis.mSemantic = 0;\n\t\t\tthis.mIndex = 0;\n\t\t\tthis.mData = [];\n\t\t\tthis.mDataLength = 0;\n\t\t\tthis.mType = 0;\n\t\t\tthis.dataAsColor = function () {\n\n\t\t\t\tvar array = new Uint8Array(this.mData).buffer;\n\t\t\t\tvar reader = new DataView(array);\n\t\t\t\tvar r = reader.getFloat32(0, true);\n\t\t\t\tvar g = reader.getFloat32(4, true);\n\t\t\t\tvar b = reader.getFloat32(8, true);\n\t\t\t\t//var a = reader.getFloat32(12, true);\n\t\t\t\treturn new THREE.Color(r, g, b);\n\t\t\t};\n\n\t\t\tthis.dataAsFloat = function () {\n\n\t\t\t\tvar array = new Uint8Array(this.mData).buffer;\n\t\t\t\tvar reader = new DataView(array);\n\t\t\t\tvar r = reader.getFloat32(0, true);\n\t\t\t\treturn r;\n\t\t\t};\n\n\t\t\tthis.dataAsBool = function () {\n\n\t\t\t\tvar array = new Uint8Array(this.mData).buffer;\n\t\t\t\tvar reader = new DataView(array);\n\t\t\t\tvar r = reader.getFloat32(0, true);\n\t\t\t\treturn !!r;\n\t\t\t};\n\n\t\t\tthis.dataAsString = function () {\n\n\t\t\t\tvar s = new aiString();\n\t\t\t\ts.data = this.mData;\n\t\t\t\treturn s.toString();\n\t\t\t};\n\n\t\t\tthis.dataAsMap = function () {\n\n\t\t\t\tvar s = new aiString();\n\t\t\t\ts.data = this.mData;\n\t\t\t\tvar path = s.toString();\n\t\t\t\tpath = path.replace(/\\\\/g, '/');\n\n\t\t\t\tif (path.indexOf('/') != -1) {\n\n\t\t\t\t\tpath = path.substr(path.lastIndexOf('/') + 1);\n\t\t\t\t}\n\n\t\t\t\treturn textureLoader.load(path);\n\t\t\t};\n\t\t}\n\t\tvar namePropMapping = {\n\n\t\t\t\"?mat.name\": \"name\",\n\t\t\t\"$mat.shadingm\": \"shading\",\n\t\t\t\"$mat.twosided\": \"twoSided\",\n\t\t\t\"$mat.wireframe\": \"wireframe\",\n\t\t\t\"$clr.ambient\": \"ambient\",\n\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\"$clr.specular\": \"specular\",\n\t\t\t\"$clr.emissive\": \"emissive\",\n\t\t\t\"$clr.transparent\": \"transparent\",\n\t\t\t\"$clr.reflective\": \"reflect\",\n\t\t\t\"$mat.shininess\": \"shininess\",\n\t\t\t\"$mat.reflectivity\": \"reflectivity\",\n\t\t\t\"$mat.refracti\": \"refraction\",\n\t\t\t\"$tex.file\": \"map\"\n\n\t\t};\n\n\t\tvar nameTypeMapping = {\n\n\t\t\t\"?mat.name\": \"string\",\n\t\t\t\"$mat.shadingm\": \"bool\",\n\t\t\t\"$mat.twosided\": \"bool\",\n\t\t\t\"$mat.wireframe\": \"bool\",\n\t\t\t\"$clr.ambient\": \"color\",\n\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\"$clr.specular\": \"color\",\n\t\t\t\"$clr.emissive\": \"color\",\n\t\t\t\"$clr.transparent\": \"color\",\n\t\t\t\"$clr.reflective\": \"color\",\n\t\t\t\"$mat.shininess\": \"float\",\n\t\t\t\"$mat.reflectivity\": \"float\",\n\t\t\t\"$mat.refracti\": \"float\",\n\t\t\t\"$tex.file\": \"map\"\n\n\t\t};\n\n\t\tfunction aiMaterial() {\n\n\t\t\tthis.mNumAllocated = 0;\n\t\t\tthis.mNumProperties = 0;\n\t\t\tthis.mProperties = [];\n\t\t\tthis.toTHREE = function (scene) {\n\n\t\t\t\tvar name = this.mProperties[0].dataAsString();\n\t\t\t\tvar mat = new THREE.MeshPhongMaterial();\n\n\t\t\t\tfor (var i = 0; i < this.mProperties.length; i++) {\n\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'float') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'color') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'bool') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'string') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n\n\t\t\t\t\t\tvar prop = this.mProperties[i];\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmat.ambient.r = .53;\n\t\t\t\tmat.ambient.g = .53;\n\t\t\t\tmat.ambient.b = .53;\n\t\t\t\tmat.color.r = 1;\n\t\t\t\tmat.color.g = 1;\n\t\t\t\tmat.color.b = 1;\n\t\t\t\treturn mat;\n\t\t\t};\n\t\t}\n\n\t\tfunction veclerp(v1, v2, l) {\n\n\t\t\tvar v = new THREE.Vector3();\n\t\t\tvar lm1 = 1 - l;\n\t\t\tv.x = v1.x * l + v2.x * lm1;\n\t\t\tv.y = v1.y * l + v2.y * lm1;\n\t\t\tv.z = v1.z * l + v2.z * lm1;\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction quatlerp(q1, q2, l) {\n\n\t\t\treturn q1.clone().slerp(q2, 1 - l);\n\t\t}\n\n\t\tfunction sampleTrack(keys, time, lne, lerp) {\n\n\t\t\tif (keys.length == 1) return keys[0].mValue.toTHREE();\n\n\t\t\tvar dist = Infinity;\n\t\t\tvar key = null;\n\t\t\tvar nextKey = null;\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\n\t\t\t\tvar timeDist = Math.abs(keys[i].mTime - time);\n\n\t\t\t\tif (timeDist < dist && keys[i].mTime <= time) {\n\n\t\t\t\t\tdist = timeDist;\n\t\t\t\t\tkey = keys[i];\n\t\t\t\t\tnextKey = keys[i + 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!key) {\n\n\t\t\t\treturn null;\n\t\t\t} else if (nextKey) {\n\n\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\tvar T = key.mTime - time;\n\t\t\t\tvar l = T / dT;\n\n\t\t\t\treturn lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n\t\t\t} else {\n\n\t\t\t\tnextKey = keys[0].clone();\n\t\t\t\tnextKey.mTime += lne;\n\n\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\tvar T = key.mTime - time;\n\t\t\t\tvar l = T / dT;\n\n\t\t\t\treturn lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n\t\t\t}\n\t\t}\n\n\t\tfunction aiNodeAnim() {\n\n\t\t\tthis.mNodeName = \"\";\n\t\t\tthis.mNumPositionKeys = 0;\n\t\t\tthis.mNumRotationKeys = 0;\n\t\t\tthis.mNumScalingKeys = 0;\n\t\t\tthis.mPositionKeys = [];\n\t\t\tthis.mRotationKeys = [];\n\t\t\tthis.mScalingKeys = [];\n\t\t\tthis.mPreState = \"\";\n\t\t\tthis.mPostState = \"\";\n\t\t\tthis.init = function (tps) {\n\n\t\t\t\tif (!tps) tps = 1;\n\n\t\t\t\tfunction t(t) {\n\n\t\t\t\t\tt.mTime /= tps;\n\t\t\t\t}\n\n\t\t\t\tthis.mPositionKeys.forEach(t);\n\t\t\t\tthis.mRotationKeys.forEach(t);\n\t\t\t\tthis.mScalingKeys.forEach(t);\n\t\t\t};\n\n\t\t\tthis.sortKeys = function () {\n\n\t\t\t\tfunction comp(a, b) {\n\n\t\t\t\t\treturn a.mTime - b.mTime;\n\t\t\t\t}\n\n\t\t\t\tthis.mPositionKeys.sort(comp);\n\t\t\t\tthis.mRotationKeys.sort(comp);\n\t\t\t\tthis.mScalingKeys.sort(comp);\n\t\t\t};\n\n\t\t\tthis.getLength = function () {\n\n\t\t\t\treturn Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n\n\t\t\t\t\treturn a.mTime;\n\t\t\t\t})), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n\n\t\t\t\t\treturn a.mTime;\n\t\t\t\t})), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n\n\t\t\t\t\treturn a.mTime;\n\t\t\t\t})));\n\t\t\t};\n\n\t\t\tthis.toTHREE = function (o, tps) {\n\n\t\t\t\tthis.sortKeys();\n\t\t\t\tvar length = this.getLength();\n\t\t\t\tvar track = new Virtulous.KeyFrameTrack();\n\n\t\t\t\tfor (var i = 0; i < length; i += .05) {\n\n\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\t\tvar time = i;\n\t\t\t\t\tvar pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n\t\t\t\t\tvar scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n\t\t\t\t\tvar rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n\t\t\t\t\tmatrix.compose(pos, rotation, scale);\n\n\t\t\t\t\tvar key = new Virtulous.KeyFrame(time, matrix);\n\t\t\t\t\ttrack.addKey(key);\n\t\t\t\t}\n\n\t\t\t\ttrack.target = o.findNode(this.mNodeName).toTHREE();\n\n\t\t\t\tvar tracks = [track];\n\n\t\t\t\tif (o.nodeToBoneMap[this.mNodeName]) {\n\n\t\t\t\t\tfor (var i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n\n\t\t\t\t\t\tvar t2 = track.clone();\n\t\t\t\t\t\tt2.target = o.nodeToBoneMap[this.mNodeName][i];\n\t\t\t\t\t\ttracks.push(t2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiAnimation() {\n\n\t\t\tthis.mName = \"\";\n\t\t\tthis.mDuration = 0;\n\t\t\tthis.mTicksPerSecond = 0;\n\t\t\tthis.mNumChannels = 0;\n\t\t\tthis.mChannels = [];\n\t\t\tthis.toTHREE = function (root) {\n\n\t\t\t\tvar animationHandle = new Virtulous.Animation();\n\n\t\t\t\tfor (var i in this.mChannels) {\n\n\t\t\t\t\tthis.mChannels[i].init(this.mTicksPerSecond);\n\n\t\t\t\t\tvar tracks = this.mChannels[i].toTHREE(root);\n\n\t\t\t\t\tfor (var j in tracks) {\n\n\t\t\t\t\t\ttracks[j].init();\n\t\t\t\t\t\tanimationHandle.addTrack(tracks[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tanimationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n\n\t\t\t\t\treturn e.length;\n\t\t\t\t}));\n\t\t\t\treturn animationHandle;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiTexture() {\n\n\t\t\tthis.mWidth = 0;\n\t\t\tthis.mHeight = 0;\n\t\t\tthis.texAchFormatHint = [];\n\t\t\tthis.pcData = [];\n\t\t}\n\n\t\tfunction aiLight() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mType = 0;\n\t\t\tthis.mAttenuationConstant = 0;\n\t\t\tthis.mAttenuationLinear = 0;\n\t\t\tthis.mAttenuationQuadratic = 0;\n\t\t\tthis.mAngleInnerCone = 0;\n\t\t\tthis.mAngleOuterCone = 0;\n\t\t\tthis.mColorDiffuse = null;\n\t\t\tthis.mColorSpecular = null;\n\t\t\tthis.mColorAmbient = null;\n\t\t}\n\n\t\tfunction aiCamera() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mPosition = null;\n\t\t\tthis.mLookAt = null;\n\t\t\tthis.mUp = null;\n\t\t\tthis.mHorizontalFOV = 0;\n\t\t\tthis.mClipPlaneNear = 0;\n\t\t\tthis.mClipPlaneFar = 0;\n\t\t\tthis.mAspect = 0;\n\t\t}\n\n\t\tfunction aiScene() {\n\n\t\t\tthis.mFlags = 0;\n\t\t\tthis.mNumMeshes = 0;\n\t\t\tthis.mNumMaterials = 0;\n\t\t\tthis.mNumAnimations = 0;\n\t\t\tthis.mNumTextures = 0;\n\t\t\tthis.mNumLights = 0;\n\t\t\tthis.mNumCameras = 0;\n\t\t\tthis.mRootNode = null;\n\t\t\tthis.mMeshes = [];\n\t\t\tthis.mMaterials = [];\n\t\t\tthis.mAnimations = [];\n\t\t\tthis.mLights = [];\n\t\t\tthis.mCameras = [];\n\t\t\tthis.nodeToBoneMap = {};\n\t\t\tthis.findNode = function (name, root) {\n\n\t\t\t\tif (!root) {\n\n\t\t\t\t\troot = this.mRootNode;\n\t\t\t\t}\n\n\t\t\t\tif (root.mName == name) {\n\n\t\t\t\t\treturn root;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < root.mChildren.length; i++) {\n\n\t\t\t\t\tvar ret = this.findNode(name, root.mChildren[i]);\n\t\t\t\t\tif (ret) return ret;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t};\n\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\tthis.nodeCount = 0;\n\n\t\t\t\tmarkBones(this);\n\n\t\t\t\tvar o = this.mRootNode.toTHREE(this);\n\n\t\t\t\tfor (var i in this.mMeshes) {\n\t\t\t\t\tthis.mMeshes[i].hookupSkeletons(this, o);\n\t\t\t\t}if (this.mAnimations.length > 0) {\n\n\t\t\t\t\tvar a = this.mAnimations[0].toTHREE(this);\n\t\t\t\t}\n\n\t\t\t\treturn { object: o, animation: a };\n\t\t\t};\n\t\t}\n\n\t\tfunction aiMatrix4() {\n\n\t\t\tthis.elements = [[], [], [], []];\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\tvar m = new THREE.Matrix4();\n\n\t\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\t\tfor (var i2 = 0; i2 < 4; ++i2) {\n\n\t\t\t\t\t\tm.elements[i * 4 + i2] = this.elements[i2][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn m;\n\t\t\t};\n\t\t}\n\n\t\tvar littleEndian = true;\n\n\t\tfunction readFloat(dataview) {\n\n\t\t\tvar val = dataview.getFloat32(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 4;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_double(dataview) {\n\n\t\t\tvar val = dataview.getFloat64(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 8;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_uint8_t(dataview) {\n\n\t\t\tvar val = dataview.getUint8(dataview.readOffset);\n\t\t\tdataview.readOffset += 1;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_uint16_t(dataview) {\n\n\t\t\tvar val = dataview.getUint16(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 2;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_unsigned_int(dataview) {\n\n\t\t\tvar val = dataview.getUint32(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 4;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_uint32_t(dataview) {\n\n\t\t\tvar val = dataview.getUint32(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 4;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_aiVector3D(stream) {\n\n\t\t\tvar v = new aiVector3D();\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\tv.z = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiVector2D(stream) {\n\n\t\t\tvar v = new aiVector2D();\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiVector4D(stream) {\n\n\t\t\tvar v = new aiVector4D();\n\t\t\tv.w = readFloat(stream);\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\tv.z = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiColor3D(stream) {\n\n\t\t\tvar c = new aiColor3D();\n\t\t\tc.r = readFloat(stream);\n\t\t\tc.g = readFloat(stream);\n\t\t\tc.b = readFloat(stream);\n\t\t\treturn c;\n\t\t}\n\n\t\tfunction Read_aiColor4D(stream) {\n\n\t\t\tvar c = new aiColor4D();\n\t\t\tc.r = readFloat(stream);\n\t\t\tc.g = readFloat(stream);\n\t\t\tc.b = readFloat(stream);\n\t\t\tc.a = readFloat(stream);\n\t\t\treturn c;\n\t\t}\n\n\t\tfunction Read_aiQuaternion(stream) {\n\n\t\t\tvar v = new aiQuaternion();\n\t\t\tv.w = readFloat(stream);\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\tv.z = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiString(stream) {\n\n\t\t\tvar s = new aiString();\n\t\t\tvar stringlengthbytes = Read_unsigned_int(stream);\n\t\t\tstream.ReadBytes(s.data, 1, stringlengthbytes);\n\t\t\treturn s.toString();\n\t\t}\n\n\t\tfunction Read_aiVertexWeight(stream) {\n\n\t\t\tvar w = new aiVertexWeight();\n\t\t\tw.mVertexId = Read_unsigned_int(stream);\n\t\t\tw.mWeight = readFloat(stream);\n\t\t\treturn w;\n\t\t}\n\n\t\tfunction Read_aiMatrix4x4(stream) {\n\n\t\t\tvar m = new aiMatrix4();\n\n\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\tfor (var i2 = 0; i2 < 4; ++i2) {\n\n\t\t\t\t\tm.elements[i][i2] = readFloat(stream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn m;\n\t\t}\n\n\t\tfunction Read_aiVectorKey(stream) {\n\n\t\t\tvar v = new aiVectorKey();\n\t\t\tv.mTime = Read_double(stream);\n\t\t\tv.mValue = Read_aiVector3D(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiQuatKey(stream) {\n\n\t\t\tvar v = new aiQuatKey();\n\t\t\tv.mTime = Read_double(stream);\n\t\t\tv.mValue = Read_aiQuaternion(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction ReadArray(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVector2D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVector2D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVector3D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVector3D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVector4D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVector4D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVertexWeight(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVertexWeight(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiColor4D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiColor4D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVectorKey(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVectorKey(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiQuatKey(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiQuatKey(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadBounds(stream, T /*p*/, n) {\n\n\t\t\t// not sure what to do here, the data isn't really useful.\n\t\t\treturn stream.Seek(sizeof(T) * n, aiOrigin_CUR);\n\t\t}\n\n\t\tfunction ai_assert(bool) {\n\n\t\t\tif (!bool) throw \"asset failed\";\n\t\t}\n\n\t\tfunction ReadBinaryNode(stream, parent, depth) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tvar node = new aiNode();\n\t\t\tnode.mParent = parent;\n\t\t\tnode.mDepth = depth;\n\t\t\tnode.mName = Read_aiString(stream);\n\t\t\tnode.mTransformation = Read_aiMatrix4x4(stream);\n\t\t\tnode.mNumChildren = Read_unsigned_int(stream);\n\t\t\tnode.mNumMeshes = Read_unsigned_int(stream);\n\n\t\t\tif (node.mNumMeshes) {\n\n\t\t\t\tnode.mMeshes = [];\n\n\t\t\t\tfor (var i = 0; i < node.mNumMeshes; ++i) {\n\n\t\t\t\t\tnode.mMeshes[i] = Read_unsigned_int(stream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node.mNumChildren) {\n\n\t\t\t\tnode.mChildren = [];\n\n\t\t\t\tfor (var i = 0; i < node.mNumChildren; ++i) {\n\n\t\t\t\t\tvar node2 = ReadBinaryNode(stream, node, depth++);\n\t\t\t\t\tnode.mChildren[i] = node2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\n\t\t// -----------------------------------------------------------------------------------\n\n\t\tfunction ReadBinaryBone(stream, b) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tb.mName = Read_aiString(stream);\n\t\t\tb.mNumWeights = Read_unsigned_int(stream);\n\t\t\tb.mOffsetMatrix = Read_aiMatrix4x4(stream);\n\t\t\t// for the moment we write dumb min/max values for the bones, too.\n\t\t\t// maybe I'll add a better, hash-like solution later\n\t\t\tif (shortened) {\n\n\t\t\t\tReadBounds(stream, b.mWeights, b.mNumWeights);\n\t\t\t} else {\n\n\t\t\t\t// else write as usual\n\n\t\t\t\tb.mWeights = [];\n\t\t\t\tReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n\t\t\t}\n\n\t\t\treturn b;\n\t\t}\n\n\t\tfunction ReadBinaryMesh(stream, mesh) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tmesh.mPrimitiveTypes = Read_unsigned_int(stream);\n\t\t\tmesh.mNumVertices = Read_unsigned_int(stream);\n\t\t\tmesh.mNumFaces = Read_unsigned_int(stream);\n\t\t\tmesh.mNumBones = Read_unsigned_int(stream);\n\t\t\tmesh.mMaterialIndex = Read_unsigned_int(stream);\n\t\t\tmesh.mNumUVComponents = [];\n\t\t\t// first of all, write bits for all existent vertex components\n\t\t\tvar c = Read_unsigned_int(stream);\n\n\t\t\tif (c & ASSBIN_MESH_HAS_POSITIONS) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mVertices = [];\n\t\t\t\t\tmesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c & ASSBIN_MESH_HAS_NORMALS) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mNormals = [];\n\t\t\t\t\tmesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n\t\t\t\t\tReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mTangents = [];\n\t\t\t\t\tmesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t\tmesh.mBitangents = [];\n\t\t\t\t\tmesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n\n\t\t\t\tif (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mColors[n] = [];\n\t\t\t\t\tmesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmesh.mTexCoordsBuffers = [];\n\n\t\t\tfor (var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n\n\t\t\t\tif (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break;\n\n\t\t\t\t// write number of UV components\n\t\t\t\tmesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mTextureCoords[n] = [];\n\t\t\t\t\t//note that assbin always writes 3d texcoords\n\t\t\t\t\tmesh.mTexCoordsBuffers[n] = [];\n\n\t\t\t\t\tfor (var uv = 0; uv < mesh.mNumVertices; uv++) {\n\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[n].push(readFloat(stream));\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[n].push(readFloat(stream));\n\t\t\t\t\t\treadFloat(stream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// write faces. There are no floating-point calculations involved\n\t\t\t// in these, so we can write a simple hash over the face data\n\t\t\t// to the dump file. We generate a single 32 Bit hash for 512 faces\n\t\t\t// using Assimp's standard hashing function.\n\t\t\tif (shortened) {\n\n\t\t\t\tRead_unsigned_int(stream);\n\t\t\t} else {\n\n\t\t\t\t// else write as usual\n\n\t\t\t\t// if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n\t\t\t\tmesh.mFaces = [];\n\n\t\t\t\tvar indexCounter = 0;\n\t\t\t\tmesh.mIndexArray = [];\n\n\t\t\t\tfor (var i = 0; i < mesh.mNumFaces; ++i) {\n\n\t\t\t\t\tvar f = mesh.mFaces[i] = new aiFace();\n\t\t\t\t\t// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\t\t\t\t\tf.mNumIndices = Read_uint16_t(stream);\n\t\t\t\t\tf.mIndices = [];\n\n\t\t\t\t\tfor (var a = 0; a < f.mNumIndices; ++a) {\n\n\t\t\t\t\t\tif (mesh.mNumVertices < 1 << 16) {\n\n\t\t\t\t\t\t\tf.mIndices[a] = Read_uint16_t(stream);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tf.mIndices[a] = Read_unsigned_int(stream);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f.mNumIndices === 3) {\n\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[0]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[1]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[2]);\n\t\t\t\t\t} else if (f.mNumIndices === 4) {\n\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[0]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[1]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[2]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[2]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[3]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[0]);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// write bones\n\t\t\tif (mesh.mNumBones) {\n\n\t\t\t\tmesh.mBones = [];\n\n\t\t\t\tfor (var a = 0; a < mesh.mNumBones; ++a) {\n\n\t\t\t\t\tmesh.mBones[a] = new aiBone();\n\t\t\t\t\tReadBinaryBone(stream, mesh.mBones[a]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadBinaryMaterialProperty(stream, prop) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tprop.mKey = Read_aiString(stream);\n\t\t\tprop.mSemantic = Read_unsigned_int(stream);\n\t\t\tprop.mIndex = Read_unsigned_int(stream);\n\t\t\tprop.mDataLength = Read_unsigned_int(stream);\n\t\t\tprop.mType = Read_unsigned_int(stream);\n\t\t\tprop.mData = [];\n\t\t\tstream.ReadBytes(prop.mData, 1, prop.mDataLength);\n\t\t}\n\n\t\t// -----------------------------------------------------------------------------------\n\n\t\tfunction ReadBinaryMaterial(stream, mat) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tmat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n\n\t\t\tif (mat.mNumProperties) {\n\n\t\t\t\tif (mat.mProperties) {\n\n\t\t\t\t\tdelete mat.mProperties;\n\t\t\t\t}\n\n\t\t\t\tmat.mProperties = [];\n\n\t\t\t\tfor (var i = 0; i < mat.mNumProperties; ++i) {\n\n\t\t\t\t\tmat.mProperties[i] = new aiMaterialProperty();\n\t\t\t\t\tReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryNodeAnim(stream, nd) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tnd.mNodeName = Read_aiString(stream);\n\t\t\tnd.mNumPositionKeys = Read_unsigned_int(stream);\n\t\t\tnd.mNumRotationKeys = Read_unsigned_int(stream);\n\t\t\tnd.mNumScalingKeys = Read_unsigned_int(stream);\n\t\t\tnd.mPreState = Read_unsigned_int(stream);\n\t\t\tnd.mPostState = Read_unsigned_int(stream);\n\n\t\t\tif (nd.mNumPositionKeys) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tnd.mPositionKeys = [];\n\t\t\t\t\tReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nd.mNumRotationKeys) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tnd.mRotationKeys = [];\n\t\t\t\t\tReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nd.mNumScalingKeys) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tnd.mScalingKeys = [];\n\t\t\t\t\tReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryAnim(stream, anim) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tanim.mName = Read_aiString(stream);\n\t\t\tanim.mDuration = Read_double(stream);\n\t\t\tanim.mTicksPerSecond = Read_double(stream);\n\t\t\tanim.mNumChannels = Read_unsigned_int(stream);\n\n\t\t\tif (anim.mNumChannels) {\n\n\t\t\t\tanim.mChannels = [];\n\n\t\t\t\tfor (var a = 0; a < anim.mNumChannels; ++a) {\n\n\t\t\t\t\tanim.mChannels[a] = new aiNodeAnim();\n\t\t\t\t\tReadBinaryNodeAnim(stream, anim.mChannels[a]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadBinaryTexture(stream, tex) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\ttex.mWidth = Read_unsigned_int(stream);\n\t\t\ttex.mHeight = Read_unsigned_int(stream);\n\t\t\tstream.ReadBytes(tex.achFormatHint, 1, 4);\n\n\t\t\tif (!shortened) {\n\n\t\t\t\tif (!tex.mHeight) {\n\n\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\tstream.ReadBytes(tex.pcData, 1, tex.mWidth);\n\t\t\t\t} else {\n\n\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\tstream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryLight(stream, l) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tl.mName = Read_aiString(stream);\n\t\t\tl.mType = Read_unsigned_int(stream);\n\n\t\t\tif (l.mType != aiLightSource_DIRECTIONAL) {\n\n\t\t\t\tl.mAttenuationConstant = readFloat(stream);\n\t\t\t\tl.mAttenuationLinear = readFloat(stream);\n\t\t\t\tl.mAttenuationQuadratic = readFloat(stream);\n\t\t\t}\n\n\t\t\tl.mColorDiffuse = Read_aiColor3D(stream);\n\t\t\tl.mColorSpecular = Read_aiColor3D(stream);\n\t\t\tl.mColorAmbient = Read_aiColor3D(stream);\n\n\t\t\tif (l.mType == aiLightSource_SPOT) {\n\n\t\t\t\tl.mAngleInnerCone = readFloat(stream);\n\t\t\t\tl.mAngleOuterCone = readFloat(stream);\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryCamera(stream, cam) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tcam.mName = Read_aiString(stream);\n\t\t\tcam.mPosition = Read_aiVector3D(stream);\n\t\t\tcam.mLookAt = Read_aiVector3D(stream);\n\t\t\tcam.mUp = Read_aiVector3D(stream);\n\t\t\tcam.mHorizontalFOV = readFloat(stream);\n\t\t\tcam.mClipPlaneNear = readFloat(stream);\n\t\t\tcam.mClipPlaneFar = readFloat(stream);\n\t\t\tcam.mAspect = readFloat(stream);\n\t\t}\n\n\t\tfunction ReadBinaryScene(stream, scene) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tscene.mFlags = Read_unsigned_int(stream);\n\t\t\tscene.mNumMeshes = Read_unsigned_int(stream);\n\t\t\tscene.mNumMaterials = Read_unsigned_int(stream);\n\t\t\tscene.mNumAnimations = Read_unsigned_int(stream);\n\t\t\tscene.mNumTextures = Read_unsigned_int(stream);\n\t\t\tscene.mNumLights = Read_unsigned_int(stream);\n\t\t\tscene.mNumCameras = Read_unsigned_int(stream);\n\t\t\t// Read node graph\n\t\t\tscene.mRootNode = new aiNode();\n\t\t\tscene.mRootNode = ReadBinaryNode(stream, null, 0);\n\t\t\t// Read all meshes\n\t\t\tif (scene.mNumMeshes) {\n\n\t\t\t\tscene.mMeshes = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumMeshes; ++i) {\n\n\t\t\t\t\tscene.mMeshes[i] = new aiMesh();\n\t\t\t\t\tReadBinaryMesh(stream, scene.mMeshes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read materials\n\t\t\tif (scene.mNumMaterials) {\n\n\t\t\t\tscene.mMaterials = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumMaterials; ++i) {\n\n\t\t\t\t\tscene.mMaterials[i] = new aiMaterial();\n\t\t\t\t\tReadBinaryMaterial(stream, scene.mMaterials[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read all animations\n\t\t\tif (scene.mNumAnimations) {\n\n\t\t\t\tscene.mAnimations = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumAnimations; ++i) {\n\n\t\t\t\t\tscene.mAnimations[i] = new aiAnimation();\n\t\t\t\t\tReadBinaryAnim(stream, scene.mAnimations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read all textures\n\t\t\tif (scene.mNumTextures) {\n\n\t\t\t\tscene.mTextures = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumTextures; ++i) {\n\n\t\t\t\t\tscene.mTextures[i] = new aiTexture();\n\t\t\t\t\tReadBinaryTexture(stream, scene.mTextures[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read lights\n\t\t\tif (scene.mNumLights) {\n\n\t\t\t\tscene.mLights = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumLights; ++i) {\n\n\t\t\t\t\tscene.mLights[i] = new aiLight();\n\t\t\t\t\tReadBinaryLight(stream, scene.mLights[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read cameras\n\t\t\tif (scene.mNumCameras) {\n\n\t\t\t\tscene.mCameras = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumCameras; ++i) {\n\n\t\t\t\t\tscene.mCameras[i] = new aiCamera();\n\t\t\t\t\tReadBinaryCamera(stream, scene.mCameras[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar aiOrigin_CUR = 0;\n\t\tvar aiOrigin_BEG = 1;\n\n\t\tfunction extendStream(stream) {\n\n\t\t\tstream.readOffset = 0;\n\t\t\tstream.Seek = function (off, ori) {\n\n\t\t\t\tif (ori == aiOrigin_CUR) {\n\n\t\t\t\t\tstream.readOffset += off;\n\t\t\t\t}\n\t\t\t\tif (ori == aiOrigin_BEG) {\n\n\t\t\t\t\tstream.readOffset = off;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstream.ReadBytes = function (buff, size, n) {\n\n\t\t\t\tvar bytes = size * n;\n\t\t\t\tfor (var i = 0; i < bytes; i++) {\n\t\t\t\t\tbuff[i] = Read_uint8_t(this);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstream.subArray32 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Float32Array(newbuff);\n\t\t\t};\n\n\t\t\tstream.subArrayUint16 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Uint16Array(newbuff);\n\t\t\t};\n\n\t\t\tstream.subArrayUint8 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Uint8Array(newbuff);\n\t\t\t};\n\n\t\t\tstream.subArrayUint32 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Uint32Array(newbuff);\n\t\t\t};\n\t\t}\n\n\t\tvar shortened, compressed;\n\n\t\tfunction InternReadFile(pFiledata) {\n\n\t\t\tvar pScene = new aiScene();\n\t\t\tvar stream = new DataView(pFiledata);\n\t\t\textendStream(stream);\n\t\t\tstream.Seek(44, aiOrigin_CUR); // signature\n\t\t\t/*unsigned int versionMajor =*/\n\t\t\tvar versionMajor = Read_unsigned_int(stream);\n\t\t\t/*unsigned int versionMinor =*/\n\t\t\tvar versionMinor = Read_unsigned_int(stream);\n\t\t\t/*unsigned int versionRevision =*/\n\t\t\tvar versionRevision = Read_unsigned_int(stream);\n\t\t\t/*unsigned int compileFlags =*/\n\t\t\tvar compileFlags = Read_unsigned_int(stream);\n\t\t\tshortened = Read_uint16_t(stream) > 0;\n\t\t\tcompressed = Read_uint16_t(stream) > 0;\n\t\t\tif (shortened) throw \"Shortened binaries are not supported!\";\n\t\t\tstream.Seek(256, aiOrigin_CUR); // original filename\n\t\t\tstream.Seek(128, aiOrigin_CUR); // options\n\t\t\tstream.Seek(64, aiOrigin_CUR); // padding\n\t\t\tif (compressed) {\n\n\t\t\t\tvar uncompressedSize = Read_uint32_t(stream);\n\t\t\t\tvar compressedSize = stream.FileSize() - stream.Tell();\n\t\t\t\tvar compressedData = [];\n\t\t\t\tstream.Read(compressedData, 1, compressedSize);\n\t\t\t\tvar uncompressedData = [];\n\t\t\t\tuncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);\n\t\t\t\tvar buff = new ArrayBuffer(uncompressedData);\n\t\t\t\tReadBinaryScene(buff, pScene);\n\t\t\t} else {\n\n\t\t\t\tReadBinaryScene(stream, pScene);\n\t\t\t\treturn pScene.toTHREE();\n\t\t\t}\n\t\t}\n\n\t\treturn InternReadFile(buffer);\n\t}\n\n};\n\nexports.default = AssimpLoader;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Author: Pierre Lepers\n * Date: 09/12/2013 17:21\n */\n\nexports.default = function () {\n\n\tvar UNCOMPRESSED = 0,\n\t    DEFLATE = 1,\n\t    LZMA = 2,\n\t    AWD_FIELD_INT8 = 1,\n\t    AWD_FIELD_INT16 = 2,\n\t    AWD_FIELD_INT32 = 3,\n\t    AWD_FIELD_UINT8 = 4,\n\t    AWD_FIELD_UINT16 = 5,\n\t    AWD_FIELD_UINT32 = 6,\n\t    AWD_FIELD_FLOAT32 = 7,\n\t    AWD_FIELD_FLOAT64 = 8,\n\t    AWD_FIELD_BOOL = 21,\n\t    AWD_FIELD_COLOR = 22,\n\t    AWD_FIELD_BADDR = 23,\n\t    AWD_FIELD_STRING = 31,\n\t    AWD_FIELD_BYTEARRAY = 32,\n\t    AWD_FIELD_VECTOR2x1 = 41,\n\t    AWD_FIELD_VECTOR3x1 = 42,\n\t    AWD_FIELD_VECTOR4x1 = 43,\n\t    AWD_FIELD_MTX3x2 = 44,\n\t    AWD_FIELD_MTX3x3 = 45,\n\t    AWD_FIELD_MTX4x3 = 46,\n\t    AWD_FIELD_MTX4x4 = 47,\n\t    BOOL = 21,\n\t    COLOR = 22,\n\t    BADDR = 23,\n\t    INT8 = 1,\n\t    INT16 = 2,\n\t    INT32 = 3,\n\t    UINT8 = 4,\n\t    UINT16 = 5,\n\t    UINT32 = 6,\n\t    FLOAT32 = 7,\n\t    FLOAT64 = 8;\n\n\tvar littleEndian = true;\n\n\tfunction Block() {\n\n\t\tthis.id = 0;\n\t\tthis.data = null;\n\t}\n\n\tfunction AWDProperties() {}\n\n\tAWDProperties.prototype = {\n\t\tset: function set(key, value) {\n\n\t\t\tthis[key] = value;\n\t\t},\n\n\t\tget: function get(key, fallback) {\n\n\t\t\tif (this.hasOwnProperty(key)) {\n\n\t\t\t\treturn this[key];\n\t\t\t} else {\n\n\t\t\t\treturn fallback;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar AWDLoader = function AWDLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\t\tthis.trunk = new THREE.Object3D();\n\n\t\tthis.materialFactory = undefined;\n\n\t\tthis._url = '';\n\t\tthis._baseDir = '';\n\n\t\tthis._data = undefined;\n\t\tthis._ptr = 0;\n\n\t\tthis._version = [];\n\t\tthis._streaming = false;\n\t\tthis._optimized_for_accuracy = false;\n\t\tthis._compression = 0;\n\t\tthis._bodylen = 0xFFFFFFFF;\n\n\t\tthis._blocks = [new Block()];\n\n\t\tthis._accuracyMatrix = false;\n\t\tthis._accuracyGeo = false;\n\t\tthis._accuracyProps = false;\n\t};\n\n\tAWDLoader.prototype = {\n\n\t\tconstructor: AWDLoader,\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tthis._url = url;\n\t\t\tthis._baseDir = url.substr(0, url.lastIndexOf('/') + 1);\n\n\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.load(url, function (text) {\n\n\t\t\t\tonLoad(scope.parse(text));\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tparse: function parse(data) {\n\n\t\t\tvar blen = data.byteLength;\n\n\t\t\tthis._ptr = 0;\n\t\t\tthis._data = new DataView(data);\n\n\t\t\tthis._parseHeader();\n\n\t\t\tif (this._compression != 0) {\n\n\t\t\t\tconsole.error('compressed AWD not supported');\n\t\t\t}\n\n\t\t\tif (!this._streaming && this._bodylen != data.byteLength - this._ptr) {\n\n\t\t\t\tconsole.error('AWDLoader: body len does not match file length', this._bodylen, blen - this._ptr);\n\t\t\t}\n\n\t\t\twhile (this._ptr < blen) {\n\n\t\t\t\tthis.parseNextBlock();\n\t\t\t}\n\n\t\t\treturn this.trunk;\n\t\t},\n\n\t\tparseNextBlock: function parseNextBlock() {\n\n\t\t\tvar assetData,\n\t\t\t    ns,\n\t\t\t    type,\n\t\t\t    len,\n\t\t\t    block,\n\t\t\t    blockId = this.readU32(),\n\t\t\t    ns = this.readU8(),\n\t\t\t    type = this.readU8(),\n\t\t\t    flags = this.readU8(),\n\t\t\t    len = this.readU32();\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 1:\n\t\t\t\t\tassetData = this.parseMeshData(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 22:\n\t\t\t\t\tassetData = this.parseContainer(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 23:\n\t\t\t\t\tassetData = this.parseMeshInstance(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 81:\n\t\t\t\t\tassetData = this.parseMaterial(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 82:\n\t\t\t\t\tassetData = this.parseTexture(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 101:\n\t\t\t\t\tassetData = this.parseSkeleton(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//  case 111:\n\t\t\t\t//    assetData = this.parseMeshPoseAnimation(len, true);\n\t\t\t\t//    break;\n\n\t\t\t\tcase 112:\n\t\t\t\t\tassetData = this.parseMeshPoseAnimation(len, false);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 113:\n\t\t\t\t\tassetData = this.parseVertexAnimationSet(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 102:\n\t\t\t\t\tassetData = this.parseSkeletonPose(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 103:\n\t\t\t\t\tassetData = this.parseSkeletonAnimation(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 122:\n\t\t\t\t\tassetData = this.parseAnimatorSet(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// case 121:\n\t\t\t\t//  assetData = parseUVAnimation(len);\n\t\t\t\t//  break;\n\n\t\t\t\tdefault:\n\t\t\t\t\t//debug('Ignoring block!',type, len);\n\t\t\t\t\tthis._ptr += len;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// Store block reference for later use\n\t\t\tthis._blocks[blockId] = block = new Block();\n\t\t\tblock.data = assetData;\n\t\t\tblock.id = blockId;\n\t\t},\n\n\t\t_parseHeader: function _parseHeader() {\n\n\t\t\tvar version = this._version,\n\t\t\t    awdmagic = this.readU8() << 16 | this.readU8() << 8 | this.readU8();\n\n\t\t\tif (awdmagic != 4282180) throw new Error(\"AWDLoader - bad magic\");\n\n\t\t\tversion[0] = this.readU8();\n\t\t\tversion[1] = this.readU8();\n\n\t\t\tvar flags = this.readU16();\n\n\t\t\tthis._streaming = (flags & 0x1) == 0x1;\n\n\t\t\tif (version[0] === 2 && version[1] === 1) {\n\n\t\t\t\tthis._accuracyMatrix = (flags & 0x2) === 0x2;\n\t\t\t\tthis._accuracyGeo = (flags & 0x4) === 0x4;\n\t\t\t\tthis._accuracyProps = (flags & 0x8) === 0x8;\n\t\t\t}\n\n\t\t\tthis._geoNrType = this._accuracyGeo ? FLOAT64 : FLOAT32;\n\t\t\tthis._matrixNrType = this._accuracyMatrix ? FLOAT64 : FLOAT32;\n\t\t\tthis._propsNrType = this._accuracyProps ? FLOAT64 : FLOAT32;\n\n\t\t\tthis._optimized_for_accuracy = (flags & 0x2) === 0x2;\n\n\t\t\tthis._compression = this.readU8();\n\t\t\tthis._bodylen = this.readU32();\n\t\t},\n\n\t\tparseContainer: function parseContainer(len) {\n\n\t\t\tvar parent,\n\t\t\t    ctr = new THREE.Object3D(),\n\t\t\t    par_id = this.readU32(),\n\t\t\t    mtx = this.parseMatrix4();\n\n\t\t\tctr.name = this.readUTF();\n\t\t\tctr.applyMatrix(mtx);\n\n\t\t\tparent = this._blocks[par_id].data || this.trunk;\n\t\t\tparent.add(ctr);\n\n\t\t\tthis.parseProperties({\n\t\t\t\t1: this._matrixNrType,\n\t\t\t\t2: this._matrixNrType,\n\t\t\t\t3: this._matrixNrType,\n\t\t\t\t4: UINT8\n\t\t\t});\n\n\t\t\tctr.extra = this.parseUserAttributes();\n\n\t\t\treturn ctr;\n\t\t},\n\n\t\tparseMeshInstance: function parseMeshInstance(len) {\n\n\t\t\tvar name, mesh, geometries, meshLen, meshes, par_id, data_id, mtx, materials, mat, mat_id, num_materials, parent, i;\n\n\t\t\tpar_id = this.readU32();\n\t\t\tmtx = this.parseMatrix4();\n\t\t\tname = this.readUTF();\n\t\t\tdata_id = this.readU32();\n\t\t\tnum_materials = this.readU16();\n\n\t\t\tgeometries = this.getBlock(data_id);\n\n\t\t\tmaterials = [];\n\n\t\t\tfor (i = 0; i < num_materials; i++) {\n\n\t\t\t\tmat_id = this.readU32();\n\t\t\t\tmat = this.getBlock(mat_id);\n\t\t\t\tmaterials.push(mat);\n\t\t\t}\n\n\t\t\tmeshLen = geometries.length;\n\t\t\tmeshes = [];\n\n\t\t\t// TODO : BufferGeometry don't support \"geometryGroups\" for now.\n\t\t\t// so we create sub meshes for each groups\n\t\t\tif (meshLen > 1) {\n\n\t\t\t\tmesh = new THREE.Object3D();\n\t\t\t\tfor (i = 0; i < meshLen; i++) {\n\n\t\t\t\t\tvar sm = new THREE.Mesh(geometries[i]);\n\t\t\t\t\tmeshes.push(sm);\n\t\t\t\t\tmesh.add(sm);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tmesh = new THREE.Mesh(geometries[0]);\n\t\t\t\tmeshes.push(mesh);\n\t\t\t}\n\n\t\t\tmesh.applyMatrix(mtx);\n\t\t\tmesh.name = name;\n\n\t\t\tparent = this.getBlock(par_id) || this.trunk;\n\t\t\tparent.add(mesh);\n\n\t\t\tvar matLen = materials.length;\n\t\t\tvar maxLen = Math.max(meshLen, matLen);\n\t\t\tfor (i = 0; i < maxLen; i++) {\n\t\t\t\tmeshes[i % meshLen].material = materials[i % matLen];\n\t\t\t} // Ignore for now\n\t\t\tthis.parseProperties(null);\n\t\t\tmesh.extra = this.parseUserAttributes();\n\n\t\t\treturn mesh;\n\t\t},\n\n\t\tparseMaterial: function parseMaterial(len) {\n\n\t\t\tvar name, type, props, mat, attributes, finalize, num_methods, methods_parsed;\n\n\t\t\tname = this.readUTF();\n\t\t\ttype = this.readU8();\n\t\t\tnum_methods = this.readU8();\n\n\t\t\t//log( \"AWDLoader parseMaterial \",name )\n\n\t\t\t// Read material numerical properties\n\t\t\t// (1=color, 2=bitmap url, 11=alpha_blending, 12=alpha_threshold, 13=repeat)\n\t\t\tprops = this.parseProperties({\n\t\t\t\t1: AWD_FIELD_INT32,\n\t\t\t\t2: AWD_FIELD_BADDR,\n\t\t\t\t11: AWD_FIELD_BOOL,\n\t\t\t\t12: AWD_FIELD_FLOAT32,\n\t\t\t\t13: AWD_FIELD_BOOL\n\t\t\t});\n\n\t\t\tmethods_parsed = 0;\n\n\t\t\twhile (methods_parsed < num_methods) {\n\n\t\t\t\tvar method_type = this.readU16();\n\t\t\t\tthis.parseProperties(null);\n\t\t\t\tthis.parseUserAttributes();\n\t\t\t}\n\n\t\t\tattributes = this.parseUserAttributes();\n\n\t\t\tif (this.materialFactory !== undefined) {\n\n\t\t\t\tmat = this.materialFactory(name);\n\t\t\t\tif (mat) return mat;\n\t\t\t}\n\n\t\t\tmat = new THREE.MeshPhongMaterial();\n\n\t\t\tif (type === 1) {\n\n\t\t\t\t// Color material\n\t\t\t\tmat.color.setHex(props.get(1, 0xcccccc));\n\t\t\t} else if (type === 2) {\n\n\t\t\t\t// Bitmap material\n\t\t\t\tvar tex_addr = props.get(2, 0);\n\t\t\t\tmat.map = this.getBlock(tex_addr);\n\t\t\t}\n\n\t\t\tmat.extra = attributes;\n\t\t\tmat.alphaThreshold = props.get(12, 0.0);\n\t\t\tmat.repeat = props.get(13, false);\n\n\t\t\treturn mat;\n\t\t},\n\n\t\tparseTexture: function parseTexture(len) {\n\n\t\t\tvar name = this.readUTF(),\n\t\t\t    type = this.readU8(),\n\t\t\t    asset,\n\t\t\t    data_len;\n\n\t\t\t// External\n\t\t\tif (type === 0) {\n\n\t\t\t\tdata_len = this.readU32();\n\t\t\t\tvar url = this.readUTFBytes(data_len);\n\t\t\t\tconsole.log(url);\n\n\t\t\t\tasset = this.loadTexture(url);\n\t\t\t} else {}\n\t\t\t// embed texture not supported\n\n\t\t\t// Ignore for now\n\t\t\tthis.parseProperties(null);\n\n\t\t\tthis.parseUserAttributes();\n\t\t\treturn asset;\n\t\t},\n\n\t\tloadTexture: function loadTexture(url) {\n\n\t\t\tvar tex = new THREE.Texture();\n\n\t\t\tvar loader = new THREE.ImageLoader(this.manager);\n\n\t\t\tloader.load(this._baseDir + url, function (image) {\n\n\t\t\t\ttex.image = image;\n\t\t\t\ttex.needsUpdate = true;\n\t\t\t});\n\n\t\t\treturn tex;\n\t\t},\n\n\t\tparseSkeleton: function parseSkeleton(len) {\n\n\t\t\t// Array<Bone>\n\t\t\tvar name = this.readUTF(),\n\t\t\t    num_joints = this.readU16(),\n\t\t\t    skeleton = [],\n\t\t\t    joints_parsed = 0;\n\n\t\t\tthis.parseProperties(null);\n\n\t\t\twhile (joints_parsed < num_joints) {\n\n\t\t\t\tvar joint, ibp;\n\n\t\t\t\t// Ignore joint id\n\t\t\t\tthis.readU16();\n\n\t\t\t\tjoint = new THREE.Bone();\n\t\t\t\tjoint.parent = this.readU16() - 1; // 0=null in AWD\n\t\t\t\tjoint.name = this.readUTF();\n\n\t\t\t\tibp = this.parseMatrix4();\n\t\t\t\tjoint.skinMatrix = ibp;\n\n\t\t\t\t// Ignore joint props/attributes for now\n\t\t\t\tthis.parseProperties(null);\n\t\t\t\tthis.parseUserAttributes();\n\n\t\t\t\tskeleton.push(joint);\n\t\t\t\tjoints_parsed++;\n\t\t\t}\n\n\t\t\t// Discard attributes for now\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn skeleton;\n\t\t},\n\n\t\tparseSkeletonPose: function parseSkeletonPose(blockID) {\n\n\t\t\tvar name = this.readUTF();\n\n\t\t\tvar num_joints = this.readU16();\n\t\t\tthis.parseProperties(null);\n\n\t\t\t// debug( 'parse Skeleton Pose. joints : ' + num_joints);\n\n\t\t\tvar pose = [];\n\n\t\t\tvar joints_parsed = 0;\n\n\t\t\twhile (joints_parsed < num_joints) {\n\n\t\t\t\tvar joint_pose;\n\n\t\t\t\tvar has_transform; //:uint;\n\t\t\t\tvar mtx_data;\n\n\t\t\t\thas_transform = this.readU8();\n\n\t\t\t\tif (has_transform === 1) {\n\n\t\t\t\t\tmtx_data = this.parseMatrix4();\n\t\t\t\t} else {\n\n\t\t\t\t\tmtx_data = new THREE.Matrix4();\n\t\t\t\t}\n\t\t\t\tpose[joints_parsed] = mtx_data;\n\t\t\t\tjoints_parsed++;\n\t\t\t}\n\n\t\t\t// Skip attributes for now\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn pose;\n\t\t},\n\n\t\tparseSkeletonAnimation: function parseSkeletonAnimation(blockID) {\n\n\t\t\tvar frame_dur;\n\t\t\tvar pose_addr;\n\t\t\tvar pose;\n\n\t\t\tvar name = this.readUTF();\n\n\t\t\tvar clip = [];\n\n\t\t\tvar num_frames = this.readU16();\n\t\t\tthis.parseProperties(null);\n\n\t\t\tvar frames_parsed = 0;\n\t\t\tvar returnedArray;\n\n\t\t\t// debug( 'parse Skeleton Animation. frames : ' + num_frames);\n\n\t\t\twhile (frames_parsed < num_frames) {\n\n\t\t\t\tpose_addr = this.readU32();\n\t\t\t\tframe_dur = this.readU16();\n\n\t\t\t\tpose = this._blocks[pose_addr].data;\n\t\t\t\t// debug( 'pose address ',pose[2].elements[12],pose[2].elements[13],pose[2].elements[14] );\n\t\t\t\tclip.push({\n\t\t\t\t\tpose: pose,\n\t\t\t\t\tduration: frame_dur\n\t\t\t\t});\n\n\t\t\t\tframes_parsed++;\n\t\t\t}\n\n\t\t\tif (clip.length === 0) {\n\n\t\t\t\t// debug(\"Could not this SkeletonClipNode, because no Frames where set.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Ignore attributes for now\n\t\t\tthis.parseUserAttributes();\n\t\t\treturn clip;\n\t\t},\n\n\t\tparseVertexAnimationSet: function parseVertexAnimationSet(len) {\n\n\t\t\tvar poseBlockAdress,\n\t\t\t    name = this.readUTF(),\n\t\t\t    num_frames = this.readU16(),\n\t\t\t    props = this.parseProperties({ 1: UINT16 }),\n\t\t\t    frames_parsed = 0,\n\t\t\t    skeletonFrames = [];\n\n\t\t\twhile (frames_parsed < num_frames) {\n\n\t\t\t\tposeBlockAdress = this.readU32();\n\t\t\t\tskeletonFrames.push(this._blocks[poseBlockAdress].data);\n\t\t\t\tframes_parsed++;\n\t\t\t}\n\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn skeletonFrames;\n\t\t},\n\n\t\tparseAnimatorSet: function parseAnimatorSet(len) {\n\n\t\t\tvar targetMesh;\n\n\t\t\tvar animSetBlockAdress; //:int\n\n\t\t\tvar targetAnimationSet; //:AnimationSetBase;\n\t\t\tvar outputString = \"\"; //:String = \"\";\n\t\t\tvar name = this.readUTF();\n\t\t\tvar type = this.readU16();\n\n\t\t\tvar props = this.parseProperties({ 1: BADDR });\n\n\t\t\tanimSetBlockAdress = this.readU32();\n\t\t\tvar targetMeshLength = this.readU16();\n\n\t\t\tvar meshAdresses = []; //:Vector.<uint> = new Vector.<uint>;\n\n\t\t\tfor (var i = 0; i < targetMeshLength; i++) {\n\t\t\t\tmeshAdresses.push(this.readU32());\n\t\t\t}var activeState = this.readU16();\n\t\t\tvar autoplay = Boolean(this.readU8());\n\t\t\tthis.parseUserAttributes();\n\t\t\tthis.parseUserAttributes();\n\n\t\t\tvar returnedArray;\n\t\t\tvar targetMeshes = []; //:Vector.<Mesh> = new Vector.<Mesh>;\n\n\t\t\tfor (i = 0; i < meshAdresses.length; i++) {\n\n\t\t\t\t//      returnedArray = getAssetByID(meshAdresses[i], [AssetType.MESH]);\n\t\t\t\t//      if (returnedArray[0])\n\t\t\t\ttargetMeshes.push(this._blocks[meshAdresses[i]].data);\n\t\t\t}\n\n\t\t\ttargetAnimationSet = this._blocks[animSetBlockAdress].data;\n\t\t\tvar thisAnimator;\n\n\t\t\tif (type == 1) {\n\n\t\t\t\tthisAnimator = {\n\t\t\t\t\tanimationSet: targetAnimationSet,\n\t\t\t\t\tskeleton: this._blocks[props.get(1, 0)].data\n\t\t\t\t};\n\t\t\t} else if (type == 2) {\n\t\t\t\t// debug( \"vertex Anim???\");\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targetMeshes.length; i++) {\n\n\t\t\t\ttargetMeshes[i].animator = thisAnimator;\n\t\t\t}\n\t\t\t// debug(\"Parsed a Animator: Name = \" + name);\n\n\t\t\treturn thisAnimator;\n\t\t},\n\n\t\tparseMeshData: function parseMeshData(len) {\n\n\t\t\tvar name = this.readUTF(),\n\t\t\t    num_subs = this.readU16(),\n\t\t\t    geom,\n\t\t\t    subs_parsed = 0,\n\t\t\t    buffer,\n\t\t\t    skinW,\n\t\t\t    skinI,\n\t\t\t    geometries = [];\n\n\t\t\t// Ignore for now\n\t\t\tthis.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });\n\n\t\t\t// Loop through sub meshes\n\t\t\twhile (subs_parsed < num_subs) {\n\n\t\t\t\tvar sm_len, sm_end, attrib;\n\n\t\t\t\tgeom = new THREE.BufferGeometry();\n\t\t\t\tgeom.name = name;\n\t\t\t\tgeometries.push(geom);\n\n\t\t\t\tsm_len = this.readU32();\n\t\t\t\tsm_end = this._ptr + sm_len;\n\n\t\t\t\t// Ignore for now\n\t\t\t\tthis.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });\n\n\t\t\t\t// Loop through data streams\n\t\t\t\twhile (this._ptr < sm_end) {\n\n\t\t\t\t\tvar idx = 0,\n\t\t\t\t\t    str_type = this.readU8(),\n\t\t\t\t\t    str_ftype = this.readU8(),\n\t\t\t\t\t    str_len = this.readU32(),\n\t\t\t\t\t    str_end = str_len + this._ptr;\n\n\t\t\t\t\tif (str_type === 1) {\n\n\t\t\t\t\t\t// VERTICES\n\n\t\t\t\t\t\tbuffer = new Float32Array(str_len / 12 * 3);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 3);\n\n\t\t\t\t\t\tgeom.addAttribute('position', attrib);\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx] = -this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 1] = this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 2] = this.readF32();\n\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (str_type === 2) {\n\n\t\t\t\t\t\t// INDICES\n\n\t\t\t\t\t\tbuffer = new Uint16Array(str_len / 2);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 1);\n\t\t\t\t\t\tgeom.setIndex(attrib);\n\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx + 1] = this.readU16();\n\t\t\t\t\t\t\tbuffer[idx] = this.readU16();\n\t\t\t\t\t\t\tbuffer[idx + 2] = this.readU16();\n\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (str_type === 3) {\n\n\t\t\t\t\t\t// UVS\n\n\t\t\t\t\t\tbuffer = new Float32Array(str_len / 8 * 2);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 2);\n\n\t\t\t\t\t\tgeom.addAttribute('uv', attrib);\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx] = this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 1] = 1.0 - this.readF32();\n\t\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (str_type === 4) {\n\n\t\t\t\t\t\t// NORMALS\n\n\t\t\t\t\t\tbuffer = new Float32Array(str_len / 12 * 3);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 3);\n\t\t\t\t\t\tgeom.addAttribute('normal', attrib);\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx] = -this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 1] = this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 2] = this.readF32();\n\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._ptr = str_end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.parseUserAttributes();\n\n\t\t\t\tgeom.computeBoundingSphere();\n\t\t\t\tsubs_parsed++;\n\t\t\t}\n\n\t\t\t//geom.computeFaceNormals();\n\n\t\t\tthis.parseUserAttributes();\n\t\t\t//finalizeAsset(geom, name);\n\n\t\t\treturn geometries;\n\t\t},\n\n\t\tparseMeshPoseAnimation: function parseMeshPoseAnimation(len, poseOnly) {\n\n\t\t\tvar num_frames = 1,\n\t\t\t    num_submeshes,\n\t\t\t    frames_parsed,\n\t\t\t    subMeshParsed,\n\t\t\t    frame_dur,\n\t\t\t    x,\n\t\t\t    y,\n\t\t\t    z,\n\t\t\t    str_len,\n\t\t\t    str_end,\n\t\t\t    geom,\n\t\t\t    subGeom,\n\t\t\t    idx = 0,\n\t\t\t    clip = {},\n\t\t\t    indices,\n\t\t\t    verts,\n\t\t\t    num_Streams,\n\t\t\t    streamsParsed,\n\t\t\t    streamtypes = [],\n\t\t\t    props,\n\t\t\t    thisGeo,\n\t\t\t    name = this.readUTF(),\n\t\t\t    geoAdress = this.readU32();\n\n\t\t\tvar mesh = this.getBlock(geoAdress);\n\n\t\t\tif (mesh === null) {\n\n\t\t\t\tconsole.log(\"parseMeshPoseAnimation target mesh not found at:\", geoAdress);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgeom = mesh.geometry;\n\t\t\tgeom.morphTargets = [];\n\n\t\t\tif (!poseOnly) num_frames = this.readU16();\n\n\t\t\tnum_submeshes = this.readU16();\n\t\t\tnum_Streams = this.readU16();\n\n\t\t\t// debug(\"VA num_frames : \", num_frames );\n\t\t\t// debug(\"VA num_submeshes : \", num_submeshes );\n\t\t\t// debug(\"VA numstreams : \", num_Streams );\n\n\t\t\tstreamsParsed = 0;\n\t\t\twhile (streamsParsed < num_Streams) {\n\n\t\t\t\tstreamtypes.push(this.readU16());\n\t\t\t\tstreamsParsed++;\n\t\t\t}\n\t\t\tprops = this.parseProperties({ 1: BOOL, 2: BOOL });\n\n\t\t\tclip.looping = props.get(1, true);\n\t\t\tclip.stitchFinalFrame = props.get(2, false);\n\n\t\t\tframes_parsed = 0;\n\n\t\t\twhile (frames_parsed < num_frames) {\n\n\t\t\t\tframe_dur = this.readU16();\n\t\t\t\tsubMeshParsed = 0;\n\n\t\t\t\twhile (subMeshParsed < num_submeshes) {\n\n\t\t\t\t\tstreamsParsed = 0;\n\t\t\t\t\tstr_len = this.readU32();\n\t\t\t\t\tstr_end = this._ptr + str_len;\n\n\t\t\t\t\twhile (streamsParsed < num_Streams) {\n\n\t\t\t\t\t\tif (streamtypes[streamsParsed] === 1) {\n\n\t\t\t\t\t\t\t//geom.addAttribute( 'morphTarget'+frames_parsed, Float32Array, str_len/12, 3 );\n\t\t\t\t\t\t\tvar buffer = new Float32Array(str_len / 4);\n\t\t\t\t\t\t\tgeom.morphTargets.push({\n\t\t\t\t\t\t\t\tarray: buffer\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t//buffer = geom.attributes['morphTarget'+frames_parsed].array\n\t\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\t\tbuffer[idx] = this.readF32();\n\t\t\t\t\t\t\t\tbuffer[idx + 1] = this.readF32();\n\t\t\t\t\t\t\t\tbuffer[idx + 2] = this.readF32();\n\t\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsubMeshParsed++;\n\t\t\t\t\t\t} else this._ptr = str_end;\n\t\t\t\t\t\tstreamsParsed++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tframes_parsed++;\n\t\t\t}\n\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn null;\n\t\t},\n\n\t\tgetBlock: function getBlock(id) {\n\n\t\t\treturn this._blocks[id].data;\n\t\t},\n\n\t\tparseMatrix4: function parseMatrix4() {\n\n\t\t\tvar mtx = new THREE.Matrix4();\n\t\t\tvar e = mtx.elements;\n\n\t\t\te[0] = this.readF32();\n\t\t\te[1] = this.readF32();\n\t\t\te[2] = this.readF32();\n\t\t\te[3] = 0.0;\n\t\t\t//e[3] = 0.0;\n\n\t\t\te[4] = this.readF32();\n\t\t\te[5] = this.readF32();\n\t\t\te[6] = this.readF32();\n\t\t\t//e[7] = this.readF32();\n\t\t\te[7] = 0.0;\n\n\t\t\te[8] = this.readF32();\n\t\t\te[9] = this.readF32();\n\t\t\te[10] = this.readF32();\n\t\t\t//e[11] = this.readF32();\n\t\t\te[11] = 0.0;\n\n\t\t\te[12] = -this.readF32();\n\t\t\te[13] = this.readF32();\n\t\t\te[14] = this.readF32();\n\t\t\t//e[15] = this.readF32();\n\t\t\te[15] = 1.0;\n\t\t\treturn mtx;\n\t\t},\n\n\t\tparseProperties: function parseProperties(expected) {\n\n\t\t\tvar list_len = this.readU32();\n\t\t\tvar list_end = this._ptr + list_len;\n\n\t\t\tvar props = new AWDProperties();\n\n\t\t\tif (expected) {\n\n\t\t\t\twhile (this._ptr < list_end) {\n\n\t\t\t\t\tvar key = this.readU16();\n\t\t\t\t\tvar len = this.readU32();\n\t\t\t\t\tvar type;\n\n\t\t\t\t\tif (expected.hasOwnProperty(key)) {\n\n\t\t\t\t\t\ttype = expected[key];\n\t\t\t\t\t\tprops.set(key, this.parseAttrValue(type, len));\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._ptr += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn props;\n\t\t},\n\n\t\tparseUserAttributes: function parseUserAttributes() {\n\n\t\t\t// skip for now\n\t\t\tthis._ptr = this.readU32() + this._ptr;\n\t\t\treturn null;\n\t\t},\n\n\t\tparseAttrValue: function parseAttrValue(type, len) {\n\n\t\t\tvar elem_len;\n\t\t\tvar read_func;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase AWD_FIELD_INT8:\n\t\t\t\t\telem_len = 1;\n\t\t\t\t\tread_func = this.readI8;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_INT16:\n\t\t\t\t\telem_len = 2;\n\t\t\t\t\tread_func = this.readI16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_INT32:\n\t\t\t\t\telem_len = 4;\n\t\t\t\t\tread_func = this.readI32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_BOOL:\n\t\t\t\tcase AWD_FIELD_UINT8:\n\t\t\t\t\telem_len = 1;\n\t\t\t\t\tread_func = this.readU8;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_UINT16:\n\t\t\t\t\telem_len = 2;\n\t\t\t\t\tread_func = this.readU16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_UINT32:\n\t\t\t\tcase AWD_FIELD_BADDR:\n\t\t\t\t\telem_len = 4;\n\t\t\t\t\tread_func = this.readU32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_FLOAT32:\n\t\t\t\t\telem_len = 4;\n\t\t\t\t\tread_func = this.readF32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_FLOAT64:\n\t\t\t\t\telem_len = 8;\n\t\t\t\t\tread_func = this.readF64;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_VECTOR2x1:\n\t\t\t\tcase AWD_FIELD_VECTOR3x1:\n\t\t\t\tcase AWD_FIELD_VECTOR4x1:\n\t\t\t\tcase AWD_FIELD_MTX3x2:\n\t\t\t\tcase AWD_FIELD_MTX3x3:\n\t\t\t\tcase AWD_FIELD_MTX4x3:\n\t\t\t\tcase AWD_FIELD_MTX4x4:\n\t\t\t\t\telem_len = 8;\n\t\t\t\t\tread_func = this.readF64;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (elem_len < len) {\n\n\t\t\t\tvar list;\n\t\t\t\tvar num_read;\n\t\t\t\tvar num_elems;\n\n\t\t\t\tlist = [];\n\t\t\t\tnum_read = 0;\n\t\t\t\tnum_elems = len / elem_len;\n\n\t\t\t\twhile (num_read < num_elems) {\n\n\t\t\t\t\tlist.push(read_func.call(this));\n\t\t\t\t\tnum_read++;\n\t\t\t\t}\n\n\t\t\t\treturn list;\n\t\t\t} else {\n\n\t\t\t\treturn read_func.call(this);\n\t\t\t}\n\t\t},\n\n\t\treadU8: function readU8() {\n\n\t\t\treturn this._data.getUint8(this._ptr++);\n\t\t},\n\t\treadI8: function readI8() {\n\n\t\t\treturn this._data.getInt8(this._ptr++);\n\t\t},\n\t\treadU16: function readU16() {\n\n\t\t\tvar a = this._data.getUint16(this._ptr, littleEndian);\n\t\t\tthis._ptr += 2;\n\t\t\treturn a;\n\t\t},\n\t\treadI16: function readI16() {\n\n\t\t\tvar a = this._data.getInt16(this._ptr, littleEndian);\n\t\t\tthis._ptr += 2;\n\t\t\treturn a;\n\t\t},\n\t\treadU32: function readU32() {\n\n\t\t\tvar a = this._data.getUint32(this._ptr, littleEndian);\n\t\t\tthis._ptr += 4;\n\t\t\treturn a;\n\t\t},\n\t\treadI32: function readI32() {\n\n\t\t\tvar a = this._data.getInt32(this._ptr, littleEndian);\n\t\t\tthis._ptr += 4;\n\t\t\treturn a;\n\t\t},\n\t\treadF32: function readF32() {\n\n\t\t\tvar a = this._data.getFloat32(this._ptr, littleEndian);\n\t\t\tthis._ptr += 4;\n\t\t\treturn a;\n\t\t},\n\t\treadF64: function readF64() {\n\n\t\t\tvar a = this._data.getFloat64(this._ptr, littleEndian);\n\t\t\tthis._ptr += 8;\n\t\t\treturn a;\n\t\t},\n\n\t\t/**\n  * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.\n  * @param {Array.<number>} bytes UTF-8 byte array.\n  * @return {string} 16-bit Unicode string.\n  */\n\t\treadUTF: function readUTF() {\n\n\t\t\tvar len = this.readU16();\n\t\t\treturn this.readUTFBytes(len);\n\t\t},\n\n\t\t/**\n   * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.\n   * @param {Array.<number>} bytes UTF-8 byte array.\n   * @return {string} 16-bit Unicode string.\n   */\n\t\treadUTFBytes: function readUTFBytes(len) {\n\n\t\t\t// TODO(user): Use native implementations if/when available\n\t\t\tvar out = [],\n\t\t\t    c = 0;\n\n\t\t\twhile (out.length < len) {\n\n\t\t\t\tvar c1 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\tif (c1 < 128) {\n\n\t\t\t\t\tout[c++] = String.fromCharCode(c1);\n\t\t\t\t} else if (c1 > 191 && c1 < 224) {\n\n\t\t\t\t\tvar c2 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\t\tout[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n\t\t\t\t} else {\n\n\t\t\t\t\tvar c2 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\t\tvar c3 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\t\tout[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t}\n\n\t};\n\n\treturn AWDLoader;\n}();\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar BabylonLoader = function BabylonLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nBabylonLoader.prototype = {\n\n\tconstructor: BabylonLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(json) {\n\n\t\tfunction parseMaterials(json) {\n\n\t\t\tvar materials = {};\n\n\t\t\tfor (var i = 0, l = json.materials.length; i < l; i++) {\n\n\t\t\t\tvar data = json.materials[i];\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial();\n\t\t\t\tmaterial.name = data.name;\n\t\t\t\tmaterial.color.fromArray(data.diffuse);\n\t\t\t\tmaterial.emissive.fromArray(data.emissive);\n\t\t\t\tmaterial.specular.fromArray(data.specular);\n\t\t\t\tmaterial.shininess = data.specularPower;\n\t\t\t\tmaterial.opacity = data.alpha;\n\n\t\t\t\tmaterials[data.id] = material;\n\t\t\t}\n\n\t\t\tif (json.multiMaterials) {\n\n\t\t\t\tfor (var i = 0, l = json.multiMaterials.length; i < l; i++) {\n\n\t\t\t\t\tvar data = json.multiMaterials[i];\n\n\t\t\t\t\tconsole.warn('THREE.BabylonLoader: Multi materials not yet supported.');\n\n\t\t\t\t\tmaterials[data.id] = new THREE.MeshPhongMaterial();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn materials;\n\t\t}\n\n\t\tfunction parseGeometry(json) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar indices = json.indices;\n\t\t\tvar positions = json.positions;\n\t\t\tvar normals = json.normals;\n\t\t\tvar uvs = json.uvs;\n\n\t\t\t// indices\n\n\t\t\tgeometry.setIndex(indices);\n\n\t\t\t// positions\n\n\t\t\tfor (var j = 2, jl = positions.length; j < jl; j += 3) {\n\n\t\t\t\tpositions[j] = -positions[j];\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n\n\t\t\t// normals\n\n\t\t\tif (normals) {\n\n\t\t\t\tfor (var j = 2, jl = normals.length; j < jl; j += 3) {\n\n\t\t\t\t\tnormals[j] = -normals[j];\n\t\t\t\t}\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif (uvs) {\n\n\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\t\t\t}\n\n\t\t\t// offsets\n\n\t\t\tvar subMeshes = json.subMeshes;\n\n\t\t\tif (subMeshes) {\n\n\t\t\t\tfor (var j = 0, jl = subMeshes.length; j < jl; j++) {\n\n\t\t\t\t\tvar subMesh = subMeshes[j];\n\n\t\t\t\t\tgeometry.addGroup(subMesh.indexStart, subMesh.indexCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseObjects(json, materials) {\n\n\t\t\tvar objects = {};\n\t\t\tvar scene = new THREE.Scene();\n\n\t\t\tvar cameras = json.cameras;\n\n\t\t\tfor (var i = 0, l = cameras.length; i < l; i++) {\n\n\t\t\t\tvar data = cameras[i];\n\n\t\t\t\tvar camera = new THREE.PerspectiveCamera(data.fov / Math.PI * 180, 1.33, data.minZ, data.maxZ);\n\n\t\t\t\tcamera.name = data.name;\n\t\t\t\tcamera.position.fromArray(data.position);\n\t\t\t\tif (data.rotation) camera.rotation.fromArray(data.rotation);\n\n\t\t\t\tobjects[data.id] = camera;\n\t\t\t}\n\n\t\t\tvar lights = json.lights;\n\n\t\t\tfor (var i = 0, l = lights.length; i < l; i++) {\n\n\t\t\t\tvar data = lights[i];\n\n\t\t\t\tvar light;\n\n\t\t\t\tswitch (data.type) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tlight = new THREE.DirectionalLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tlight = new THREE.SpotLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tlight = new THREE.HemisphereLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlight.name = data.name;\n\t\t\t\tif (data.position) light.position.set(data.position[0], data.position[1], -data.position[2]);\n\t\t\t\tlight.color.fromArray(data.diffuse);\n\t\t\t\tif (data.groundColor) light.groundColor.fromArray(data.groundColor);\n\t\t\t\tif (data.intensity) light.intensity = data.intensity;\n\n\t\t\t\tobjects[data.id] = light;\n\n\t\t\t\tscene.add(light);\n\t\t\t}\n\n\t\t\tvar meshes = json.meshes;\n\n\t\t\tfor (var i = 0, l = meshes.length; i < l; i++) {\n\n\t\t\t\tvar data = meshes[i];\n\n\t\t\t\tvar object;\n\n\t\t\t\tif (data.indices) {\n\n\t\t\t\t\tvar geometry = parseGeometry(data);\n\n\t\t\t\t\tobject = new THREE.Mesh(geometry, materials[data.materialId]);\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = new THREE.Group();\n\t\t\t\t}\n\n\t\t\t\tobject.name = data.name;\n\t\t\t\tobject.position.set(data.position[0], data.position[1], -data.position[2]);\n\t\t\t\tobject.rotation.fromArray(data.rotation);\n\t\t\t\tif (data.rotationQuaternion) object.quaternion.fromArray(data.rotationQuaternion);\n\t\t\t\tobject.scale.fromArray(data.scaling);\n\t\t\t\t// object.visible = data.isVisible;\n\n\t\t\t\tif (data.parentId) {\n\n\t\t\t\t\tobjects[data.parentId].add(object);\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.add(object);\n\t\t\t\t}\n\n\t\t\t\tobjects[data.id] = object;\n\t\t\t}\n\n\t\t\treturn scene;\n\t\t}\n\n\t\tvar materials = parseMaterials(json);\n\t\tvar scene = parseObjects(json, materials);\n\n\t\treturn scene;\n\t}\n\n};\n\nexports.default = BabylonLoader;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar BinaryLoader = function BinaryLoader(manager) {\n\n\tif (typeof manager === 'boolean') {\n\n\t\tconsole.warn('THREE.BinaryLoader: showStatus parameter has been removed from constructor.');\n\t\tmanager = undefined;\n\t}\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nBinaryLoader.prototype = {\n\n\tconstructor: BinaryLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\t// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)\n\t//  - binary models consist of two files: JS and BIN\n\t//  - parameters\n\t//\t\t- url (required)\n\t//\t\t- callback (required)\n\t//\t\t- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)\n\t//\t\t- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t// todo: unify load API to for easier SceneLoader use\n\n\t\tvar texturePath = this.texturePath || THREE.LoaderUtils.extractUrlBase(url);\n\t\tvar binaryPath = this.binaryPath || THREE.LoaderUtils.extractUrlBase(url);\n\n\t\t// #1 load JS part via web worker\n\n\t\tvar scope = this;\n\n\t\tvar jsonloader = new THREE.FileLoader(this.manager);\n\t\tjsonloader.load(url, function (data) {\n\n\t\t\tvar json = JSON.parse(data);\n\n\t\t\tvar bufferUrl = binaryPath + json.buffers;\n\n\t\t\tvar bufferLoader = new THREE.FileLoader(scope.manager);\n\t\t\tbufferLoader.setResponseType('arraybuffer');\n\t\t\tbufferLoader.load(bufferUrl, function (bufData) {\n\n\t\t\t\t// IEWEBGL needs this ???\n\t\t\t\t//buffer = ( new Uint8Array( xhr.responseBody ) ).buffer;\n\n\t\t\t\t//// iOS and other XMLHttpRequest level 1 ???\n\n\t\t\t\tscope.parse(bufData, onLoad, texturePath, json.materials);\n\t\t\t}, onProgress, onError);\n\t\t}, onProgress, onError);\n\t},\n\n\tsetBinaryPath: function setBinaryPath(value) {\n\n\t\tthis.binaryPath = value;\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tsetTexturePath: function setTexturePath(value) {\n\n\t\tthis.texturePath = value;\n\t},\n\n\tparse: function parse(data, callback, texturePath, jsonMaterials) {\n\n\t\tvar Model = function Model() {\n\n\t\t\tvar scope = this,\n\t\t\t    currentOffset = 0,\n\t\t\t    md,\n\t\t\t    normals = [],\n\t\t\t    uvs = [],\n\t\t\t    start_tri_flat,\n\t\t\t    start_tri_smooth,\n\t\t\t    start_tri_flat_uv,\n\t\t\t    start_tri_smooth_uv,\n\t\t\t    start_quad_flat,\n\t\t\t    start_quad_smooth,\n\t\t\t    start_quad_flat_uv,\n\t\t\t    start_quad_smooth_uv,\n\t\t\t    tri_size,\n\t\t\t    quad_size,\n\t\t\t    len_tri_flat,\n\t\t\t    len_tri_smooth,\n\t\t\t    len_tri_flat_uv,\n\t\t\t    len_tri_smooth_uv,\n\t\t\t    len_quad_flat,\n\t\t\t    len_quad_smooth,\n\t\t\t    len_quad_flat_uv;\n\n\t\t\tTHREE.Geometry.call(this);\n\n\t\t\tmd = parseMetaData(data, currentOffset);\n\n\t\t\tcurrentOffset += md.header_bytes;\n\t\t\t/*\n   \t\tmd.vertex_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n   \t\tmd.material_index_bytes = Uint16Array.BYTES_PER_ELEMENT;\n   \t\tmd.normal_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n   \t\tmd.uv_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n   */\n\t\t\t// buffers sizes\n\n\t\t\ttri_size = md.vertex_index_bytes * 3 + md.material_index_bytes;\n\t\t\tquad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;\n\n\t\t\tlen_tri_flat = md.ntri_flat * tri_size;\n\t\t\tlen_tri_smooth = md.ntri_smooth * (tri_size + md.normal_index_bytes * 3);\n\t\t\tlen_tri_flat_uv = md.ntri_flat_uv * (tri_size + md.uv_index_bytes * 3);\n\t\t\tlen_tri_smooth_uv = md.ntri_smooth_uv * (tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3);\n\n\t\t\tlen_quad_flat = md.nquad_flat * quad_size;\n\t\t\tlen_quad_smooth = md.nquad_smooth * (quad_size + md.normal_index_bytes * 4);\n\t\t\tlen_quad_flat_uv = md.nquad_flat_uv * (quad_size + md.uv_index_bytes * 4);\n\n\t\t\t// read buffers\n\n\t\t\tcurrentOffset += init_vertices(currentOffset);\n\n\t\t\tcurrentOffset += init_normals(currentOffset);\n\t\t\tcurrentOffset += handlePadding(md.nnormals * 3);\n\n\t\t\tcurrentOffset += init_uvs(currentOffset);\n\n\t\t\tstart_tri_flat = currentOffset;\n\t\t\tstart_tri_smooth = start_tri_flat + len_tri_flat + handlePadding(md.ntri_flat * 2);\n\t\t\tstart_tri_flat_uv = start_tri_smooth + len_tri_smooth + handlePadding(md.ntri_smooth * 2);\n\t\t\tstart_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding(md.ntri_flat_uv * 2);\n\n\t\t\tstart_quad_flat = start_tri_smooth_uv + len_tri_smooth_uv + handlePadding(md.ntri_smooth_uv * 2);\n\t\t\tstart_quad_smooth = start_quad_flat + len_quad_flat + handlePadding(md.nquad_flat * 2);\n\t\t\tstart_quad_flat_uv = start_quad_smooth + len_quad_smooth + handlePadding(md.nquad_smooth * 2);\n\t\t\tstart_quad_smooth_uv = start_quad_flat_uv + len_quad_flat_uv + handlePadding(md.nquad_flat_uv * 2);\n\n\t\t\t// have to first process faces with uvs\n\t\t\t// so that face and uv indices match\n\n\t\t\tinit_triangles_flat_uv(start_tri_flat_uv);\n\t\t\tinit_triangles_smooth_uv(start_tri_smooth_uv);\n\n\t\t\tinit_quads_flat_uv(start_quad_flat_uv);\n\t\t\tinit_quads_smooth_uv(start_quad_smooth_uv);\n\n\t\t\t// now we can process untextured faces\n\n\t\t\tinit_triangles_flat(start_tri_flat);\n\t\t\tinit_triangles_smooth(start_tri_smooth);\n\n\t\t\tinit_quads_flat(start_quad_flat);\n\t\t\tinit_quads_smooth(start_quad_smooth);\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfunction handlePadding(n) {\n\n\t\t\t\treturn n % 4 ? 4 - n % 4 : 0;\n\t\t\t}\n\n\t\t\tfunction parseMetaData(data, offset) {\n\n\t\t\t\tvar metaData = {\n\n\t\t\t\t\t'signature': parseString(data, offset, 12),\n\t\t\t\t\t'header_bytes': parseUChar8(data, offset + 12),\n\n\t\t\t\t\t'vertex_coordinate_bytes': parseUChar8(data, offset + 13),\n\t\t\t\t\t'normal_coordinate_bytes': parseUChar8(data, offset + 14),\n\t\t\t\t\t'uv_coordinate_bytes': parseUChar8(data, offset + 15),\n\n\t\t\t\t\t'vertex_index_bytes': parseUChar8(data, offset + 16),\n\t\t\t\t\t'normal_index_bytes': parseUChar8(data, offset + 17),\n\t\t\t\t\t'uv_index_bytes': parseUChar8(data, offset + 18),\n\t\t\t\t\t'material_index_bytes': parseUChar8(data, offset + 19),\n\n\t\t\t\t\t'nvertices': parseUInt32(data, offset + 20),\n\t\t\t\t\t'nnormals': parseUInt32(data, offset + 20 + 4 * 1),\n\t\t\t\t\t'nuvs': parseUInt32(data, offset + 20 + 4 * 2),\n\n\t\t\t\t\t'ntri_flat': parseUInt32(data, offset + 20 + 4 * 3),\n\t\t\t\t\t'ntri_smooth': parseUInt32(data, offset + 20 + 4 * 4),\n\t\t\t\t\t'ntri_flat_uv': parseUInt32(data, offset + 20 + 4 * 5),\n\t\t\t\t\t'ntri_smooth_uv': parseUInt32(data, offset + 20 + 4 * 6),\n\n\t\t\t\t\t'nquad_flat': parseUInt32(data, offset + 20 + 4 * 7),\n\t\t\t\t\t'nquad_smooth': parseUInt32(data, offset + 20 + 4 * 8),\n\t\t\t\t\t'nquad_flat_uv': parseUInt32(data, offset + 20 + 4 * 9),\n\t\t\t\t\t'nquad_smooth_uv': parseUInt32(data, offset + 20 + 4 * 10)\n\n\t\t\t\t};\n\t\t\t\t/*\n    \t\t\tconsole.log( \"signature: \" + metaData.signature );\n    \t\t\t\tconsole.log( \"header_bytes: \" + metaData.header_bytes );\n    \t\t\tconsole.log( \"vertex_coordinate_bytes: \" + metaData.vertex_coordinate_bytes );\n    \t\t\tconsole.log( \"normal_coordinate_bytes: \" + metaData.normal_coordinate_bytes );\n    \t\t\tconsole.log( \"uv_coordinate_bytes: \" + metaData.uv_coordinate_bytes );\n    \t\t\t\tconsole.log( \"vertex_index_bytes: \" + metaData.vertex_index_bytes );\n    \t\t\tconsole.log( \"normal_index_bytes: \" + metaData.normal_index_bytes );\n    \t\t\tconsole.log( \"uv_index_bytes: \" + metaData.uv_index_bytes );\n    \t\t\tconsole.log( \"material_index_bytes: \" + metaData.material_index_bytes );\n    \t\t\t\tconsole.log( \"nvertices: \" + metaData.nvertices );\n    \t\t\tconsole.log( \"nnormals: \" + metaData.nnormals );\n    \t\t\tconsole.log( \"nuvs: \" + metaData.nuvs );\n    \t\t\t\tconsole.log( \"ntri_flat: \" + metaData.ntri_flat );\n    \t\t\tconsole.log( \"ntri_smooth: \" + metaData.ntri_smooth );\n    \t\t\tconsole.log( \"ntri_flat_uv: \" + metaData.ntri_flat_uv );\n    \t\t\tconsole.log( \"ntri_smooth_uv: \" + metaData.ntri_smooth_uv );\n    \t\t\t\tconsole.log( \"nquad_flat: \" + metaData.nquad_flat );\n    \t\t\tconsole.log( \"nquad_smooth: \" + metaData.nquad_smooth );\n    \t\t\tconsole.log( \"nquad_flat_uv: \" + metaData.nquad_flat_uv );\n    \t\t\tconsole.log( \"nquad_smooth_uv: \" + metaData.nquad_smooth_uv );\n    \t\t\t\tvar total = metaData.header_bytes\n    \t\t\t\t\t  + metaData.nvertices * metaData.vertex_coordinate_bytes * 3\n    \t\t\t\t\t  + metaData.nnormals * metaData.normal_coordinate_bytes * 3\n    \t\t\t\t\t  + metaData.nuvs * metaData.uv_coordinate_bytes * 2\n    \t\t\t\t\t  + metaData.ntri_flat * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes )\n    \t\t\t\t\t  + metaData.ntri_smooth * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 )\n    \t\t\t\t\t  + metaData.ntri_flat_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.uv_index_bytes*3 )\n    \t\t\t\t\t  + metaData.ntri_smooth_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 + metaData.uv_index_bytes*3 )\n    \t\t\t\t\t  + metaData.nquad_flat * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes )\n    \t\t\t\t\t  + metaData.nquad_smooth * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 )\n    \t\t\t\t\t  + metaData.nquad_flat_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.uv_index_bytes*4 )\n    \t\t\t\t\t  + metaData.nquad_smooth_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 + metaData.uv_index_bytes*4 );\n    \t\t\tconsole.log( \"total bytes: \" + total );\n    */\n\n\t\t\t\treturn metaData;\n\t\t\t}\n\n\t\t\tfunction parseString(data, offset, length) {\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(data, offset, length));\n\t\t\t}\n\n\t\t\tfunction parseUChar8(data, offset) {\n\n\t\t\t\tvar charArray = new Uint8Array(data, offset, 1);\n\n\t\t\t\treturn charArray[0];\n\t\t\t}\n\n\t\t\tfunction parseUInt32(data, offset) {\n\n\t\t\t\tvar intArray = new Uint32Array(data, offset, 1);\n\n\t\t\t\treturn intArray[0];\n\t\t\t}\n\n\t\t\tfunction init_vertices(start) {\n\n\t\t\t\tvar nElements = md.nvertices;\n\n\t\t\t\tvar coordArray = new Float32Array(data, start, nElements * 3);\n\n\t\t\t\tvar i, x, y, z;\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\tx = coordArray[i * 3];\n\t\t\t\t\ty = coordArray[i * 3 + 1];\n\t\t\t\t\tz = coordArray[i * 3 + 2];\n\n\t\t\t\t\tscope.vertices.push(new THREE.Vector3(x, y, z));\n\t\t\t\t}\n\n\t\t\t\treturn nElements * 3 * Float32Array.BYTES_PER_ELEMENT;\n\t\t\t}\n\n\t\t\tfunction init_normals(start) {\n\n\t\t\t\tvar nElements = md.nnormals;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar normalArray = new Int8Array(data, start, nElements * 3);\n\n\t\t\t\t\tvar i, x, y, z;\n\n\t\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\t\tx = normalArray[i * 3];\n\t\t\t\t\t\ty = normalArray[i * 3 + 1];\n\t\t\t\t\t\tz = normalArray[i * 3 + 2];\n\n\t\t\t\t\t\tnormals.push(x / 127, y / 127, z / 127);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nElements * 3 * Int8Array.BYTES_PER_ELEMENT;\n\t\t\t}\n\n\t\t\tfunction init_uvs(start) {\n\n\t\t\t\tvar nElements = md.nuvs;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar uvArray = new Float32Array(data, start, nElements * 2);\n\n\t\t\t\t\tvar i, u, v;\n\n\t\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\t\tu = uvArray[i * 2];\n\t\t\t\t\t\tv = uvArray[i * 2 + 1];\n\n\t\t\t\t\t\tuvs.push(u, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nElements * 2 * Float32Array.BYTES_PER_ELEMENT;\n\t\t\t}\n\n\t\t\tfunction init_uvs3(nElements, offset) {\n\n\t\t\t\tvar i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;\n\n\t\t\t\tvar uvIndexBuffer = new Uint32Array(data, offset, 3 * nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\tuva = uvIndexBuffer[i * 3];\n\t\t\t\t\tuvb = uvIndexBuffer[i * 3 + 1];\n\t\t\t\t\tuvc = uvIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tu1 = uvs[uva * 2];\n\t\t\t\t\tv1 = uvs[uva * 2 + 1];\n\n\t\t\t\t\tu2 = uvs[uvb * 2];\n\t\t\t\t\tv2 = uvs[uvb * 2 + 1];\n\n\t\t\t\t\tu3 = uvs[uvc * 2];\n\t\t\t\t\tv3 = uvs[uvc * 2 + 1];\n\n\t\t\t\t\tscope.faceVertexUvs[0].push([new THREE.Vector2(u1, v1), new THREE.Vector2(u2, v2), new THREE.Vector2(u3, v3)]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_uvs4(nElements, offset) {\n\n\t\t\t\tvar i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;\n\n\t\t\t\tvar uvIndexBuffer = new Uint32Array(data, offset, 4 * nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\tuva = uvIndexBuffer[i * 4];\n\t\t\t\t\tuvb = uvIndexBuffer[i * 4 + 1];\n\t\t\t\t\tuvc = uvIndexBuffer[i * 4 + 2];\n\t\t\t\t\tuvd = uvIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tu1 = uvs[uva * 2];\n\t\t\t\t\tv1 = uvs[uva * 2 + 1];\n\n\t\t\t\t\tu2 = uvs[uvb * 2];\n\t\t\t\t\tv2 = uvs[uvb * 2 + 1];\n\n\t\t\t\t\tu3 = uvs[uvc * 2];\n\t\t\t\t\tv3 = uvs[uvc * 2 + 1];\n\n\t\t\t\t\tu4 = uvs[uvd * 2];\n\t\t\t\t\tv4 = uvs[uvd * 2 + 1];\n\n\t\t\t\t\tscope.faceVertexUvs[0].push([new THREE.Vector2(u1, v1), new THREE.Vector2(u2, v2), new THREE.Vector2(u4, v4)]);\n\n\t\t\t\t\tscope.faceVertexUvs[0].push([new THREE.Vector2(u2, v2), new THREE.Vector2(u3, v3), new THREE.Vector2(u4, v4)]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces3_flat(nElements, offsetVertices, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, m;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 3 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 3];\n\t\t\t\t\tb = vertexIndexBuffer[i * 3 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, c, null, null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces4_flat(nElements, offsetVertices, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, d, m;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 4 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 4];\n\t\t\t\t\tb = vertexIndexBuffer[i * 4 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 4 + 2];\n\t\t\t\t\td = vertexIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, d, null, null, m));\n\t\t\t\t\tscope.faces.push(new THREE.Face3(b, c, d, null, null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces3_smooth(nElements, offsetVertices, offsetNormals, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, m;\n\t\t\t\tvar na, nb, nc;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 3 * nElements);\n\t\t\t\tvar normalIndexBuffer = new Uint32Array(data, offsetNormals, 3 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 3];\n\t\t\t\t\tb = vertexIndexBuffer[i * 3 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tna = normalIndexBuffer[i * 3];\n\t\t\t\t\tnb = normalIndexBuffer[i * 3 + 1];\n\t\t\t\t\tnc = normalIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tvar nax = normals[na * 3],\n\t\t\t\t\t    nay = normals[na * 3 + 1],\n\t\t\t\t\t    naz = normals[na * 3 + 2],\n\t\t\t\t\t    nbx = normals[nb * 3],\n\t\t\t\t\t    nby = normals[nb * 3 + 1],\n\t\t\t\t\t    nbz = normals[nb * 3 + 2],\n\t\t\t\t\t    ncx = normals[nc * 3],\n\t\t\t\t\t    ncy = normals[nc * 3 + 1],\n\t\t\t\t\t    ncz = normals[nc * 3 + 2];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, c, [new THREE.Vector3(nax, nay, naz), new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ncx, ncy, ncz)], null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces4_smooth(nElements, offsetVertices, offsetNormals, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, d, m;\n\t\t\t\tvar na, nb, nc, nd;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 4 * nElements);\n\t\t\t\tvar normalIndexBuffer = new Uint32Array(data, offsetNormals, 4 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 4];\n\t\t\t\t\tb = vertexIndexBuffer[i * 4 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 4 + 2];\n\t\t\t\t\td = vertexIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tna = normalIndexBuffer[i * 4];\n\t\t\t\t\tnb = normalIndexBuffer[i * 4 + 1];\n\t\t\t\t\tnc = normalIndexBuffer[i * 4 + 2];\n\t\t\t\t\tnd = normalIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tvar nax = normals[na * 3],\n\t\t\t\t\t    nay = normals[na * 3 + 1],\n\t\t\t\t\t    naz = normals[na * 3 + 2],\n\t\t\t\t\t    nbx = normals[nb * 3],\n\t\t\t\t\t    nby = normals[nb * 3 + 1],\n\t\t\t\t\t    nbz = normals[nb * 3 + 2],\n\t\t\t\t\t    ncx = normals[nc * 3],\n\t\t\t\t\t    ncy = normals[nc * 3 + 1],\n\t\t\t\t\t    ncz = normals[nc * 3 + 2],\n\t\t\t\t\t    ndx = normals[nd * 3],\n\t\t\t\t\t    ndy = normals[nd * 3 + 1],\n\t\t\t\t\t    ndz = normals[nd * 3 + 2];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, d, [new THREE.Vector3(nax, nay, naz), new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ndx, ndy, ndz)], null, m));\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(b, c, d, [new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ncx, ncy, ncz), new THREE.Vector3(ndx, ndy, ndz)], null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_flat(start) {\n\n\t\t\t\tvar nElements = md.ntri_flat;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tinit_faces3_flat(nElements, start, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_flat_uv(start) {\n\n\t\t\t\tvar nElements = md.ntri_flat_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\t\tinit_faces3_flat(nElements, start, offsetMaterials);\n\t\t\t\t\tinit_uvs3(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_smooth(start) {\n\n\t\t\t\tvar nElements = md.ntri_smooth;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\t\tinit_faces3_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_smooth_uv(start) {\n\n\t\t\t\tvar nElements = md.ntri_smooth_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\t\tinit_faces3_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t\tinit_uvs3(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_flat(start) {\n\n\t\t\t\tvar nElements = md.nquad_flat;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tinit_faces4_flat(nElements, start, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_flat_uv(start) {\n\n\t\t\t\tvar nElements = md.nquad_flat_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\t\tinit_faces4_flat(nElements, start, offsetMaterials);\n\t\t\t\t\tinit_uvs4(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_smooth(start) {\n\n\t\t\t\tvar nElements = md.nquad_smooth;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\t\tinit_faces4_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_smooth_uv(start) {\n\n\t\t\t\tvar nElements = md.nquad_smooth_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\t\tinit_faces4_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t\tinit_uvs4(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tModel.prototype = Object.create(THREE.Geometry.prototype);\n\t\tModel.prototype.constructor = Model;\n\n\t\tvar geometry = new Model();\n\t\tvar materials = THREE.Loader.prototype.initMaterials(jsonMaterials, texturePath, this.crossOrigin);\n\n\t\tcallback(geometry, materials);\n\t}\n\n};\n\nexports.default = BinaryLoader;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author herzig / http://github.com/herzig\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: reads BVH files and outputs a single THREE.Skeleton and an THREE.AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nvar BVHLoader = function BVHLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.animateBonePositions = true;\n\tthis.animateBoneRotations = true;\n};\n\nBVHLoader.prototype = {\n\n\tconstructor: BVHLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(text) {\n\n\t\t/*\n  \treads a string array (lines) from a BVH file\n  \tand outputs a skeleton structure including motion data\n  \t\treturns thee root node:\n  \t{ name: '', channels: [], children: [] }\n  */\n\t\tfunction readBvh(lines) {\n\n\t\t\t// read model structure\n\n\t\t\tif (nextLine(lines) !== 'HIERARCHY') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: HIERARCHY expected.');\n\t\t\t}\n\n\t\t\tvar list = []; // collects flat array of all bones\n\t\t\tvar root = readNode(lines, nextLine(lines), list);\n\n\t\t\t// read motion data\n\n\t\t\tif (nextLine(lines) !== 'MOTION') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: MOTION expected.');\n\t\t\t}\n\n\t\t\t// number of frames\n\n\t\t\tvar tokens = nextLine(lines).split(/[\\s]+/);\n\t\t\tvar numFrames = parseInt(tokens[1]);\n\n\t\t\tif (isNaN(numFrames)) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Failed to read number of frames.');\n\t\t\t}\n\n\t\t\t// frame time\n\n\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\t\t\tvar frameTime = parseFloat(tokens[2]);\n\n\t\t\tif (isNaN(frameTime)) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Failed to read frame time.');\n\t\t\t}\n\n\t\t\t// read frame data line by line\n\n\t\t\tfor (var i = 0; i < numFrames; i++) {\n\n\t\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\t\t\t\treadFrameData(tokens, i * frameTime, root);\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\t/*\n  \tRecursively reads data from a single frame into the bone hierarchy.\n  \tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n  \tkeyframe data is stored in bone.frames.\n  \t\t- data: splitted string array (frame values), values are shift()ed so\n  \tthis should be empty after parsing the whole hierarchy.\n  \t- frameTime: playback time for this keyframe.\n  \t- bone: the bone to read frame data from.\n  */\n\t\tfunction readFrameData(data, frameTime, bone) {\n\n\t\t\t// end sites have no motion data\n\n\t\t\tif (bone.type === 'ENDSITE') return;\n\n\t\t\t// add keyframe\n\n\t\t\tvar keyframe = {\n\t\t\t\ttime: frameTime,\n\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\trotation: new THREE.Quaternion()\n\t\t\t};\n\n\t\t\tbone.frames.push(keyframe);\n\n\t\t\tvar quat = new THREE.Quaternion();\n\n\t\t\tvar vx = new THREE.Vector3(1, 0, 0);\n\t\t\tvar vy = new THREE.Vector3(0, 1, 0);\n\t\t\tvar vz = new THREE.Vector3(0, 0, 1);\n\n\t\t\t// parse values for each channel in node\n\n\t\t\tfor (var i = 0; i < bone.channels.length; i++) {\n\n\t\t\t\tswitch (bone.channels[i]) {\n\n\t\t\t\t\tcase 'Xposition':\n\t\t\t\t\t\tkeyframe.position.x = parseFloat(data.shift().trim());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yposition':\n\t\t\t\t\t\tkeyframe.position.y = parseFloat(data.shift().trim());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zposition':\n\t\t\t\t\t\tkeyframe.position.z = parseFloat(data.shift().trim());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Xrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n\t\t\t\t\t\tkeyframe.rotation.multiply(quat);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n\t\t\t\t\t\tkeyframe.rotation.multiply(quat);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n\t\t\t\t\t\tkeyframe.rotation.multiply(quat);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn('THREE.BVHLoader: Invalid channel type.');\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// parse child nodes\n\n\t\t\tfor (var i = 0; i < bone.children.length; i++) {\n\n\t\t\t\treadFrameData(data, frameTime, bone.children[i]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n   Recursively parses the HIERACHY section of the BVH file\n  \t - lines: all lines of the file. lines are consumed as we go along.\n   - firstline: line containing the node type and name e.g. 'JOINT hip'\n   - list: collects a flat list of nodes\n  \t returns: a BVH node including children\n  */\n\t\tfunction readNode(lines, firstline, list) {\n\n\t\t\tvar node = { name: '', type: '', frames: [] };\n\t\t\tlist.push(node);\n\n\t\t\t// parse node type and name\n\n\t\t\tvar tokens = firstline.split(/[\\s]+/);\n\n\t\t\tif (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n\n\t\t\t\tnode.type = 'ENDSITE';\n\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\n\t\t\t} else {\n\n\t\t\t\tnode.name = tokens[1];\n\t\t\t\tnode.type = tokens[0].toUpperCase();\n\t\t\t}\n\n\t\t\tif (nextLine(lines) !== '{') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Expected opening { after type & name');\n\t\t\t}\n\n\t\t\t// parse OFFSET\n\n\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\n\t\t\tif (tokens[0] !== 'OFFSET') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n\t\t\t}\n\n\t\t\tif (tokens.length !== 4) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n\t\t\t}\n\n\t\t\tvar offset = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n\n\t\t\tif (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Invalid values of OFFSET.');\n\t\t\t}\n\n\t\t\tnode.offset = offset;\n\n\t\t\t// parse CHANNELS definitions\n\n\t\t\tif (node.type !== 'ENDSITE') {\n\n\t\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\n\t\t\t\tif (tokens[0] !== 'CHANNELS') {\n\n\t\t\t\t\tconsole.error('THREE.BVHLoader: Expected CHANNELS definition.');\n\t\t\t\t}\n\n\t\t\t\tvar numChannels = parseInt(tokens[1]);\n\t\t\t\tnode.channels = tokens.splice(2, numChannels);\n\t\t\t\tnode.children = [];\n\t\t\t}\n\n\t\t\t// read children\n\n\t\t\twhile (true) {\n\n\t\t\t\tvar line = nextLine(lines);\n\n\t\t\t\tif (line === '}') {\n\n\t\t\t\t\treturn node;\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.children.push(readNode(lines, line, list));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n  \trecursively converts the internal bvh node structure to a THREE.Bone hierarchy\n  \t\tsource: the bvh root node\n  \tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n  \t\treturns the root THREE.Bone\n  */\n\t\tfunction toTHREEBone(source, list) {\n\n\t\t\tvar bone = new THREE.Bone();\n\t\t\tlist.push(bone);\n\n\t\t\tbone.position.add(source.offset);\n\t\t\tbone.name = source.name;\n\n\t\t\tif (source.type !== 'ENDSITE') {\n\n\t\t\t\tfor (var i = 0; i < source.children.length; i++) {\n\n\t\t\t\t\tbone.add(toTHREEBone(source.children[i], list));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bone;\n\t\t}\n\n\t\t/*\n  \tbuilds a THREE.AnimationClip from the keyframe data saved in each bone.\n  \t\tbone: bvh root node\n  \t\treturns: a THREE.AnimationClip containing position and quaternion tracks\n  */\n\t\tfunction toTHREEAnimation(bones) {\n\n\t\t\tvar tracks = [];\n\n\t\t\t// create a position and quaternion animation track for each node\n\n\t\t\tfor (var i = 0; i < bones.length; i++) {\n\n\t\t\t\tvar bone = bones[i];\n\n\t\t\t\tif (bone.type === 'ENDSITE') continue;\n\n\t\t\t\t// track data\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar positions = [];\n\t\t\t\tvar rotations = [];\n\n\t\t\t\tfor (var j = 0; j < bone.frames.length; j++) {\n\n\t\t\t\t\tvar frame = bone.frames[j];\n\n\t\t\t\t\ttimes.push(frame.time);\n\n\t\t\t\t\t// the animation system animates the position property,\n\t\t\t\t\t// so we have to add the joint offset to all values\n\n\t\t\t\t\tpositions.push(frame.position.x + bone.offset.x);\n\t\t\t\t\tpositions.push(frame.position.y + bone.offset.y);\n\t\t\t\t\tpositions.push(frame.position.z + bone.offset.z);\n\n\t\t\t\t\trotations.push(frame.rotation.x);\n\t\t\t\t\trotations.push(frame.rotation.y);\n\t\t\t\t\trotations.push(frame.rotation.z);\n\t\t\t\t\trotations.push(frame.rotation.w);\n\t\t\t\t}\n\n\t\t\t\tif (scope.animateBonePositions) {\n\n\t\t\t\t\ttracks.push(new THREE.VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));\n\t\t\t\t}\n\n\t\t\t\tif (scope.animateBoneRotations) {\n\n\t\t\t\t\ttracks.push(new THREE.QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new THREE.AnimationClip('animation', -1, tracks);\n\t\t}\n\n\t\t/*\n  \treturns the next non-empty line in lines\n  */\n\t\tfunction nextLine(lines) {\n\n\t\t\tvar line;\n\t\t\t// skip empty lines\n\t\t\twhile ((line = lines.shift().trim()).length === 0) {}\n\t\t\treturn line;\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar lines = text.split(/[\\r\\n]+/g);\n\n\t\tvar bones = readBvh(lines);\n\n\t\tvar threeBones = [];\n\t\ttoTHREEBone(bones[0], threeBones);\n\n\t\tvar threeClip = toTHREEAnimation(bones);\n\n\t\treturn {\n\t\t\tskeleton: new THREE.Skeleton(threeBones),\n\t\t\tclip: threeClip\n\t\t};\n\t}\n\n};\n\nexports.default = BVHLoader;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar ColladaLoader = function ColladaLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nColladaLoader.prototype = {\n\n\tconstructor: ColladaLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text, path));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetPath: function setPath(value) {\n\n\t\tthis.path = value;\n\t},\n\n\toptions: {\n\n\t\tset convertUpAxis(value) {\n\n\t\t\tconsole.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n\t\t}\n\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(text, path) {\n\n\t\tfunction getElementsByTagName(xml, name) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tvar array = [];\n\t\t\tvar childNodes = xml.childNodes;\n\n\t\t\tfor (var i = 0, l = childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = childNodes[i];\n\n\t\t\t\tif (child.nodeName === name) {\n\n\t\t\t\t\tarray.push(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseStrings(text) {\n\n\t\t\tif (text.length === 0) return [];\n\n\t\t\tvar parts = text.trim().split(/\\s+/);\n\t\t\tvar array = new Array(parts.length);\n\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++) {\n\n\t\t\t\tarray[i] = parts[i];\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseFloats(text) {\n\n\t\t\tif (text.length === 0) return [];\n\n\t\t\tvar parts = text.trim().split(/\\s+/);\n\t\t\tvar array = new Array(parts.length);\n\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++) {\n\n\t\t\t\tarray[i] = parseFloat(parts[i]);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseInts(text) {\n\n\t\t\tif (text.length === 0) return [];\n\n\t\t\tvar parts = text.trim().split(/\\s+/);\n\t\t\tvar array = new Array(parts.length);\n\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++) {\n\n\t\t\t\tarray[i] = parseInt(parts[i]);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseId(text) {\n\n\t\t\treturn text.substring(1);\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + count++;\n\t\t}\n\n\t\tfunction isEmpty(object) {\n\n\t\t\treturn Object.keys(object).length === 0;\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset(xml) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n\t\t\t\tupAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n\t\t\t};\n\t\t}\n\n\t\tfunction parseAssetUnit(xml) {\n\n\t\t\tif (xml !== undefined && xml.hasAttribute('meter') === true) {\n\n\t\t\t\treturn parseFloat(xml.getAttribute('meter'));\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\t\t\t}\n\t\t}\n\n\t\tfunction parseAssetUpAxis(xml) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary(xml, libraryName, nodeName, parser) {\n\n\t\t\tvar library = getElementsByTagName(xml, libraryName)[0];\n\n\t\t\tif (library !== undefined) {\n\n\t\t\t\tvar elements = getElementsByTagName(library, nodeName);\n\n\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\t\tparser(elements[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction buildLibrary(data, builder) {\n\n\t\t\tfor (var name in data) {\n\n\t\t\t\tvar object = data[name];\n\t\t\t\tobject.build = builder(data[name]);\n\t\t\t}\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild(data, builder) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\tdata.build = builder(data);\n\n\t\t\treturn data.build;\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tvar id;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute('id');\n\t\t\t\t\t\tdata.sources[id] = parseSource(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute('id');\n\t\t\t\t\t\tdata.samplers[id] = parseAnimationSampler(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute('target');\n\t\t\t\t\t\tdata.channels[id] = parseAnimationChannel(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.animations[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseAnimationSampler(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tdata.inputs[semantic] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseAnimationChannel(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tvar target = xml.getAttribute('target');\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tvar parts = target.split('/');\n\n\t\t\tvar id = parts.shift();\n\t\t\tvar sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tvar arraySyntax = sid.indexOf('(') !== -1;\n\t\t\tvar memberSyntax = sid.indexOf('.') !== -1;\n\n\t\t\tif (memberSyntax) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split('.');\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\t\t\t} else if (arraySyntax) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tvar indices = sid.split('(');\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor (var i = 0; i < indices.length; i++) {\n\n\t\t\t\t\tindices[i] = parseInt(indices[i].replace(/\\)/, ''));\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId(xml.getAttribute('source'));\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildAnimation(data) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar channels = data.channels;\n\t\t\tvar samplers = data.samplers;\n\t\t\tvar sources = data.sources;\n\n\t\t\tfor (var target in channels) {\n\n\t\t\t\tif (channels.hasOwnProperty(target)) {\n\n\t\t\t\t\tvar channel = channels[target];\n\t\t\t\t\tvar sampler = samplers[channel.sampler];\n\n\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\n\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tvar inputSource = sources[inputId];\n\t\t\t\t\tvar outputSource = sources[outputId];\n\n\t\t\t\t\tvar animation = buildAnimationChannel(channel, inputSource, outputSource);\n\n\t\t\t\t\tcreateKeyframeTracks(animation, tracks);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tracks;\n\t\t}\n\n\t\tfunction getAnimation(id) {\n\n\t\t\treturn getBuild(library.animations[id], buildAnimation);\n\t\t}\n\n\t\tfunction buildAnimationChannel(channel, inputSource, outputSource) {\n\n\t\t\tvar node = library.nodes[channel.id];\n\t\t\tvar object3D = getNode(node.id);\n\n\t\t\tvar transform = node.transforms[channel.sid];\n\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tvar time, stride;\n\t\t\tvar i, il, j, jl;\n\n\t\t\tvar data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch (transform) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor (i = 0, il = inputSource.array.length; i < il; i++) {\n\n\t\t\t\t\t\ttime = inputSource.array[i];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif (data[time] === undefined) data[time] = {};\n\n\t\t\t\t\t\tif (channel.arraySyntax === true) {\n\n\t\t\t\t\t\t\tvar value = outputSource.array[stride];\n\t\t\t\t\t\t\tvar index = channel.indices[0] + 4 * channel.indices[1];\n\n\t\t\t\t\t\t\tdata[time][index] = value;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor (j = 0, jl = outputSource.stride; j < jl; j++) {\n\n\t\t\t\t\t\t\t\tdata[time][j] = outputSource.array[stride + j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar keyframes = prepareAnimationData(data, defaultMatrix);\n\n\t\t\tvar animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\t\t}\n\n\t\tfunction prepareAnimationData(data, defaultMatrix) {\n\n\t\t\tvar keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor (var time in data) {\n\n\t\t\t\tkeyframes.push({ time: parseFloat(time), value: data[time] });\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort(ascending);\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor (var i = 0; i < 16; i++) {\n\n\t\t\t\ttransformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending(a, b) {\n\n\t\t\t\treturn a.time - b.time;\n\t\t\t}\n\t\t}\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\tfunction createKeyframeTracks(animation, tracks) {\n\n\t\t\tvar keyframes = animation.keyframes;\n\t\t\tvar name = animation.name;\n\n\t\t\tvar times = [];\n\t\t\tvar positionData = [];\n\t\t\tvar quaternionData = [];\n\t\t\tvar scaleData = [];\n\n\t\t\tfor (var i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tvar time = keyframe.time;\n\t\t\t\tvar value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray(value).transpose();\n\t\t\t\tmatrix.decompose(position, quaternion, scale);\n\n\t\t\t\ttimes.push(time);\n\t\t\t\tpositionData.push(position.x, position.y, position.z);\n\t\t\t\tquaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n\t\t\t\tscaleData.push(scale.x, scale.y, scale.z);\n\t\t\t}\n\n\t\t\tif (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));\n\t\t\tif (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n\t\t\tif (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));\n\n\t\t\treturn tracks;\n\t\t}\n\n\t\tfunction transformAnimationData(keyframes, property, defaultValue) {\n\n\t\t\tvar keyframe;\n\n\t\t\tvar empty = true;\n\t\t\tvar i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor (i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\tkeyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] === undefined) {\n\n\t\t\t\t\tkeyframe.value[property] = null; // mark as missing\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (empty === true) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor (i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\t\tkeyframe = keyframes[i];\n\n\t\t\t\t\tkeyframe.value[property] = defaultValue;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes(keyframes, property);\n\t\t\t}\n\t\t}\n\n\t\tfunction createMissingKeyframes(keyframes, property) {\n\n\t\t\tvar prev, next;\n\n\t\t\tfor (var i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] === null) {\n\n\t\t\t\t\tprev = getPrev(keyframes, i, property);\n\t\t\t\t\tnext = getNext(keyframes, i, property);\n\n\t\t\t\t\tif (prev === null) {\n\n\t\t\t\t\t\tkeyframe.value[property] = next.value[property];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (next === null) {\n\n\t\t\t\t\t\tkeyframe.value[property] = prev.value[property];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate(keyframe, prev, next, property);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getPrev(keyframes, i, property) {\n\n\t\t\twhile (i >= 0) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] !== null) return keyframe;\n\n\t\t\t\ti--;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction getNext(keyframes, i, property) {\n\n\t\t\twhile (i < keyframes.length) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] !== null) return keyframe;\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction interpolate(key, prev, next, property) {\n\n\t\t\tif (next.time - prev.time === 0) {\n\n\t\t\t\tkey.value[property] = prev.value[property];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkey.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('id') || 'default',\n\t\t\t\tstart: parseFloat(xml.getAttribute('start') || 0),\n\t\t\t\tend: parseFloat(xml.getAttribute('end') || 0),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.clips[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildAnimationClip(data) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar name = data.name;\n\t\t\tvar duration = data.end - data.start || -1;\n\t\t\tvar animations = data.animations;\n\n\t\t\tfor (var i = 0, il = animations.length; i < il; i++) {\n\n\t\t\t\tvar animationTracks = getAnimation(animations[i]);\n\n\t\t\t\tfor (var j = 0, jl = animationTracks.length; j < jl; j++) {\n\n\t\t\t\t\ttracks.push(animationTracks[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new THREE.AnimationClip(name, duration, tracks);\n\t\t}\n\n\t\tfunction getAnimationClip(id) {\n\n\t\t\treturn getBuild(library.clips[id], buildAnimationClip);\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tdata.skin = parseSkin(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.controllers[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseSkin(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tvar id = child.getAttribute('id');\n\t\t\t\t\t\tdata.sources[id] = parseSource(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseJoints(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tdata.inputs[semantic] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseVertexWeights(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tvar offset = parseInt(child.getAttribute('offset'));\n\t\t\t\t\t\tdata.inputs[semantic] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildController(data) {\n\n\t\t\tvar build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tvar geometry = library.geometries[build.id];\n\n\t\t\tif (data.skin !== undefined) {\n\n\t\t\t\tbuild.skin = buildSkin(data.skin);\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\t\t\t}\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction buildSkin(data) {\n\n\t\t\tvar BONE_LIMIT = 4;\n\n\t\t\tvar build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertexWeights = data.vertexWeights;\n\n\t\t\tvar vcount = vertexWeights.vcount;\n\t\t\tvar v = vertexWeights.v;\n\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tvar jointSource = data.sources[data.joints.inputs.JOINT];\n\t\t\tvar inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n\n\t\t\tvar weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n\t\t\tvar stride = 0;\n\n\t\t\tvar i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor (i = 0, l = vcount.length; i < l; i++) {\n\n\t\t\t\tvar jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\t\t\t\tvar vertexSkinData = [];\n\n\t\t\t\tfor (j = 0; j < jointCount; j++) {\n\n\t\t\t\t\tvar skinIndex = v[stride + jointOffset];\n\t\t\t\t\tvar weightId = v[stride + weightOffset];\n\t\t\t\t\tvar skinWeight = weights[weightId];\n\n\t\t\t\t\tvertexSkinData.push({ index: skinIndex, weight: skinWeight });\n\n\t\t\t\t\tstride += 2;\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort(descending);\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor (j = 0; j < BONE_LIMIT; j++) {\n\n\t\t\t\t\tvar d = vertexSkinData[j];\n\n\t\t\t\t\tif (d !== undefined) {\n\n\t\t\t\t\t\tbuild.indices.array.push(d.index);\n\t\t\t\t\t\tbuild.weights.array.push(d.weight);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push(0);\n\t\t\t\t\t\tbuild.weights.array.push(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tbuild.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor (i = 0, l = jointSource.array.length; i < l; i++) {\n\n\t\t\t\tvar name = jointSource.array[i];\n\t\t\t\tvar boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n\n\t\t\t\tbuild.joints.push({ name: name, boneInverse: boneInverse });\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending(a, b) {\n\n\t\t\t\treturn b.weight - a.weight;\n\t\t\t}\n\t\t}\n\n\t\tfunction getController(id) {\n\n\t\t\treturn getBuild(library.controllers[id], buildController);\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinit_from: getElementsByTagName(xml, 'init_from')[0].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildImage(data) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\treturn data.init_from;\n\t\t}\n\n\t\tfunction getImage(id) {\n\n\t\t\tvar data = library.images[id];\n\n\t\t\tif (data !== undefined) {\n\n\t\t\t\treturn getBuild(data, buildImage);\n\t\t\t}\n\n\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.effects[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectNewparam(xml, data) {\n\n\t\t\tvar sid = xml.getAttribute('sid');\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[sid] = parseEffectSurface(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[sid] = parseEffectSampler(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEffectSurface(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectSampler(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameters(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[child.nodeName] = parseEffectParameter(child);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[child.nodeName] = {\n\t\t\t\t\t\t\topaque: child.getAttribute('opaque'),\n\t\t\t\t\t\t\tdata: parseEffectParameter(child)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameter(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloats(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[child.nodeName] = { id: child.getAttribute('texture'), extra: parseEffectParameterTexture(child) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameterTexture(xml) {\n\n\t\t\tvar data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra(xml, data) {\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique(xml, data) {\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[child.nodeName] = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif (child.textContent.toUpperCase() === 'TRUE') {\n\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = 1;\n\t\t\t\t\t\t} else if (child.textContent.toUpperCase() === 'FALSE') {\n\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = 0;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = parseInt(child.textContent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEffectExtra(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[child.nodeName] = parseInt(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildEffect(data) {\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction getEffect(id) {\n\n\t\t\treturn getBuild(library.effects[id], buildEffect);\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name')\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId(child.getAttribute('url'));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.materials[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildMaterial(data) {\n\n\t\t\tvar effect = getEffect(data.url);\n\t\t\tvar technique = effect.profile.technique;\n\t\t\tvar extra = effect.profile.extra;\n\n\t\t\tvar material;\n\n\t\t\tswitch (technique.type) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name;\n\n\t\t\tfunction getTexture(textureObject) {\n\n\t\t\t\tvar sampler = effect.profile.samplers[textureObject.id];\n\t\t\t\tvar image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif (sampler !== undefined) {\n\n\t\t\t\t\tvar surface = effect.profile.surfaces[sampler.source];\n\t\t\t\t\timage = getImage(surface.init_from);\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n\t\t\t\t\timage = getImage(textureObject.id);\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif (image !== null) {\n\n\t\t\t\t\tvar texture = textureLoader.load(image);\n\n\t\t\t\t\tvar extra = textureObject.extra;\n\n\t\t\t\t\tif (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n\n\t\t\t\t\t\tvar technique = extra.technique;\n\n\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\t\t\ttexture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n\t\t\t\t\t\ttexture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn texture;\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parameters = technique.parameters;\n\n\t\t\tfor (var key in parameters) {\n\n\t\t\t\tvar parameter = parameters[key];\n\n\t\t\t\tswitch (key) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif (parameter.color) material.color.fromArray(parameter.color);\n\t\t\t\t\t\tif (parameter.texture) material.map = getTexture(parameter.texture);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n\t\t\t\t\t\tif (parameter.texture) material.specularMap = getTexture(parameter.texture);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif (parameter.float && material.shininess) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n\t\t\t\t\t\tif (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar transparent = parameters['transparent'];\n\t\t\tvar transparency = parameters['transparency'];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif (transparency === undefined && transparent) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif (transparent === undefined && transparency) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [1, 1, 1, 1]\n\t\t\t\t\t} };\n\t\t\t}\n\n\t\t\tif (transparent && transparency) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif (transparent.data.texture) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = transparent.data.color;\n\n\t\t\t\t\tswitch (transparent.opaque) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[3] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - color[0] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - color[3] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[0] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.opacity < 1) material.transparent = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n\n\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getMaterial(id) {\n\n\t\t\treturn getBuild(library.materials[id], buildMaterial);\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name')\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.cameras[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseCameraOptics(xml) {\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {};\n\t\t}\n\n\t\tfunction parseCameraTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters(child);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseCameraParameters(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildCamera(data) {\n\n\t\t\tvar camera;\n\n\t\t\tswitch (data.optics.technique) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = xmag === undefined ? ymag * aspectRatio : xmag;\n\t\t\t\t\tymag = ymag === undefined ? xmag / aspectRatio : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n\t\t\t\t\tdata.optics.parameters.znear, data.optics.parameters.zfar);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new THREE.PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name;\n\n\t\t\treturn camera;\n\t\t}\n\n\t\tfunction getCamera(id) {\n\n\t\t\tvar data = library.cameras[id];\n\n\t\t\tif (data !== undefined) {\n\n\t\t\t\treturn getBuild(data, buildCamera);\n\t\t\t}\n\n\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.lights[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseLightTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseLightParameters(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.color = new THREE.Color().fromArray(array);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tvar f = parseFloat(child.textContent);\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt(1 / f) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildLight(data) {\n\n\t\t\tvar light;\n\n\t\t\tswitch (data.technique) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new THREE.DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new THREE.SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new THREE.AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (data.parameters.color) light.color.copy(data.parameters.color);\n\t\t\tif (data.parameters.distance) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\t\t}\n\n\t\tfunction getLight(id) {\n\n\t\t\tvar data = library.lights[id];\n\n\t\t\tif (data !== undefined) {\n\n\t\t\t\treturn getBuild(data, buildLight);\n\t\t\t}\n\n\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name'),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tvar mesh = getElementsByTagName(xml, 'mesh')[0];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif (mesh === undefined) return;\n\n\t\t\tfor (var i = 0; i < mesh.childNodes.length; i++) {\n\n\t\t\t\tvar child = mesh.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tvar id = child.getAttribute('id');\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[id] = parseSource(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push(parseGeometryPrimitive(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.geometries[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseSource(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tvar accessor = getElementsByTagName(child, 'accessor')[0];\n\n\t\t\t\t\t\tif (accessor !== undefined) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt(accessor.getAttribute('stride'));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseGeometryVertices(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tdata[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseGeometryPrimitive(xml) {\n\n\t\t\tvar primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute('material'),\n\t\t\t\tcount: parseInt(xml.getAttribute('count')),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tvar offset = parseInt(child.getAttribute('offset'));\n\t\t\t\t\t\tprimitive.inputs[semantic] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max(primitive.stride, offset + 1);\n\t\t\t\t\t\tif (semantic === 'TEXCOORD') primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn primitive;\n\t\t}\n\n\t\tfunction groupPrimitives(primitives) {\n\n\t\t\tvar build = {};\n\n\t\t\tfor (var i = 0; i < primitives.length; i++) {\n\n\t\t\t\tvar primitive = primitives[i];\n\n\t\t\t\tif (build[primitive.type] === undefined) build[primitive.type] = [];\n\n\t\t\t\tbuild[primitive.type].push(primitive);\n\t\t\t}\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction checkUVCoordinates(primitives) {\n\n\t\t\tvar count = 0;\n\n\t\t\tfor (var i = 0, l = primitives.length; i < l; i++) {\n\n\t\t\t\tvar primitive = primitives[i];\n\n\t\t\t\tif (primitive.hasUV === true) {\n\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (count > 0 && count < primitives.length) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction buildGeometry(data) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertices = data.vertices;\n\t\t\tvar primitives = data.primitives;\n\n\t\t\tif (primitives.length === 0) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tvar groupedPrimitives = groupPrimitives(primitives);\n\n\t\t\tfor (var type in groupedPrimitives) {\n\n\t\t\t\tvar primitiveType = groupedPrimitives[type];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates(primitiveType);\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[type] = buildGeometryType(primitiveType, sources, vertices);\n\t\t\t}\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction buildGeometryType(primitives, sources, vertices) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar position = { array: [], stride: 0 };\n\t\t\tvar normal = { array: [], stride: 0 };\n\t\t\tvar uv = { array: [], stride: 0 };\n\t\t\tvar color = { array: [], stride: 0 };\n\n\t\t\tvar skinIndex = { array: [], stride: 4 };\n\t\t\tvar skinWeight = { array: [], stride: 4 };\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar materialKeys = [];\n\n\t\t\tvar start = 0;\n\n\t\t\tfor (var p = 0; p < primitives.length; p++) {\n\n\t\t\t\tvar primitive = primitives[p];\n\t\t\t\tvar inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tvar count = 0;\n\n\t\t\t\tswitch (primitive.type) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor (var g = 0; g < primitive.count; g++) {\n\n\t\t\t\t\t\t\tvar vc = primitive.vcount[g];\n\n\t\t\t\t\t\t\tswitch (vc) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += (vc - 2) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup(start, count, p);\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif (primitive.material) {\n\n\t\t\t\t\tmaterialKeys.push(primitive.material);\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor (var name in inputs) {\n\n\t\t\t\t\tvar input = inputs[name];\n\n\t\t\t\t\tswitch (name) {\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor (var key in vertices) {\n\n\t\t\t\t\t\t\t\tvar id = vertices[key];\n\n\t\t\t\t\t\t\t\tswitch (key) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, position.array);\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[id].stride;\n\n\t\t\t\t\t\t\t\t\t\tif (sources.skinWeights && sources.skinIndices) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar count = (position.array.length - prevLength) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < count; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push(0, 0);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, normal.array);\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, color.array);\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, uv.array);\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n\t\t\t\t\t\t\tnormal.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, color.array);\n\t\t\t\t\t\t\tcolor.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n\t\t\t\t\t\t\tuv.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif (position.array.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));\n\t\t\tif (normal.array.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));\n\t\t\tif (color.array.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));\n\t\t\tif (uv.array.length > 0) geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));\n\n\t\t\tif (skinIndex.array.length > 0) geometry.addAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n\t\t\tif (skinWeight.array.length > 0) geometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[0].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction buildGeometryData(primitive, source, offset, array) {\n\n\t\t\tvar indices = primitive.p;\n\t\t\tvar stride = primitive.stride;\n\t\t\tvar vcount = primitive.vcount;\n\n\t\t\tfunction pushVector(i) {\n\n\t\t\t\tvar index = indices[i + offset] * sourceStride;\n\t\t\t\tvar length = index + sourceStride;\n\n\t\t\t\tfor (; index < length; index++) {\n\n\t\t\t\t\tarray.push(sourceArray[index]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar sourceArray = source.array;\n\t\t\tvar sourceStride = source.stride;\n\n\t\t\tif (primitive.vcount !== undefined) {\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor (var i = 0, l = vcount.length; i < l; i++) {\n\n\t\t\t\t\tvar count = vcount[i];\n\n\t\t\t\t\tif (count === 4) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\tvar d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector(a);pushVector(b);pushVector(d);\n\t\t\t\t\t\tpushVector(b);pushVector(c);pushVector(d);\n\t\t\t\t\t} else if (count === 3) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector(a);pushVector(b);pushVector(c);\n\t\t\t\t\t} else if (count > 4) {\n\n\t\t\t\t\t\tfor (var k = 1, kl = count - 2; k <= kl; k++) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * k;\n\t\t\t\t\t\t\tvar c = index + stride * (k + 1);\n\n\t\t\t\t\t\t\tpushVector(a);pushVector(b);pushVector(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (var i = 0, l = indices.length; i < l; i += stride) {\n\n\t\t\t\t\tpushVector(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getGeometry(id) {\n\n\t\t\treturn getBuild(library.geometries[id], buildGeometry);\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildKinematicsModel(data) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction getKinematicsModel(id) {\n\n\t\t\treturn getBuild(library.kinematicsModels[id], buildKinematicsModel);\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon(xml, data) {\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push(parseKinematicsLink(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseKinematicsJoint(xml) {\n\n\t\t\tvar data;\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter(xml, data) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute('sid'),\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\taxis: new THREE.Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.axis.fromArray(array);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tvar max = child.getElementsByTagName('max')[0];\n\t\t\t\t\t\tvar min = child.getElementsByTagName('min')[0];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat(max.textContent);\n\t\t\t\t\t\tdata.limits.min = parseFloat(min.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif (data.limits.min >= data.limits.max) {\n\n\t\t\t\tdata.static = true;\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsLink(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute('sid'),\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push(parseKinematicsAttachment(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push(parseKinematicsTransform(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsAttachment(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tjoint: xml.getAttribute('joint').split('/').pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push(parseKinematicsLink(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push(parseKinematicsTransform(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsTransform(xml) {\n\n\t\t\tvar data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tvar array = parseFloats(xml.textContent);\n\n\t\t\tswitch (data.type) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new THREE.Matrix4();\n\t\t\t\t\tdata.obj.fromArray(array).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\tdata.obj.fromArray(array);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\tdata.obj.fromArray(array);\n\t\t\t\t\tdata.angle = THREE.Math.degToRad(array[3]);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsScene(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis(xml) {\n\n\t\t\tvar data = {\n\t\t\t\ttarget: xml.getAttribute('target').split('/').pop()\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar param = child.getElementsByTagName('param')[0];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tvar tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildKinematicsScene(data) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction getKinematicsScene(id) {\n\n\t\t\treturn getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tvar kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n\t\t\tvar kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n\t\t\tvar visualSceneId = Object.keys(library.visualScenes)[0];\n\n\t\t\tif (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n\n\t\t\tvar kinematicsModel = getKinematicsModel(kinematicsModelId);\n\t\t\tvar kinematicsScene = getKinematicsScene(kinematicsSceneId);\n\t\t\tvar visualScene = getVisualScene(visualSceneId);\n\n\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tvar jointMap = {};\n\n\t\t\tfor (var i = 0, l = bindJointAxis.length; i < l; i++) {\n\n\t\t\t\tvar axis = bindJointAxis[i];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tvar targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n\t\t\t\tif (targetElement) {\n\n\t\t\t\t\t// get the parent of the transfrom element\n\n\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect(axis.jointIndex, parentVisualElement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction connect(jointIndex, visualElement) {\n\n\t\t\t\tvar visualElementName = visualElement.getAttribute('name');\n\t\t\t\tvar joint = kinematicsModel.joints[jointIndex];\n\n\t\t\t\tvisualScene.traverse(function (object) {\n\n\t\t\t\t\tif (object.name === visualElementName) {\n\n\t\t\t\t\t\tjointMap[jointIndex] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList(visualElement),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar m0 = new THREE.Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function getJointValue(jointIndex) {\n\n\t\t\t\t\tvar jointData = jointMap[jointIndex];\n\n\t\t\t\t\tif (jointData) {\n\n\t\t\t\t\t\treturn jointData.position;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function setJointValue(jointIndex, value) {\n\n\t\t\t\t\tvar jointData = jointMap[jointIndex];\n\n\t\t\t\t\tif (jointData) {\n\n\t\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\t\tif (value > joint.limits.max || value < joint.limits.min) {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n\t\t\t\t\t\t} else if (joint.static) {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar object = jointData.object;\n\t\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor (var i = 0; i < transforms.length; i++) {\n\n\t\t\t\t\t\t\t\tvar transform = transforms[i];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n\n\t\t\t\t\t\t\t\t\tswitch (joint.type) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeRotationAxis(axis, THREE.Math.degToRad(value)));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch (transform.type) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(transform.obj);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale(transform.obj);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy(matrix);\n\t\t\t\t\t\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\n\n\t\t\t\t\t\t\tjointMap[jointIndex].position = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tfunction buildTransformList(node) {\n\n\t\t\tvar transforms = [];\n\n\t\t\tvar xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar matrix = new THREE.Matrix4().fromArray(array).transpose();\n\t\t\t\t\t\ttransforms.push({\n\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray(array);\n\t\t\t\t\t\ttransforms.push({\n\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray(array);\n\t\t\t\t\t\tvar angle = THREE.Math.degToRad(array[3]);\n\t\t\t\t\t\ttransforms.push({\n\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn transforms;\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes(xml) {\n\n\t\t\tvar elements = xml.getElementsByTagName('node');\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\tvar element = elements[i];\n\n\t\t\t\tif (element.hasAttribute('id') === false) {\n\n\t\t\t\t\telement.setAttribute('id', generateId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tvar vector = new THREE.Vector3();\n\n\t\tfunction parseNode(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\ttype: xml.getAttribute('type'),\n\t\t\t\tid: xml.getAttribute('id'),\n\t\t\t\tsid: xml.getAttribute('sid'),\n\t\t\t\tmatrix: new THREE.Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push(child.getAttribute('id'));\n\t\t\t\t\t\tparseNode(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push(parseNodeInstance(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push(parseNodeInstance(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.matrix.multiply(matrix.fromArray(array).transpose());\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvector.fromArray(array);\n\t\t\t\t\t\tdata.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar angle = THREE.Math.degToRad(array[3]);\n\t\t\t\t\t\tdata.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.matrix.scale(vector.fromArray(array));\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.nodes[data.id] = data;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseNodeInstance(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tid: parseId(xml.getAttribute('url')),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tvar instances = child.getElementsByTagName('instance_material');\n\n\t\t\t\t\t\tfor (var j = 0; j < instances.length; j++) {\n\n\t\t\t\t\t\t\tvar instance = instances[j];\n\t\t\t\t\t\t\tvar symbol = instance.getAttribute('symbol');\n\t\t\t\t\t\t\tvar target = instance.getAttribute('target');\n\n\t\t\t\t\t\t\tdata.materials[symbol] = parseId(target);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push(parseId(child.textContent));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildSkeleton(skeletons, joints) {\n\n\t\t\tvar boneData = [];\n\t\t\tvar sortedBoneData = [];\n\n\t\t\tvar i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor (i = 0; i < skeletons.length; i++) {\n\n\t\t\t\tvar skeleton = skeletons[i];\n\n\t\t\t\tvar root;\n\n\t\t\t\tif (hasNode(skeleton)) {\n\n\t\t\t\t\troot = getNode(skeleton);\n\t\t\t\t\tbuildBoneHierarchy(root, joints, boneData);\n\t\t\t\t} else if (hasVisualScene(skeleton)) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tvar visualScene = library.visualScenes[skeleton];\n\t\t\t\t\tvar children = visualScene.children;\n\n\t\t\t\t\tfor (var j = 0; j < children.length; j++) {\n\n\t\t\t\t\t\tvar child = children[j];\n\n\t\t\t\t\t\tif (child.type === 'JOINT') {\n\n\t\t\t\t\t\t\tvar root = getNode(child.id);\n\t\t\t\t\t\t\tbuildBoneHierarchy(root, joints, boneData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor (i = 0; i < joints.length; i++) {\n\n\t\t\t\tfor (j = 0; j < boneData.length; j++) {\n\n\t\t\t\t\tdata = boneData[j];\n\n\t\t\t\t\tif (data.bone.name === joints[i].name) {\n\n\t\t\t\t\t\tsortedBoneData[i] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor (i = 0; i < boneData.length; i++) {\n\n\t\t\t\tdata = boneData[i];\n\n\t\t\t\tif (data.processed === false) {\n\n\t\t\t\t\tsortedBoneData.push(data);\n\t\t\t\t\tdata.processed = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tvar bones = [];\n\t\t\tvar boneInverses = [];\n\n\t\t\tfor (i = 0; i < sortedBoneData.length; i++) {\n\n\t\t\t\tdata = sortedBoneData[i];\n\n\t\t\t\tbones.push(data.bone);\n\t\t\t\tboneInverses.push(data.boneInverse);\n\t\t\t}\n\n\t\t\treturn new THREE.Skeleton(bones, boneInverses);\n\t\t}\n\n\t\tfunction buildBoneHierarchy(root, joints, boneData) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse(function (object) {\n\n\t\t\t\tif (object.isBone === true) {\n\n\t\t\t\t\tvar boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor (var i = 0; i < joints.length; i++) {\n\n\t\t\t\t\t\tvar joint = joints[i];\n\n\t\t\t\t\t\tif (joint.name === object.name) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (boneInverse === undefined) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new THREE.Matrix4();\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push({ bone: object, boneInverse: boneInverse, processed: false });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction buildNode(data) {\n\n\t\t\tvar objects = [];\n\n\t\t\tvar matrix = data.matrix;\n\t\t\tvar nodes = data.nodes;\n\t\t\tvar type = data.type;\n\t\t\tvar instanceCameras = data.instanceCameras;\n\t\t\tvar instanceControllers = data.instanceControllers;\n\t\t\tvar instanceLights = data.instanceLights;\n\t\t\tvar instanceGeometries = data.instanceGeometries;\n\t\t\tvar instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\n\t\t\t\tobjects.push(getNode(nodes[i]));\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor (var i = 0, l = instanceCameras.length; i < l; i++) {\n\n\t\t\t\tvar instanceCamera = getCamera(instanceCameras[i]);\n\n\t\t\t\tif (instanceCamera !== null) {\n\n\t\t\t\t\tobjects.push(instanceCamera.clone());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor (var i = 0, l = instanceControllers.length; i < l; i++) {\n\n\t\t\t\tvar instance = instanceControllers[i];\n\t\t\t\tvar controller = getController(instance.id);\n\t\t\t\tvar geometries = getGeometry(controller.id);\n\t\t\t\tvar newObjects = buildObjects(geometries, instance.materials);\n\n\t\t\t\tvar skeletons = instance.skeletons;\n\t\t\t\tvar joints = controller.skin.joints;\n\n\t\t\t\tvar skeleton = buildSkeleton(skeletons, joints);\n\n\t\t\t\tfor (var j = 0, jl = newObjects.length; j < jl; j++) {\n\n\t\t\t\t\tvar object = newObjects[j];\n\n\t\t\t\t\tif (object.isSkinnedMesh) {\n\n\t\t\t\t\t\tobject.bind(skeleton, controller.skin.bindMatrix);\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push(object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor (var i = 0, l = instanceLights.length; i < l; i++) {\n\n\t\t\t\tvar instanceLight = getLight(instanceLights[i]);\n\n\t\t\t\tif (instanceLight !== null) {\n\n\t\t\t\t\tobjects.push(instanceLight.clone());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor (var i = 0, l = instanceGeometries.length; i < l; i++) {\n\n\t\t\t\tvar instance = instanceGeometries[i];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tvar geometries = getGeometry(instance.id);\n\t\t\t\tvar newObjects = buildObjects(geometries, instance.materials);\n\n\t\t\t\tfor (var j = 0, jl = newObjects.length; j < jl; j++) {\n\n\t\t\t\t\tobjects.push(newObjects[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor (var i = 0, l = instanceNodes.length; i < l; i++) {\n\n\t\t\t\tobjects.push(getNode(instanceNodes[i]).clone());\n\t\t\t}\n\n\t\t\tvar object;\n\n\t\t\tif (nodes.length === 0 && objects.length === 1) {\n\n\t\t\t\tobject = objects[0];\n\t\t\t} else {\n\n\t\t\t\tobject = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();\n\n\t\t\t\tfor (var i = 0; i < objects.length; i++) {\n\n\t\t\t\t\tobject.add(objects[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (object.name === '') {\n\n\t\t\t\tobject.name = type === 'JOINT' ? data.sid : data.name;\n\t\t\t}\n\n\t\t\tobject.matrix.copy(matrix);\n\t\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\n\n\t\t\treturn object;\n\t\t}\n\n\t\tfunction resolveMaterialBinding(keys, instanceMaterials) {\n\n\t\t\tvar materials = [];\n\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\n\t\t\t\tvar id = instanceMaterials[keys[i]];\n\t\t\t\tmaterials.push(getMaterial(id));\n\t\t\t}\n\n\t\t\treturn materials;\n\t\t}\n\n\t\tfunction buildObjects(geometries, instanceMaterials) {\n\n\t\t\tvar objects = [];\n\n\t\t\tfor (var type in geometries) {\n\n\t\t\t\tvar geometry = geometries[type];\n\n\t\t\t\tvar materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif (materials.length === 0) {\n\n\t\t\t\t\tif (type === 'lines' || type === 'linestrips') {\n\n\t\t\t\t\t\tmaterials.push(new THREE.LineBasicMaterial());\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push(new THREE.MeshPhongMaterial());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tvar skinning = geometry.data.attributes.skinIndex !== undefined;\n\n\t\t\t\tif (skinning) {\n\n\t\t\t\t\tfor (var i = 0, l = materials.length; i < l; i++) {\n\n\t\t\t\t\t\tmaterials[i].skinning = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tvar material = materials.length === 1 ? materials[0] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tswitch (type) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new THREE.LineSegments(geometry.data, material);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new THREE.Line(geometry.data, material);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif (skinning) {\n\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh(geometry.data, material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new THREE.Mesh(geometry.data, material);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push(object);\n\t\t\t}\n\n\t\t\treturn objects;\n\t\t}\n\n\t\tfunction hasNode(id) {\n\n\t\t\treturn library.nodes[id] !== undefined;\n\t\t}\n\n\t\tfunction getNode(id) {\n\n\t\t\treturn getBuild(library.nodes[id], buildNode);\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name'),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes(xml);\n\n\t\t\tvar elements = getElementsByTagName(xml, 'node');\n\n\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\tdata.children.push(parseNode(elements[i]));\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildVisualScene(data) {\n\n\t\t\tvar group = new THREE.Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tvar children = data.children;\n\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\n\t\t\t\tvar child = children[i];\n\n\t\t\t\tgroup.add(getNode(child.id));\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\n\t\tfunction hasVisualScene(id) {\n\n\t\t\treturn library.visualScenes[id] !== undefined;\n\t\t}\n\n\t\tfunction getVisualScene(id) {\n\n\t\t\treturn getBuild(library.visualScenes[id], buildVisualScene);\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene(xml) {\n\n\t\t\tvar instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n\t\t\treturn getVisualScene(parseId(instance.getAttribute('url')));\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tvar clips = library.clips;\n\n\t\t\tif (isEmpty(clips) === true) {\n\n\t\t\t\tif (isEmpty(library.animations) === false) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\tfor (var id in library.animations) {\n\n\t\t\t\t\t\tvar animationTracks = getAnimation(id);\n\n\t\t\t\t\t\tfor (var i = 0, l = animationTracks.length; i < l; i++) {\n\n\t\t\t\t\t\t\ttracks.push(animationTracks[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push(new THREE.AnimationClip('default', -1, tracks));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (var id in clips) {\n\n\t\t\t\t\tanimations.push(getAnimationClip(id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (text.length === 0) {\n\n\t\t\treturn { scene: new THREE.Scene() };\n\t\t}\n\n\t\tvar xml = new DOMParser().parseFromString(text, 'application/xml');\n\n\t\tvar collada = getElementsByTagName(xml, 'COLLADA')[0];\n\n\t\t// metadata\n\n\t\tvar version = collada.getAttribute('version');\n\t\tconsole.log('THREE.ColladaLoader: File version', version);\n\n\t\tvar asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setPath(path).setCrossOrigin(this.crossOrigin);\n\n\t\t//\n\n\t\tvar animations = [];\n\t\tvar kinematics = {};\n\t\tvar count = 0;\n\n\t\t//\n\n\t\tvar library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n\t\tparseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n\t\tparseLibrary(collada, 'library_controllers', 'controller', parseController);\n\t\tparseLibrary(collada, 'library_images', 'image', parseImage);\n\t\tparseLibrary(collada, 'library_effects', 'effect', parseEffect);\n\t\tparseLibrary(collada, 'library_materials', 'material', parseMaterial);\n\t\tparseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n\t\tparseLibrary(collada, 'library_lights', 'light', parseLight);\n\t\tparseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n\t\tparseLibrary(collada, 'library_nodes', 'node', parseNode);\n\t\tparseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n\t\tparseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n\t\tparseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n\n\t\tbuildLibrary(library.animations, buildAnimation);\n\t\tbuildLibrary(library.clips, buildAnimationClip);\n\t\tbuildLibrary(library.controllers, buildController);\n\t\tbuildLibrary(library.images, buildImage);\n\t\tbuildLibrary(library.effects, buildEffect);\n\t\tbuildLibrary(library.materials, buildMaterial);\n\t\tbuildLibrary(library.cameras, buildCamera);\n\t\tbuildLibrary(library.lights, buildLight);\n\t\tbuildLibrary(library.geometries, buildGeometry);\n\t\tbuildLibrary(library.visualScenes, buildVisualScene);\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tvar scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n\n\t\tif (asset.upAxis === 'Z_UP') {\n\n\t\t\tscene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n\t\t}\n\n\t\tscene.scale.multiplyScalar(asset.unit);\n\n\t\treturn {\n\t\t\tanimations: animations,\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\t}\n\n};\n\nexports.default = ColladaLoader;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar DDSLoader = function DDSLoader() {\n\n\tthis._parser = DDSLoader.parse;\n};\n\nDDSLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);\nDDSLoader.prototype.constructor = DDSLoader;\n\nDDSLoader.parse = function (buffer, loadMipmaps) {\n\n\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t// Adapted from @toji's DDS utils\n\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t// All values and structures referenced from:\n\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\tvar DDS_MAGIC = 0x20534444;\n\n\tvar DDSD_CAPS = 0x1,\n\t    DDSD_HEIGHT = 0x2,\n\t    DDSD_WIDTH = 0x4,\n\t    DDSD_PITCH = 0x8,\n\t    DDSD_PIXELFORMAT = 0x1000,\n\t    DDSD_MIPMAPCOUNT = 0x20000,\n\t    DDSD_LINEARSIZE = 0x80000,\n\t    DDSD_DEPTH = 0x800000;\n\n\tvar DDSCAPS_COMPLEX = 0x8,\n\t    DDSCAPS_MIPMAP = 0x400000,\n\t    DDSCAPS_TEXTURE = 0x1000;\n\n\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t    DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t    DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t    DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t    DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t    DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t    DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t    DDSCAPS2_VOLUME = 0x200000;\n\n\tvar DDPF_ALPHAPIXELS = 0x1,\n\t    DDPF_ALPHA = 0x2,\n\t    DDPF_FOURCC = 0x4,\n\t    DDPF_RGB = 0x40,\n\t    DDPF_YUV = 0x200,\n\t    DDPF_LUMINANCE = 0x20000;\n\n\tfunction fourCCToInt32(value) {\n\n\t\treturn value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n\t}\n\n\tfunction int32ToFourCC(value) {\n\n\t\treturn String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n\t}\n\n\tfunction loadARGBMip(buffer, dataOffset, width, height) {\n\n\t\tvar dataLength = width * height * 4;\n\t\tvar srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n\t\tvar byteArray = new Uint8Array(dataLength);\n\t\tvar dst = 0;\n\t\tvar src = 0;\n\t\tfor (var y = 0; y < height; y++) {\n\n\t\t\tfor (var x = 0; x < width; x++) {\n\n\t\t\t\tvar b = srcBuffer[src];src++;\n\t\t\t\tvar g = srcBuffer[src];src++;\n\t\t\t\tvar r = srcBuffer[src];src++;\n\t\t\t\tvar a = srcBuffer[src];src++;\n\t\t\t\tbyteArray[dst] = r;dst++; //r\n\t\t\t\tbyteArray[dst] = g;dst++; //g\n\t\t\t\tbyteArray[dst] = b;dst++; //b\n\t\t\t\tbyteArray[dst] = a;dst++; //a\n\t\t\t}\n\t\t}\n\t\treturn byteArray;\n\t}\n\n\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n\tvar FOURCC_ETC1 = fourCCToInt32(\"ETC1\");\n\n\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t// Offsets into the header array\n\n\tvar off_magic = 0;\n\n\tvar off_size = 1;\n\tvar off_flags = 2;\n\tvar off_height = 3;\n\tvar off_width = 4;\n\n\tvar off_mipmapCount = 7;\n\n\tvar off_pfFlags = 20;\n\tvar off_pfFourCC = 21;\n\tvar off_RGBBitCount = 22;\n\tvar off_RBitMask = 23;\n\tvar off_GBitMask = 24;\n\tvar off_BBitMask = 25;\n\tvar off_ABitMask = 26;\n\n\tvar off_caps = 27;\n\tvar off_caps2 = 28;\n\tvar off_caps3 = 29;\n\tvar off_caps4 = 30;\n\n\t// Parse header\n\n\tvar header = new Int32Array(buffer, 0, headerLengthInt);\n\n\tif (header[off_magic] !== DDS_MAGIC) {\n\n\t\tconsole.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');\n\t\treturn dds;\n\t}\n\n\tif (!header[off_pfFlags] & DDPF_FOURCC) {\n\n\t\tconsole.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');\n\t\treturn dds;\n\t}\n\n\tvar blockBytes;\n\n\tvar fourCC = header[off_pfFourCC];\n\n\tvar isRGBAUncompressed = false;\n\n\tswitch (fourCC) {\n\n\t\tcase FOURCC_DXT1:\n\n\t\t\tblockBytes = 8;\n\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\tbreak;\n\n\t\tcase FOURCC_DXT3:\n\n\t\t\tblockBytes = 16;\n\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\tbreak;\n\n\t\tcase FOURCC_DXT5:\n\n\t\t\tblockBytes = 16;\n\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\tbreak;\n\n\t\tcase FOURCC_ETC1:\n\n\t\t\tblockBytes = 8;\n\t\t\tdds.format = THREE.RGB_ETC1_Format;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tif (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {\n\n\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\tblockBytes = 64;\n\t\t\t\tdds.format = THREE.RGBAFormat;\n\t\t\t} else {\n\n\t\t\t\tconsole.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n\t\t\t\treturn dds;\n\t\t\t}\n\n\t}\n\n\tdds.mipmapCount = 1;\n\n\tif (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n\n\t\tdds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n\t}\n\n\tvar caps2 = header[off_caps2];\n\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\tif (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n\n\t\tconsole.error('THREE.DDSLoader.parse: Incomplete cubemap faces');\n\t\treturn dds;\n\t}\n\n\tdds.width = header[off_width];\n\tdds.height = header[off_height];\n\n\tvar dataOffset = header[off_size] + 4;\n\n\t// Extract mipmaps buffers\n\n\tvar faces = dds.isCubemap ? 6 : 1;\n\n\tfor (var face = 0; face < faces; face++) {\n\n\t\tvar width = dds.width;\n\t\tvar height = dds.height;\n\n\t\tfor (var i = 0; i < dds.mipmapCount; i++) {\n\n\t\t\tif (isRGBAUncompressed) {\n\n\t\t\t\tvar byteArray = loadARGBMip(buffer, dataOffset, width, height);\n\t\t\t\tvar dataLength = byteArray.length;\n\t\t\t} else {\n\n\t\t\t\tvar dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n\t\t\t\tvar byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n\t\t\t}\n\n\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\tdds.mipmaps.push(mipmap);\n\n\t\t\tdataOffset += dataLength;\n\n\t\t\twidth = Math.max(width >> 1, 1);\n\t\t\theight = Math.max(height >> 1, 1);\n\t\t}\n\t}\n\n\treturn dds;\n};\n\nexports.default = DDSLoader;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// Copyright 2016 The Draco Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n'use strict';\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nvar DRACOLoader = function DRACOLoader(manager) {\n  this.timeLoaded = 0;\n  this.manager = manager || THREE.DefaultLoadingManager;\n  this.materials = null;\n  this.verbosity = 0;\n  this.attributeOptions = {};\n  this.drawMode = THREE.TrianglesDrawMode;\n  // Native Draco attribute type to Three.JS attribute type.\n  this.nativeAttributeMap = {\n    'position': 'POSITION',\n    'normal': 'NORMAL',\n    'color': 'COLOR',\n    'uv': 'TEX_COORD'\n  };\n};\n\nDRACOLoader.prototype = {\n\n  constructor: DRACOLoader,\n\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new THREE.FileLoader(scope.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    if (this.crossOrigin !== undefined) {\n      loader.crossOrigin = this.crossOrigin;\n    }\n    loader.load(url, function (blob) {\n      scope.decodeDracoFile(blob, onLoad);\n    }, onProgress, onError);\n  },\n\n  setPath: function setPath(value) {\n    this.path = value;\n  },\n\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  },\n\n  setVerbosity: function setVerbosity(level) {\n    this.verbosity = level;\n  },\n\n  /**\n   *  Sets desired mode for generated geometry indices.\n   *  Can be either:\n   *      THREE.TrianglesDrawMode\n   *      THREE.TriangleStripDrawMode\n   */\n  setDrawMode: function setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n  },\n\n  /**\n   * Skips dequantization for a specific attribute.\n   * |attributeName| is the THREE.js name of the given attribute type.\n   * The only currently supported |attributeName| is 'position', more may be\n   * added in future.\n   */\n  setSkipDequantization: function setSkipDequantization(attributeName, skip) {\n    var skipDequantization = true;\n    if (typeof skip !== 'undefined') skipDequantization = skip;\n    this.getAttributeOptions(attributeName).skipDequantization = skipDequantization;\n  },\n\n  /**\n   * |attributeUniqueIdMap| specifies attribute unique id for an attribute in\n   * the geometry to be decoded. The name of the attribute must be one of the\n   * supported attribute type in Three.JS, including:\n   *     'position',\n   *     'color',\n   *     'normal',\n   *     'uv',\n   *     'uv2',\n   *     'skinIndex',\n   *     'skinWeight'.\n   * The format is:\n   *     attributeUniqueIdMap[attributeName] = attributeId\n   */\n  decodeDracoFile: function decodeDracoFile(rawBuffer, callback, attributeUniqueIdMap) {\n    var scope = this;\n    DRACOLoader.getDecoderModule().then(function (module) {\n      scope.decodeDracoFileInternal(rawBuffer, module.decoder, callback, attributeUniqueIdMap || {});\n    });\n  },\n\n  decodeDracoFileInternal: function decodeDracoFileInternal(rawBuffer, dracoDecoder, callback, attributeUniqueIdMap) {\n    /*\n     * Here is how to use Draco Javascript decoder and get the geometry.\n     */\n    var buffer = new dracoDecoder.DecoderBuffer();\n    buffer.Init(new Int8Array(rawBuffer), rawBuffer.byteLength);\n    var decoder = new dracoDecoder.Decoder();\n\n    /*\n     * Determine what type is this file: mesh or point cloud.\n     */\n    var geometryType = decoder.GetEncodedGeometryType(buffer);\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      if (this.verbosity > 0) {\n        console.log('Loaded a mesh.');\n      }\n    } else if (geometryType == dracoDecoder.POINT_CLOUD) {\n      if (this.verbosity > 0) {\n        console.log('Loaded a point cloud.');\n      }\n    } else {\n      var errorMsg = 'THREE.DRACOLoader: Unknown geometry type.';\n      console.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n    callback(this.convertDracoGeometryTo3JS(dracoDecoder, decoder, geometryType, buffer, attributeUniqueIdMap));\n  },\n\n  addAttributeToGeometry: function addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer) {\n    if (attribute.ptr === 0) {\n      var errorMsg = 'THREE.DRACOLoader: No attribute ' + attributeName;\n      console.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n    var numComponents = attribute.num_components();\n    var attributeData = new dracoDecoder.DracoFloat32Array();\n    decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    // Allocate space for attribute.\n    geometryBuffer[attributeName] = new Float32Array(numValues);\n    // Copy data from decoder.\n    for (var i = 0; i < numValues; i++) {\n      geometryBuffer[attributeName][i] = attributeData.GetValue(i);\n    }\n    // Add attribute to THREEJS geometry for rendering.\n    geometry.addAttribute(attributeName, new THREE.Float32BufferAttribute(geometryBuffer[attributeName], numComponents));\n    dracoDecoder.destroy(attributeData);\n  },\n\n  convertDracoGeometryTo3JS: function convertDracoGeometryTo3JS(dracoDecoder, decoder, geometryType, buffer, attributeUniqueIdMap) {\n    if (this.getAttributeOptions('position').skipDequantization === true) {\n      decoder.SkipAttributeTransform(dracoDecoder.POSITION);\n    }\n    var dracoGeometry;\n    var decodingStatus;\n    var start_time = performance.now();\n    if (geometryType === dracoDecoder.TRIANGULAR_MESH) {\n      dracoGeometry = new dracoDecoder.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n    } else {\n      dracoGeometry = new dracoDecoder.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {\n      var errorMsg = 'THREE.DRACOLoader: Decoding failed: ';\n      errorMsg += decodingStatus.error_msg();\n      console.error(errorMsg);\n      dracoDecoder.destroy(decoder);\n      dracoDecoder.destroy(dracoGeometry);\n      throw new Error(errorMsg);\n    }\n\n    var decode_end = performance.now();\n    dracoDecoder.destroy(buffer);\n    /*\n     * Example on how to retrieve mesh and attributes.\n     */\n    var numFaces;\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      numFaces = dracoGeometry.num_faces();\n      if (this.verbosity > 0) {\n        console.log('Number of faces loaded: ' + numFaces.toString());\n      }\n    } else {\n      numFaces = 0;\n    }\n\n    var numPoints = dracoGeometry.num_points();\n    var numAttributes = dracoGeometry.num_attributes();\n    if (this.verbosity > 0) {\n      console.log('Number of points loaded: ' + numPoints.toString());\n      console.log('Number of attributes loaded: ' + numAttributes.toString());\n    }\n\n    // Verify if there is position attribute.\n    var posAttId = decoder.GetAttributeId(dracoGeometry, dracoDecoder.POSITION);\n    if (posAttId == -1) {\n      var errorMsg = 'THREE.DRACOLoader: No position attribute found.';\n      console.error(errorMsg);\n      dracoDecoder.destroy(decoder);\n      dracoDecoder.destroy(dracoGeometry);\n      throw new Error(errorMsg);\n    }\n    var posAttribute = decoder.GetAttribute(dracoGeometry, posAttId);\n\n    // Structure for converting to THREEJS geometry later.\n    var geometryBuffer = {};\n    // Import data to Three JS geometry.\n    var geometry = new THREE.BufferGeometry();\n\n    // Add native Draco attribute type to geometry.\n    for (var attributeName in this.nativeAttributeMap) {\n      // The native attribute type is only used when no unique Id is\n      // provided. For example, loading .drc files.\n      if (attributeUniqueIdMap[attributeName] === undefined) {\n        var attId = decoder.GetAttributeId(dracoGeometry, dracoDecoder[this.nativeAttributeMap[attributeName]]);\n        if (attId !== -1) {\n          if (this.verbosity > 0) {\n            console.log('Loaded ' + attributeName + ' attribute.');\n          }\n          var attribute = decoder.GetAttribute(dracoGeometry, attId);\n          this.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer);\n        }\n      }\n    }\n\n    // Add attributes of user specified unique id. E.g. GLTF models.\n    for (var attributeName in attributeUniqueIdMap) {\n      var attributeId = attributeUniqueIdMap[attributeName];\n      var attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeId);\n      this.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer);\n    }\n\n    // For mesh, we need to generate the faces.\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      if (this.drawMode === THREE.TriangleStripDrawMode) {\n        var stripsArray = new dracoDecoder.DracoInt32Array();\n        var numStrips = decoder.GetTriangleStripsFromMesh(dracoGeometry, stripsArray);\n        geometryBuffer.indices = new Uint32Array(stripsArray.size());\n        for (var i = 0; i < stripsArray.size(); ++i) {\n          geometryBuffer.indices[i] = stripsArray.GetValue(i);\n        }\n        dracoDecoder.destroy(stripsArray);\n      } else {\n        var numIndices = numFaces * 3;\n        geometryBuffer.indices = new Uint32Array(numIndices);\n        var ia = new dracoDecoder.DracoInt32Array();\n        for (var i = 0; i < numFaces; ++i) {\n          decoder.GetFaceFromMesh(dracoGeometry, i, ia);\n          var index = i * 3;\n          geometryBuffer.indices[index] = ia.GetValue(0);\n          geometryBuffer.indices[index + 1] = ia.GetValue(1);\n          geometryBuffer.indices[index + 2] = ia.GetValue(2);\n        }\n        dracoDecoder.destroy(ia);\n      }\n    }\n\n    geometry.drawMode = this.drawMode;\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      geometry.setIndex(new (geometryBuffer.indices.length > 65535 ? THREE.Uint32BufferAttribute : THREE.Uint16BufferAttribute)(geometryBuffer.indices, 1));\n    }\n    var posTransform = new dracoDecoder.AttributeQuantizationTransform();\n    if (posTransform.InitFromAttribute(posAttribute)) {\n      // Quantized attribute. Store the quantization parameters into the\n      // THREE.js attribute.\n      geometry.attributes['position'].isQuantized = true;\n      geometry.attributes['position'].maxRange = posTransform.range();\n      geometry.attributes['position'].numQuantizationBits = posTransform.quantization_bits();\n      geometry.attributes['position'].minValues = new Float32Array(3);\n      for (var i = 0; i < 3; ++i) {\n        geometry.attributes['position'].minValues[i] = posTransform.min_value(i);\n      }\n    }\n    dracoDecoder.destroy(posTransform);\n    dracoDecoder.destroy(decoder);\n    dracoDecoder.destroy(dracoGeometry);\n\n    this.decode_time = decode_end - start_time;\n    this.import_time = performance.now() - decode_end;\n\n    if (this.verbosity > 0) {\n      console.log('Decode time: ' + this.decode_time);\n      console.log('Import time: ' + this.import_time);\n    }\n    return geometry;\n  },\n\n  isVersionSupported: function isVersionSupported(version, callback) {\n    DRACOLoader.getDecoderModule().then(function (module) {\n      callback(module.decoder.isVersionSupported(version));\n    });\n  },\n\n  getAttributeOptions: function getAttributeOptions(attributeName) {\n    if (typeof this.attributeOptions[attributeName] === 'undefined') this.attributeOptions[attributeName] = {};\n    return this.attributeOptions[attributeName];\n  }\n};\n\nDRACOLoader.decoderPath = './';\nDRACOLoader.decoderConfig = {};\nDRACOLoader.decoderModulePromise = null;\n\n/**\n * Sets the base path for decoder source files.\n * @param {string} path\n */\nDRACOLoader.setDecoderPath = function (path) {\n  DRACOLoader.decoderPath = path;\n};\n\n/**\n * Sets decoder configuration and releases singleton decoder module. Module\n * will be recreated with the next decoding call.\n * @param {Object} config\n */\nDRACOLoader.setDecoderConfig = function (config) {\n  var wasmBinary = DRACOLoader.decoderConfig.wasmBinary;\n  DRACOLoader.decoderConfig = config || {};\n  DRACOLoader.releaseDecoderModule();\n\n  // Reuse WASM binary.\n  if (wasmBinary) DRACOLoader.decoderConfig.wasmBinary = wasmBinary;\n};\n\n/**\n * Releases the singleton DracoDecoderModule instance. Module will be recreated\n * with the next decoding call.\n */\nDRACOLoader.releaseDecoderModule = function () {\n  DRACOLoader.decoderModulePromise = null;\n};\n\n/**\n * Gets WebAssembly or asm.js singleton instance of DracoDecoderModule\n * after testing for browser support. Returns Promise that resolves when\n * module is available.\n * @return {Promise<{decoder: DracoDecoderModule}>}\n */\nDRACOLoader.getDecoderModule = function () {\n  var scope = this;\n  var path = DRACOLoader.decoderPath;\n  var config = DRACOLoader.decoderConfig;\n  var promise = DRACOLoader.decoderModulePromise;\n\n  if (promise) return promise;\n\n  // Load source files.\n  if (typeof DracoDecoderModule !== 'undefined') {\n    // Loaded externally.\n    promise = Promise.resolve();\n  } else if ((typeof WebAssembly === 'undefined' ? 'undefined' : _typeof(WebAssembly)) !== 'object' || config.type === 'js') {\n    // Load with asm.js.\n    promise = DRACOLoader._loadScript(path + 'draco_decoder.js');\n  } else {\n    // Load with WebAssembly.\n    config.wasmBinaryFile = path + 'draco_decoder.wasm';\n    promise = DRACOLoader._loadScript(path + 'draco_wasm_wrapper.js').then(function () {\n      return DRACOLoader._loadArrayBuffer(config.wasmBinaryFile);\n    }).then(function (wasmBinary) {\n      config.wasmBinary = wasmBinary;\n    });\n  }\n\n  // Wait for source files, then create and return a decoder.\n  promise = promise.then(function () {\n    return new Promise(function (resolve) {\n      config.onModuleLoaded = function (decoder) {\n        scope.timeLoaded = performance.now();\n        // Module is Promise-like. Wrap before resolving to avoid loop.\n        resolve({ decoder: decoder });\n      };\n      DracoDecoderModule(config);\n    });\n  });\n\n  DRACOLoader.decoderModulePromise = promise;\n  return promise;\n};\n\n/**\n * @param {string} src\n * @return {Promise}\n */\nDRACOLoader._loadScript = function (src) {\n  var prevScript = document.getElementById('decoder_script');\n  if (prevScript !== null) {\n    prevScript.parentNode.removeChild(prevScript);\n  }\n  var head = document.getElementsByTagName('head')[0];\n  var script = document.createElement('script');\n  script.id = 'decoder_script';\n  script.type = 'text/javascript';\n  script.src = src;\n  return new Promise(function (resolve) {\n    script.onload = resolve;\n    head.appendChild(script);\n  });\n};\n\n/**\n * @param {string} src\n * @return {Promise}\n */\nDRACOLoader._loadArrayBuffer = function (src) {\n  var loader = new THREE.FileLoader();\n  loader.setResponseType('arraybuffer');\n  return new Promise(function (resolve, reject) {\n    loader.load(src, resolve, undefined, reject);\n  });\n};\n\nexports.default = DRACOLoader;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n* @author Richard M. / https://github.com/richardmonette\n*/\n\nvar EquiangularToCubeGenerator = function EquiangularToCubeGenerator(sourceTexture, resolution) {\n\n\tthis.sourceTexture = sourceTexture;\n\tthis.resolution = resolution;\n\n\tthis.views = [{ t: [1, 0, 0], u: [0, -1, 0] }, { t: [-1, 0, 0], u: [0, -1, 0] }, { t: [0, 1, 0], u: [0, 0, 1] }, { t: [0, -1, 0], u: [0, 0, -1] }, { t: [0, 0, 1], u: [0, -1, 0] }, { t: [0, 0, -1], u: [0, -1, 0] }];\n\n\tthis.camera = new THREE.PerspectiveCamera(90, 1, 0.1, 10);\n\tthis.boxMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), this.getShader());\n\tthis.boxMesh.material.side = THREE.BackSide;\n\tthis.scene = new THREE.Scene();\n\tthis.scene.add(this.boxMesh);\n\n\tvar params = {\n\t\tformat: THREE.RGBAFormat,\n\t\tmagFilter: this.sourceTexture.magFilter,\n\t\tminFilter: this.sourceTexture.minFilter,\n\t\ttype: this.sourceTexture.type,\n\t\tgenerateMipmaps: this.sourceTexture.generateMipmaps,\n\t\tanisotropy: this.sourceTexture.anisotropy,\n\t\tencoding: this.sourceTexture.encoding\n\t};\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution, params);\n};\n\nEquiangularToCubeGenerator.prototype = {\n\n\tconstructor: EquiangularToCubeGenerator,\n\n\tupdate: function update(renderer) {\n\n\t\tfor (var i = 0; i < 6; i++) {\n\n\t\t\tthis.renderTarget.activeCubeFace = i;\n\n\t\t\tvar v = this.views[i];\n\n\t\t\tthis.camera.position.set(0, 0, 0);\n\t\t\tthis.camera.up.set(v.u[0], v.u[1], v.u[2]);\n\t\t\tthis.camera.lookAt(v.t[0], v.t[1], v.t[2]);\n\n\t\t\trenderer.render(this.scene, this.camera, this.renderTarget, true);\n\t\t}\n\n\t\treturn this.renderTarget.texture;\n\t},\n\n\tgetShader: function getShader() {\n\n\t\tvar shaderMaterial = new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"equirectangularMap\": { value: this.sourceTexture }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec3 localPosition;\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tlocalPosition = position;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\n\\\n\t\t\t\tvarying vec3 localPosition;\\n\\\n\t\t\t\tuniform sampler2D equirectangularMap;\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvec2 EquiangularSampleUV(vec3 v) {\\n\\\n\t\t\t    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\\n\\\n\t\t\t    uv *= vec2(0.1591, 0.3183); // inverse atan\\n\\\n\t\t\t    uv += 0.5;\\n\\\n\t\t\t    return uv;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 uv = EquiangularSampleUV(normalize(localPosition));\\n\\\n    \t\t\tvec3 color = texture2D(equirectangularMap, uv).rgb;\\n\\\n    \t\t\t\\n\\\n\t\t\t\t\tgl_FragColor = vec4( color, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tblending: THREE.CustomBlending,\n\t\t\tpremultipliedAlpha: false,\n\t\t\tblendSrc: THREE.OneFactor,\n\t\t\tblendDst: THREE.ZeroFactor,\n\t\t\tblendSrcAlpha: THREE.OneFactor,\n\t\t\tblendDstAlpha: THREE.ZeroFactor,\n\t\t\tblendEquation: THREE.AddEquation\n\n\t\t});\n\n\t\tshaderMaterial.type = 'EquiangularToCubeGenerator';\n\n\t\treturn shaderMaterial;\n\t},\n\n\tdispose: function dispose() {\n\n\t\tthis.boxMesh.geometry.dispose();\n\t\tthis.boxMesh.material.dispose();\n\t\tthis.renderTarget.dispose();\n\t}\n\n};\n\nexports.default = EquiangularToCubeGenerator;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Richard M. / https://github.com/richardmonette\n *\n * OpenEXR loader which, currently, supports reading 16 bit half data, in either\n * uncompressed or PIZ wavelet compressed form.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function EXRLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nEXRLoader.prototype = Object.create(THREE.DataTextureLoader.prototype);\n\nEXRLoader.prototype._parser = function (buffer) {\n\n\tvar USHORT_RANGE = 1 << 16;\n\tvar BITMAP_SIZE = USHORT_RANGE >> 3;\n\n\tvar HUF_ENCBITS = 16; // literal (value) bit length\n\tvar HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\tvar HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\tvar HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\tvar HUF_DECMASK = HUF_DECSIZE - 1;\n\n\tvar SHORT_ZEROCODE_RUN = 59;\n\tvar LONG_ZEROCODE_RUN = 63;\n\tvar SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\tvar LONGEST_LONG_RUN = 255 + SHORTEST_LONG_RUN;\n\n\tvar BYTES_PER_HALF = 2;\n\n\tvar ULONG_SIZE = 8;\n\tvar FLOAT32_SIZE = 4;\n\tvar INT32_SIZE = 4;\n\tvar INT16_SIZE = 2;\n\tvar INT8_SIZE = 1;\n\n\tfunction reverseLutFromBitmap(bitmap, lut) {\n\n\t\tvar k = 0;\n\n\t\tfor (var i = 0; i < USHORT_RANGE; ++i) {\n\n\t\t\tif (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n\n\t\t\t\tlut[k++] = i;\n\t\t\t}\n\t\t}\n\n\t\tvar n = k - 1;\n\n\t\twhile (k < USHORT_RANGE) {\n\t\t\tlut[k++] = 0;\n\t\t}return n;\n\t}\n\n\tfunction hufClearDecTable(hdec) {\n\n\t\tfor (var i = 0; i < HUF_DECSIZE; i++) {\n\n\t\t\thdec[i] = {};\n\t\t\thdec[i].len = 0;\n\t\t\thdec[i].lit = 0;\n\t\t\thdec[i].p = null;\n\t\t}\n\t}\n\n\tvar getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\tfunction getBits(nBits, c, lc, uInt8Array, inOffset) {\n\n\t\twhile (lc < nBits) {\n\n\t\t\tc = c << 8 | parseUint8Array(uInt8Array, inOffset);\n\t\t\tlc += 8;\n\t\t}\n\n\t\tlc -= nBits;\n\n\t\tgetBitsReturn.l = c >> lc & (1 << nBits) - 1;\n\t\tgetBitsReturn.c = c;\n\t\tgetBitsReturn.lc = lc;\n\t}\n\n\tvar hufTableBuffer = new Array(59);\n\n\tfunction hufCanonicalCodeTable(hcode) {\n\n\t\tfor (var i = 0; i <= 58; ++i) {\n\t\t\thufTableBuffer[i] = 0;\n\t\t}for (var i = 0; i < HUF_ENCSIZE; ++i) {\n\t\t\thufTableBuffer[hcode[i]] += 1;\n\t\t}var c = 0;\n\n\t\tfor (var i = 58; i > 0; --i) {\n\n\t\t\tvar nc = c + hufTableBuffer[i] >> 1;\n\t\t\thufTableBuffer[i] = c;\n\t\t\tc = nc;\n\t\t}\n\n\t\tfor (var i = 0; i < HUF_ENCSIZE; ++i) {\n\n\t\t\tvar l = hcode[i];\n\t\t\tif (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n\t\t}\n\t}\n\n\tfunction hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n\n\t\tvar p = inOffset;\n\t\tvar c = 0;\n\t\tvar lc = 0;\n\n\t\tfor (; im <= iM; im++) {\n\n\t\t\tif (p.value - inOffset.value > ni) return false;\n\n\t\t\tgetBits(6, c, lc, uInt8Array, p);\n\n\t\t\tvar l = getBitsReturn.l;\n\t\t\tc = getBitsReturn.c;\n\t\t\tlc = getBitsReturn.lc;\n\n\t\t\thcode[im] = l;\n\n\t\t\tif (l == LONG_ZEROCODE_RUN) {\n\n\t\t\t\tif (p.value - inOffset.value > ni) {\n\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\t\t\t\t}\n\n\t\t\t\tgetBits(8, c, lc, uInt8Array, p);\n\n\t\t\t\tvar zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\tc = getBitsReturn.c;\n\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\tif (im + zerun > iM + 1) {\n\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\t\t\t\t}\n\n\t\t\t\twhile (zerun--) {\n\t\t\t\t\thcode[im++] = 0;\n\t\t\t\t}im--;\n\t\t\t} else if (l >= SHORT_ZEROCODE_RUN) {\n\n\t\t\t\tvar zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\tif (im + zerun > iM + 1) {\n\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\t\t\t\t}\n\n\t\t\t\twhile (zerun--) {\n\t\t\t\t\thcode[im++] = 0;\n\t\t\t\t}im--;\n\t\t\t}\n\t\t}\n\n\t\thufCanonicalCodeTable(hcode);\n\t}\n\n\tfunction hufLength(code) {\n\t\treturn code & 63;\n\t}\n\n\tfunction hufCode(code) {\n\t\treturn code >> 6;\n\t}\n\n\tfunction hufBuildDecTable(hcode, im, iM, hdecod) {\n\n\t\tfor (; im <= iM; im++) {\n\n\t\t\tvar c = hufCode(hcode[im]);\n\t\t\tvar l = hufLength(hcode[im]);\n\n\t\t\tif (c >> l) {\n\n\t\t\t\tthrow 'Invalid table entry';\n\t\t\t}\n\n\t\t\tif (l > HUF_DECBITS) {\n\n\t\t\t\tvar pl = hdecod[c >> l - HUF_DECBITS];\n\n\t\t\t\tif (pl.len) {\n\n\t\t\t\t\tthrow 'Invalid table entry';\n\t\t\t\t}\n\n\t\t\t\tpl.lit++;\n\n\t\t\t\tif (pl.p) {\n\n\t\t\t\t\tvar p = pl.p;\n\t\t\t\t\tpl.p = new Array(pl.lit);\n\n\t\t\t\t\tfor (var i = 0; i < pl.lit - 1; ++i) {\n\n\t\t\t\t\t\tpl.p[i] = p[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tpl.p = new Array(1);\n\t\t\t\t}\n\n\t\t\t\tpl.p[pl.lit - 1] = im;\n\t\t\t} else if (l) {\n\n\t\t\t\tvar plOffset = 0;\n\n\t\t\t\tfor (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n\n\t\t\t\t\tvar pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n\t\t\t\t\tif (pl.len || pl.p) {\n\n\t\t\t\t\t\tthrow 'Invalid table entry';\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.len = l;\n\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\tplOffset++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tvar getCharReturn = { c: 0, lc: 0 };\n\n\tfunction getChar(c, lc, uInt8Array, inOffset) {\n\n\t\tc = c << 8 | parseUint8Array(uInt8Array, inOffset);\n\t\tlc += 8;\n\n\t\tgetCharReturn.c = c;\n\t\tgetCharReturn.lc = lc;\n\t}\n\n\tvar getCodeReturn = { c: 0, lc: 0 };\n\n\tfunction getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n\n\t\tif (po == rlc) {\n\n\t\t\tif (lc < 8) {\n\n\t\t\t\tgetChar(c, lc, uInt8Array, inOffset);\n\t\t\t\tc = getCharReturn.c;\n\t\t\t\tlc = getCharReturn.lc;\n\t\t\t}\n\n\t\t\tlc -= 8;\n\n\t\t\tvar cs = c >> lc;\n\n\t\t\tif (out + cs > oe) {\n\n\t\t\t\tthrow 'Issue with getCode';\n\t\t\t}\n\n\t\t\tvar s = out[-1];\n\n\t\t\twhile (cs-- > 0) {\n\n\t\t\t\toutBuffer[outBufferOffset.value++] = s;\n\t\t\t}\n\t\t} else if (outBufferOffset.value < outBufferEndOffset) {\n\n\t\t\toutBuffer[outBufferOffset.value++] = po;\n\t\t} else {\n\n\t\t\tthrow 'Issue with getCode';\n\t\t}\n\n\t\tgetCodeReturn.c = c;\n\t\tgetCodeReturn.lc = lc;\n\t}\n\n\tvar NBITS = 16;\n\tvar A_OFFSET = 1 << NBITS - 1;\n\tvar M_OFFSET = 1 << NBITS - 1;\n\tvar MOD_MASK = (1 << NBITS) - 1;\n\n\tfunction UInt16(value) {\n\n\t\treturn value & 0xFFFF;\n\t}\n\n\tfunction Int16(value) {\n\n\t\tvar ref = UInt16(value);\n\t\treturn ref > 0x7FFF ? ref - 0x10000 : ref;\n\t}\n\n\tvar wdec14Return = { a: 0, b: 0 };\n\n\tfunction wdec14(l, h) {\n\n\t\tvar ls = Int16(l);\n\t\tvar hs = Int16(h);\n\n\t\tvar hi = hs;\n\t\tvar ai = ls + (hi & 1) + (hi >> 1);\n\n\t\tvar as = ai;\n\t\tvar bs = ai - hi;\n\n\t\twdec14Return.a = as;\n\t\twdec14Return.b = bs;\n\t}\n\n\tfunction wav2Decode(j, buffer, nx, ox, ny, oy, mx) {\n\n\t\tvar n = nx > ny ? ny : nx;\n\t\tvar p = 1;\n\t\tvar p2;\n\n\t\twhile (p <= n) {\n\t\t\tp <<= 1;\n\t\t}p >>= 1;\n\t\tp2 = p;\n\t\tp >>= 1;\n\n\t\twhile (p >= 1) {\n\n\t\t\tvar py = 0;\n\t\t\tvar ey = py + oy * (ny - p2);\n\t\t\tvar oy1 = oy * p;\n\t\t\tvar oy2 = oy * p2;\n\t\t\tvar ox1 = ox * p;\n\t\t\tvar ox2 = ox * p2;\n\t\t\tvar i00, i01, i10, i11;\n\n\t\t\tfor (; py <= ey; py += oy2) {\n\n\t\t\t\tvar px = py;\n\t\t\t\tvar ex = py + ox * (nx - p2);\n\n\t\t\t\tfor (; px <= ex; px += ox2) {\n\n\t\t\t\t\tvar p01 = px + ox1;\n\t\t\t\t\tvar p10 = px + oy1;\n\t\t\t\t\tvar p11 = p10 + ox1;\n\n\t\t\t\t\twdec14(buffer[px + j], buffer[p10 + j]);\n\n\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\twdec14(buffer[p01 + j], buffer[p11 + j]);\n\n\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\twdec14(i00, i01);\n\n\t\t\t\t\tbuffer[px + j] = wdec14Return.a;\n\t\t\t\t\tbuffer[p01 + j] = wdec14Return.b;\n\n\t\t\t\t\twdec14(i10, i11);\n\n\t\t\t\t\tbuffer[p10 + j] = wdec14Return.a;\n\t\t\t\t\tbuffer[p11 + j] = wdec14Return.b;\n\t\t\t\t}\n\n\t\t\t\tif (nx & p) {\n\n\t\t\t\t\tvar p10 = px + oy1;\n\n\t\t\t\t\twdec14(buffer[px + j], buffer[p10 + j]);\n\n\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\tbuffer[p10 + j] = wdec14Return.b;\n\n\t\t\t\t\tbuffer[px + j] = i00;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ny & p) {\n\n\t\t\t\tvar px = py;\n\t\t\t\tvar ex = py + ox * (nx - p2);\n\n\t\t\t\tfor (; px <= ex; px += ox2) {\n\n\t\t\t\t\tvar p01 = px + ox1;\n\n\t\t\t\t\twdec14(buffer[px + j], buffer[p01 + j]);\n\n\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\tbuffer[p01 + j] = wdec14Return.b;\n\n\t\t\t\t\tbuffer[px + j] = i00;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp2 = p;\n\t\t\tp >>= 1;\n\t\t}\n\n\t\treturn py;\n\t}\n\n\tfunction hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n\n\t\tvar c = 0;\n\t\tvar lc = 0;\n\t\tvar outBufferEndOffset = no;\n\t\tvar inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n\t\twhile (inOffset.value < inOffsetEnd) {\n\n\t\t\tgetChar(c, lc, uInt8Array, inOffset);\n\n\t\t\tc = getCharReturn.c;\n\t\t\tlc = getCharReturn.lc;\n\n\t\t\twhile (lc >= HUF_DECBITS) {\n\n\t\t\t\tvar index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n\t\t\t\tvar pl = decodingTable[index];\n\n\t\t\t\tif (pl.len) {\n\n\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\tgetCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n\n\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\tlc = getCodeReturn.lc;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (!pl.p) {\n\n\t\t\t\t\t\tthrow 'hufDecode issues';\n\t\t\t\t\t}\n\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tfor (j = 0; j < pl.lit; j++) {\n\n\t\t\t\t\t\tvar l = hufLength(encodingTable[pl.p[j]]);\n\n\t\t\t\t\t\twhile (lc < l && inOffset.value < inOffsetEnd) {\n\n\t\t\t\t\t\t\tgetChar(c, lc, uInt8Array, inOffset);\n\n\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (lc >= l) {\n\n\t\t\t\t\t\t\tif (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n\n\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\tgetCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n\n\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j == pl.lit) {\n\n\t\t\t\t\t\tthrow 'hufDecode issues';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar i = 8 - ni & 7;\n\n\t\tc >>= i;\n\t\tlc -= i;\n\n\t\twhile (lc > 0) {\n\n\t\t\tvar pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n\t\t\tif (pl.len) {\n\n\t\t\t\tlc -= pl.len;\n\n\t\t\t\tgetCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n\n\t\t\t\tc = getCodeReturn.c;\n\t\t\t\tlc = getCodeReturn.lc;\n\t\t\t} else {\n\n\t\t\t\tthrow 'hufDecode issues';\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, outOffset, nRaw) {\n\n\t\tvar initialInOffset = inOffset.value;\n\n\t\tvar im = parseUint32(inDataView, inOffset);\n\t\tvar iM = parseUint32(inDataView, inOffset);\n\n\t\tinOffset.value += 4;\n\n\t\tvar nBits = parseUint32(inDataView, inOffset);\n\n\t\tinOffset.value += 4;\n\n\t\tif (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n\n\t\t\tthrow 'Something wrong with HUF_ENCSIZE';\n\t\t}\n\n\t\tvar freq = new Array(HUF_ENCSIZE);\n\t\tvar hdec = new Array(HUF_DECSIZE);\n\n\t\thufClearDecTable(hdec);\n\n\t\tvar ni = nCompressed - (inOffset.value - initialInOffset);\n\n\t\thufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n\t\tif (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n\n\t\t\tthrow 'Something wrong with hufUncompress';\n\t\t}\n\n\t\thufBuildDecTable(freq, im, iM, hdec);\n\n\t\thufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n\t}\n\n\tfunction applyLut(lut, data, nData) {\n\n\t\tfor (var i = 0; i < nData; ++i) {\n\n\t\t\tdata[i] = lut[data[i]];\n\t\t}\n\t}\n\n\tfunction decompressPIZ(outBuffer, outOffset, uInt8Array, inDataView, inOffset, tmpBufSize, num_channels, exrChannelInfos, dataWidth, num_lines) {\n\n\t\tvar bitmap = new Uint8Array(BITMAP_SIZE);\n\n\t\tvar minNonZero = parseUint16(inDataView, inOffset);\n\t\tvar maxNonZero = parseUint16(inDataView, inOffset);\n\n\t\tif (maxNonZero >= BITMAP_SIZE) {\n\n\t\t\tthrow 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n\t\t}\n\n\t\tif (minNonZero <= maxNonZero) {\n\n\t\t\tfor (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n\n\t\t\t\tbitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n\t\t\t}\n\t\t}\n\n\t\tvar lut = new Uint16Array(USHORT_RANGE);\n\t\tvar maxValue = reverseLutFromBitmap(bitmap, lut);\n\n\t\tvar length = parseUint32(inDataView, inOffset);\n\n\t\thufUncompress(uInt8Array, inDataView, inOffset, length, outBuffer, outOffset, tmpBufSize);\n\n\t\tvar pizChannelData = new Array(num_channels);\n\n\t\tvar outBufferEnd = 0;\n\n\t\tfor (var i = 0; i < num_channels; i++) {\n\n\t\t\tvar exrChannelInfo = exrChannelInfos[i];\n\n\t\t\tvar pixelSize = 2; // assumes HALF_FLOAT\n\n\t\t\tpizChannelData[i] = {};\n\t\t\tpizChannelData[i]['start'] = outBufferEnd;\n\t\t\tpizChannelData[i]['end'] = pizChannelData[i]['start'];\n\t\t\tpizChannelData[i]['nx'] = dataWidth;\n\t\t\tpizChannelData[i]['ny'] = num_lines;\n\t\t\tpizChannelData[i]['size'] = 1;\n\n\t\t\toutBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n\t\t}\n\n\t\tvar fooOffset = 0;\n\n\t\tfor (var i = 0; i < num_channels; i++) {\n\n\t\t\tfor (var j = 0; j < pizChannelData[i].size; ++j) {\n\n\t\t\t\tfooOffset += wav2Decode(j + fooOffset, outBuffer, pizChannelData[i].nx, pizChannelData[i].size, pizChannelData[i].ny, pizChannelData[i].nx * pizChannelData[i].size, maxValue);\n\t\t\t}\n\t\t}\n\n\t\tapplyLut(lut, outBuffer, outBufferEnd);\n\n\t\treturn true;\n\t}\n\n\tfunction parseNullTerminatedString(buffer, offset) {\n\n\t\tvar uintBuffer = new Uint8Array(buffer);\n\t\tvar endOffset = 0;\n\n\t\twhile (uintBuffer[offset.value + endOffset] != 0) {\n\n\t\t\tendOffset += 1;\n\t\t}\n\n\t\tvar stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n\n\t\toffset.value = offset.value + endOffset + 1;\n\n\t\treturn stringValue;\n\t}\n\n\tfunction parseFixedLengthString(buffer, offset, size) {\n\n\t\tvar stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n\n\t\toffset.value = offset.value + size;\n\n\t\treturn stringValue;\n\t}\n\n\tfunction parseUlong(dataView, offset) {\n\n\t\tvar uLong = dataView.getUint32(0, true);\n\n\t\toffset.value = offset.value + ULONG_SIZE;\n\n\t\treturn uLong;\n\t}\n\n\tfunction parseUint32(dataView, offset) {\n\n\t\tvar Uint32 = dataView.getUint32(offset.value, true);\n\n\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\treturn Uint32;\n\t}\n\n\tfunction parseUint8Array(uInt8Array, offset) {\n\n\t\tvar Uint8 = uInt8Array[offset.value];\n\n\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\treturn Uint8;\n\t}\n\n\tfunction parseUint8(dataView, offset) {\n\n\t\tvar Uint8 = dataView.getUint8(offset.value);\n\n\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\treturn Uint8;\n\t}\n\n\tfunction parseFloat32(dataView, offset) {\n\n\t\tvar float = dataView.getFloat32(offset.value, true);\n\n\t\toffset.value += FLOAT32_SIZE;\n\n\t\treturn float;\n\t}\n\n\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\tfunction decodeFloat16(binary) {\n\n\t\tvar exponent = (binary & 0x7C00) >> 10,\n\t\t    fraction = binary & 0x03FF;\n\n\t\treturn (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1F ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n\t}\n\n\tfunction parseUint16(dataView, offset) {\n\n\t\tvar Uint16 = dataView.getUint16(offset.value, true);\n\n\t\toffset.value += INT16_SIZE;\n\n\t\treturn Uint16;\n\t}\n\n\tfunction parseFloat16(buffer, offset) {\n\n\t\treturn decodeFloat16(parseUint16(buffer, offset));\n\t}\n\n\tfunction parseChlist(dataView, buffer, offset, size) {\n\n\t\tvar startOffset = offset.value;\n\t\tvar channels = [];\n\n\t\twhile (offset.value < startOffset + size - 1) {\n\n\t\t\tvar name = parseNullTerminatedString(buffer, offset);\n\t\t\tvar pixelType = parseUint32(dataView, offset); // TODO: Cast this to UINT, HALF or FLOAT\n\t\t\tvar pLinear = parseUint8(dataView, offset);\n\t\t\toffset.value += 3; // reserved, three chars\n\t\t\tvar xSampling = parseUint32(dataView, offset);\n\t\t\tvar ySampling = parseUint32(dataView, offset);\n\n\t\t\tchannels.push({\n\t\t\t\tname: name,\n\t\t\t\tpixelType: pixelType,\n\t\t\t\tpLinear: pLinear,\n\t\t\t\txSampling: xSampling,\n\t\t\t\tySampling: ySampling\n\t\t\t});\n\t\t}\n\n\t\toffset.value += 1;\n\n\t\treturn channels;\n\t}\n\n\tfunction parseChromaticities(dataView, offset) {\n\n\t\tvar redX = parseFloat32(dataView, offset);\n\t\tvar redY = parseFloat32(dataView, offset);\n\t\tvar greenX = parseFloat32(dataView, offset);\n\t\tvar greenY = parseFloat32(dataView, offset);\n\t\tvar blueX = parseFloat32(dataView, offset);\n\t\tvar blueY = parseFloat32(dataView, offset);\n\t\tvar whiteX = parseFloat32(dataView, offset);\n\t\tvar whiteY = parseFloat32(dataView, offset);\n\n\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\t}\n\n\tfunction parseCompression(dataView, offset) {\n\n\t\tvar compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION'];\n\n\t\tvar compression = parseUint8(dataView, offset);\n\n\t\treturn compressionCodes[compression];\n\t}\n\n\tfunction parseBox2i(dataView, offset) {\n\n\t\tvar xMin = parseUint32(dataView, offset);\n\t\tvar yMin = parseUint32(dataView, offset);\n\t\tvar xMax = parseUint32(dataView, offset);\n\t\tvar yMax = parseUint32(dataView, offset);\n\n\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\t}\n\n\tfunction parseLineOrder(dataView, offset) {\n\n\t\tvar lineOrders = ['INCREASING_Y'];\n\n\t\tvar lineOrder = parseUint8(dataView, offset);\n\n\t\treturn lineOrders[lineOrder];\n\t}\n\n\tfunction parseV2f(dataView, offset) {\n\n\t\tvar x = parseFloat32(dataView, offset);\n\t\tvar y = parseFloat32(dataView, offset);\n\n\t\treturn [x, y];\n\t}\n\n\tfunction parseValue(dataView, buffer, offset, type, size) {\n\n\t\tif (type === 'string' || type === 'iccProfile') {\n\n\t\t\treturn parseFixedLengthString(buffer, offset, size);\n\t\t} else if (type === 'chlist') {\n\n\t\t\treturn parseChlist(dataView, buffer, offset, size);\n\t\t} else if (type === 'chromaticities') {\n\n\t\t\treturn parseChromaticities(dataView, offset);\n\t\t} else if (type === 'compression') {\n\n\t\t\treturn parseCompression(dataView, offset);\n\t\t} else if (type === 'box2i') {\n\n\t\t\treturn parseBox2i(dataView, offset);\n\t\t} else if (type === 'lineOrder') {\n\n\t\t\treturn parseLineOrder(dataView, offset);\n\t\t} else if (type === 'float') {\n\n\t\t\treturn parseFloat32(dataView, offset);\n\t\t} else if (type === 'v2f') {\n\n\t\t\treturn parseV2f(dataView, offset);\n\t\t} else if (type === 'int') {\n\n\t\t\treturn parseUint32(dataView, offset);\n\t\t} else {\n\n\t\t\tthrow 'Cannot parse value for unsupported type: ' + type;\n\t\t}\n\t}\n\n\tvar bufferDataView = new DataView(buffer);\n\tvar uInt8Array = new Uint8Array(buffer);\n\n\tvar EXRHeader = {};\n\n\tvar magic = bufferDataView.getUint32(0, true);\n\tvar versionByteZero = bufferDataView.getUint8(4, true);\n\tvar fullMask = bufferDataView.getUint8(5, true);\n\n\t// start of header\n\n\tvar offset = { value: 8 }; // start at 8, after magic stuff\n\n\tvar keepReading = true;\n\n\twhile (keepReading) {\n\n\t\tvar attributeName = parseNullTerminatedString(buffer, offset);\n\n\t\tif (attributeName == 0) {\n\n\t\t\tkeepReading = false;\n\t\t} else {\n\n\t\t\tvar attributeType = parseNullTerminatedString(buffer, offset);\n\t\t\tvar attributeSize = parseUint32(bufferDataView, offset);\n\t\t\tvar attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);\n\n\t\t\tEXRHeader[attributeName] = attributeValue;\n\t\t}\n\t}\n\n\t// offsets\n\n\tvar dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n\tvar scanlineBlockSize = 1; // 1 for NO_COMPRESSION\n\n\tif (EXRHeader.compression === 'PIZ_COMPRESSION') {\n\n\t\tscanlineBlockSize = 32;\n\t}\n\n\tvar numBlocks = dataWindowHeight / scanlineBlockSize;\n\n\tfor (var i = 0; i < numBlocks; i++) {\n\n\t\tvar scanlineOffset = parseUlong(bufferDataView, offset);\n\t}\n\n\t// we should be passed the scanline offset table, start reading pixel data\n\n\tvar width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n\tvar height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;\n\tvar numChannels = EXRHeader.channels.length;\n\n\tvar byteArray = new Float32Array(width * height * numChannels);\n\n\tvar channelOffsets = {\n\t\tR: 0,\n\t\tG: 1,\n\t\tB: 2,\n\t\tA: 3\n\t};\n\n\tif (EXRHeader.compression === 'NO_COMPRESSION') {\n\n\t\tfor (var y = 0; y < height; y++) {\n\n\t\t\tvar y_scanline = parseUint32(bufferDataView, offset);\n\t\t\tvar dataSize = parseUint32(bufferDataView, offset);\n\n\t\t\tfor (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n\n\t\t\t\tvar cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n\t\t\t\tif (EXRHeader.channels[channelID].pixelType === 1) {\n\n\t\t\t\t\t// HALF\n\t\t\t\t\tfor (var x = 0; x < width; x++) {\n\n\t\t\t\t\t\tvar val = parseFloat16(bufferDataView, offset);\n\n\t\t\t\t\t\tbyteArray[(height - y_scanline) * (width * numChannels) + x * numChannels + cOff] = val;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Only supported pixel format is HALF';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (EXRHeader.compression === 'PIZ_COMPRESSION') {\n\n\t\tfor (var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {\n\n\t\t\tvar line_no = parseUint32(bufferDataView, offset);\n\t\t\tvar data_len = parseUint32(bufferDataView, offset);\n\n\t\t\tvar tmpBufferSize = width * scanlineBlockSize * (EXRHeader.channels.length * BYTES_PER_HALF);\n\t\t\tvar tmpBuffer = new Uint16Array(tmpBufferSize);\n\t\t\tvar tmpOffset = { value: 0 };\n\n\t\t\tdecompressPIZ(tmpBuffer, tmpOffset, uInt8Array, bufferDataView, offset, tmpBufferSize, numChannels, EXRHeader.channels, width, scanlineBlockSize);\n\n\t\t\tfor (var line_y = 0; line_y < scanlineBlockSize; line_y++) {\n\n\t\t\t\tfor (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n\n\t\t\t\t\tvar cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n\t\t\t\t\tif (EXRHeader.channels[channelID].pixelType === 1) {\n\n\t\t\t\t\t\t// HALF\n\t\t\t\t\t\tfor (var x = 0; x < width; x++) {\n\n\t\t\t\t\t\t\tvar val = decodeFloat16(tmpBuffer[channelID * (scanlineBlockSize * width) + line_y * width + x]);\n\n\t\t\t\t\t\t\tvar true_y = line_y + scanlineBlockIdx * scanlineBlockSize;\n\n\t\t\t\t\t\t\tbyteArray[(height - true_y) * (width * numChannels) + x * numChannels + cOff] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow 'Only supported pixel format is HALF';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\tthrow 'Cannot decompress unsupported compression';\n\t}\n\n\treturn {\n\t\theader: EXRHeader,\n\t\twidth: width,\n\t\theight: height,\n\t\tdata: byteArray,\n\t\tformat: THREE.RGBFormat,\n\t\ttype: THREE.FloatType\n\t};\n};\n\nexports.default = EXRLoader;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nexports.default = function () {\n\n\tvar FBXLoader = function FBXLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t};\n\n\tObject.assign(FBXLoader.prototype, {\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar resourceDirectory = THREE.LoaderUtils.extractUrlBase(url);\n\n\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.load(url, function (buffer) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar scene = self.parse(buffer, resourceDirectory);\n\t\t\t\t\tonLoad(scene);\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\twindow.setTimeout(function () {\n\n\t\t\t\t\t\tif (onError) onError(error);\n\n\t\t\t\t\t\tself.manager.itemError(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tparse: function parse(FBXBuffer, resourceDirectory) {\n\n\t\t\tvar FBXTree;\n\n\t\t\tif (isFbxFormatBinary(FBXBuffer)) {\n\n\t\t\t\tFBXTree = new BinaryParser().parse(FBXBuffer);\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString(FBXBuffer);\n\n\t\t\t\tif (!isFbxFormatASCII(FBXText)) {\n\n\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown format.');\n\t\t\t\t}\n\n\t\t\t\tif (getFbxVersion(FBXText) < 7000) {\n\n\t\t\t\t\tthrow new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n\t\t\t\t}\n\n\t\t\t\tFBXTree = new TextParser().parse(FBXText);\n\t\t\t}\n\n\t\t\t// console.log( FBXTree );\n\n\t\t\tvar connections = parseConnections(FBXTree);\n\t\t\tvar images = parseImages(FBXTree);\n\t\t\tvar textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n\t\t\tvar materials = parseMaterials(FBXTree, textures, connections);\n\t\t\tvar deformers = parseDeformers(FBXTree, connections);\n\t\t\tvar geometryMap = parseGeometries(FBXTree, connections, deformers);\n\t\t\tvar sceneGraph = parseScene(FBXTree, connections, deformers.skeletons, geometryMap, materials);\n\n\t\t\treturn sceneGraph;\n\t\t}\n\n\t});\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tfunction parseConnections(FBXTree) {\n\n\t\tvar connectionMap = new Map();\n\n\t\tif ('Connections' in FBXTree) {\n\n\t\t\tvar rawConnections = FBXTree.Connections.connections;\n\n\t\t\trawConnections.forEach(function (rawConnection) {\n\n\t\t\t\tvar fromID = rawConnection[0];\n\t\t\t\tvar toID = rawConnection[1];\n\t\t\t\tvar relationship = rawConnection[2];\n\n\t\t\t\tif (!connectionMap.has(fromID)) {\n\n\t\t\t\t\tconnectionMap.set(fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get(fromID).parents.push(parentRelationship);\n\n\t\t\t\tif (!connectionMap.has(toID)) {\n\n\t\t\t\t\tconnectionMap.set(toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get(toID).children.push(childRelationship);\n\t\t\t});\n\t\t}\n\n\t\treturn connectionMap;\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tfunction parseImages(FBXTree) {\n\n\t\tvar images = {};\n\t\tvar blobs = {};\n\n\t\tif ('Video' in FBXTree.Objects) {\n\n\t\t\tvar videoNodes = FBXTree.Objects.Video;\n\n\t\t\tfor (var nodeID in videoNodes) {\n\n\t\t\t\tvar videoNode = videoNodes[nodeID];\n\n\t\t\t\tvar id = parseInt(nodeID);\n\n\t\t\t\timages[id] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ('Content' in videoNode) {\n\n\t\t\t\t\tvar arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n\t\t\t\t\tvar base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n\n\t\t\t\t\tif (arrayBufferContent || base64Content) {\n\n\t\t\t\t\t\tvar image = parseImage(videoNodes[nodeID]);\n\n\t\t\t\t\t\tblobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var id in images) {\n\n\t\t\tvar filename = images[id];\n\n\t\t\tif (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\n\t\t}\n\n\t\treturn images;\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tfunction parseImage(videoNode) {\n\n\t\tvar content = videoNode.Content;\n\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tvar extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n\t\tvar type;\n\n\t\tswitch (extension) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tga':\n\n\t\t\t\tif (typeof THREE.TGALoader !== 'function') {\n\n\t\t\t\t\tconsole.warn('FBXLoader: THREE.TGALoader is required to load TGA textures');\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (THREE.Loader.Handlers.get('.tga') === null) {\n\n\t\t\t\t\t\tTHREE.Loader.Handlers.add(/\\.tga$/i, new THREE.TGALoader());\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif (typeof content === 'string') {\n\t\t\t// ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\t\t} else {\n\t\t\t// Binary Format\n\n\t\t\tvar array = new Uint8Array(content);\n\t\t\treturn window.URL.createObjectURL(new Blob([array], { type: type }));\n\t\t}\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tfunction parseTextures(FBXTree, loader, images, connections) {\n\n\t\tvar textureMap = new Map();\n\n\t\tif ('Texture' in FBXTree.Objects) {\n\n\t\t\tvar textureNodes = FBXTree.Objects.Texture;\n\t\t\tfor (var nodeID in textureNodes) {\n\n\t\t\t\tvar texture = parseTexture(textureNodes[nodeID], loader, images, connections);\n\t\t\t\ttextureMap.set(parseInt(nodeID), texture);\n\t\t\t}\n\t\t}\n\n\t\treturn textureMap;\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tfunction parseTexture(textureNode, loader, images, connections) {\n\n\t\tvar texture = loadTexture(textureNode, loader, images, connections);\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\tif ('Scaling' in textureNode) {\n\n\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[0];\n\t\t\ttexture.repeat.y = values[1];\n\t\t}\n\n\t\treturn texture;\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\tfunction loadTexture(textureNode, loader, images, connections) {\n\n\t\tvar fileName;\n\n\t\tvar currentPath = loader.path;\n\n\t\tvar children = connections.get(textureNode.id).children;\n\n\t\tif (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n\n\t\t\tfileName = images[children[0].ID];\n\n\t\t\tif (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n\n\t\t\t\tloader.setPath(undefined);\n\t\t\t}\n\t\t}\n\n\t\tvar texture;\n\n\t\tif (textureNode.FileName.slice(-3).toLowerCase() === 'tga') {\n\n\t\t\ttexture = THREE.Loader.Handlers.get('.tga').load(fileName);\n\t\t} else {\n\n\t\t\ttexture = loader.load(fileName);\n\t\t}\n\n\t\tloader.setPath(currentPath);\n\n\t\treturn texture;\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tfunction parseMaterials(FBXTree, textureMap, connections) {\n\n\t\tvar materialMap = new Map();\n\n\t\tif ('Material' in FBXTree.Objects) {\n\n\t\t\tvar materialNodes = FBXTree.Objects.Material;\n\n\t\t\tfor (var nodeID in materialNodes) {\n\n\t\t\t\tvar material = parseMaterial(FBXTree, materialNodes[nodeID], textureMap, connections);\n\n\t\t\t\tif (material !== null) materialMap.set(parseInt(nodeID), material);\n\t\t\t}\n\t\t}\n\n\t\treturn materialMap;\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tfunction parseMaterial(FBXTree, materialNode, textureMap, connections) {\n\n\t\tvar ID = materialNode.id;\n\t\tvar name = materialNode.attrName;\n\t\tvar type = materialNode.ShadingModel;\n\n\t\t//Case where FBX wraps shading model in property object.\n\t\tif ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n\n\t\t\ttype = type.value;\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif (!connections.has(ID)) return null;\n\n\t\tvar parameters = parseParameters(FBXTree, materialNode, textureMap, ID, connections);\n\n\t\tvar material;\n\n\t\tswitch (type.toLowerCase()) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial({ color: 0x3300ff });\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues(parameters);\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tfunction parseParameters(FBXTree, properties, textureMap, ID, connections) {\n\n\t\tvar parameters = {};\n\n\t\tif (properties.BumpFactor) {\n\n\t\t\tparameters.bumpScale = properties.BumpFactor.value;\n\t\t}\n\t\tif (properties.Diffuse) {\n\n\t\t\tparameters.color = new THREE.Color().fromArray(properties.Diffuse.value);\n\t\t} else if (properties.DiffuseColor && properties.DiffuseColor.type === 'Color') {\n\n\t\t\t// The blender exporter exports diffuse here instead of in properties.Diffuse\n\t\t\tparameters.color = new THREE.Color().fromArray(properties.DiffuseColor.value);\n\t\t}\n\t\tif (properties.DisplacementFactor) {\n\n\t\t\tparameters.displacementScale = properties.DisplacementFactor.value;\n\t\t}\n\t\tif (properties.Emissive) {\n\n\t\t\tparameters.emissive = new THREE.Color().fromArray(properties.Emissive.value);\n\t\t} else if (properties.EmissiveColor && properties.EmissiveColor.type === 'Color') {\n\n\t\t\t// The blender exporter exports emissive color here instead of in properties.Emissive\n\t\t\tparameters.emissive = new THREE.Color().fromArray(properties.EmissiveColor.value);\n\t\t}\n\t\tif (properties.EmissiveFactor) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);\n\t\t}\n\t\tif (properties.Opacity) {\n\n\t\t\tparameters.opacity = parseFloat(properties.Opacity.value);\n\t\t}\n\t\tif (parameters.opacity < 1.0) {\n\n\t\t\tparameters.transparent = true;\n\t\t}\n\t\tif (properties.ReflectionFactor) {\n\n\t\t\tparameters.reflectivity = properties.ReflectionFactor.value;\n\t\t}\n\t\tif (properties.Shininess) {\n\n\t\t\tparameters.shininess = properties.Shininess.value;\n\t\t}\n\t\tif (properties.Specular) {\n\n\t\t\tparameters.specular = new THREE.Color().fromArray(properties.Specular.value);\n\t\t} else if (properties.SpecularColor && properties.SpecularColor.type === 'Color') {\n\n\t\t\t// The blender exporter exports specular color here instead of in properties.Specular\n\t\t\tparameters.specular = new THREE.Color().fromArray(properties.SpecularColor.value);\n\t\t}\n\n\t\tconnections.get(ID).children.forEach(function (child) {\n\n\t\t\tvar type = child.relationship;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = textureMap.get(child.ID);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tparameters.map = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tparameters.normalMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tparameters.alphaMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t});\n\n\t\treturn parameters;\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tfunction getTexture(FBXTree, textureMap, id, connections) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ('LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture) {\n\n\t\t\tconsole.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n\t\t\tid = connections.get(id).children[0].ID;\n\t\t}\n\n\t\treturn textureMap.get(id);\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tfunction parseDeformers(FBXTree, connections) {\n\n\t\tvar skeletons = {};\n\t\tvar morphTargets = {};\n\n\t\tif ('Deformer' in FBXTree.Objects) {\n\n\t\t\tvar DeformerNodes = FBXTree.Objects.Deformer;\n\n\t\t\tfor (var nodeID in DeformerNodes) {\n\n\t\t\t\tvar deformerNode = DeformerNodes[nodeID];\n\n\t\t\t\tvar relationships = connections.get(parseInt(nodeID));\n\n\t\t\t\tif (deformerNode.attrType === 'Skin') {\n\n\t\t\t\t\tvar skeleton = parseSkeleton(relationships, DeformerNodes);\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n\t\t\t\t\tskeleton.geometryID = relationships.parents[0].ID;\n\n\t\t\t\t\tskeletons[nodeID] = skeleton;\n\t\t\t\t} else if (deformerNode.attrType === 'BlendShape') {\n\n\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\tid: nodeID\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = parseMorphTargets(relationships, deformerNode, DeformerNodes, connections, FBXTree);\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n\t\t\t\t\tmorphTarget.parentGeoID = relationships.parents[0].ID;\n\n\t\t\t\t\tmorphTargets[nodeID] = morphTarget;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets\n\n\t\t};\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tfunction parseSkeleton(connections, deformerNodes) {\n\n\t\tvar rawBones = [];\n\n\t\tconnections.children.forEach(function (child) {\n\n\t\t\tvar boneNode = deformerNodes[child.ID];\n\n\t\t\tif (boneNode.attrType !== 'Cluster') return;\n\n\t\t\tvar rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransform: new THREE.Matrix4().fromArray(boneNode.Transform.a),\n\t\t\t\ttransformLink: new THREE.Matrix4().fromArray(boneNode.TransformLink.a),\n\t\t\t\tlinkMode: boneNode.Mode\n\n\t\t\t};\n\n\t\t\tif ('Indexes' in boneNode) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\t\t\t}\n\n\t\t\trawBones.push(rawBone);\n\t\t});\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tfunction parseMorphTargets(relationships, deformerNode, deformerNodes, connections) {\n\n\t\tvar rawMorphTargets = [];\n\n\t\tfor (var i = 0; i < relationships.children.length; i++) {\n\n\t\t\tif (i === 8) {\n\n\t\t\t\tconsole.warn('FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.');\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar child = relationships.children[i];\n\n\t\t\tvar morphTargetNode = deformerNodes[child.ID];\n\n\t\t\tvar rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n\n\t\t\tvar targetRelationships = connections.get(parseInt(child.ID));\n\n\t\t\ttargetRelationships.children.forEach(function (child) {\n\n\t\t\t\tif (child.relationship === 'DeformPercent') {\n\n\t\t\t\t\t// TODO: animation of morph targets is currently unsupported\n\t\t\t\t\trawMorphTarget.weightCurveID = child.ID;\n\t\t\t\t\t// weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n\t\t\t\t} else {\n\n\t\t\t\t\trawMorphTarget.geoID = child.ID;\n\t\t\t\t\t// morphGeo = FBXTree.Objects.Geometry[ geoID ];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trawMorphTargets.push(rawMorphTarget);\n\t\t}\n\n\t\treturn rawMorphTargets;\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tfunction parseGeometries(FBXTree, connections, deformers) {\n\n\t\tvar geometryMap = new Map();\n\n\t\tif ('Geometry' in FBXTree.Objects) {\n\n\t\t\tvar geoNodes = FBXTree.Objects.Geometry;\n\n\t\t\tfor (var nodeID in geoNodes) {\n\n\t\t\t\tvar relationships = connections.get(parseInt(nodeID));\n\t\t\t\tvar geo = parseGeometry(FBXTree, relationships, geoNodes[nodeID], deformers);\n\n\t\t\t\tgeometryMap.set(parseInt(nodeID), geo);\n\t\t\t}\n\t\t}\n\n\t\treturn geometryMap;\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tfunction parseGeometry(FBXTree, relationships, geoNode, deformers) {\n\n\t\tswitch (geoNode.attrType) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn parseMeshGeometry(FBXTree, relationships, geoNode, deformers);\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn parseNurbsGeometry(geoNode);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tfunction parseMeshGeometry(FBXTree, relationships, geoNode, deformers) {\n\n\t\tvar skeletons = deformers.skeletons;\n\t\tvar morphTargets = deformers.morphTargets;\n\n\t\tvar modelNodes = relationships.parents.map(function (parent) {\n\n\t\t\treturn FBXTree.Objects.Model[parent.ID];\n\t\t});\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif (modelNodes.length === 0) return;\n\n\t\tvar skeleton = relationships.children.reduce(function (skeleton, child) {\n\n\t\t\tif (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n\n\t\t\treturn skeleton;\n\t\t}, null);\n\n\t\tvar morphTarget = relationships.children.reduce(function (morphTarget, child) {\n\n\t\t\tif (morphTargets[child.ID] !== undefined) morphTarget = morphTargets[child.ID];\n\n\t\t\treturn morphTarget;\n\t\t}, null);\n\n\t\tvar preTransform = new THREE.Matrix4();\n\n\t\t// TODO: if there is more than one model associated with the geometry, AND the models have\n\t\t// different geometric transforms, then this will cause problems\n\t\t// if ( modelNodes.length > 1 ) { }\n\n\t\t// For now just assume one model and get the preRotations from that\n\t\tvar modelNode = modelNodes[0];\n\n\t\tif ('GeometricRotation' in modelNode) {\n\n\t\t\tvar array = modelNode.GeometricRotation.value.map(THREE.Math.degToRad);\n\t\t\tarray[3] = 'ZYX';\n\n\t\t\tpreTransform.makeRotationFromEuler(new THREE.Euler().fromArray(array));\n\t\t}\n\n\t\tif ('GeometricTranslation' in modelNode) {\n\n\t\t\tpreTransform.setPosition(new THREE.Vector3().fromArray(modelNode.GeometricTranslation.value));\n\t\t}\n\n\t\tif ('GeometricScaling' in modelNode) {\n\n\t\t\tpreTransform.scale(new THREE.Vector3().fromArray(modelNode.GeometricScaling.value));\n\t\t}\n\n\t\treturn genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform);\n\t}\n\n\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\tfunction genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform) {\n\n\t\tvar geo = new THREE.BufferGeometry();\n\t\tif (geoNode.attrName) geo.name = geoNode.attrName;\n\n\t\tvar geoInfo = getGeoInfo(geoNode, skeleton);\n\n\t\tvar buffers = genBuffers(geoInfo);\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute(buffers.vertex, 3);\n\n\t\tpreTransform.applyToBufferAttribute(positionAttribute);\n\n\t\tgeo.addAttribute('position', positionAttribute);\n\n\t\tif (buffers.colors.length > 0) {\n\n\t\t\tgeo.addAttribute('color', new THREE.Float32BufferAttribute(buffers.colors, 3));\n\t\t}\n\n\t\tif (skeleton) {\n\n\t\t\tgeo.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffers.weightsIndices, 4));\n\n\t\t\tgeo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffers.vertexWeights, 4));\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\t\t}\n\n\t\tif (buffers.normal.length > 0) {\n\n\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute(buffers.normal, 3);\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix(preTransform);\n\t\t\tnormalMatrix.applyToBufferAttribute(normalAttribute);\n\n\t\t\tgeo.addAttribute('normal', normalAttribute);\n\t\t}\n\n\t\tbuffers.uvs.forEach(function (uvBuffer, i) {\n\n\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\tvar name = 'uv' + (i + 1).toString();\n\n\t\t\t// the first uv buffer is just called 'uv'\n\t\t\tif (i === 0) {\n\n\t\t\t\tname = 'uv';\n\t\t\t}\n\n\t\t\tgeo.addAttribute(name, new THREE.Float32BufferAttribute(buffers.uvs[i], 2));\n\t\t});\n\n\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tvar prevMaterialIndex = buffers.materialIndex[0];\n\t\t\tvar startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach(function (currentIndex, i) {\n\n\t\t\t\tif (currentIndex !== prevMaterialIndex) {\n\n\t\t\t\t\tgeo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif (geo.groups.length > 0) {\n\n\t\t\t\tvar lastGroup = geo.groups[geo.groups.length - 1];\n\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif (lastIndex !== buffers.materialIndex.length) {\n\n\t\t\t\t\tgeo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif (geo.groups.length === 0) {\n\n\t\t\t\tgeo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n\t\t\t}\n\t\t}\n\n\t\taddMorphTargets(FBXTree, geo, geoNode, morphTarget, preTransform);\n\n\t\treturn geo;\n\t}\n\n\tfunction getGeoInfo(geoNode, skeleton) {\n\n\t\tvar geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif (geoNode.LayerElementColor) {\n\n\t\t\tgeoInfo.color = getColors(geoNode.LayerElementColor[0]);\n\t\t}\n\n\t\tif (geoNode.LayerElementMaterial) {\n\n\t\t\tgeoInfo.material = getMaterials(geoNode.LayerElementMaterial[0]);\n\t\t}\n\n\t\tif (geoNode.LayerElementNormal) {\n\n\t\t\tgeoInfo.normal = getNormals(geoNode.LayerElementNormal[0]);\n\t\t}\n\n\t\tif (geoNode.LayerElementUV) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tvar i = 0;\n\t\t\twhile (geoNode.LayerElementUV[i]) {\n\n\t\t\t\tgeoInfo.uv.push(getUVs(geoNode.LayerElementUV[i]));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif (skeleton !== null) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach(function (rawBone, i) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach(function (index, j) {\n\n\t\t\t\t\tif (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[index].push({\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[j]\n\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn geoInfo;\n\t}\n\n\tfunction genBuffers(geoInfo) {\n\n\t\tvar buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: []\n\t\t};\n\n\t\tvar polygonIndex = 0;\n\t\tvar faceLength = 0;\n\t\tvar displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tvar facePositionIndexes = [];\n\t\tvar faceNormals = [];\n\t\tvar faceColors = [];\n\t\tvar faceUVs = [];\n\t\tvar faceWeights = [];\n\t\tvar faceWeightIndices = [];\n\n\t\tgeoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n\n\t\t\tvar endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif (vertexIndex < 0) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\t\t\t}\n\n\t\t\tvar weightIndices = [];\n\t\t\tvar weights = [];\n\n\t\t\tfacePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n\t\t\tif (geoInfo.color) {\n\n\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n\n\t\t\t\tfaceColors.push(data[0], data[1], data[2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.skeleton) {\n\n\t\t\t\tif (geoInfo.weightTable[vertexIndex] !== undefined) {\n\n\t\t\t\t\tgeoInfo.weightTable[vertexIndex].forEach(function (wt) {\n\n\t\t\t\t\t\tweights.push(wt.weight);\n\t\t\t\t\t\tweightIndices.push(wt.id);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (weights.length > 4) {\n\n\t\t\t\t\tif (!displayedWeightsWarning) {\n\n\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wIndex = [0, 0, 0, 0];\n\t\t\t\t\tvar Weight = [0, 0, 0, 0];\n\n\t\t\t\t\tweights.forEach(function (weight, weightIndex) {\n\n\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\tvar currentIndex = weightIndices[weightIndex];\n\n\t\t\t\t\t\tWeight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n\n\t\t\t\t\t\t\tif (currentWeight > comparedWeight) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[comparedWeightIndex] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tvar tmp = wIndex[comparedWeightIndex];\n\t\t\t\t\t\t\t\twIndex[comparedWeightIndex] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile (weights.length < 4) {\n\n\t\t\t\t\tweights.push(0);\n\t\t\t\t\tweightIndices.push(0);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\t\tfaceWeights.push(weights[i]);\n\t\t\t\t\tfaceWeightIndices.push(weightIndices[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (geoInfo.normal) {\n\n\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n\n\t\t\t\tfaceNormals.push(data[0], data[1], data[2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t\tvar materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n\t\t\t}\n\n\t\t\tif (geoInfo.uv) {\n\n\t\t\t\tgeoInfo.uv.forEach(function (uv, i) {\n\n\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n\n\t\t\t\t\tif (faceUVs[i] === undefined) {\n\n\t\t\t\t\t\tfaceUVs[i] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[i].push(data[0]);\n\t\t\t\t\tfaceUVs[i].push(data[1]);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfaceLength++;\n\n\t\t\tif (endOfFace) {\n\n\t\t\t\tgenFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n\n\t\t\t\tpolygonIndex++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\t\t\t}\n\t\t});\n\n\t\treturn buffers;\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tfunction genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n\n\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n\n\t\t\tif (geoInfo.skeleton) {\n\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[0]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[1]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[2]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[3]);\n\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[0]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[1]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[2]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[3]);\n\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n\t\t\t}\n\n\t\t\tif (geoInfo.color) {\n\n\t\t\t\tbuffers.colors.push(faceColors[0]);\n\t\t\t\tbuffers.colors.push(faceColors[1]);\n\t\t\t\tbuffers.colors.push(faceColors[2]);\n\n\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3]);\n\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n\n\t\t\t\tbuffers.colors.push(faceColors[i * 3]);\n\t\t\t\tbuffers.colors.push(faceColors[i * 3 + 1]);\n\t\t\t\tbuffers.colors.push(faceColors[i * 3 + 2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t}\n\n\t\t\tif (geoInfo.normal) {\n\n\t\t\t\tbuffers.normal.push(faceNormals[0]);\n\t\t\t\tbuffers.normal.push(faceNormals[1]);\n\t\t\t\tbuffers.normal.push(faceNormals[2]);\n\n\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3]);\n\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n\n\t\t\t\tbuffers.normal.push(faceNormals[i * 3]);\n\t\t\t\tbuffers.normal.push(faceNormals[i * 3 + 1]);\n\t\t\t\tbuffers.normal.push(faceNormals[i * 3 + 2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.uv) {\n\n\t\t\t\tgeoInfo.uv.forEach(function (uv, j) {\n\n\t\t\t\t\tif (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][0]);\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][1]);\n\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][i * 2]);\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addMorphTargets(FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform) {\n\n\t\tif (morphTarget === null) return;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\tparentGeo.morphAttributes.normal = [];\n\n\t\tmorphTarget.rawTargets.forEach(function (rawTarget) {\n\n\t\t\tvar morphGeoNode = FBXTree.Objects.Geometry[rawTarget.geoID];\n\n\t\t\tif (morphGeoNode !== undefined) {\n\n\t\t\t\tgenMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform);\n\t\t\t}\n\t\t});\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tfunction genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform) {\n\n\t\tvar morphGeo = new THREE.BufferGeometry();\n\t\tif (morphGeoNode.attrName) morphGeo.name = morphGeoNode.attrName;\n\n\t\tvar vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t// make a copy of the parent's vertex positions\n\t\tvar vertexPositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a.slice() : [];\n\n\t\tvar morphPositions = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n\t\tvar indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n\n\t\tfor (var i = 0; i < indices.length; i++) {\n\n\t\t\tvar morphIndex = indices[i] * 3;\n\n\t\t\t// FBX format uses blend shapes rather than morph targets. This can be converted\n\t\t\t// by additively combining the blend shape positions with the original geometry's positions\n\t\t\tvertexPositions[morphIndex] += morphPositions[i * 3];\n\t\t\tvertexPositions[morphIndex + 1] += morphPositions[i * 3 + 1];\n\t\t\tvertexPositions[morphIndex + 2] += morphPositions[i * 3 + 2];\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tvar morphGeoInfo = {\n\t\t\tvertexIndices: vertexIndices,\n\t\t\tvertexPositions: vertexPositions\n\t\t};\n\n\t\tvar morphBuffers = genBuffers(morphGeoInfo);\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute(morphBuffers.vertex, 3);\n\t\tpositionAttribute.name = morphGeoNode.attrName;\n\n\t\tpreTransform.applyToBufferAttribute(positionAttribute);\n\n\t\tparentGeo.morphAttributes.position.push(positionAttribute);\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tfunction getNormals(NormalNode) {\n\n\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\tvar buffer = NormalNode.Normals.a;\n\t\tvar indexBuffer = [];\n\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\tif ('NormalIndex' in NormalNode) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\t\t\t} else if ('NormalsIndex' in NormalNode) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tfunction getUVs(UVNode) {\n\n\t\tvar mappingType = UVNode.MappingInformationType;\n\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\tvar buffer = UVNode.UV.a;\n\t\tvar indexBuffer = [];\n\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tfunction getColors(ColorNode) {\n\n\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\tvar buffer = ColorNode.Colors.a;\n\t\tvar indexBuffer = [];\n\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tfunction getMaterials(MaterialNode) {\n\n\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif (mappingType === 'NoMappingInformation') {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [0],\n\t\t\t\tindices: [0],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\t\t}\n\n\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tvar materialIndices = [];\n\n\t\tfor (var i = 0; i < materialIndexBuffer.length; ++i) {\n\n\t\t\tmaterialIndices.push(i);\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\tvar dataArray = [];\n\n\tfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\tvar index;\n\n\t\tswitch (infoObject.mappingType) {\n\n\t\t\tcase 'ByPolygonVertex':\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon':\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice':\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame':\n\t\t\t\tindex = infoObject.indices[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n\n\t\t}\n\n\t\tif (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tfunction parseNurbsGeometry(geoNode) {\n\n\t\tif (THREE.NURBSCurve === undefined) {\n\n\t\t\tconsole.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n\t\t\treturn new THREE.BufferGeometry();\n\t\t}\n\n\t\tvar order = parseInt(geoNode.Order);\n\n\t\tif (isNaN(order)) {\n\n\t\t\tconsole.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n\t\t\treturn new THREE.BufferGeometry();\n\t\t}\n\n\t\tvar degree = order - 1;\n\n\t\tvar knots = geoNode.KnotVector.a;\n\t\tvar controlPoints = [];\n\t\tvar pointsValues = geoNode.Points.a;\n\n\t\tfor (var i = 0, l = pointsValues.length; i < l; i += 4) {\n\n\t\t\tcontrolPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n\t\t}\n\n\t\tvar startKnot, endKnot;\n\n\t\tif (geoNode.Form === 'Closed') {\n\n\t\t\tcontrolPoints.push(controlPoints[0]);\n\t\t} else if (geoNode.Form === 'Periodic') {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor (var i = 0; i < degree; ++i) {\n\n\t\t\t\tcontrolPoints.push(controlPoints[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n\t\tvar vertices = curve.getPoints(controlPoints.length * 7);\n\n\t\tvar positions = new Float32Array(vertices.length * 3);\n\n\t\tvertices.forEach(function (vertex, i) {\n\n\t\t\tvertex.toArray(positions, i * 3);\n\t\t});\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n\t\treturn geometry;\n\t}\n\n\t// create the main THREE.Group() to be returned by the loader\n\tfunction parseScene(FBXTree, connections, skeletons, geometryMap, materialMap) {\n\n\t\tvar sceneGraph = new THREE.Group();\n\n\t\tvar modelMap = parseModels(FBXTree, skeletons, geometryMap, materialMap, connections);\n\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tmodelMap.forEach(function (model) {\n\n\t\t\tvar modelNode = modelNodes[model.ID];\n\t\t\tsetLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph);\n\n\t\t\tvar parentConnections = connections.get(model.ID).parents;\n\n\t\t\tparentConnections.forEach(function (connection) {\n\n\t\t\t\tvar parent = modelMap.get(connection.ID);\n\t\t\t\tif (parent !== undefined) parent.add(model);\n\t\t\t});\n\n\t\t\tif (model.parent === null) {\n\n\t\t\t\tsceneGraph.add(model);\n\t\t\t}\n\t\t});\n\n\t\tbindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections);\n\n\t\taddAnimations(FBXTree, connections, sceneGraph);\n\n\t\tcreateAmbientLight(FBXTree, sceneGraph);\n\n\t\treturn sceneGraph;\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tfunction parseModels(FBXTree, skeletons, geometryMap, materialMap, connections) {\n\n\t\tvar modelMap = new Map();\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tfor (var nodeID in modelNodes) {\n\n\t\t\tvar id = parseInt(nodeID);\n\t\t\tvar node = modelNodes[nodeID];\n\t\t\tvar relationships = connections.get(id);\n\n\t\t\tvar model = buildSkeleton(relationships, skeletons, id, node.attrName);\n\n\t\t\tif (!model) {\n\n\t\t\t\tswitch (node.attrType) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = createCamera(FBXTree, relationships);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = createLight(FBXTree, relationships);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = createMesh(FBXTree, relationships, geometryMap, materialMap);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = createCurve(relationships, geometryMap);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n\t\t\t\tmodel.ID = id;\n\t\t\t}\n\n\t\t\tsetModelTransforms(FBXTree, model, node);\n\t\t\tmodelMap.set(id, model);\n\t\t}\n\n\t\treturn modelMap;\n\t}\n\n\tfunction buildSkeleton(relationships, skeletons, id, name) {\n\n\t\tvar bone = null;\n\n\t\trelationships.parents.forEach(function (parent) {\n\n\t\t\tfor (var ID in skeletons) {\n\n\t\t\t\tvar skeleton = skeletons[ID];\n\n\t\t\t\tskeleton.rawBones.forEach(function (rawBone, i) {\n\n\t\t\t\t\tif (rawBone.ID === parent.ID) {\n\n\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\t\tbone.matrixWorld.copy(rawBone.transformLink);\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\t\t\t\t\t\tbone.name = THREE.PropertyBinding.sanitizeNodeName(name);\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[i] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif (subBone !== null) {\n\n\t\t\t\t\t\t\tbone.add(subBone);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn bone;\n\t}\n\n\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\tfunction createCamera(FBXTree, relationships) {\n\n\t\tvar model;\n\t\tvar cameraAttribute;\n\n\t\trelationships.children.forEach(function (child) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n\t\t\tif (attr !== undefined) {\n\n\t\t\t\tcameraAttribute = attr;\n\t\t\t}\n\t\t});\n\n\t\tif (cameraAttribute === undefined) {\n\n\t\t\tmodel = new THREE.Object3D();\n\t\t} else {\n\n\t\t\tvar type = 0;\n\t\t\tif (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n\n\t\t\t\ttype = 1;\n\t\t\t}\n\n\t\t\tvar nearClippingPlane = 1;\n\t\t\tif (cameraAttribute.NearPlane !== undefined) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\t\t\t}\n\n\t\t\tvar farClippingPlane = 1000;\n\t\t\tif (cameraAttribute.FarPlane !== undefined) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\t\t\t}\n\n\t\t\tvar width = window.innerWidth;\n\t\t\tvar height = window.innerHeight;\n\n\t\t\tif (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\t\t\t}\n\n\t\t\tvar aspect = width / height;\n\n\t\t\tvar fov = 45;\n\t\t\tif (cameraAttribute.FieldOfView !== undefined) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\t\t\t}\n\n\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\t// Perspective\n\t\t\t\t\tmodel = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n\t\t\t\t\tif (focalLength !== null) model.setFocalLength(focalLength);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\t// Orthographic\n\t\t\t\t\tmodel = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t}\n\n\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\tfunction createLight(FBXTree, relationships) {\n\n\t\tvar model;\n\t\tvar lightAttribute;\n\n\t\trelationships.children.forEach(function (child) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n\t\t\tif (attr !== undefined) {\n\n\t\t\t\tlightAttribute = attr;\n\t\t\t}\n\t\t});\n\n\t\tif (lightAttribute === undefined) {\n\n\t\t\tmodel = new THREE.Object3D();\n\t\t} else {\n\n\t\t\tvar type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif (lightAttribute.LightType === undefined) {\n\n\t\t\t\ttype = 0;\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\t\t\t}\n\n\t\t\tvar color = 0xffffff;\n\n\t\t\tif (lightAttribute.Color !== undefined) {\n\n\t\t\t\tcolor = new THREE.Color().fromArray(lightAttribute.Color.value);\n\t\t\t}\n\n\t\t\tvar intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n\n\t\t\t\tintensity = 0;\n\t\t\t}\n\n\t\t\tvar distance = 0;\n\t\t\tif (lightAttribute.FarAttenuationEnd !== undefined) {\n\n\t\t\t\tif (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n\n\t\t\t\t\tdistance = 0;\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tvar decay = 1;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\t// Point\n\t\t\t\t\tmodel = new THREE.PointLight(color, intensity, distance, decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\t// Directional\n\t\t\t\t\tmodel = new THREE.DirectionalLight(color, intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\t// Spot\n\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\tif (lightAttribute.InnerAngle !== undefined) {\n\n\t\t\t\t\t\tangle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\tif (lightAttribute.OuterAngle !== undefined) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n\t\t\t\t\t\tpenumbra = Math.max(penumbra, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n\t\t\t\t\tmodel = new THREE.PointLight(color, intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n\n\t\t\t\tmodel.castShadow = true;\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tfunction createMesh(FBXTree, relationships, geometryMap, materialMap) {\n\n\t\tvar model;\n\t\tvar geometry = null;\n\t\tvar material = null;\n\t\tvar materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach(function (child) {\n\n\t\t\tif (geometryMap.has(child.ID)) {\n\n\t\t\t\tgeometry = geometryMap.get(child.ID);\n\t\t\t}\n\n\t\t\tif (materialMap.has(child.ID)) {\n\n\t\t\t\tmaterials.push(materialMap.get(child.ID));\n\t\t\t}\n\t\t});\n\n\t\tif (materials.length > 1) {\n\n\t\t\tmaterial = materials;\n\t\t} else if (materials.length > 0) {\n\n\t\t\tmaterial = materials[0];\n\t\t} else {\n\n\t\t\tmaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });\n\t\t\tmaterials.push(material);\n\t\t}\n\n\t\tif ('color' in geometry.attributes) {\n\n\t\t\tmaterials.forEach(function (material) {\n\n\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\t\t\t});\n\t\t}\n\n\t\tif (geometry.FBX_Deformer) {\n\n\t\t\tmaterials.forEach(function (material) {\n\n\t\t\t\tmaterial.skinning = true;\n\t\t\t});\n\n\t\t\tmodel = new THREE.SkinnedMesh(geometry, material);\n\t\t} else {\n\n\t\t\tmodel = new THREE.Mesh(geometry, material);\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tfunction createCurve(relationships, geometryMap) {\n\n\t\tvar geometry = relationships.children.reduce(function (geo, child) {\n\n\t\t\tif (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n\n\t\t\treturn geo;\n\t\t}, null);\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tvar material = new THREE.LineBasicMaterial({ color: 0x3300ff, linewidth: 1 });\n\t\treturn new THREE.Line(geometry, material);\n\t}\n\n\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\tfunction createAmbientLight(FBXTree, sceneGraph) {\n\n\t\tif ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings) {\n\n\t\t\tvar ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n\t\t\tvar r = ambientColor[0];\n\t\t\tvar g = ambientColor[1];\n\t\t\tvar b = ambientColor[2];\n\n\t\t\tif (r !== 0 || g !== 0 || b !== 0) {\n\n\t\t\t\tvar color = new THREE.Color(r, g, b);\n\t\t\t\tsceneGraph.add(new THREE.AmbientLight(color, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph) {\n\n\t\tif ('LookAtProperty' in modelNode) {\n\n\t\t\tvar children = connections.get(model.ID).children;\n\n\t\t\tchildren.forEach(function (child) {\n\n\t\t\t\tif (child.relationship === 'LookAtProperty') {\n\n\t\t\t\t\tvar lookAtTarget = FBXTree.Objects.Model[child.ID];\n\n\t\t\t\t\tif ('Lcl_Translation' in lookAtTarget) {\n\n\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif (model.target !== undefined) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray(pos);\n\t\t\t\t\t\t\tsceneGraph.add(model.target);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt(new THREE.Vector3().fromArray(pos));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t// parse the model node for transform details and apply them to the model\n\tfunction setModelTransforms(FBXTree, model, modelNode) {\n\n\t\t// http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\tif ('RotationOrder' in modelNode) {\n\n\t\t\tvar enums = ['XYZ', // default\n\t\t\t'XZY', 'YZX', 'ZXY', 'YXZ', 'ZYX', 'SphericXYZ'];\n\n\t\t\tvar value = parseInt(modelNode.RotationOrder.value, 10);\n\n\t\t\tif (value > 0 && value < 6) {\n\n\t\t\t\t// model.rotation.order = enums[ value ];\n\n\t\t\t\t// Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n\t\t\t\tconsole.warn('THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[value]);\n\t\t\t} else if (value === 6) {\n\n\t\t\t\tconsole.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n\t\t\t}\n\t\t}\n\n\t\tif ('Lcl_Translation' in modelNode) {\n\n\t\t\tmodel.position.fromArray(modelNode.Lcl_Translation.value);\n\t\t}\n\n\t\tif ('Lcl_Rotation' in modelNode) {\n\n\t\t\tvar rotation = modelNode.Lcl_Rotation.value.map(THREE.Math.degToRad);\n\t\t\trotation.push('ZYX');\n\t\t\tmodel.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));\n\t\t}\n\n\t\tif ('Lcl_Scaling' in modelNode) {\n\n\t\t\tmodel.scale.fromArray(modelNode.Lcl_Scaling.value);\n\t\t}\n\n\t\tif ('PreRotation' in modelNode) {\n\n\t\t\tvar array = modelNode.PreRotation.value.map(THREE.Math.degToRad);\n\t\t\tarray[3] = 'ZYX';\n\n\t\t\tvar preRotations = new THREE.Euler().fromArray(array);\n\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler(preRotations);\n\t\t\tmodel.quaternion.premultiply(preRotations);\n\t\t}\n\t}\n\n\tfunction bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections) {\n\n\t\tvar bindMatrices = parsePoseNodes(FBXTree);\n\n\t\tfor (var ID in skeletons) {\n\n\t\t\tvar skeleton = skeletons[ID];\n\n\t\t\tvar parents = connections.get(parseInt(skeleton.ID)).parents;\n\n\t\t\tparents.forEach(function (parent) {\n\n\t\t\t\tif (geometryMap.has(parent.ID)) {\n\n\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\tvar geoRelationships = connections.get(geoID);\n\n\t\t\t\t\tgeoRelationships.parents.forEach(function (geoConnParent) {\n\n\t\t\t\t\t\tif (modelMap.has(geoConnParent.ID)) {\n\n\t\t\t\t\t\t\tvar model = modelMap.get(geoConnParent.ID);\n\n\t\t\t\t\t\t\tmodel.bind(new THREE.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction parsePoseNodes(FBXTree) {\n\n\t\tvar bindMatrices = {};\n\n\t\tif ('Pose' in FBXTree.Objects) {\n\n\t\t\tvar BindPoseNode = FBXTree.Objects.Pose;\n\n\t\t\tfor (var nodeID in BindPoseNode) {\n\n\t\t\t\tif (BindPoseNode[nodeID].attrType === 'BindPose') {\n\n\t\t\t\t\tvar poseNodes = BindPoseNode[nodeID].PoseNode;\n\n\t\t\t\t\tif (Array.isArray(poseNodes)) {\n\n\t\t\t\t\t\tposeNodes.forEach(function (poseNode) {\n\n\t\t\t\t\t\t\tbindMatrices[poseNode.Node] = new THREE.Matrix4().fromArray(poseNode.Matrix.a);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[poseNodes.Node] = new THREE.Matrix4().fromArray(poseNodes.Matrix.a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bindMatrices;\n\t}\n\n\tfunction parseAnimations(FBXTree, connections) {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif (FBXTree.Objects.AnimationCurve === undefined) return undefined;\n\n\t\tvar curveNodesMap = parseAnimationCurveNodes(FBXTree);\n\n\t\tparseAnimationCurves(FBXTree, connections, curveNodesMap);\n\n\t\tvar layersMap = parseAnimationLayers(FBXTree, connections, curveNodesMap);\n\t\tvar rawClips = parseAnimStacks(FBXTree, connections, layersMap);\n\n\t\treturn rawClips;\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tfunction parseAnimationCurveNodes(FBXTree) {\n\n\t\tvar rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n\n\t\tvar curveNodesMap = new Map();\n\n\t\tfor (var nodeID in rawCurveNodes) {\n\n\t\t\tvar rawCurveNode = rawCurveNodes[nodeID];\n\n\t\t\tif (rawCurveNode.attrName.match(/S|R|T/) !== null) {\n\n\t\t\t\tvar curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {}\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set(curveNode.id, curveNode);\n\t\t\t}\n\t\t}\n\n\t\treturn curveNodesMap;\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tfunction parseAnimationCurves(FBXTree, connections, curveNodesMap) {\n\n\t\tvar rawCurves = FBXTree.Objects.AnimationCurve;\n\n\t\tfor (var nodeID in rawCurves) {\n\n\t\t\tvar animationCurve = {\n\n\t\t\t\tid: rawCurves[nodeID].id,\n\t\t\t\ttimes: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n\t\t\t\tvalues: rawCurves[nodeID].KeyValueFloat.a\n\n\t\t\t};\n\n\t\t\tvar relationships = connections.get(animationCurve.id);\n\n\t\t\tif (relationships !== undefined) {\n\n\t\t\t\tvar animationCurveID = relationships.parents[0].ID;\n\t\t\t\tvar animationCurveRelationship = relationships.parents[0].relationship;\n\n\t\t\t\tif (animationCurveRelationship.match(/X/)) {\n\n\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n\t\t\t\t} else if (animationCurveRelationship.match(/Y/)) {\n\n\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n\t\t\t\t} else if (animationCurveRelationship.match(/Z/)) {\n\n\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tfunction parseAnimationLayers(FBXTree, connections, curveNodesMap) {\n\n\t\tvar rawLayers = FBXTree.Objects.AnimationLayer;\n\n\t\tvar layersMap = new Map();\n\n\t\tfor (var nodeID in rawLayers) {\n\n\t\t\tvar layerCurveNodes = [];\n\n\t\t\tvar connection = connections.get(parseInt(nodeID));\n\n\t\t\tif (connection !== undefined) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tvar children = connection.children;\n\n\t\t\t\tchildren.forEach(function (child, i) {\n\n\t\t\t\t\tif (curveNodesMap.has(child.ID)) {\n\n\t\t\t\t\t\tvar curveNode = curveNodesMap.get(child.ID);\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n\n\t\t\t\t\t\t\tif (layerCurveNodes[i] === undefined) {\n\n\t\t\t\t\t\t\t\tvar modelID;\n\n\t\t\t\t\t\t\t\tconnections.get(child.ID).parents.forEach(function (parent) {\n\n\t\t\t\t\t\t\t\t\tif (parent.relationship !== undefined) modelID = parent.ID;\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tvar rawModel = FBXTree.Objects.Model[modelID.toString()];\n\n\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),\n\t\t\t\t\t\t\t\t\tinitialPosition: [0, 0, 0],\n\t\t\t\t\t\t\t\t\tinitialRotation: [0, 0, 0],\n\t\t\t\t\t\t\t\t\tinitialScale: [1, 1, 1]\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif ('Lcl_Translation' in rawModel) node.initialPosition = rawModel.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\tif ('Lcl_Rotation' in rawModel) node.initialRotation = rawModel.Lcl_Rotation.value;\n\n\t\t\t\t\t\t\t\tif ('Lcl_Scaling' in rawModel) node.initialScale = rawModel.Lcl_Scaling.value;\n\n\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\tif ('PreRotation' in rawModel) node.preRotations = rawModel.PreRotation.value;\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[i] = node;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[i][curveNode.attr] = curveNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tlayersMap.set(parseInt(nodeID), layerCurveNodes);\n\t\t\t}\n\t\t}\n\n\t\treturn layersMap;\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\tfunction parseAnimStacks(FBXTree, connections, layersMap) {\n\n\t\tvar rawStacks = FBXTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tvar rawClips = {};\n\n\t\tfor (var nodeID in rawStacks) {\n\n\t\t\tvar children = connections.get(parseInt(nodeID)).children;\n\n\t\t\tif (children.length > 1) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n\t\t\t}\n\n\t\t\tvar layer = layersMap.get(children[0].ID);\n\n\t\t\trawClips[nodeID] = {\n\n\t\t\t\tname: rawStacks[nodeID].attrName,\n\t\t\t\tlayer: layer\n\n\t\t\t};\n\t\t}\n\n\t\treturn rawClips;\n\t}\n\n\t// take raw animation data from parseAnimations and connect it up to the loaded models\n\tfunction addAnimations(FBXTree, connections, sceneGraph) {\n\n\t\tsceneGraph.animations = [];\n\n\t\tvar rawClips = parseAnimations(FBXTree, connections);\n\n\t\tif (rawClips === undefined) return;\n\n\t\tfor (var key in rawClips) {\n\n\t\t\tvar rawClip = rawClips[key];\n\n\t\t\tvar clip = addClip(rawClip);\n\n\t\t\tsceneGraph.animations.push(clip);\n\t\t}\n\t}\n\n\tfunction addClip(rawClip) {\n\n\t\tvar tracks = [];\n\n\t\trawClip.layer.forEach(function (rawTracks) {\n\n\t\t\ttracks = tracks.concat(generateTracks(rawTracks));\n\t\t});\n\n\t\treturn new THREE.AnimationClip(rawClip.name, -1, tracks);\n\t}\n\n\tfunction generateTracks(rawTracks) {\n\n\t\tvar tracks = [];\n\n\t\tif (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n\n\t\t\tvar positionTrack = generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position');\n\t\t\tif (positionTrack !== undefined) tracks.push(positionTrack);\n\t\t}\n\n\t\tif (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n\n\t\t\tvar rotationTrack = generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations);\n\t\t\tif (rotationTrack !== undefined) tracks.push(rotationTrack);\n\t\t}\n\n\t\tif (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n\n\t\t\tvar scaleTrack = generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale');\n\t\t\tif (scaleTrack !== undefined) tracks.push(scaleTrack);\n\t\t}\n\n\t\treturn tracks;\n\t}\n\n\tfunction generateVectorTrack(modelName, curves, initialValue, type) {\n\n\t\tvar times = getTimesForAllAxes(curves);\n\t\tvar values = getKeyframeTrackValues(times, curves, initialValue);\n\n\t\treturn new THREE.VectorKeyframeTrack(modelName + '.' + type, times, values);\n\t}\n\n\tfunction generateRotationTrack(modelName, curves, initialValue, preRotations) {\n\n\t\tif (curves.x !== undefined) {\n\n\t\t\tinterpolateRotations(curves.x);\n\t\t\tcurves.x.values = curves.x.values.map(THREE.Math.degToRad);\n\t\t}\n\t\tif (curves.y !== undefined) {\n\n\t\t\tinterpolateRotations(curves.y);\n\t\t\tcurves.y.values = curves.y.values.map(THREE.Math.degToRad);\n\t\t}\n\t\tif (curves.z !== undefined) {\n\n\t\t\tinterpolateRotations(curves.z);\n\t\t\tcurves.z.values = curves.z.values.map(THREE.Math.degToRad);\n\t\t}\n\n\t\tvar times = getTimesForAllAxes(curves);\n\t\tvar values = getKeyframeTrackValues(times, curves, initialValue);\n\n\t\tif (preRotations !== undefined) {\n\n\t\t\tpreRotations = preRotations.map(THREE.Math.degToRad);\n\t\t\tpreRotations.push('ZYX');\n\n\t\t\tpreRotations = new THREE.Euler().fromArray(preRotations);\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler(preRotations);\n\t\t}\n\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar quaternionValues = [];\n\n\t\tfor (var i = 0; i < values.length; i += 3) {\n\n\t\t\teuler.set(values[i], values[i + 1], values[i + 2], 'ZYX');\n\n\t\t\tquaternion.setFromEuler(euler);\n\n\t\t\tif (preRotations !== undefined) quaternion.premultiply(preRotations);\n\n\t\t\tquaternion.toArray(quaternionValues, i / 3 * 4);\n\t\t}\n\n\t\treturn new THREE.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n\t}\n\n\tfunction getKeyframeTrackValues(times, curves, initialValue) {\n\n\t\tvar prevValue = initialValue;\n\n\t\tvar values = [];\n\n\t\tvar xIndex = -1;\n\t\tvar yIndex = -1;\n\t\tvar zIndex = -1;\n\n\t\ttimes.forEach(function (time) {\n\n\t\t\tif (curves.x) xIndex = curves.x.times.indexOf(time);\n\t\t\tif (curves.y) yIndex = curves.y.times.indexOf(time);\n\t\t\tif (curves.z) zIndex = curves.z.times.indexOf(time);\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif (xIndex !== -1) {\n\n\t\t\t\tvar xValue = curves.x.values[xIndex];\n\t\t\t\tvalues.push(xValue);\n\t\t\t\tprevValue[0] = xValue;\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push(prevValue[0]);\n\t\t\t}\n\n\t\t\tif (yIndex !== -1) {\n\n\t\t\t\tvar yValue = curves.y.values[yIndex];\n\t\t\t\tvalues.push(yValue);\n\t\t\t\tprevValue[1] = yValue;\n\t\t\t} else {\n\n\t\t\t\tvalues.push(prevValue[1]);\n\t\t\t}\n\n\t\t\tif (zIndex !== -1) {\n\n\t\t\t\tvar zValue = curves.z.values[zIndex];\n\t\t\t\tvalues.push(zValue);\n\t\t\t\tprevValue[2] = zValue;\n\t\t\t} else {\n\n\t\t\t\tvalues.push(prevValue[2]);\n\t\t\t}\n\t\t});\n\n\t\treturn values;\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tfunction getTimesForAllAxes(curves) {\n\n\t\tvar times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif (curves.x !== undefined) times = times.concat(curves.x.times);\n\t\tif (curves.y !== undefined) times = times.concat(curves.y.times);\n\t\tif (curves.z !== undefined) times = times.concat(curves.z.times);\n\n\t\t// then sort them and remove duplicates\n\t\ttimes = times.sort(function (a, b) {\n\n\t\t\treturn a - b;\n\t\t}).filter(function (elem, index, array) {\n\n\t\t\treturn array.indexOf(elem) == index;\n\t\t});\n\n\t\treturn times;\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tfunction interpolateRotations(curve) {\n\n\t\tfor (var i = 1; i < curve.values.length; i++) {\n\n\t\t\tvar initialValue = curve.values[i - 1];\n\t\t\tvar valuesSpan = curve.values[i] - initialValue;\n\n\t\t\tvar absoluteSpan = Math.abs(valuesSpan);\n\n\t\t\tif (absoluteSpan >= 180) {\n\n\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\tvar initialTime = curve.times[i - 1];\n\t\t\t\tvar timeSpan = curve.times[i] - initialTime;\n\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\twhile (nextTime < curve.times[i]) {\n\n\t\t\t\t\tinterpolatedTimes.push(nextTime);\n\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\tinterpolatedValues.push(nextValue);\n\t\t\t\t\tnextValue += step;\n\t\t\t\t}\n\n\t\t\t\tcurve.times = inject(curve.times, i, interpolatedTimes);\n\t\t\t\tcurve.values = inject(curve.values, i, interpolatedValues);\n\t\t\t}\n\t\t}\n\t}\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tObject.assign(TextParser.prototype, {\n\n\t\tgetPrevNode: function getPrevNode() {\n\n\t\t\treturn this.nodeStack[this.currentIndent - 2];\n\t\t},\n\n\t\tgetCurrentNode: function getCurrentNode() {\n\n\t\t\treturn this.nodeStack[this.currentIndent - 1];\n\t\t},\n\n\t\tgetCurrentProp: function getCurrentProp() {\n\n\t\t\treturn this.currentProp;\n\t\t},\n\n\t\tpushStack: function pushStack(node) {\n\n\t\t\tthis.nodeStack.push(node);\n\t\t\tthis.currentIndent += 1;\n\t\t},\n\n\t\tpopStack: function popStack() {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\t\t},\n\n\t\tsetCurrentProp: function setCurrentProp(val, name) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\t\t},\n\n\t\tparse: function parse(text) {\n\n\t\t\tthis.currentIndent = 0;\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar self = this;\n\n\t\t\tvar split = text.split('\\n');\n\n\t\t\tsplit.forEach(function (line, i) {\n\n\t\t\t\tvar matchComment = line.match(/^[\\s\\t]*;/);\n\t\t\t\tvar matchEmpty = line.match(/^[\\s\\t]*$/);\n\n\t\t\t\tif (matchComment || matchEmpty) return;\n\n\t\t\t\tvar matchBeginning = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '');\n\t\t\t\tvar matchProperty = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n\t\t\t\tvar matchEnd = line.match('^\\\\t{' + (self.currentIndent - 1) + '}}');\n\n\t\t\t\tif (matchBeginning) {\n\n\t\t\t\t\tself.parseNodeBegin(line, matchBeginning);\n\t\t\t\t} else if (matchProperty) {\n\n\t\t\t\t\tself.parseNodeProperty(line, matchProperty, split[++i]);\n\t\t\t\t} else if (matchEnd) {\n\n\t\t\t\t\tself.popStack();\n\t\t\t\t} else if (line.match(/^[^\\s\\t}]/)) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tself.parseNodePropertyContinued(line);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn this.allNodes;\n\t\t},\n\n\t\tparseNodeBegin: function parseNodeBegin(line, property) {\n\n\t\t\tvar nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n\n\t\t\tvar nodeAttrs = property[2].split(',').map(function (attr) {\n\n\t\t\t\treturn attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n\t\t\t});\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr(nodeAttrs);\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif (this.currentIndent === 0) {\n\n\t\t\t\tthis.allNodes.add(nodeName, node);\n\t\t\t} else {\n\t\t\t\t// a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif (nodeName in currentNode) {\n\n\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif (nodeName === 'PoseNode') {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push(node);\n\t\t\t\t\t} else if (currentNode[nodeName].id !== undefined) {\n\n\t\t\t\t\t\tcurrentNode[nodeName] = {};\n\t\t\t\t\t\tcurrentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n\t\t\t\t} else if (typeof attrs.id === 'number') {\n\n\t\t\t\t\tcurrentNode[nodeName] = {};\n\t\t\t\t\tcurrentNode[nodeName][attrs.id] = node;\n\t\t\t\t} else if (nodeName !== 'Properties70') {\n\n\t\t\t\t\tif (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof attrs.id === 'number') node.id = attrs.id;\n\t\t\tif (attrs.name !== '') node.attrName = attrs.name;\n\t\t\tif (attrs.type !== '') node.attrType = attrs.type;\n\n\t\t\tthis.pushStack(node);\n\t\t},\n\n\t\tparseNodeAttr: function parseNodeAttr(attrs) {\n\n\t\t\tvar id = attrs[0];\n\n\t\t\tif (attrs[0] !== '') {\n\n\t\t\t\tid = parseInt(attrs[0]);\n\n\t\t\t\tif (isNaN(id)) {\n\n\t\t\t\t\tid = attrs[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar name = '',\n\t\t\t    type = '';\n\n\t\t\tif (attrs.length > 1) {\n\n\t\t\t\tname = attrs[1].replace(/^(\\w+)::/, '');\n\t\t\t\ttype = attrs[2];\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\t\t},\n\n\t\tparseNodeProperty: function parseNodeProperty(line, property, contentLine) {\n\n\t\t\tvar propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n\t\t\tvar propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif (propName === 'Content' && propValue === ',') {\n\n\t\t\t\tpropValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif (parentName === 'Properties70') {\n\n\t\t\t\tthis.parseNodeSpecialProperty(line, propName, propValue);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif (propName === 'C') {\n\n\t\t\t\tvar connProps = propValue.split(',').slice(1);\n\t\t\t\tvar from = parseInt(connProps[0]);\n\t\t\t\tvar to = parseInt(connProps[1]);\n\n\t\t\t\tvar rest = propValue.split(',').slice(3);\n\n\t\t\t\trest = rest.map(function (elem) {\n\n\t\t\t\t\treturn elem.trim().replace(/^\"/, '');\n\t\t\t\t});\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [from, to];\n\t\t\t\tappend(propValue, rest);\n\n\t\t\t\tif (currentNode[propName] === undefined) {\n\n\t\t\t\t\tcurrentNode[propName] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif (propName === 'Node') currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif (propName in currentNode && Array.isArray(currentNode[propName])) {\n\n\t\t\t\tcurrentNode[propName].push(propValue);\n\t\t\t} else {\n\n\t\t\t\tif (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n\t\t\t}\n\n\t\t\tthis.setCurrentProp(currentNode, propName);\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif (propName === 'a' && propValue.slice(-1) !== ',') {\n\n\t\t\t\tcurrentNode.a = parseNumberArray(propValue);\n\t\t\t}\n\t\t},\n\n\t\tparseNodePropertyContinued: function parseNodePropertyContinued(line) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif (line.slice(-1) !== ',') {\n\n\t\t\t\tcurrentNode.a = parseNumberArray(currentNode.a);\n\t\t\t}\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function parseNodeSpecialProperty(line, propName, propValue) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split('\",').map(function (prop) {\n\n\t\t\t\treturn prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n\t\t\t});\n\n\t\t\tvar innerPropName = props[0];\n\t\t\tvar innerPropType1 = props[1];\n\t\t\tvar innerPropType2 = props[2];\n\t\t\tvar innerPropFlag = props[3];\n\t\t\tvar innerPropValue = props[4];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch (innerPropType1) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat(innerPropValue);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray(innerPropValue);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[innerPropName] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp(this.getPrevNode(), innerPropName);\n\t\t}\n\n\t});\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tObject.assign(BinaryParser.prototype, {\n\n\t\tparse: function parse(buffer) {\n\n\t\t\tvar reader = new BinaryReader(buffer);\n\t\t\treader.skip(23); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tconsole.log('THREE.FBXLoader: FBX binary version: ' + version);\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile (!this.endOfContent(reader)) {\n\n\t\t\t\tvar node = this.parseNode(reader, version);\n\t\t\t\tif (node !== null) allNodes.add(node.name, node);\n\t\t\t}\n\n\t\t\treturn allNodes;\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function endOfContent(reader) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif (reader.size() % 16 === 0) {\n\n\t\t\t\treturn (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\t\t\t}\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function parseNode(reader, version) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\tvar propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString(nameLen);\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif (endOffset === 0) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor (var i = 0; i < numProperties; i++) {\n\n\t\t\t\tpropertyList.push(this.parseProperty(reader));\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[0] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[1] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[2] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n\n\t\t\twhile (endOffset > reader.getOffset()) {\n\n\t\t\t\tvar subNode = this.parseNode(reader, version);\n\n\t\t\t\tif (subNode !== null) this.parseSubNode(name, node, subNode);\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif (typeof id === 'number') node.id = id;\n\t\t\tif (attrName !== '') node.attrName = attrName;\n\t\t\tif (attrType !== '') node.attrType = attrType;\n\t\t\tif (name !== '') node.name = name;\n\n\t\t\treturn node;\n\t\t},\n\n\t\tparseSubNode: function parseSubNode(name, node, subNode) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif (subNode.singleProperty === true) {\n\n\t\t\t\tvar value = subNode.propertyList[0];\n\n\t\t\t\tif (Array.isArray(value)) {\n\n\t\t\t\t\tnode[subNode.name] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[subNode.name] = value;\n\t\t\t\t}\n\t\t\t} else if (name === 'Connections' && subNode.name === 'C') {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach(function (property, i) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif (i !== 0) array.push(property);\n\t\t\t\t});\n\n\t\t\t\tif (node.connections === undefined) {\n\n\t\t\t\t\tnode.connections = [];\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push(array);\n\t\t\t} else if (subNode.name === 'Properties70') {\n\n\t\t\t\tvar keys = Object.keys(subNode);\n\n\t\t\t\tkeys.forEach(function (key) {\n\n\t\t\t\t\tnode[key] = subNode[key];\n\t\t\t\t});\n\t\t\t} else if (name === 'Properties70' && subNode.name === 'P') {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[0];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[1];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[2];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[3];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n\t\t\t\tif (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n\t\t\t\tif (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n\n\t\t\t\t\tinnerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[4];\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[innerPropName] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\t\t\t} else if (node[subNode.name] === undefined) {\n\n\t\t\t\tif (typeof subNode.id === 'number') {\n\n\t\t\t\t\tnode[subNode.name] = {};\n\t\t\t\t\tnode[subNode.name][subNode.id] = subNode;\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[subNode.name] = subNode;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (subNode.name === 'PoseNode') {\n\n\t\t\t\t\tif (!Array.isArray(node[subNode.name])) {\n\n\t\t\t\t\t\tnode[subNode.name] = [node[subNode.name]];\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[subNode.name].push(subNode);\n\t\t\t\t} else if (node[subNode.name][subNode.id] === undefined) {\n\n\t\t\t\t\tnode[subNode.name][subNode.id] = subNode;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tparseProperty: function parseProperty(reader) {\n\n\t\t\tvar type = reader.getString(1);\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer(length);\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString(length);\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif (encoding === 0) {\n\n\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray(arrayLength);\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array(arrayLength);\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array(arrayLength);\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array(arrayLength);\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array(arrayLength);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (window.Zlib === undefined) {\n\n\t\t\t\t\t\tconsole.error('THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js');\n\t\t\t\t\t}\n\n\t\t\t\t\tvar inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader(inflate.decompress().buffer);\n\n\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray(arrayLength);\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array(arrayLength);\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array(arrayLength);\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array(arrayLength);\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array(arrayLength);\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown property type ' + type);\n\n\t\t\t}\n\t\t}\n\n\t});\n\n\tfunction BinaryReader(buffer, littleEndian) {\n\n\t\tthis.dv = new DataView(buffer);\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = littleEndian !== undefined ? littleEndian : true;\n\t}\n\n\tObject.assign(BinaryReader.prototype, {\n\n\t\tgetOffset: function getOffset() {\n\n\t\t\treturn this.offset;\n\t\t},\n\n\t\tsize: function size() {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\t\t},\n\n\t\tskip: function skip(length) {\n\n\t\t\tthis.offset += length;\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function getBoolean() {\n\n\t\t\treturn (this.getUint8() & 1) === 1;\n\t\t},\n\n\t\tgetBooleanArray: function getBooleanArray(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getBoolean());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetUint8: function getUint8() {\n\n\t\t\tvar value = this.dv.getUint8(this.offset);\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetInt16: function getInt16() {\n\n\t\t\tvar value = this.dv.getInt16(this.offset, this.littleEndian);\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetInt32: function getInt32() {\n\n\t\t\tvar value = this.dv.getInt32(this.offset, this.littleEndian);\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetInt32Array: function getInt32Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getInt32());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetUint32: function getUint32() {\n\n\t\t\tvar value = this.dv.getUint32(this.offset, this.littleEndian);\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function getInt64() {\n\n\t\t\tvar low, high;\n\n\t\t\tif (this.littleEndian) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif (high & 0x80000000) {\n\n\t\t\t\thigh = ~high & 0xFFFFFFFF;\n\t\t\t\tlow = ~low & 0xFFFFFFFF;\n\n\t\t\t\tif (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n\n\t\t\t\tlow = low + 1 & 0xFFFFFFFF;\n\n\t\t\t\treturn -(high * 0x100000000 + low);\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\t\t},\n\n\t\tgetInt64Array: function getInt64Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getInt64());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function getUint64() {\n\n\t\t\tvar low, high;\n\n\t\t\tif (this.littleEndian) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\t\t},\n\n\t\tgetFloat32: function getFloat32() {\n\n\t\t\tvar value = this.dv.getFloat32(this.offset, this.littleEndian);\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetFloat32Array: function getFloat32Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getFloat32());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetFloat64: function getFloat64() {\n\n\t\t\tvar value = this.dv.getFloat64(this.offset, this.littleEndian);\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetFloat64Array: function getFloat64Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getFloat64());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetArrayBuffer: function getArrayBuffer(size) {\n\n\t\t\tvar value = this.dv.buffer.slice(this.offset, this.offset + size);\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetString: function getString(size) {\n\n\t\t\tvar a = new Uint8Array(size);\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta[i] = this.getUint8();\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf(0);\n\t\t\tif (nullByte >= 0) a = a.slice(0, nullByte);\n\n\t\t\treturn THREE.LoaderUtils.decodeText(a);\n\t\t}\n\n\t});\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tObject.assign(FBXTree.prototype, {\n\n\t\tadd: function add(key, val) {\n\n\t\t\tthis[key] = val;\n\t\t}\n\n\t});\n\n\tfunction isFbxFormatBinary(buffer) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n\t}\n\n\tfunction isFbxFormatASCII(text) {\n\n\t\tvar CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read(offset) {\n\n\t\t\tvar result = text[offset - 1];\n\t\t\ttext = text.slice(cursor + offset);\n\t\t\tcursor++;\n\t\t\treturn result;\n\t\t}\n\n\t\tfor (var i = 0; i < CORRECT.length; ++i) {\n\n\t\t\tvar num = read(1);\n\t\t\tif (num === CORRECT[i]) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction getFbxVersion(text) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match(versionRegExp);\n\t\tif (match) {\n\n\t\t\tvar version = parseInt(match[1]);\n\t\t\treturn version;\n\t\t}\n\t\tthrow new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds(time) {\n\n\t\treturn time / 46186158000;\n\t}\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray(value) {\n\n\t\tvar array = value.split(',').map(function (val) {\n\n\t\t\treturn parseFloat(val);\n\t\t});\n\n\t\treturn array;\n\t}\n\n\tfunction convertArrayBufferToString(buffer, from, to) {\n\n\t\tif (from === undefined) from = 0;\n\t\tif (to === undefined) to = buffer.byteLength;\n\n\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n\t}\n\n\tfunction append(a, b) {\n\n\t\tfor (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n\n\t\t\ta[j] = b[i];\n\t\t}\n\t}\n\n\tfunction slice(a, b, from, to) {\n\n\t\tfor (var i = from, j = 0; i < to; i++, j++) {\n\n\t\t\ta[j] = b[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject(a1, index, a2) {\n\n\t\treturn a1.slice(0, index).concat(a2).concat(a1.slice(index));\n\t}\n\n\treturn FBXLoader;\n}();\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n'use strict';\n\n/**\n * THREE.GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n *\n * Gcode files are composed by commands used by machines to create objects.\n *\n * @class THREE.GCodeLoader\n * @param {Manager} manager Loading manager.\n * @author tentone\n * @author joewalnes\n */\nvar GCodeLoader = function GCodeLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.splitLayer = false;\n};\n\nGCodeLoader.prototype.load = function (url, onLoad, onProgress, onError) {\n\n\tvar self = this;\n\n\tvar loader = new THREE.FileLoader(self.manager);\n\tloader.load(url, function (text) {\n\n\t\tonLoad(self.parse(text));\n\t}, onProgress, onError);\n};\n\nGCodeLoader.prototype.parse = function (data) {\n\n\tvar state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };\n\tvar layers = [];\n\n\tvar currentLayer = undefined;\n\n\tvar pathMaterial = new THREE.LineBasicMaterial({ color: 0xFF0000 });\n\tpathMaterial.name = 'path';\n\n\tvar extrudingMaterial = new THREE.LineBasicMaterial({ color: 0x00FF00 });\n\textrudingMaterial.name = 'extruded';\n\n\tfunction newLayer(line) {\n\n\t\tcurrentLayer = { vertex: [], pathVertex: [], z: line.z };\n\t\tlayers.push(currentLayer);\n\t}\n\n\t//Create lie segment between p1 and p2\n\tfunction addSegment(p1, p2) {\n\n\t\tif (currentLayer === undefined) {\n\n\t\t\tnewLayer(p1);\n\t\t}\n\n\t\tif (line.extruding) {\n\n\t\t\tcurrentLayer.vertex.push(p1.x, p1.y, p1.z);\n\t\t\tcurrentLayer.vertex.push(p2.x, p2.y, p2.z);\n\t\t} else {\n\n\t\t\tcurrentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n\t\t\tcurrentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n\t\t}\n\t}\n\n\tfunction delta(v1, v2) {\n\n\t\treturn state.relative ? v2 : v2 - v1;\n\t}\n\n\tfunction absolute(v1, v2) {\n\n\t\treturn state.relative ? v1 + v2 : v2;\n\t}\n\n\tvar lines = data.replace(/;.+/g, '').split('\\n');\n\n\tfor (var i = 0; i < lines.length; i++) {\n\n\t\tvar tokens = lines[i].split(' ');\n\t\tvar cmd = tokens[0].toUpperCase();\n\n\t\t//Argumments\n\t\tvar args = {};\n\t\ttokens.splice(1).forEach(function (token) {\n\n\t\t\tif (token[0] !== undefined) {\n\n\t\t\t\tvar key = token[0].toLowerCase();\n\t\t\t\tvar value = parseFloat(token.substring(1));\n\t\t\t\targs[key] = value;\n\t\t\t}\n\t\t});\n\n\t\t//Process commands\n\t\t//G0/G1 ‚Äì Linear Movement\n\t\tif (cmd === 'G0' || cmd === 'G1') {\n\n\t\t\tvar line = {\n\t\t\t\tx: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n\t\t\t\ty: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n\t\t\t\tz: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n\t\t\t\te: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n\t\t\t\tf: args.f !== undefined ? absolute(state.f, args.f) : state.f\n\t\t\t};\n\n\t\t\t//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n\t\t\tif (delta(state.e, line.e) > 0) {\n\n\t\t\t\tline.extruding = delta(state.e, line.e) > 0;\n\n\t\t\t\tif (currentLayer == undefined || line.z != currentLayer.z) {\n\n\t\t\t\t\tnewLayer(line);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddSegment(state, line);\n\t\t\tstate = line;\n\t\t} else if (cmd === 'G2' || cmd === 'G3') {\n\n\t\t\t//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n\t\t\tconsole.warn('THREE.GCodeLoader: Arc command not supported');\n\t\t} else if (cmd === 'G90') {\n\n\t\t\t//G90: Set to Absolute Positioning\n\t\t\tstate.relative = false;\n\t\t} else if (cmd === 'G91') {\n\n\t\t\t//G91: Set to state.relative Positioning\n\t\t\tstate.relative = true;\n\t\t} else if (cmd === 'G92') {\n\n\t\t\t//G92: Set Position\n\t\t\tvar line = state;\n\t\t\tline.x = args.x !== undefined ? args.x : line.x;\n\t\t\tline.y = args.y !== undefined ? args.y : line.y;\n\t\t\tline.z = args.z !== undefined ? args.z : line.z;\n\t\t\tline.e = args.e !== undefined ? args.e : line.e;\n\t\t\tstate = line;\n\t\t} else {\n\n\t\t\tconsole.warn('THREE.GCodeLoader: Command not supported:' + cmd);\n\t\t}\n\t}\n\n\tfunction addObject(vertex, extruding) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertex, 3));\n\n\t\tvar segments = new THREE.LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n\t\tsegments.name = 'layer' + i;\n\t\tobject.add(segments);\n\t}\n\n\tvar object = new THREE.Group();\n\tobject.name = 'gcode';\n\n\tif (this.splitLayer) {\n\n\t\tfor (var i = 0; i < layers.length; i++) {\n\n\t\t\tvar layer = layers[i];\n\t\t\taddObject(layer.vertex, true);\n\t\t\taddObject(layer.pathVertex, false);\n\t\t}\n\t} else {\n\n\t\tvar vertex = [],\n\t\t    pathVertex = [];\n\n\t\tfor (var i = 0; i < layers.length; i++) {\n\n\t\t\tvar layer = layers[i];\n\n\t\t\tvertex = vertex.concat(layer.vertex);\n\t\t\tpathVertex = pathVertex.concat(layer.pathVertex);\n\t\t}\n\n\t\taddObject(vertex, true);\n\t\taddObject(pathVertex, false);\n\t}\n\n\tobject.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n\n\treturn object;\n};\n\nexports.default = GCodeLoader;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _RGBELoader = __webpack_require__(6);\n\nvar _RGBELoader2 = _interopRequireDefault(_RGBELoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n* @author Prashant Sharma / spidersharma03\n* @author Ben Houston / http://clara.io / bhouston\n*/\n\nvar HDRCubeTextureLoader = function HDRCubeTextureLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t// override in sub classes\n\tthis.hdrLoader = new _RGBELoader2.default();\n};\n\nHDRCubeTextureLoader.prototype.load = function (type, urls, onLoad, onProgress, onError) {\n\n\tvar RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n\n\t\tvar e = sourceArray[sourceOffset + 3];\n\t\tvar scale = Math.pow(2.0, e - 128.0) / 255.0;\n\n\t\tdestArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n\t\tdestArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n\t\tdestArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n\t};\n\n\tvar RGBEByteToRGBHalf = function () {\n\n\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\tvar floatView = new Float32Array(1);\n\t\tvar int32View = new Int32Array(floatView.buffer);\n\n\t\t/* This method is faster than the OpenEXR implementation (very often\n   * used, eg. in Ogre), with the additional benefit of rounding, inspired\n   * by James Tursa?s half-precision code. */\n\t\tfunction toHalf(val) {\n\n\t\t\tfloatView[0] = val;\n\t\t\tvar x = int32View[0];\n\n\t\t\tvar bits = x >> 16 & 0x8000; /* Get the sign */\n\t\t\tvar m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n\t\t\tvar e = x >> 23 & 0xff; /* Using int is faster here */\n\n\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n    * half, return signed zero. */\n\t\t\tif (e < 103) return bits;\n\n\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\t\t\tif (e > 142) {\n\n\t\t\t\tbits |= 0x7c00;\n\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n    \t\t * not Inf, so make sure we set one mantissa bit too. */\n\t\t\t\tbits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\t\treturn bits;\n\t\t\t}\n\n\t\t\t/* If exponent underflows but not too much, return a denormal */\n\t\t\tif (e < 113) {\n\n\t\t\t\tm |= 0x0800;\n\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n\t\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\t\treturn bits;\n\t\t\t}\n\n\t\t\tbits |= e - 112 << 10 | m >> 1;\n\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n    * the exponent, which is OK. */\n\t\t\tbits += m & 1;\n\t\t\treturn bits;\n\t\t}\n\n\t\treturn function (sourceArray, sourceOffset, destArray, destOffset) {\n\n\t\t\tvar e = sourceArray[sourceOffset + 3];\n\t\t\tvar scale = Math.pow(2.0, e - 128.0) / 255.0;\n\n\t\t\tdestArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);\n\t\t\tdestArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);\n\t\t\tdestArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);\n\t\t};\n\t}();\n\n\t//\n\n\tvar texture = new THREE.CubeTexture();\n\n\ttexture.type = type;\n\ttexture.encoding = type === THREE.UnsignedByteType ? THREE.RGBEEncoding : THREE.LinearEncoding;\n\ttexture.format = type === THREE.UnsignedByteType ? THREE.RGBAFormat : THREE.RGBFormat;\n\ttexture.minFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;\n\ttexture.magFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;\n\ttexture.generateMipmaps = texture.encoding !== THREE.RGBEEncoding;\n\ttexture.anisotropy = 0;\n\n\tvar scope = this.hdrLoader;\n\n\tvar loaded = 0;\n\n\tfunction loadHDRData(i, onLoad, onProgress, onError) {\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(urls[i], function (buffer) {\n\n\t\t\tloaded++;\n\n\t\t\tvar texData = scope._parser(buffer);\n\n\t\t\tif (!texData) return;\n\n\t\t\tif (type === THREE.FloatType) {\n\n\t\t\t\tvar numElements = texData.data.length / 4 * 3;\n\t\t\t\tvar floatdata = new Float32Array(numElements);\n\n\t\t\t\tfor (var j = 0; j < numElements; j++) {\n\n\t\t\t\t\tRGBEByteToRGBFloat(texData.data, j * 4, floatdata, j * 3);\n\t\t\t\t}\n\n\t\t\t\ttexData.data = floatdata;\n\t\t\t} else if (type === THREE.HalfFloatType) {\n\n\t\t\t\tvar numElements = texData.data.length / 4 * 3;\n\t\t\t\tvar halfdata = new Uint16Array(numElements);\n\n\t\t\t\tfor (var j = 0; j < numElements; j++) {\n\n\t\t\t\t\tRGBEByteToRGBHalf(texData.data, j * 4, halfdata, j * 3);\n\t\t\t\t}\n\n\t\t\t\ttexData.data = halfdata;\n\t\t\t}\n\n\t\t\tif (undefined !== texData.image) {\n\n\t\t\t\ttexture[i].images = texData.image;\n\t\t\t} else if (undefined !== texData.data) {\n\n\t\t\t\tvar dataTexture = new THREE.DataTexture(texData.data, texData.width, texData.height);\n\t\t\t\tdataTexture.format = texture.format;\n\t\t\t\tdataTexture.type = texture.type;\n\t\t\t\tdataTexture.encoding = texture.encoding;\n\t\t\t\tdataTexture.minFilter = texture.minFilter;\n\t\t\t\tdataTexture.magFilter = texture.magFilter;\n\t\t\t\tdataTexture.generateMipmaps = texture.generateMipmaps;\n\n\t\t\t\ttexture.images[i] = dataTexture;\n\t\t\t}\n\n\t\t\tif (loaded === 6) {\n\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t}\n\t\t}, onProgress, onError);\n\t}\n\n\tfor (var i = 0; i < urls.length; i++) {\n\n\t\tloadHDRData(i, onLoad, onProgress, onError);\n\t}\n\n\treturn texture;\n};\n\nexports.default = HDRCubeTextureLoader;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar KMZLoader = function KMZLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nKMZLoader.prototype = {\n\n\tconstructor: KMZLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tvar zip = new JSZip(data); // eslint-disable-line no-undef\n\n\t\t// console.log( zip );\n\n\t\t// var xml = new DOMParser().parseFromString( zip.file( 'doc.kml' ).asText(), 'application/xml' );\n\n\t\tfunction loadImage(image) {\n\n\t\t\tvar path = decodeURI(image.init_from);\n\n\t\t\t// Hack to support relative paths\n\t\t\tpath = path.replace('../', '');\n\n\t\t\tvar regex = new RegExp(path + '$');\n\t\t\tvar files = zip.file(regex);\n\n\t\t\t// console.log( image, files );\n\n\t\t\tif (files.length) {\n\n\t\t\t\tvar file = files[0];\n\t\t\t\tvar blob = new Blob([file.asArrayBuffer()], { type: 'application/octet-binary' });\n\t\t\t\timage.build.src = URL.createObjectURL(blob);\n\t\t\t}\n\t\t}\n\n\t\t// load collada\n\n\t\tvar files = zip.file(/dae$/i);\n\n\t\tif (files.length) {\n\n\t\t\tvar file = files[0];\n\n\t\t\tvar collada = new THREE.ColladaLoader().parse(file.asText());\n\n\t\t\t// fix images\n\n\t\t\tvar images = collada.library.images;\n\n\t\t\tfor (var name in images) {\n\n\t\t\t\tloadImage(images[name]);\n\t\t\t}\n\n\t\t\treturn collada;\n\t\t}\n\n\t\tconsole.error('KMZLoader: Couldn\\'t find .dae file.');\n\n\t\treturn {\n\t\t\tscene: new THREE.Group()\n\t\t};\n\t}\n\n};\n\nexports.default = KMZLoader;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author amakaseev / https://github.com/amakaseev\n *\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nvar KTXLoader = function KTXLoader() {\n\n\tthis._parser = KTXLoader.parse;\n};\n\nKTXLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);\nKTXLoader.prototype.constructor = KTXLoader;\n\nKTXLoader.parse = function (buffer, loadMipmaps) {\n\n\tvar ktx = new KhronosTextureContainer(buffer, 1);\n\n\treturn {\n\t\tmipmaps: ktx.mipmaps(loadMipmaps),\n\t\twidth: ktx.pixelWidth,\n\t\theight: ktx.pixelHeight,\n\t\tformat: ktx.glInternalFormat,\n\t\tisCubemap: ktx.numberOfFaces === 6,\n\t\tmipmapCount: ktx.numberOfMipmapLevels\n\t};\n};\n\nvar KhronosTextureContainer = function () {\n\n\t/**\n  * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n  * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n  * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n  * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n  */\n\tfunction KhronosTextureContainer(arrayBuffer, facesExpected, threeDExpected, textureArrayExpected) {\n\n\t\tthis.arrayBuffer = arrayBuffer;\n\n\t\t// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n\t\t// '¬¥', 'K', 'T', 'X', ' ', '1', '1', '¬™', '\\r', '\\n', '\\x1A', '\\n'\n\t\t// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n\t\tvar identifier = new Uint8Array(this.arrayBuffer, 0, 12);\n\t\tif (identifier[0] !== 0xAB || identifier[1] !== 0x4B || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xBB || identifier[8] !== 0x0D || identifier[9] !== 0x0A || identifier[10] !== 0x1A || identifier[11] !== 0x0A) {\n\n\t\t\tconsole.error('texture missing KTX identifier');\n\t\t\treturn;\n\t\t}\n\n\t\t// load the reset of the header in native 32 bit int\n\t\tvar header = new Int32Array(this.arrayBuffer, 12, 13);\n\t\t// determine of the remaining header values are recorded in the opposite endianness & require conversion\n\t\tvar oppositeEndianess = header[0] === 0x01020304;\n\t\t// read all the header elements in order they exist in the file, without modification (sans endainness)\n\t\tthis.glType = oppositeEndianess ? this.switchEndainness(header[1]) : header[1]; // must be 0 for compressed textures\n\t\tthis.glTypeSize = oppositeEndianess ? this.switchEndainness(header[2]) : header[2]; // must be 1 for compressed textures\n\t\tthis.glFormat = oppositeEndianess ? this.switchEndainness(header[3]) : header[3]; // must be 0 for compressed textures\n\t\tthis.glInternalFormat = oppositeEndianess ? this.switchEndainness(header[4]) : header[4]; // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n\t\tthis.glBaseInternalFormat = oppositeEndianess ? this.switchEndainness(header[5]) : header[5]; // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n\t\tthis.pixelWidth = oppositeEndianess ? this.switchEndainness(header[6]) : header[6]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n\t\tthis.pixelHeight = oppositeEndianess ? this.switchEndainness(header[7]) : header[7]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n\t\tthis.pixelDepth = oppositeEndianess ? this.switchEndainness(header[8]) : header[8]; // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n\t\tthis.numberOfArrayElements = oppositeEndianess ? this.switchEndainness(header[9]) : header[9]; // used for texture arrays\n\t\tthis.numberOfFaces = oppositeEndianess ? this.switchEndainness(header[10]) : header[10]; // used for cubemap textures, should either be 1 or 6\n\t\tthis.numberOfMipmapLevels = oppositeEndianess ? this.switchEndainness(header[11]) : header[11]; // number of levels; disregard possibility of 0 for compressed textures\n\t\tthis.bytesOfKeyValueData = oppositeEndianess ? this.switchEndainness(header[12]) : header[12]; // the amount of space after the header for meta-data\n\n\t\t// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n\t\tif (this.glType !== 0) {\n\n\t\t\tconsole.warn('only compressed formats currently supported');\n\t\t\treturn;\n\t\t} else {\n\n\t\t\t// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n\t\t\tthis.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\n\t\t}\n\t\tif (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n\n\t\t\tconsole.warn('only 2D textures currently supported');\n\t\t\treturn;\n\t\t}\n\t\tif (this.numberOfArrayElements !== 0) {\n\n\t\t\tconsole.warn('texture arrays not currently supported');\n\t\t\treturn;\n\t\t}\n\t\tif (this.numberOfFaces !== facesExpected) {\n\n\t\t\tconsole.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);\n\t\t\treturn;\n\t\t}\n\t\t// we now have a completely validated file, so could use existence of loadType as success\n\t\t// would need to make this more elaborate & adjust checks above to support more than one load type\n\t\tthis.loadType = KhronosTextureContainer.COMPRESSED_2D;\n\t}\n\n\t// not as fast hardware based, but will probably never need to use\n\tKhronosTextureContainer.prototype.switchEndainness = function (val) {\n\n\t\treturn (val & 0xFF) << 24 | (val & 0xFF00) << 8 | val >> 8 & 0xFF00 | val >> 24 & 0xFF;\n\t};\n\n\t// return mipmaps for THREE.js\n\tKhronosTextureContainer.prototype.mipmaps = function (loadMipmaps) {\n\n\t\tvar mipmaps = [];\n\n\t\t// initialize width & height for level 1\n\t\tvar dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n\t\tvar width = this.pixelWidth;\n\t\tvar height = this.pixelHeight;\n\t\tvar mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n\n\t\tfor (var level = 0; level < mipmapCount; level++) {\n\n\t\t\tvar imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n\t\t\tfor (var face = 0; face < this.numberOfFaces; face++) {\n\n\t\t\t\tvar byteArray = new Uint8Array(this.arrayBuffer, dataOffset + 4, imageSize);\n\n\t\t\t\tmipmaps.push({ \"data\": byteArray, \"width\": width, \"height\": height });\n\n\t\t\t\tdataOffset += imageSize + 4; // size of the image + 4 for the imageSize field\n\t\t\t\tdataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image\n\t\t\t}\n\t\t\twidth = Math.max(1.0, width * 0.5);\n\t\t\theight = Math.max(1.0, height * 0.5);\n\t\t}\n\n\t\treturn mipmaps;\n\t};\n\n\tKhronosTextureContainer.HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n\t// load types\n\tKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n\tKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n\tKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\n\tKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n\n\treturn KhronosTextureContainer;\n}();\n\nexports.default = KTXLoader;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar MD2Loader = function MD2Loader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nMD2Loader.prototype = {\n\n\tconstructor: MD2Loader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function () {\n\n\t\tvar normals = [[-0.525731, 0.000000, 0.850651], [-0.442863, 0.238856, 0.864188], [-0.295242, 0.000000, 0.955423], [-0.309017, 0.500000, 0.809017], [-0.162460, 0.262866, 0.951056], [0.000000, 0.000000, 1.000000], [0.000000, 0.850651, 0.525731], [-0.147621, 0.716567, 0.681718], [0.147621, 0.716567, 0.681718], [0.000000, 0.525731, 0.850651], [0.309017, 0.500000, 0.809017], [0.525731, 0.000000, 0.850651], [0.295242, 0.000000, 0.955423], [0.442863, 0.238856, 0.864188], [0.162460, 0.262866, 0.951056], [-0.681718, 0.147621, 0.716567], [-0.809017, 0.309017, 0.500000], [-0.587785, 0.425325, 0.688191], [-0.850651, 0.525731, 0.000000], [-0.864188, 0.442863, 0.238856], [-0.716567, 0.681718, 0.147621], [-0.688191, 0.587785, 0.425325], [-0.500000, 0.809017, 0.309017], [-0.238856, 0.864188, 0.442863], [-0.425325, 0.688191, 0.587785], [-0.716567, 0.681718, -0.147621], [-0.500000, 0.809017, -0.309017], [-0.525731, 0.850651, 0.000000], [0.000000, 0.850651, -0.525731], [-0.238856, 0.864188, -0.442863], [0.000000, 0.955423, -0.295242], [-0.262866, 0.951056, -0.162460], [0.000000, 1.000000, 0.000000], [0.000000, 0.955423, 0.295242], [-0.262866, 0.951056, 0.162460], [0.238856, 0.864188, 0.442863], [0.262866, 0.951056, 0.162460], [0.500000, 0.809017, 0.309017], [0.238856, 0.864188, -0.442863], [0.262866, 0.951056, -0.162460], [0.500000, 0.809017, -0.309017], [0.850651, 0.525731, 0.000000], [0.716567, 0.681718, 0.147621], [0.716567, 0.681718, -0.147621], [0.525731, 0.850651, 0.000000], [0.425325, 0.688191, 0.587785], [0.864188, 0.442863, 0.238856], [0.688191, 0.587785, 0.425325], [0.809017, 0.309017, 0.500000], [0.681718, 0.147621, 0.716567], [0.587785, 0.425325, 0.688191], [0.955423, 0.295242, 0.000000], [1.000000, 0.000000, 0.000000], [0.951056, 0.162460, 0.262866], [0.850651, -0.525731, 0.000000], [0.955423, -0.295242, 0.000000], [0.864188, -0.442863, 0.238856], [0.951056, -0.162460, 0.262866], [0.809017, -0.309017, 0.500000], [0.681718, -0.147621, 0.716567], [0.850651, 0.000000, 0.525731], [0.864188, 0.442863, -0.238856], [0.809017, 0.309017, -0.500000], [0.951056, 0.162460, -0.262866], [0.525731, 0.000000, -0.850651], [0.681718, 0.147621, -0.716567], [0.681718, -0.147621, -0.716567], [0.850651, 0.000000, -0.525731], [0.809017, -0.309017, -0.500000], [0.864188, -0.442863, -0.238856], [0.951056, -0.162460, -0.262866], [0.147621, 0.716567, -0.681718], [0.309017, 0.500000, -0.809017], [0.425325, 0.688191, -0.587785], [0.442863, 0.238856, -0.864188], [0.587785, 0.425325, -0.688191], [0.688191, 0.587785, -0.425325], [-0.147621, 0.716567, -0.681718], [-0.309017, 0.500000, -0.809017], [0.000000, 0.525731, -0.850651], [-0.525731, 0.000000, -0.850651], [-0.442863, 0.238856, -0.864188], [-0.295242, 0.000000, -0.955423], [-0.162460, 0.262866, -0.951056], [0.000000, 0.000000, -1.000000], [0.295242, 0.000000, -0.955423], [0.162460, 0.262866, -0.951056], [-0.442863, -0.238856, -0.864188], [-0.309017, -0.500000, -0.809017], [-0.162460, -0.262866, -0.951056], [0.000000, -0.850651, -0.525731], [-0.147621, -0.716567, -0.681718], [0.147621, -0.716567, -0.681718], [0.000000, -0.525731, -0.850651], [0.309017, -0.500000, -0.809017], [0.442863, -0.238856, -0.864188], [0.162460, -0.262866, -0.951056], [0.238856, -0.864188, -0.442863], [0.500000, -0.809017, -0.309017], [0.425325, -0.688191, -0.587785], [0.716567, -0.681718, -0.147621], [0.688191, -0.587785, -0.425325], [0.587785, -0.425325, -0.688191], [0.000000, -0.955423, -0.295242], [0.000000, -1.000000, 0.000000], [0.262866, -0.951056, -0.162460], [0.000000, -0.850651, 0.525731], [0.000000, -0.955423, 0.295242], [0.238856, -0.864188, 0.442863], [0.262866, -0.951056, 0.162460], [0.500000, -0.809017, 0.309017], [0.716567, -0.681718, 0.147621], [0.525731, -0.850651, 0.000000], [-0.238856, -0.864188, -0.442863], [-0.500000, -0.809017, -0.309017], [-0.262866, -0.951056, -0.162460], [-0.850651, -0.525731, 0.000000], [-0.716567, -0.681718, -0.147621], [-0.716567, -0.681718, 0.147621], [-0.525731, -0.850651, 0.000000], [-0.500000, -0.809017, 0.309017], [-0.238856, -0.864188, 0.442863], [-0.262866, -0.951056, 0.162460], [-0.864188, -0.442863, 0.238856], [-0.809017, -0.309017, 0.500000], [-0.688191, -0.587785, 0.425325], [-0.681718, -0.147621, 0.716567], [-0.442863, -0.238856, 0.864188], [-0.587785, -0.425325, 0.688191], [-0.309017, -0.500000, 0.809017], [-0.147621, -0.716567, 0.681718], [-0.425325, -0.688191, 0.587785], [-0.162460, -0.262866, 0.951056], [0.442863, -0.238856, 0.864188], [0.162460, -0.262866, 0.951056], [0.309017, -0.500000, 0.809017], [0.147621, -0.716567, 0.681718], [0.000000, -0.525731, 0.850651], [0.425325, -0.688191, 0.587785], [0.587785, -0.425325, 0.688191], [0.688191, -0.587785, 0.425325], [-0.955423, 0.295242, 0.000000], [-0.951056, 0.162460, 0.262866], [-1.000000, 0.000000, 0.000000], [-0.850651, 0.000000, 0.525731], [-0.955423, -0.295242, 0.000000], [-0.951056, -0.162460, 0.262866], [-0.864188, 0.442863, -0.238856], [-0.951056, 0.162460, -0.262866], [-0.809017, 0.309017, -0.500000], [-0.864188, -0.442863, -0.238856], [-0.951056, -0.162460, -0.262866], [-0.809017, -0.309017, -0.500000], [-0.681718, 0.147621, -0.716567], [-0.681718, -0.147621, -0.716567], [-0.850651, 0.000000, -0.525731], [-0.688191, 0.587785, -0.425325], [-0.587785, 0.425325, -0.688191], [-0.425325, 0.688191, -0.587785], [-0.425325, -0.688191, -0.587785], [-0.587785, -0.425325, -0.688191], [-0.688191, -0.587785, -0.425325]];\n\n\t\treturn function (buffer) {\n\n\t\t\tconsole.time('MD2Loader');\n\n\t\t\tvar data = new DataView(buffer);\n\n\t\t\t// http://tfc.duke.free.fr/coding/md2-specs-en.html\n\n\t\t\tvar header = {};\n\t\t\tvar headerNames = ['ident', 'version', 'skinwidth', 'skinheight', 'framesize', 'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames', 'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'];\n\n\t\t\tfor (var i = 0; i < headerNames.length; i++) {\n\n\t\t\t\theader[headerNames[i]] = data.getInt32(i * 4, true);\n\t\t\t}\n\n\t\t\tif (header.ident !== 844121161 || header.version !== 8) {\n\n\t\t\t\tconsole.error('Not a valid MD2 file');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (header.offset_end !== data.byteLength) {\n\n\t\t\t\tconsole.error('Corrupted MD2 file');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar geometry = new THREE.Geometry();\n\n\t\t\t// uvs\n\n\t\t\tvar uvs = [];\n\t\t\tvar offset = header.offset_st;\n\n\t\t\tfor (var i = 0, l = header.num_st; i < l; i++) {\n\n\t\t\t\tvar u = data.getInt16(offset + 0, true);\n\t\t\t\tvar v = data.getInt16(offset + 2, true);\n\n\t\t\t\tuvs.push(new THREE.Vector2(u / header.skinwidth, 1 - v / header.skinheight));\n\n\t\t\t\toffset += 4;\n\t\t\t}\n\n\t\t\t// triangles\n\n\t\t\tvar offset = header.offset_tris;\n\n\t\t\tfor (var i = 0, l = header.num_tris; i < l; i++) {\n\n\t\t\t\tvar a = data.getUint16(offset + 0, true);\n\t\t\t\tvar b = data.getUint16(offset + 2, true);\n\t\t\t\tvar c = data.getUint16(offset + 4, true);\n\n\t\t\t\tgeometry.faces.push(new THREE.Face3(a, b, c));\n\n\t\t\t\tgeometry.faceVertexUvs[0].push([uvs[data.getUint16(offset + 6, true)], uvs[data.getUint16(offset + 8, true)], uvs[data.getUint16(offset + 10, true)]]);\n\n\t\t\t\toffset += 12;\n\t\t\t}\n\n\t\t\t// frames\n\n\t\t\tvar translation = new THREE.Vector3();\n\t\t\tvar scale = new THREE.Vector3();\n\t\t\tvar string = [];\n\n\t\t\tvar offset = header.offset_frames;\n\n\t\t\tfor (var i = 0, l = header.num_frames; i < l; i++) {\n\n\t\t\t\tscale.set(data.getFloat32(offset + 0, true), data.getFloat32(offset + 4, true), data.getFloat32(offset + 8, true));\n\n\t\t\t\ttranslation.set(data.getFloat32(offset + 12, true), data.getFloat32(offset + 16, true), data.getFloat32(offset + 20, true));\n\n\t\t\t\toffset += 24;\n\n\t\t\t\tfor (var j = 0; j < 16; j++) {\n\n\t\t\t\t\tvar character = data.getUint8(offset + j, true);\n\t\t\t\t\tif (character === 0) break;\n\n\t\t\t\t\tstring[j] = character;\n\t\t\t\t}\n\n\t\t\t\tvar frame = {\n\t\t\t\t\tname: String.fromCharCode.apply(null, string),\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: []\n\t\t\t\t};\n\n\t\t\t\toffset += 16;\n\n\t\t\t\tfor (var j = 0; j < header.num_vertices; j++) {\n\n\t\t\t\t\tvar x = data.getUint8(offset++, true);\n\t\t\t\t\tvar y = data.getUint8(offset++, true);\n\t\t\t\t\tvar z = data.getUint8(offset++, true);\n\t\t\t\t\tvar n = normals[data.getUint8(offset++, true)];\n\n\t\t\t\t\tvar vertex = new THREE.Vector3(x * scale.x + translation.x, z * scale.z + translation.z, y * scale.y + translation.y);\n\n\t\t\t\t\tvar normal = new THREE.Vector3(n[0], n[2], n[1]);\n\n\t\t\t\t\tframe.vertices.push(vertex);\n\t\t\t\t\tframe.normals.push(normal);\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphTargets.push(frame);\n\t\t\t}\n\n\t\t\t// Static\n\n\t\t\tgeometry.vertices = geometry.morphTargets[0].vertices;\n\n\t\t\tvar morphTarget = geometry.morphTargets[0];\n\n\t\t\tfor (var j = 0, jl = geometry.faces.length; j < jl; j++) {\n\n\t\t\t\tvar face = geometry.faces[j];\n\n\t\t\t\tface.vertexNormals = [morphTarget.normals[face.a], morphTarget.normals[face.b], morphTarget.normals[face.c]];\n\t\t\t}\n\n\t\t\t// Convert to geometry.morphNormals\n\n\t\t\tfor (var i = 0, l = geometry.morphTargets.length; i < l; i++) {\n\n\t\t\t\tvar morphTarget = geometry.morphTargets[i];\n\t\t\t\tvar vertexNormals = [];\n\n\t\t\t\tfor (var j = 0, jl = geometry.faces.length; j < jl; j++) {\n\n\t\t\t\t\tvar face = geometry.faces[j];\n\n\t\t\t\t\tvertexNormals.push({\n\t\t\t\t\t\ta: morphTarget.normals[face.a],\n\t\t\t\t\t\tb: morphTarget.normals[face.b],\n\t\t\t\t\t\tc: morphTarget.normals[face.c]\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphNormals.push({ vertexNormals: vertexNormals });\n\t\t\t}\n\n\t\t\tgeometry.animations = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);\n\n\t\t\tconsole.timeEnd('MD2Loader');\n\n\t\t\treturn geometry;\n\t\t};\n\t}()\n\n};\n\nexports.default = MD2Loader;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _mmdParser = __webpack_require__(4);\n\nvar MMDParser = _interopRequireWildcard(_mmdParser);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author takahiro / https://github.com/takahirox\n *\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - THREE.TGALoader\n *  - THREE.MMDPhysics\n *  - THREE.CCDIKSolver\n *  - THREE.OutlineEffect\n *\n *\n * This loader loads and parses PMD/PMX and VMD binary files\n * then creates mesh for Three.js.\n *\n * PMD/PMX is a model data format and VMD is a motion data format\n * used in MMD(Miku Miku Dance).\n *\n * MMD is a 3D CG animation tool which is popular in Japan.\n *\n *\n * MMD official site\n *  http://www.geocities.jp/higuchuu4/index_e.htm\n *\n * PMD, VMD format\n *  http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  http://gulshan-i-raz.geo.jp/labs/2012/10/17/pmx-format1/\n *\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\nvar MMDLoader = function MMDLoader(manager) {\n\n\tTHREE.Loader.call(this);\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.parser = new MMDParser.Parser();\n\tthis.textureCrossOrigin = null;\n};\n\nMMDLoader.prototype = Object.create(THREE.Loader.prototype);\nMMDLoader.prototype.constructor = MMDLoader;\n\n/*\n * base64 encoded defalut toon textures toon00.bmp - toon10.bmp\n * Users don't need to prepare default texture files.\n *\n * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n */\nMMDLoader.prototype.defaultToonTextures = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='];\n\n/*\n * Set 'anonymous' for the the texture image file in other domain\n * even if server responds with \"Access-Control-Allow-Origin: *\"\n * because some image operation fails in MMDLoader.\n */\nMMDLoader.prototype.setTextureCrossOrigin = function (value) {\n\n\tthis.textureCrossOrigin = value;\n};\n\nMMDLoader.prototype.load = function (modelUrl, vmdUrls, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tthis.loadModel(modelUrl, function (mesh) {\n\n\t\tscope.loadVmds(vmdUrls, function (vmd) {\n\n\t\t\tscope.pourVmdIntoModel(mesh, vmd);\n\t\t\tcallback(mesh);\n\t\t}, onProgress, onError);\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.loadModel = function (url, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tvar texturePath = THREE.LoaderUtils.extractUrlBase(url);\n\tvar modelExtension = this.extractExtension(url);\n\n\tthis.loadFileAsBuffer(url, function (buffer) {\n\n\t\tcallback(scope.createModel(buffer, modelExtension, texturePath, onProgress, onError));\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.createModel = function (buffer, modelExtension, texturePath, onProgress, onError) {\n\n\treturn this.createMesh(this.parseModel(buffer, modelExtension), texturePath, onProgress, onError);\n};\n\nMMDLoader.prototype.loadVmd = function (url, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tthis.loadFileAsBuffer(url, function (buffer) {\n\n\t\tcallback(scope.parseVmd(buffer));\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.loadVmds = function (urls, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tvar vmds = [];\n\turls = urls.slice();\n\n\tfunction run() {\n\n\t\tvar url = urls.shift();\n\n\t\tscope.loadVmd(url, function (vmd) {\n\n\t\t\tvmds.push(vmd);\n\n\t\t\tif (urls.length > 0) {\n\n\t\t\t\trun();\n\t\t\t} else {\n\n\t\t\t\tcallback(scope.mergeVmds(vmds));\n\t\t\t}\n\t\t}, onProgress, onError);\n\t}\n\n\trun();\n};\n\nMMDLoader.prototype.loadAudio = function (url, callback, onProgress, onError) {\n\n\tvar listener = new THREE.AudioListener();\n\tvar audio = new THREE.Audio(listener);\n\tvar loader = new THREE.AudioLoader(this.manager);\n\n\tloader.load(url, function (buffer) {\n\n\t\taudio.setBuffer(buffer);\n\t\tcallback(audio, listener);\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.loadVpd = function (url, callback, onProgress, onError, params) {\n\n\tvar scope = this;\n\n\tvar func = (params && params.charcode === 'unicode' ? this.loadFileAsText : this.loadFileAsShiftJISText).bind(this);\n\n\tfunc(url, function (text) {\n\n\t\tcallback(scope.parseVpd(text));\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.parseModel = function (buffer, modelExtension) {\n\n\t// Should I judge from model data header?\n\tswitch (modelExtension.toLowerCase()) {\n\n\t\tcase 'pmd':\n\t\t\treturn this.parsePmd(buffer);\n\n\t\tcase 'pmx':\n\t\t\treturn this.parsePmx(buffer);\n\n\t\tdefault:\n\t\t\tthrow 'extension ' + modelExtension + ' is not supported.';\n\n\t}\n};\n\nMMDLoader.prototype.parsePmd = function (buffer) {\n\n\treturn this.parser.parsePmd(buffer, true);\n};\n\nMMDLoader.prototype.parsePmx = function (buffer) {\n\n\treturn this.parser.parsePmx(buffer, true);\n};\n\nMMDLoader.prototype.parseVmd = function (buffer) {\n\n\treturn this.parser.parseVmd(buffer, true);\n};\n\nMMDLoader.prototype.parseVpd = function (text) {\n\n\treturn this.parser.parseVpd(text, true);\n};\n\nMMDLoader.prototype.mergeVmds = function (vmds) {\n\n\treturn this.parser.mergeVmds(vmds);\n};\n\nMMDLoader.prototype.pourVmdIntoModel = function (mesh, vmd, name) {\n\n\tthis.createAnimation(mesh, vmd, name);\n};\n\nMMDLoader.prototype.pourVmdIntoCamera = function (camera, vmd, name) {\n\n\tvar helper = new MMDLoader.DataCreationHelper();\n\n\tvar initAnimation = function initAnimation() {\n\n\t\tvar orderedMotions = helper.createOrderedMotionArray(vmd.cameras);\n\n\t\tvar times = [];\n\t\tvar centers = [];\n\t\tvar quaternions = [];\n\t\tvar positions = [];\n\t\tvar fovs = [];\n\n\t\tvar cInterpolations = [];\n\t\tvar qInterpolations = [];\n\t\tvar pInterpolations = [];\n\t\tvar fInterpolations = [];\n\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar euler = new THREE.Euler();\n\t\tvar position = new THREE.Vector3();\n\t\tvar center = new THREE.Vector3();\n\n\t\tvar pushVector3 = function pushVector3(array, vec) {\n\n\t\t\tarray.push(vec.x);\n\t\t\tarray.push(vec.y);\n\t\t\tarray.push(vec.z);\n\t\t};\n\n\t\tvar pushQuaternion = function pushQuaternion(array, q) {\n\n\t\t\tarray.push(q.x);\n\t\t\tarray.push(q.y);\n\t\t\tarray.push(q.z);\n\t\t\tarray.push(q.w);\n\t\t};\n\n\t\tvar pushInterpolation = function pushInterpolation(array, interpolation, index) {\n\n\t\t\tarray.push(interpolation[index * 4 + 0] / 127); // x1\n\t\t\tarray.push(interpolation[index * 4 + 1] / 127); // x2\n\t\t\tarray.push(interpolation[index * 4 + 2] / 127); // y1\n\t\t\tarray.push(interpolation[index * 4 + 3] / 127); // y2\n\t\t};\n\n\t\tvar createTrack = function createTrack(node, type, times, values, interpolations) {\n\n\t\t\t/*\n    * optimizes here not to let KeyframeTrackPrototype optimize\n    * because KeyframeTrackPrototype optimizes times and values but\n    * doesn't optimize interpolations.\n    */\n\t\t\tif (times.length > 2) {\n\n\t\t\t\ttimes = times.slice();\n\t\t\t\tvalues = values.slice();\n\t\t\t\tinterpolations = interpolations.slice();\n\n\t\t\t\tvar stride = values.length / times.length;\n\t\t\t\tvar interpolateStride = stride === 3 ? 12 : 4; // 3: Vector3, others: Quaternion or Number\n\n\t\t\t\tvar index = 1;\n\n\t\t\t\tfor (var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n\n\t\t\t\t\tfor (var i = 0; i < stride; i++) {\n\n\t\t\t\t\t\tif (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aheadIndex > index) {\n\n\t\t\t\t\t\ttimes[index] = times[aheadIndex];\n\n\t\t\t\t\t\tfor (var i = 0; i < stride; i++) {\n\n\t\t\t\t\t\t\tvalues[index * stride + i] = values[aheadIndex * stride + i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var i = 0; i < interpolateStride; i++) {\n\n\t\t\t\t\t\t\tinterpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttimes.length = index + 1;\n\t\t\t\tvalues.length = (index + 1) * stride;\n\t\t\t\tinterpolations.length = (index + 1) * interpolateStride;\n\t\t\t}\n\n\t\t\tvar track = new THREE[type](node, times, values);\n\n\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n\n\t\t\t\treturn new MMDLoader.CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n\t\t\t};\n\n\t\t\treturn track;\n\t\t};\n\n\t\tfor (var i = 0; i < orderedMotions.length; i++) {\n\n\t\t\tvar m = orderedMotions[i];\n\n\t\t\tvar time = m.frameNum / 30;\n\t\t\tvar pos = m.position;\n\t\t\tvar rot = m.rotation;\n\t\t\tvar distance = m.distance;\n\t\t\tvar fov = m.fov;\n\t\t\tvar interpolation = m.interpolation;\n\n\t\t\tposition.set(0, 0, -distance);\n\t\t\tcenter.set(pos[0], pos[1], pos[2]);\n\n\t\t\teuler.set(-rot[0], -rot[1], -rot[2]);\n\t\t\tquaternion.setFromEuler(euler);\n\n\t\t\tposition.add(center);\n\t\t\tposition.applyQuaternion(quaternion);\n\n\t\t\ttimes.push(time);\n\n\t\t\tpushVector3(centers, center);\n\t\t\tpushQuaternion(quaternions, quaternion);\n\t\t\tpushVector3(positions, position);\n\n\t\t\tfovs.push(fov);\n\n\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\tpushInterpolation(cInterpolations, interpolation, j);\n\t\t\t}\n\n\t\t\tpushInterpolation(qInterpolations, interpolation, 3);\n\n\t\t\t// use same one parameter for x, y, z axis.\n\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\tpushInterpolation(pInterpolations, interpolation, 4);\n\t\t\t}\n\n\t\t\tpushInterpolation(fInterpolations, interpolation, 5);\n\t\t}\n\n\t\tif (times.length === 0) return;\n\n\t\tvar tracks = [];\n\n\t\ttracks.push(createTrack('.center', 'VectorKeyframeTrack', times, centers, cInterpolations));\n\t\ttracks.push(createTrack('.quaternion', 'QuaternionKeyframeTrack', times, quaternions, qInterpolations));\n\t\ttracks.push(createTrack('.position', 'VectorKeyframeTrack', times, positions, pInterpolations));\n\t\ttracks.push(createTrack('.fov', 'NumberKeyframeTrack', times, fovs, fInterpolations));\n\n\t\tvar clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name, -1, tracks);\n\n\t\tif (camera.center === undefined) camera.center = new THREE.Vector3(0, 0, 0);\n\t\tif (camera.animations === undefined) camera.animations = [];\n\t\tcamera.animations.push(clip);\n\t};\n\n\tinitAnimation();\n};\n\nMMDLoader.prototype.extractExtension = function (url) {\n\n\tvar index = url.lastIndexOf('.');\n\n\tif (index < 0) {\n\n\t\treturn null;\n\t}\n\n\treturn url.slice(index + 1);\n};\n\nMMDLoader.prototype.loadFile = function (url, onLoad, onProgress, onError, responseType, mimeType) {\n\n\tvar loader = new THREE.FileLoader(this.manager);\n\n\tif (mimeType !== undefined) loader.setMimeType(mimeType);\n\n\tloader.setResponseType(responseType);\n\n\tvar request = loader.load(url, function (result) {\n\n\t\tonLoad(result);\n\t}, onProgress, onError);\n\n\treturn request;\n};\n\nMMDLoader.prototype.loadFileAsBuffer = function (url, onLoad, onProgress, onError) {\n\n\tthis.loadFile(url, onLoad, onProgress, onError, 'arraybuffer');\n};\n\nMMDLoader.prototype.loadFileAsText = function (url, onLoad, onProgress, onError) {\n\n\tthis.loadFile(url, onLoad, onProgress, onError, 'text');\n};\n\nMMDLoader.prototype.loadFileAsShiftJISText = function (url, onLoad, onProgress, onError) {\n\n\tthis.loadFile(url, onLoad, onProgress, onError, 'text', 'text/plain; charset=shift_jis');\n};\n\nMMDLoader.prototype.createMesh = function (model, texturePath, onProgress, onError) {\n\n\tvar scope = this;\n\tvar geometry = new THREE.BufferGeometry();\n\tvar materials = [];\n\n\tvar buffer = {};\n\n\tbuffer.vertices = [];\n\tbuffer.uvs = [];\n\tbuffer.normals = [];\n\tbuffer.skinIndices = [];\n\tbuffer.skinWeights = [];\n\tbuffer.indices = [];\n\n\tvar initVartices = function initVartices() {\n\n\t\tfor (var i = 0; i < model.metadata.vertexCount; i++) {\n\n\t\t\tvar v = model.vertices[i];\n\n\t\t\tfor (var j = 0, jl = v.position.length; j < jl; j++) {\n\n\t\t\t\tbuffer.vertices.push(v.position[j]);\n\t\t\t}\n\n\t\t\tfor (var j = 0, jl = v.normal.length; j < jl; j++) {\n\n\t\t\t\tbuffer.normals.push(v.normal[j]);\n\t\t\t}\n\n\t\t\tfor (var j = 0, jl = v.uv.length; j < jl; j++) {\n\n\t\t\t\tbuffer.uvs.push(v.uv[j]);\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < 4; j++) {\n\n\t\t\t\tbuffer.skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < 4; j++) {\n\n\t\t\t\tbuffer.skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar initFaces = function initFaces() {\n\n\t\tfor (var i = 0; i < model.metadata.faceCount; i++) {\n\n\t\t\tvar f = model.faces[i];\n\n\t\t\tfor (var j = 0, jl = f.indices.length; j < jl; j++) {\n\n\t\t\t\tbuffer.indices.push(f.indices[j]);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar initBones = function initBones() {\n\n\t\tvar bones = [];\n\n\t\tvar rigidBodies = model.rigidBodies;\n\t\tvar dictionary = {};\n\n\t\tfor (var i = 0, il = rigidBodies.length; i < il; i++) {\n\n\t\t\tvar body = rigidBodies[i];\n\t\t\tvar value = dictionary[body.boneIndex];\n\n\t\t\t// keeps greater number if already value is set without any special reasons\n\t\t\tvalue = value === undefined ? body.type : Math.max(body.type, value);\n\n\t\t\tdictionary[body.boneIndex] = value;\n\t\t}\n\n\t\tfor (var i = 0; i < model.metadata.boneCount; i++) {\n\n\t\t\tvar bone = {};\n\t\t\tvar b = model.bones[i];\n\n\t\t\tbone.parent = b.parentIndex;\n\t\t\tbone.name = b.name;\n\t\t\tbone.pos = [b.position[0], b.position[1], b.position[2]];\n\t\t\tbone.rotq = [0, 0, 0, 1];\n\t\t\tbone.scl = [1, 1, 1];\n\n\t\t\tif (bone.parent !== -1) {\n\n\t\t\t\tbone.pos[0] -= model.bones[bone.parent].position[0];\n\t\t\t\tbone.pos[1] -= model.bones[bone.parent].position[1];\n\t\t\t\tbone.pos[2] -= model.bones[bone.parent].position[2];\n\t\t\t}\n\n\t\t\tbone.rigidBodyType = dictionary[i] !== undefined ? dictionary[i] : -1;\n\n\t\t\tbones.push(bone);\n\t\t}\n\n\t\tgeometry.bones = bones;\n\t};\n\n\tvar initIKs = function initIKs() {\n\n\t\tvar iks = [];\n\n\t\t// TODO: remove duplicated codes between PMD and PMX\n\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\tfor (var i = 0; i < model.metadata.ikCount; i++) {\n\n\t\t\t\tvar ik = model.iks[i];\n\t\t\t\tvar param = {};\n\n\t\t\t\tparam.target = ik.target;\n\t\t\t\tparam.effector = ik.effector;\n\t\t\t\tparam.iteration = ik.iteration;\n\t\t\t\tparam.maxAngle = ik.maxAngle * 4;\n\t\t\t\tparam.links = [];\n\n\t\t\t\tfor (var j = 0; j < ik.links.length; j++) {\n\n\t\t\t\t\tvar link = {};\n\t\t\t\t\tlink.index = ik.links[j].index;\n\n\t\t\t\t\tif (model.bones[link.index].name.indexOf('„Å≤„Åñ') >= 0) {\n\n\t\t\t\t\t\tlink.limitation = new THREE.Vector3(1.0, 0.0, 0.0);\n\t\t\t\t\t}\n\n\t\t\t\t\tparam.links.push(link);\n\t\t\t\t}\n\n\t\t\t\tiks.push(param);\n\t\t\t}\n\t\t} else {\n\n\t\t\tfor (var i = 0; i < model.metadata.boneCount; i++) {\n\n\t\t\t\tvar b = model.bones[i];\n\t\t\t\tvar ik = b.ik;\n\n\t\t\t\tif (ik === undefined) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar param = {};\n\n\t\t\t\tparam.target = i;\n\t\t\t\tparam.effector = ik.effector;\n\t\t\t\tparam.iteration = ik.iteration;\n\t\t\t\tparam.maxAngle = ik.maxAngle;\n\t\t\t\tparam.links = [];\n\n\t\t\t\tfor (var j = 0; j < ik.links.length; j++) {\n\n\t\t\t\t\tvar link = {};\n\t\t\t\t\tlink.index = ik.links[j].index;\n\t\t\t\t\tlink.enabled = true;\n\n\t\t\t\t\tif (ik.links[j].angleLimitation === 1) {\n\n\t\t\t\t\t\tlink.limitation = new THREE.Vector3(1.0, 0.0, 0.0);\n\t\t\t\t\t\t// TODO: use limitation angles\n\t\t\t\t\t\t// link.lowerLimitationAngle;\n\t\t\t\t\t\t// link.upperLimitationAngle;\n\t\t\t\t\t}\n\n\t\t\t\t\tparam.links.push(link);\n\t\t\t\t}\n\n\t\t\t\tiks.push(param);\n\t\t\t}\n\t\t}\n\n\t\tgeometry.iks = iks;\n\t};\n\n\tvar initGrants = function initGrants() {\n\n\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar grants = [];\n\n\t\tfor (var i = 0; i < model.metadata.boneCount; i++) {\n\n\t\t\tvar b = model.bones[i];\n\t\t\tvar grant = b.grant;\n\n\t\t\tif (grant === undefined) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar param = {};\n\n\t\t\tparam.index = i;\n\t\t\tparam.parentIndex = grant.parentIndex;\n\t\t\tparam.ratio = grant.ratio;\n\t\t\tparam.isLocal = grant.isLocal;\n\t\t\tparam.affectRotation = grant.affectRotation;\n\t\t\tparam.affectPosition = grant.affectPosition;\n\t\t\tparam.transformationClass = b.transformationClass;\n\n\t\t\tgrants.push(param);\n\t\t}\n\n\t\tgrants.sort(function (a, b) {\n\n\t\t\treturn a.transformationClass - b.transformationClass;\n\t\t});\n\n\t\tgeometry.grants = grants;\n\t};\n\n\tvar initMorphs = function initMorphs() {\n\n\t\tfunction updateVertex(attribute, index, v, ratio) {\n\n\t\t\tattribute.array[index * 3 + 0] += v.position[0] * ratio;\n\t\t\tattribute.array[index * 3 + 1] += v.position[1] * ratio;\n\t\t\tattribute.array[index * 3 + 2] += v.position[2] * ratio;\n\t\t}\n\n\t\tfunction updateVertices(attribute, m, ratio) {\n\n\t\t\tfor (var i = 0; i < m.elementCount; i++) {\n\n\t\t\t\tvar v = m.elements[i];\n\n\t\t\t\tvar index;\n\n\t\t\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\t\t\tindex = model.morphs[0].elements[v.index].index;\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = v.index;\n\t\t\t\t}\n\n\t\t\t\tupdateVertex(attribute, index, v, ratio);\n\t\t\t}\n\t\t}\n\n\t\tvar morphTargets = [];\n\t\tvar attributes = [];\n\n\t\tfor (var i = 0; i < model.metadata.morphCount; i++) {\n\n\t\t\tvar m = model.morphs[i];\n\t\t\tvar params = { name: m.name };\n\n\t\t\tvar attribute = new THREE.Float32BufferAttribute(model.metadata.vertexCount * 3, 3);\n\t\t\tattribute.name = m.name;\n\n\t\t\tfor (var j = 0; j < model.metadata.vertexCount * 3; j++) {\n\n\t\t\t\tattribute.array[j] = buffer.vertices[j];\n\t\t\t}\n\n\t\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\t\tif (i !== 0) {\n\n\t\t\t\t\tupdateVertices(attribute, m, 1.0);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (m.type === 0) {\n\t\t\t\t\t// group\n\n\t\t\t\t\tfor (var j = 0; j < m.elementCount; j++) {\n\n\t\t\t\t\t\tvar m2 = model.morphs[m.elements[j].index];\n\t\t\t\t\t\tvar ratio = m.elements[j].ratio;\n\n\t\t\t\t\t\tif (m2.type === 1) {\n\n\t\t\t\t\t\t\tupdateVertices(attribute, m2, ratio);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (m.type === 1) {\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tupdateVertices(attribute, m, 1.0);\n\t\t\t\t} else if (m.type === 2) {// bone\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 3) {// uv\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 4) {// additional uv1\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 5) {// additional uv2\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 6) {// additional uv3\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 7) {// additional uv4\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 8) {// material\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmorphTargets.push(params);\n\t\t\tattributes.push(attribute);\n\t\t}\n\n\t\tgeometry.morphTargets = morphTargets;\n\t\tgeometry.morphAttributes.position = attributes;\n\t};\n\n\tvar initMaterials = function initMaterials() {\n\n\t\tvar textures = {};\n\t\tvar textureLoader = new THREE.TextureLoader(scope.manager);\n\t\tvar tgaLoader = new THREE.TGALoader(scope.manager);\n\t\tvar canvas = document.createElement('canvas');\n\t\tvar context = canvas.getContext('2d');\n\t\tvar offset = 0;\n\t\tvar materialParams = [];\n\n\t\tif (scope.textureCrossOrigin !== null) textureLoader.setCrossOrigin(scope.textureCrossOrigin);\n\n\t\tfunction loadTexture(filePath, params) {\n\n\t\t\tif (params === undefined) {\n\n\t\t\t\tparams = {};\n\t\t\t}\n\n\t\t\tvar fullPath;\n\n\t\t\tif (params.defaultTexturePath === true) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tfullPath = scope.defaultToonTextures[parseInt(filePath.match('toon([0-9]{2})\\.bmp$')[1])];\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tconsole.warn('THREE.MMDLoader: ' + filePath + ' seems like not right default texture path. Using toon00.bmp instead.');\n\t\t\t\t\tfullPath = scope.defaultToonTextures[0];\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfullPath = texturePath + filePath;\n\t\t\t}\n\n\t\t\tif (textures[fullPath] !== undefined) return fullPath;\n\n\t\t\tvar loader = THREE.Loader.Handlers.get(fullPath);\n\n\t\t\tif (loader === null) {\n\n\t\t\t\tloader = filePath.indexOf('.tga') >= 0 ? tgaLoader : textureLoader;\n\t\t\t}\n\n\t\t\tvar texture = loader.load(fullPath, function (t) {\n\n\t\t\t\t// MMD toon texture is Axis-Y oriented\n\t\t\t\t// but Three.js gradient map is Axis-X oriented.\n\t\t\t\t// So here replaces the toon texture image with the rotated one.\n\t\t\t\tif (params.isToonTexture === true) {\n\n\t\t\t\t\tvar image = t.image;\n\t\t\t\t\tvar width = image.width;\n\t\t\t\t\tvar height = image.height;\n\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\n\t\t\t\t\tcontext.clearRect(0, 0, width, height);\n\t\t\t\t\tcontext.translate(width / 2.0, height / 2.0);\n\t\t\t\t\tcontext.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0\n\t\t\t\t\tcontext.translate(-width / 2.0, -height / 2.0);\n\t\t\t\t\tcontext.drawImage(image, 0, 0);\n\n\t\t\t\t\tt.image = context.getImageData(0, 0, width, height);\n\t\t\t\t}\n\n\t\t\t\tt.flipY = false;\n\t\t\t\tt.wrapS = THREE.RepeatWrapping;\n\t\t\t\tt.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tfor (var i = 0; i < texture.readyCallbacks.length; i++) {\n\n\t\t\t\t\ttexture.readyCallbacks[i](texture);\n\t\t\t\t}\n\n\t\t\t\tdelete texture.readyCallbacks;\n\t\t\t}, onProgress, onError);\n\n\t\t\tif (params.sphericalReflectionMapping === true) {\n\n\t\t\t\ttexture.mapping = THREE.SphericalReflectionMapping;\n\t\t\t}\n\n\t\t\ttexture.readyCallbacks = [];\n\n\t\t\ttextures[fullPath] = texture;\n\n\t\t\treturn fullPath;\n\t\t}\n\n\t\tfunction getTexture(name, textures) {\n\n\t\t\tif (textures[name] === undefined) {\n\n\t\t\t\tconsole.warn('THREE.MMDLoader: Undefined texture', name);\n\t\t\t}\n\n\t\t\treturn textures[name];\n\t\t}\n\n\t\tfor (var i = 0; i < model.metadata.materialCount; i++) {\n\n\t\t\tvar m = model.materials[i];\n\t\t\tvar params = {};\n\n\t\t\tparams.faceOffset = offset;\n\t\t\tparams.faceNum = m.faceCount;\n\n\t\t\toffset += m.faceCount;\n\n\t\t\tparams.name = m.name;\n\n\t\t\t/*\n    * Color\n    *\n    * MMD         MeshToonMaterial\n    * diffuse  -  color\n    * specular -  specular\n    * ambient  -  emissive * a\n    *               (a = 1.0 without map texture or 0.2 with map texture)\n    *\n    * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n    * It'll be too bright if material has map texture so using coef 0.2.\n    */\n\t\t\tparams.color = new THREE.Color(m.diffuse[0], m.diffuse[1], m.diffuse[2]);\n\t\t\tparams.opacity = m.diffuse[3];\n\t\t\tparams.specular = new THREE.Color(m.specular[0], m.specular[1], m.specular[2]);\n\t\t\tparams.shininess = m.shininess;\n\n\t\t\tif (params.opacity === 1.0) {\n\n\t\t\t\tparams.side = THREE.FrontSide;\n\t\t\t\tparams.transparent = false;\n\t\t\t} else {\n\n\t\t\t\tparams.side = THREE.DoubleSide;\n\t\t\t\tparams.transparent = true;\n\t\t\t}\n\n\t\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\t\tif (m.fileName) {\n\n\t\t\t\t\tvar fileName = m.fileName;\n\t\t\t\t\tvar fileNames = [];\n\n\t\t\t\t\tvar index = fileName.lastIndexOf('*');\n\n\t\t\t\t\tif (index >= 0) {\n\n\t\t\t\t\t\tfileNames.push(fileName.slice(0, index));\n\t\t\t\t\t\tfileNames.push(fileName.slice(index + 1));\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfileNames.push(fileName);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var j = 0; j < fileNames.length; j++) {\n\n\t\t\t\t\t\tvar n = fileNames[j];\n\n\t\t\t\t\t\tif (n.indexOf('.sph') >= 0 || n.indexOf('.spa') >= 0) {\n\n\t\t\t\t\t\t\tparams.envMap = loadTexture(n, { sphericalReflectionMapping: true });\n\n\t\t\t\t\t\t\tif (n.indexOf('.sph') >= 0) {\n\n\t\t\t\t\t\t\t\tparams.envMapType = THREE.MultiplyOperation;\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tparams.envMapType = THREE.AddOperation;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tparams.map = loadTexture(n);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (m.textureIndex !== -1) {\n\n\t\t\t\t\tvar n = model.textures[m.textureIndex];\n\t\t\t\t\tparams.map = loadTexture(n);\n\t\t\t\t}\n\n\t\t\t\t// TODO: support m.envFlag === 3\n\t\t\t\tif (m.envTextureIndex !== -1 && (m.envFlag === 1 || m.envFlag == 2)) {\n\n\t\t\t\t\tvar n = model.textures[m.envTextureIndex];\n\t\t\t\t\tparams.envMap = loadTexture(n, { sphericalReflectionMapping: true });\n\n\t\t\t\t\tif (m.envFlag === 1) {\n\n\t\t\t\t\t\tparams.envMapType = THREE.MultiplyOperation;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tparams.envMapType = THREE.AddOperation;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar coef = params.map === undefined ? 1.0 : 0.2;\n\t\t\tparams.emissive = new THREE.Color(m.ambient[0] * coef, m.ambient[1] * coef, m.ambient[2] * coef);\n\n\t\t\tmaterialParams.push(params);\n\t\t}\n\n\t\tfor (var i = 0; i < materialParams.length; i++) {\n\n\t\t\tvar p = materialParams[i];\n\t\t\tvar p2 = model.materials[i];\n\t\t\tvar m = new THREE.MeshToonMaterial();\n\n\t\t\tgeometry.addGroup(p.faceOffset * 3, p.faceNum * 3, i);\n\n\t\t\tif (p.name !== undefined) m.name = p.name;\n\n\t\t\tm.skinning = geometry.bones.length > 0 ? true : false;\n\t\t\tm.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n\t\t\tm.lights = true;\n\t\t\tm.side = model.metadata.format === 'pmx' && (p2.flag & 0x1) === 1 ? THREE.DoubleSide : p.side;\n\t\t\tm.transparent = p.transparent;\n\t\t\tm.fog = true;\n\n\t\t\tm.blending = THREE.CustomBlending;\n\t\t\tm.blendSrc = THREE.SrcAlphaFactor;\n\t\t\tm.blendDst = THREE.OneMinusSrcAlphaFactor;\n\t\t\tm.blendSrcAlpha = THREE.SrcAlphaFactor;\n\t\t\tm.blendDstAlpha = THREE.DstAlphaFactor;\n\n\t\t\tif (p.map !== undefined) {\n\n\t\t\t\t// Check if this part of the texture image the material uses requires transparency\n\t\t\t\tvar checkTextureTransparency = function checkTextureTransparency(m) {\n\n\t\t\t\t\tm.map.readyCallbacks.push(function (t) {\n\n\t\t\t\t\t\t// Is there any efficient ways?\n\t\t\t\t\t\tfunction createImageData(image) {\n\n\t\t\t\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\t\t\t\tc.width = image.width;\n\t\t\t\t\t\t\tc.height = image.height;\n\n\t\t\t\t\t\t\tvar ctx = c.getContext('2d');\n\t\t\t\t\t\t\tctx.drawImage(image, 0, 0);\n\n\t\t\t\t\t\t\treturn ctx.getImageData(0, 0, c.width, c.height);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction detectTextureTransparency(image, uvs, indices) {\n\n\t\t\t\t\t\t\tvar width = image.width;\n\t\t\t\t\t\t\tvar height = image.height;\n\t\t\t\t\t\t\tvar data = image.data;\n\t\t\t\t\t\t\tvar threshold = 253;\n\n\t\t\t\t\t\t\tif (data.length / (width * height) !== 4) {\n\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (var i = 0; i < indices.length; i += 3) {\n\n\t\t\t\t\t\t\t\tvar centerUV = { x: 0.0, y: 0.0 };\n\n\t\t\t\t\t\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\t\t\t\t\t\tvar index = indices[i * 3 + j];\n\t\t\t\t\t\t\t\t\tvar uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] };\n\n\t\t\t\t\t\t\t\t\tif (getAlphaByUv(image, uv) < threshold) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcenterUV.x += uv.x;\n\t\t\t\t\t\t\t\t\tcenterUV.y += uv.y;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcenterUV.x /= 3;\n\t\t\t\t\t\t\t\tcenterUV.y /= 3;\n\n\t\t\t\t\t\t\t\tif (getAlphaByUv(image, centerUV) < threshold) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n       * This method expects\n       *   t.flipY = false\n       *   t.wrapS = THREE.RepeatWrapping\n       *   t.wrapT = THREE.RepeatWrapping\n       * TODO: more precise\n       */\n\t\t\t\t\t\tfunction getAlphaByUv(image, uv) {\n\n\t\t\t\t\t\t\tvar width = image.width;\n\t\t\t\t\t\t\tvar height = image.height;\n\n\t\t\t\t\t\t\tvar x = Math.round(uv.x * width) % width;\n\t\t\t\t\t\t\tvar y = Math.round(uv.y * height) % height;\n\n\t\t\t\t\t\t\tif (x < 0) {\n\n\t\t\t\t\t\t\t\tx += width;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (y < 0) {\n\n\t\t\t\t\t\t\t\ty += height;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar index = y * width + x;\n\n\t\t\t\t\t\t\treturn image.data[index * 4 + 3];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar imageData = t.image.data !== undefined ? t.image : createImageData(t.image);\n\t\t\t\t\t\tvar indices = geometry.index.array.slice(m.faceOffset * 3, m.faceOffset * 3 + m.faceNum * 3);\n\n\t\t\t\t\t\tif (detectTextureTransparency(imageData, geometry.attributes.uv.array, indices)) m.transparent = true;\n\n\t\t\t\t\t\tdelete m.faceOffset;\n\t\t\t\t\t\tdelete m.faceNum;\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tm.faceOffset = p.faceOffset;\n\t\t\t\tm.faceNum = p.faceNum;\n\n\t\t\t\tm.map = getTexture(p.map, textures);\n\t\t\t\tcheckTextureTransparency(m);\n\t\t\t}\n\n\t\t\tif (p.envMap !== undefined) {\n\n\t\t\t\tm.envMap = getTexture(p.envMap, textures);\n\t\t\t\tm.combine = p.envMapType;\n\t\t\t}\n\n\t\t\tm.opacity = p.opacity;\n\t\t\tm.color = p.color;\n\n\t\t\tif (p.emissive !== undefined) {\n\n\t\t\t\tm.emissive = p.emissive;\n\t\t\t}\n\n\t\t\tm.specular = p.specular;\n\t\t\tm.shininess = Math.max(p.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif (model.metadata.format === 'pmd') {\n\t\t\t\tvar isDefaultToonTexture = function isDefaultToonTexture(n) {\n\n\t\t\t\t\tif (n.length !== 10) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn n.match(/toon(10|0[0-9]).bmp/) === null ? false : true;\n\t\t\t\t};\n\n\t\t\t\t// parameters for OutlineEffect\n\n\n\t\t\t\tm.outlineParameters = {\n\t\t\t\t\tthickness: p2.edgeFlag === 1 ? 0.003 : 0.0,\n\t\t\t\t\tcolor: new THREE.Color(0.0, 0.0, 0.0),\n\t\t\t\t\talpha: 1.0\n\t\t\t\t};\n\n\t\t\t\tif (m.outlineParameters.thickness === 0.0) m.outlineParameters.visible = false;\n\n\t\t\t\tvar toonFileName = p2.toonIndex === -1 ? 'toon00.bmp' : model.toonTextures[p2.toonIndex].fileName;\n\t\t\t\tvar uuid = loadTexture(toonFileName, { isToonTexture: true, defaultTexturePath: isDefaultToonTexture(toonFileName) });\n\t\t\t\tm.gradientMap = getTexture(uuid, textures);\n\t\t\t} else {\n\n\t\t\t\t// parameters for OutlineEffect\n\t\t\t\tm.outlineParameters = {\n\t\t\t\t\tthickness: p2.edgeSize / 300,\n\t\t\t\t\tcolor: new THREE.Color(p2.edgeColor[0], p2.edgeColor[1], p2.edgeColor[2]),\n\t\t\t\t\talpha: p2.edgeColor[3]\n\t\t\t\t};\n\n\t\t\t\tif ((p2.flag & 0x10) === 0 || m.outlineParameters.thickness === 0.0) m.outlineParameters.visible = false;\n\n\t\t\t\tvar toonFileName, isDefaultToon;\n\n\t\t\t\tif (p2.toonIndex === -1 || p2.toonFlag !== 0) {\n\n\t\t\t\t\tvar num = p2.toonIndex + 1;\n\t\t\t\t\ttoonFileName = 'toon' + (num < 10 ? '0' + num : num) + '.bmp';\n\t\t\t\t\tisDefaultToon = true;\n\t\t\t\t} else {\n\n\t\t\t\t\ttoonFileName = model.textures[p2.toonIndex];\n\t\t\t\t\tisDefaultToon = false;\n\t\t\t\t}\n\n\t\t\t\tvar uuid = loadTexture(toonFileName, { isToonTexture: true, defaultTexturePath: isDefaultToon });\n\t\t\t\tm.gradientMap = getTexture(uuid, textures);\n\t\t\t}\n\n\t\t\tmaterials.push(m);\n\t\t}\n\n\t\tif (model.metadata.format === 'pmx') {\n\t\t\tvar checkAlphaMorph = function checkAlphaMorph(morph, elements) {\n\n\t\t\t\tif (morph.type !== 8) {\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\t\tvar e = elements[i];\n\n\t\t\t\t\tif (e.index === -1) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar m = materials[e.index];\n\n\t\t\t\t\tif (m.opacity !== e.diffuse[3]) {\n\n\t\t\t\t\t\tm.transparent = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < model.morphs.length; i++) {\n\n\t\t\t\tvar morph = model.morphs[i];\n\t\t\t\tvar elements = morph.elements;\n\n\t\t\t\tif (morph.type === 0) {\n\n\t\t\t\t\tfor (var j = 0; j < elements.length; j++) {\n\n\t\t\t\t\t\tvar morph2 = model.morphs[elements[j].index];\n\t\t\t\t\t\tvar elements2 = morph2.elements;\n\n\t\t\t\t\t\tcheckAlphaMorph(morph2, elements2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tcheckAlphaMorph(morph, elements);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar initPhysics = function initPhysics() {\n\n\t\tvar rigidBodies = [];\n\t\tvar constraints = [];\n\n\t\tfor (var i = 0; i < model.metadata.rigidBodyCount; i++) {\n\n\t\t\tvar b = model.rigidBodies[i];\n\t\t\tvar keys = Object.keys(b);\n\n\t\t\tvar p = {};\n\n\t\t\tfor (var j = 0; j < keys.length; j++) {\n\n\t\t\t\tvar key = keys[j];\n\t\t\t\tp[key] = b[key];\n\t\t\t}\n\n\t\t\t/*\n    * RigidBody position parameter in PMX seems global position\n    * while the one in PMD seems offset from corresponding bone.\n    * So unify being offset.\n    */\n\t\t\tif (model.metadata.format === 'pmx') {\n\n\t\t\t\tif (p.boneIndex !== -1) {\n\n\t\t\t\t\tvar bone = model.bones[p.boneIndex];\n\t\t\t\t\tp.position[0] -= bone.position[0];\n\t\t\t\t\tp.position[1] -= bone.position[1];\n\t\t\t\t\tp.position[2] -= bone.position[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trigidBodies.push(p);\n\t\t}\n\n\t\tfor (var i = 0; i < model.metadata.constraintCount; i++) {\n\n\t\t\tvar c = model.constraints[i];\n\t\t\tvar keys = Object.keys(c);\n\n\t\t\tvar p = {};\n\n\t\t\tfor (var j = 0; j < keys.length; j++) {\n\n\t\t\t\tvar key = keys[j];\n\t\t\t\tp[key] = c[key];\n\t\t\t}\n\n\t\t\tvar bodyA = rigidBodies[p.rigidBodyIndex1];\n\t\t\tvar bodyB = rigidBodies[p.rigidBodyIndex2];\n\n\t\t\t/*\n    * Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n    */\n\t\t\tif (bodyA.type !== 0 && bodyB.type === 2) {\n\n\t\t\t\tif (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && model.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n\n\t\t\t\t\tbodyB.type = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconstraints.push(p);\n\t\t}\n\n\t\tgeometry.rigidBodies = rigidBodies;\n\t\tgeometry.constraints = constraints;\n\t};\n\n\tvar initGeometry = function initGeometry() {\n\n\t\tgeometry.setIndex(buffer.indices);\n\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(buffer.vertices, 3));\n\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(buffer.normals, 3));\n\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(buffer.uvs, 2));\n\t\tgeometry.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffer.skinIndices, 4));\n\t\tgeometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffer.skinWeights, 4));\n\n\t\tgeometry.computeBoundingSphere();\n\t\tgeometry.mmdFormat = model.metadata.format;\n\t};\n\n\tinitVartices();\n\tinitFaces();\n\tinitBones();\n\tinitIKs();\n\tinitGrants();\n\tinitMorphs();\n\tinitMaterials();\n\tinitPhysics();\n\tinitGeometry();\n\n\tvar mesh = new THREE.SkinnedMesh(geometry, materials);\n\n\t// console.log( mesh ); // for console debug\n\n\treturn mesh;\n};\n\nMMDLoader.prototype.createAnimation = function (mesh, vmd, name) {\n\n\tvar helper = new MMDLoader.DataCreationHelper();\n\n\tvar initMotionAnimations = function initMotionAnimations() {\n\n\t\tif (vmd.metadata.motionCount === 0) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar bones = mesh.geometry.bones;\n\t\tvar orderedMotions = helper.createOrderedMotionArrays(bones, vmd.motions, 'boneName');\n\n\t\tvar tracks = [];\n\n\t\tvar pushInterpolation = function pushInterpolation(array, interpolation, index) {\n\n\t\t\tarray.push(interpolation[index + 0] / 127); // x1\n\t\t\tarray.push(interpolation[index + 8] / 127); // x2\n\t\t\tarray.push(interpolation[index + 4] / 127); // y1\n\t\t\tarray.push(interpolation[index + 12] / 127); // y2\n\t\t};\n\n\t\tvar createTrack = function createTrack(node, type, times, values, interpolations) {\n\n\t\t\tvar track = new THREE[type](node, times, values);\n\n\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n\n\t\t\t\treturn new MMDLoader.CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n\t\t\t};\n\n\t\t\treturn track;\n\t\t};\n\n\t\tfor (var i = 0; i < orderedMotions.length; i++) {\n\n\t\t\tvar times = [];\n\t\t\tvar positions = [];\n\t\t\tvar rotations = [];\n\t\t\tvar pInterpolations = [];\n\t\t\tvar rInterpolations = [];\n\n\t\t\tvar bone = bones[i];\n\t\t\tvar array = orderedMotions[i];\n\n\t\t\tfor (var j = 0; j < array.length; j++) {\n\n\t\t\t\tvar time = array[j].frameNum / 30;\n\t\t\t\tvar pos = array[j].position;\n\t\t\t\tvar rot = array[j].rotation;\n\t\t\t\tvar interpolation = array[j].interpolation;\n\n\t\t\t\ttimes.push(time);\n\n\t\t\t\tfor (var k = 0; k < 3; k++) {\n\n\t\t\t\t\tpositions.push(bone.pos[k] + pos[k]);\n\t\t\t\t}\n\n\t\t\t\tfor (var k = 0; k < 4; k++) {\n\n\t\t\t\t\trotations.push(rot[k]);\n\t\t\t\t}\n\n\t\t\t\tfor (var k = 0; k < 3; k++) {\n\n\t\t\t\t\tpushInterpolation(pInterpolations, interpolation, k);\n\t\t\t\t}\n\n\t\t\t\tpushInterpolation(rInterpolations, interpolation, 3);\n\t\t\t}\n\n\t\t\tif (times.length === 0) continue;\n\n\t\t\tvar boneName = '.bones[' + bone.name + ']';\n\n\t\t\ttracks.push(createTrack(boneName + '.position', 'VectorKeyframeTrack', times, positions, pInterpolations));\n\t\t\ttracks.push(createTrack(boneName + '.quaternion', 'QuaternionKeyframeTrack', times, rotations, rInterpolations));\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name, -1, tracks);\n\n\t\tif (mesh.geometry.animations === undefined) mesh.geometry.animations = [];\n\t\tmesh.geometry.animations.push(clip);\n\t};\n\n\tvar initMorphAnimations = function initMorphAnimations() {\n\n\t\tif (vmd.metadata.morphCount === 0) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar orderedMorphs = helper.createOrderedMotionArrays(mesh.geometry.morphTargets, vmd.morphs, 'morphName');\n\n\t\tvar tracks = [];\n\n\t\tfor (var i = 0; i < orderedMorphs.length; i++) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\t\t\tvar array = orderedMorphs[i];\n\n\t\t\tfor (var j = 0; j < array.length; j++) {\n\n\t\t\t\ttimes.push(array[j].frameNum / 30);\n\t\t\t\tvalues.push(array[j].weight);\n\t\t\t}\n\n\t\t\tif (times.length === 0) continue;\n\n\t\t\ttracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + i + ']', times, values));\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name + 'Morph', -1, tracks);\n\n\t\tif (mesh.geometry.animations === undefined) mesh.geometry.animations = [];\n\t\tmesh.geometry.animations.push(clip);\n\t};\n\n\tinitMotionAnimations();\n\tinitMorphAnimations();\n};\n\nMMDLoader.DataCreationHelper = function () {};\n\nMMDLoader.DataCreationHelper.prototype = {\n\n\tconstructor: MMDLoader.DataCreationHelper,\n\n\t/*\n  * Note: Sometimes to use Japanese Unicode characters runs into problems in Three.js.\n  *       In such a case, use this method to convert it to Unicode hex charcode strings,\n  *       like '„ÅÇ„ÅÑ„ÅÜ' -> '0x30420x30440x3046'\n  */\n\n\ttoCharcodeStrings: function toCharcodeStrings(s) {\n\n\t\tvar str = '';\n\n\t\tfor (var i = 0; i < s.length; i++) {\n\n\t\t\tstr += '0x' + ('0000' + s[i].charCodeAt().toString(16)).substr(-4);\n\t\t}\n\n\t\treturn str;\n\t},\n\n\tcreateDictionary: function createDictionary(array) {\n\n\t\tvar dict = {};\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tdict[array[i].name] = i;\n\t\t}\n\n\t\treturn dict;\n\t},\n\n\tinitializeMotionArrays: function initializeMotionArrays(array) {\n\n\t\tvar result = [];\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tresult[i] = [];\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tsortMotionArray: function sortMotionArray(array) {\n\n\t\tarray.sort(function (a, b) {\n\n\t\t\treturn a.frameNum - b.frameNum;\n\t\t});\n\t},\n\n\tsortMotionArrays: function sortMotionArrays(arrays) {\n\n\t\tfor (var i = 0; i < arrays.length; i++) {\n\n\t\t\tthis.sortMotionArray(arrays[i]);\n\t\t}\n\t},\n\n\tcreateMotionArray: function createMotionArray(array) {\n\n\t\tvar result = [];\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tresult.push(array[i]);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tcreateMotionArrays: function createMotionArrays(array, result, dict, key) {\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tvar a = array[i];\n\t\t\tvar num = dict[a[key]];\n\n\t\t\tif (num === undefined) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult[num].push(a);\n\t\t}\n\t},\n\n\tcreateOrderedMotionArray: function createOrderedMotionArray(array) {\n\n\t\tvar result = this.createMotionArray(array);\n\t\tthis.sortMotionArray(result);\n\t\treturn result;\n\t},\n\n\tcreateOrderedMotionArrays: function createOrderedMotionArrays(targetArray, motionArray, key) {\n\n\t\tvar dict = this.createDictionary(targetArray);\n\t\tvar result = this.initializeMotionArrays(targetArray);\n\t\tthis.createMotionArrays(motionArray, result, dict, key);\n\t\tthis.sortMotionArrays(result);\n\n\t\treturn result;\n\t}\n\n};\n\nMMDLoader.CubicBezierInterpolation = function (parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n\n\tTHREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n\n\tthis.params = params;\n};\n\nMMDLoader.CubicBezierInterpolation.prototype = Object.create(THREE.LinearInterpolant.prototype);\nMMDLoader.CubicBezierInterpolation.prototype.constructor = MMDLoader.CubicBezierInterpolation;\n\nMMDLoader.CubicBezierInterpolation.prototype.interpolate_ = function (i1, t0, t, t1) {\n\n\tvar result = this.resultBuffer;\n\tvar values = this.sampleValues;\n\tvar stride = this.valueSize;\n\n\tvar offset1 = i1 * stride;\n\tvar offset0 = offset1 - stride;\n\n\t// No interpolation if next key frame is in one frame in 30fps. This is from MMD animation spec.\n\tvar weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);\n\n\tif (stride === 4) {\n\t\t// Quaternion\n\n\t\tvar x1 = this.params[i1 * 4 + 0];\n\t\tvar x2 = this.params[i1 * 4 + 1];\n\t\tvar y1 = this.params[i1 * 4 + 2];\n\t\tvar y2 = this.params[i1 * 4 + 3];\n\n\t\tvar ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n\t\tTHREE.Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n\t} else if (stride === 3) {\n\t\t// Vector3\n\n\t\tfor (var i = 0; i !== stride; ++i) {\n\n\t\t\tvar x1 = this.params[i1 * 12 + i * 4 + 0];\n\t\t\tvar x2 = this.params[i1 * 12 + i * 4 + 1];\n\t\t\tvar y1 = this.params[i1 * 12 + i * 4 + 2];\n\t\t\tvar y2 = this.params[i1 * 12 + i * 4 + 3];\n\n\t\t\tvar ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n\t\t\tresult[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n\t\t}\n\t} else {\n\t\t// Number\n\n\t\tvar x1 = this.params[i1 * 4 + 0];\n\t\tvar x2 = this.params[i1 * 4 + 1];\n\t\tvar y1 = this.params[i1 * 4 + 2];\n\t\tvar y2 = this.params[i1 * 4 + 3];\n\n\t\tvar ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n\t\tresult[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n\t}\n\n\treturn result;\n};\n\nMMDLoader.CubicBezierInterpolation.prototype._calculate = function (x1, x2, y1, y2, x) {\n\n\t/*\n  * Cubic Bezier curves\n  *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n  *\n  * B(t) = ( 1 - t ) ^ 3 * P0\n  *      + 3 * ( 1 - t ) ^ 2 * t * P1\n  *      + 3 * ( 1 - t ) * t^2 * P2\n  *      + t ^ 3 * P3\n  *      ( 0 <= t <= 1 )\n  *\n  * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n  *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n  *\n  *    x = ( 1 - t ) ^ 3 * x0\n  *      + 3 * ( 1 - t ) ^ 2 * t * x1\n  *      + 3 * ( 1 - t ) * t^2 * x2\n  *      + t ^ 3 * x3\n  *    y = ( 1 - t ) ^ 3 * y0\n  *      + 3 * ( 1 - t ) ^ 2 * t * y1\n  *      + 3 * ( 1 - t ) * t^2 * y2\n  *      + t ^ 3 * y3\n  *      ( x0 = 0, y0 = 0 )\n  *      ( x3 = 1, y3 = 1 )\n  *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n  *\n  * Here solves this equation with Bisection method,\n  *   https://en.wikipedia.org/wiki/Bisection_method\n  * gets t, and then calculate y.\n  *\n  * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n  *      + 3 * ( 1 - t ) * t^2 * x2\n  *      + t ^ 3 - x = 0\n  *\n  * (Another option: Newton's method\n  *    https://en.wikipedia.org/wiki/Newton%27s_method)\n  */\n\n\tvar c = 0.5;\n\tvar t = c;\n\tvar s = 1.0 - t;\n\tvar loop = 15;\n\tvar eps = 1e-5;\n\tvar math = Math;\n\n\tvar sst3, stt3, ttt;\n\n\tfor (var i = 0; i < loop; i++) {\n\n\t\tsst3 = 3.0 * s * s * t;\n\t\tstt3 = 3.0 * s * t * t;\n\t\tttt = t * t * t;\n\n\t\tvar ft = sst3 * x1 + stt3 * x2 + ttt - x;\n\n\t\tif (math.abs(ft) < eps) break;\n\n\t\tc /= 2.0;\n\n\t\tt += ft < 0 ? c : -c;\n\t\ts = 1.0 - t;\n\t}\n\n\treturn sst3 * y1 + stt3 * y2 + ttt;\n};\n\nTHREE.MMDAudioManager = function (audio, listener, p) {\n\n\tvar params = p === null || p === undefined ? {} : p;\n\n\tthis.audio = audio;\n\tthis.listener = listener;\n\n\tthis.elapsedTime = 0.0;\n\tthis.currentTime = 0.0;\n\tthis.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;\n\n\tthis.audioDuration = this.audio.buffer.duration;\n\tthis.duration = this.audioDuration + this.delayTime;\n};\n\nTHREE.MMDAudioManager.prototype = {\n\n\tconstructor: THREE.MMDAudioManager,\n\n\tcontrol: function control(delta) {\n\n\t\tthis.elapsed += delta;\n\t\tthis.currentTime += delta;\n\n\t\tif (this.checkIfStopAudio()) {\n\n\t\t\tthis.audio.stop();\n\t\t}\n\n\t\tif (this.checkIfStartAudio()) {\n\n\t\t\tthis.audio.play();\n\t\t}\n\t},\n\n\tcheckIfStartAudio: function checkIfStartAudio() {\n\n\t\tif (this.audio.isPlaying) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\twhile (this.currentTime >= this.duration) {\n\n\t\t\tthis.currentTime -= this.duration;\n\t\t}\n\n\t\tif (this.currentTime < this.delayTime) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.audio.startTime = this.currentTime - this.delayTime;\n\n\t\treturn true;\n\t},\n\n\tcheckIfStopAudio: function checkIfStopAudio() {\n\n\t\tif (!this.audio.isPlaying) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.currentTime >= this.duration) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n};\n\nTHREE.MMDGrantSolver = function (mesh) {\n\n\tthis.mesh = mesh;\n};\n\nTHREE.MMDGrantSolver.prototype = {\n\n\tconstructor: THREE.MMDGrantSolver,\n\n\tupdate: function () {\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function () {\n\n\t\t\tfor (var i = 0; i < this.mesh.geometry.grants.length; i++) {\n\n\t\t\t\tvar g = this.mesh.geometry.grants[i];\n\t\t\t\tvar b = this.mesh.skeleton.bones[g.index];\n\t\t\t\tvar pb = this.mesh.skeleton.bones[g.parentIndex];\n\n\t\t\t\tif (g.isLocal) {\n\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tif (g.affectPosition) {}\n\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tif (g.affectRotation) {}\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tif (g.affectPosition) {}\n\n\t\t\t\t\tif (g.affectRotation) {\n\n\t\t\t\t\t\tq.set(0, 0, 0, 1);\n\t\t\t\t\t\tq.slerp(pb.quaternion, g.ratio);\n\t\t\t\t\t\tb.quaternion.multiply(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}()\n\n};\n\nTHREE.MMDHelper = function () {\n\n\tthis.meshes = [];\n\n\tthis.doAnimation = true;\n\tthis.doIk = true;\n\tthis.doGrant = true;\n\tthis.doPhysics = true;\n\tthis.doCameraAnimation = true;\n\n\tthis.sharedPhysics = false;\n\tthis.masterPhysics = null;\n\n\tthis.audioManager = null;\n\tthis.camera = null;\n};\n\nTHREE.MMDHelper.prototype = {\n\n\tconstructor: THREE.MMDHelper,\n\n\tadd: function add(mesh) {\n\n\t\tif (!(mesh instanceof THREE.SkinnedMesh)) {\n\n\t\t\tthrow new Error('THREE.MMDHelper.add() accepts only THREE.SkinnedMesh instance.');\n\t\t}\n\n\t\tif (mesh.mixer === undefined) mesh.mixer = null;\n\t\tif (mesh.ikSolver === undefined) mesh.ikSolver = null;\n\t\tif (mesh.grantSolver === undefined) mesh.grantSolver = null;\n\t\tif (mesh.physics === undefined) mesh.physics = null;\n\t\tif (mesh.looped === undefined) mesh.looped = false;\n\n\t\tthis.meshes.push(mesh);\n\n\t\t// workaround until I make IK and Physics Animation plugin\n\t\tthis.initBackupBones(mesh);\n\t},\n\n\tsetAudio: function setAudio(audio, listener, params) {\n\n\t\tthis.audioManager = new THREE.MMDAudioManager(audio, listener, params);\n\t},\n\n\tsetCamera: function setCamera(camera) {\n\n\t\tcamera.mixer = null;\n\t\tthis.camera = camera;\n\t},\n\n\tsetPhysicses: function setPhysicses(params) {\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.setPhysics(this.meshes[i], params);\n\t\t}\n\t},\n\n\tsetPhysics: function setPhysics(mesh, params) {\n\n\t\tparams = params === undefined ? {} : Object.assign({}, params);\n\n\t\tif (params.world === undefined && this.sharedPhysics) {\n\n\t\t\tvar masterPhysics = this.getMasterPhysics();\n\n\t\t\tif (masterPhysics !== null) params.world = masterPhysics.world;\n\t\t}\n\n\t\tvar warmup = params.warmup !== undefined ? params.warmup : 60;\n\n\t\tvar physics = new THREE.MMDPhysics(mesh, params);\n\n\t\tif (mesh.mixer !== null && mesh.mixer !== undefined && params.preventAnimationWarmup !== true) {\n\n\t\t\tthis.animateOneMesh(0, mesh);\n\t\t\tphysics.reset();\n\t\t}\n\n\t\tphysics.warmup(warmup);\n\n\t\tthis.updateIKParametersDependingOnPhysicsEnabled(mesh, true);\n\n\t\tmesh.physics = physics;\n\t},\n\n\tgetMasterPhysics: function getMasterPhysics() {\n\n\t\tif (this.masterPhysics !== null) return this.masterPhysics;\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tvar physics = this.meshes[i].physics;\n\n\t\t\tif (physics !== undefined && physics !== null) {\n\n\t\t\t\tthis.masterPhysics = physics;\n\t\t\t\treturn this.masterPhysics;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tenablePhysics: function enablePhysics(enabled) {\n\n\t\tif (enabled === true) {\n\n\t\t\tthis.doPhysics = true;\n\t\t} else {\n\n\t\t\tthis.doPhysics = false;\n\t\t}\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tthis.updateIKParametersDependingOnPhysicsEnabled(this.meshes[i], enabled);\n\t\t}\n\t},\n\n\tupdateIKParametersDependingOnPhysicsEnabled: function updateIKParametersDependingOnPhysicsEnabled(mesh, physicsEnabled) {\n\n\t\tvar iks = mesh.geometry.iks;\n\t\tvar bones = mesh.geometry.bones;\n\n\t\tfor (var j = 0, jl = iks.length; j < jl; j++) {\n\n\t\t\tvar ik = iks[j];\n\t\t\tvar links = ik.links;\n\n\t\t\tfor (var k = 0, kl = links.length; k < kl; k++) {\n\n\t\t\t\tvar link = links[k];\n\n\t\t\t\tif (physicsEnabled === true) {\n\n\t\t\t\t\t// disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n\t\t\t\t\t// because its rotation will be overriden by physics\n\t\t\t\t\tlink.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n\t\t\t\t} else {\n\n\t\t\t\t\tlink.enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAnimations: function setAnimations() {\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.setAnimation(this.meshes[i]);\n\t\t}\n\t},\n\n\tsetAnimation: function setAnimation(mesh) {\n\n\t\tif (mesh.geometry.animations !== undefined) {\n\n\t\t\tmesh.mixer = new THREE.AnimationMixer(mesh);\n\n\t\t\t// TODO: find a workaround not to access (seems like) private properties\n\t\t\t//       the name of them begins with \"_\".\n\t\t\tmesh.mixer.addEventListener('loop', function (e) {\n\n\t\t\t\tif (e.action._clip.tracks.length > 0 && e.action._clip.tracks[0].name.indexOf('.bones') !== 0) return;\n\n\t\t\t\tvar mesh = e.target._root;\n\t\t\t\tmesh.looped = true;\n\t\t\t});\n\n\t\t\tvar foundAnimation = false;\n\t\t\tvar foundMorphAnimation = false;\n\n\t\t\tfor (var i = 0; i < mesh.geometry.animations.length; i++) {\n\n\t\t\t\tvar clip = mesh.geometry.animations[i];\n\n\t\t\t\tvar action = mesh.mixer.clipAction(clip);\n\n\t\t\t\tif (clip.tracks.length > 0 && clip.tracks[0].name.indexOf('.morphTargetInfluences') === 0) {\n\n\t\t\t\t\tif (!foundMorphAnimation) {\n\n\t\t\t\t\t\taction.play();\n\t\t\t\t\t\tfoundMorphAnimation = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (!foundAnimation) {\n\n\t\t\t\t\t\taction.play();\n\t\t\t\t\t\tfoundAnimation = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundAnimation) {\n\n\t\t\t\tmesh.ikSolver = new THREE.CCDIKSolver(mesh);\n\n\t\t\t\tif (mesh.geometry.grants !== undefined) {\n\n\t\t\t\t\tmesh.grantSolver = new THREE.MMDGrantSolver(mesh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsetCameraAnimation: function setCameraAnimation(camera) {\n\n\t\tif (camera.animations !== undefined) {\n\n\t\t\tcamera.mixer = new THREE.AnimationMixer(camera);\n\t\t\tcamera.mixer.clipAction(camera.animations[0]).play();\n\t\t}\n\t},\n\n\t/*\n  * detect the longest duration among model, camera, and audio animations and then\n  * set it to them to sync.\n  * TODO: touching private properties ( ._actions and ._clip ) so consider better way\n  *       to access them for safe and modularity.\n  */\n\tunifyAnimationDuration: function unifyAnimationDuration(params) {\n\n\t\tparams = params === undefined ? {} : params;\n\n\t\tvar max = 0.0;\n\n\t\tvar camera = this.camera;\n\t\tvar audioManager = this.audioManager;\n\n\t\t// check the longest duration\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tvar mesh = this.meshes[i];\n\t\t\tvar mixer = mesh.mixer;\n\n\t\t\tif (mixer === null) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < mixer._actions.length; j++) {\n\n\t\t\t\tvar action = mixer._actions[j];\n\t\t\t\tmax = Math.max(max, action._clip.duration);\n\t\t\t}\n\t\t}\n\n\t\tif (camera !== null && camera.mixer !== null) {\n\n\t\t\tvar mixer = camera.mixer;\n\n\t\t\tfor (var i = 0; i < mixer._actions.length; i++) {\n\n\t\t\t\tvar action = mixer._actions[i];\n\t\t\t\tmax = Math.max(max, action._clip.duration);\n\t\t\t}\n\t\t}\n\n\t\tif (audioManager !== null) {\n\n\t\t\tmax = Math.max(max, audioManager.duration);\n\t\t}\n\n\t\tif (params.afterglow !== undefined) {\n\n\t\t\tmax += params.afterglow;\n\t\t}\n\n\t\t// set the duration\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tvar mesh = this.meshes[i];\n\t\t\tvar mixer = mesh.mixer;\n\n\t\t\tif (mixer === null) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < mixer._actions.length; j++) {\n\n\t\t\t\tvar action = mixer._actions[j];\n\t\t\t\taction._clip.duration = max;\n\t\t\t}\n\t\t}\n\n\t\tif (camera !== null && camera.mixer !== null) {\n\n\t\t\tvar mixer = camera.mixer;\n\n\t\t\tfor (var i = 0; i < mixer._actions.length; i++) {\n\n\t\t\t\tvar action = mixer._actions[i];\n\t\t\t\taction._clip.duration = max;\n\t\t\t}\n\t\t}\n\n\t\tif (audioManager !== null) {\n\n\t\t\taudioManager.duration = max;\n\t\t}\n\t},\n\n\tcontrolAudio: function controlAudio(delta) {\n\n\t\tif (this.audioManager === null) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.audioManager.control(delta);\n\t},\n\n\tanimate: function animate(delta) {\n\n\t\tthis.controlAudio(delta);\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.animateOneMesh(delta, this.meshes[i]);\n\t\t}\n\n\t\tif (this.sharedPhysics) this.updateSharedPhysics(delta);\n\n\t\tthis.animateCamera(delta);\n\t},\n\n\tanimateOneMesh: function animateOneMesh(delta, mesh) {\n\n\t\tvar mixer = mesh.mixer;\n\t\tvar ikSolver = mesh.ikSolver;\n\t\tvar grantSolver = mesh.grantSolver;\n\t\tvar physics = mesh.physics;\n\n\t\tif (mixer !== null && this.doAnimation === true) {\n\n\t\t\t// restore/backupBones are workaround\n\t\t\t// until I make IK, Grant, and Physics Animation plugin\n\t\t\tthis.restoreBones(mesh);\n\n\t\t\tmixer.update(delta);\n\n\t\t\tthis.backupBones(mesh);\n\t\t}\n\n\t\tif (ikSolver !== null && this.doIk === true) {\n\n\t\t\tikSolver.update();\n\t\t}\n\n\t\tif (grantSolver !== null && this.doGrant === true) {\n\n\t\t\tgrantSolver.update();\n\t\t}\n\n\t\tif (mesh.looped === true) {\n\n\t\t\tif (physics !== null) physics.reset();\n\n\t\t\tmesh.looped = false;\n\t\t}\n\n\t\tif (physics !== null && this.doPhysics && !this.sharedPhysics) {\n\n\t\t\tphysics.update(delta);\n\t\t}\n\t},\n\n\tupdateSharedPhysics: function updateSharedPhysics(delta) {\n\n\t\tif (this.meshes.length === 0 || !this.doPhysics || !this.sharedPhysics) return;\n\n\t\tvar physics = this.getMasterPhysics();\n\n\t\tif (physics === null) return;\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tvar p = this.meshes[i].physics;\n\n\t\t\tif (p !== null && p !== undefined) {\n\n\t\t\t\tp.updateRigidBodies();\n\t\t\t}\n\t\t}\n\n\t\tphysics.stepSimulation(delta);\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tvar p = this.meshes[i].physics;\n\n\t\t\tif (p !== null && p !== undefined) {\n\n\t\t\t\tp.updateBones();\n\t\t\t}\n\t\t}\n\t},\n\n\tanimateCamera: function animateCamera(delta) {\n\n\t\tif (this.camera === null) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar mixer = this.camera.mixer;\n\n\t\tif (mixer !== null && this.camera.center !== undefined && this.doCameraAnimation === true) {\n\n\t\t\tmixer.update(delta);\n\n\t\t\t// TODO: Let PerspectiveCamera automatically update?\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis.camera.up.set(0, 1, 0);\n\t\t\tthis.camera.up.applyQuaternion(this.camera.quaternion);\n\t\t\tthis.camera.lookAt(this.camera.center);\n\t\t}\n\t},\n\n\tposeAsVpd: function poseAsVpd(mesh, vpd, params) {\n\n\t\tif (params === undefined) params = {};\n\n\t\tif (params.preventResetPose !== true) mesh.pose();\n\n\t\tvar bones = mesh.skeleton.bones;\n\t\tvar bones2 = vpd.bones;\n\n\t\tvar table = {};\n\n\t\tfor (var i = 0; i < bones.length; i++) {\n\n\t\t\ttable[bones[i].name] = i;\n\t\t}\n\n\t\tvar thV = new THREE.Vector3();\n\t\tvar thQ = new THREE.Quaternion();\n\n\t\tfor (var i = 0; i < bones2.length; i++) {\n\n\t\t\tvar b = bones2[i];\n\t\t\tvar index = table[b.name];\n\n\t\t\tif (index === undefined) continue;\n\n\t\t\tvar b2 = bones[index];\n\t\t\tvar t = b.translation;\n\t\t\tvar q = b.quaternion;\n\n\t\t\tthV.set(t[0], t[1], t[2]);\n\t\t\tthQ.set(q[0], q[1], q[2], q[3]);\n\n\t\t\tb2.position.add(thV);\n\t\t\tb2.quaternion.multiply(thQ);\n\t\t}\n\n\t\tmesh.updateMatrixWorld(true);\n\n\t\tif (params.preventIk !== true) {\n\n\t\t\tvar solver = new THREE.CCDIKSolver(mesh);\n\t\t\tsolver.update(params.saveOriginalBonesBeforeIK);\n\t\t}\n\n\t\tif (params.preventGrant !== true && mesh.geometry.grants !== undefined) {\n\n\t\t\tvar solver = new THREE.MMDGrantSolver(mesh);\n\t\t\tsolver.update();\n\t\t}\n\t},\n\n\t/*\n  * Note: These following three functions are workaround for r74dev.\n  *       THREE.PropertyMixer.apply() seems to save values into buffer cache\n  *       when mixer.update() is called.\n  *       ikSolver.update() and physics.update() change bone position/quaternion\n  *       without mixer.update() then buffer cache will be inconsistent.\n  *       So trying to avoid buffer cache inconsistency by doing\n  *       backup bones position/quaternion right after mixer.update() call\n  *       and then restore them after rendering.\n  */\n\tinitBackupBones: function initBackupBones(mesh) {\n\n\t\tmesh.skeleton.backupBones = [];\n\n\t\tfor (var i = 0; i < mesh.skeleton.bones.length; i++) {\n\n\t\t\tmesh.skeleton.backupBones.push(mesh.skeleton.bones[i].clone());\n\t\t}\n\t},\n\n\tbackupBones: function backupBones(mesh) {\n\n\t\tmesh.skeleton.backupBoneIsSaved = true;\n\n\t\tfor (var i = 0; i < mesh.skeleton.bones.length; i++) {\n\n\t\t\tvar b = mesh.skeleton.backupBones[i];\n\t\t\tvar b2 = mesh.skeleton.bones[i];\n\t\t\tb.position.copy(b2.position);\n\t\t\tb.quaternion.copy(b2.quaternion);\n\t\t}\n\t},\n\n\trestoreBones: function restoreBones(mesh) {\n\n\t\tif (mesh.skeleton.backupBoneIsSaved !== true) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tmesh.skeleton.backupBoneIsSaved = false;\n\n\t\tfor (var i = 0; i < mesh.skeleton.bones.length; i++) {\n\n\t\t\tvar b = mesh.skeleton.bones[i];\n\t\t\tvar b2 = mesh.skeleton.backupBones[i];\n\t\t\tb.position.copy(b2.position);\n\t\t\tb.quaternion.copy(b2.quaternion);\n\t\t}\n\t}\n\n};\n\nexports.default = MMDLoader;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author sunag / http://www.sunag.com.br/\n */\n\nvar NodeMaterialLoader = function NodeMaterialLoader(manager, library) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.nodes = {};\n\tthis.materials = {};\n\tthis.passes = {};\n\tthis.names = {};\n\tthis.library = library || {};\n};\n\nvar NodeMaterialLoaderUtils = {\n\n\treplaceUUIDObject: function replaceUUIDObject(object, uuid, value, recursive) {\n\n\t\trecursive = recursive !== undefined ? recursive : true;\n\n\t\tif ((typeof uuid === \"undefined\" ? \"undefined\" : _typeof(uuid)) === \"object\") uuid = uuid.uuid;\n\n\t\tif ((typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) === \"object\") {\n\n\t\t\tvar keys = Object.keys(object);\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\n\t\t\t\tvar key = keys[i];\n\n\t\t\t\tif (recursive) {\n\n\t\t\t\t\tobject[key] = this.replaceUUIDObject(object[key], uuid, value);\n\t\t\t\t}\n\n\t\t\t\tif (key === uuid) {\n\n\t\t\t\t\tobject[uuid] = object[key];\n\n\t\t\t\t\tdelete object[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn object === uuid ? value : object;\n\t},\n\n\treplaceUUID: function replaceUUID(json, uuid, value) {\n\n\t\tthis.replaceUUIDObject(json, uuid, value, false);\n\t\tthis.replaceUUIDObject(json.nodes, uuid, value);\n\t\tthis.replaceUUIDObject(json.materials, uuid, value);\n\t\tthis.replaceUUIDObject(json.passes, uuid, value);\n\t\tthis.replaceUUIDObject(json.library, uuid, value, false);\n\n\t\treturn json;\n\t}\n\n};\n\nObject.assign(NodeMaterialLoader.prototype, {\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t}, onProgress, onError);\n\n\t\treturn this;\n\t},\n\n\tgetObjectByName: function getObjectByName(uuid) {\n\n\t\treturn this.names[uuid];\n\t},\n\n\tgetObjectById: function getObjectById(uuid) {\n\n\t\treturn this.library[uuid] || this.nodes[uuid] || this.names[uuid];\n\t},\n\n\tgetNode: function getNode(uuid) {\n\n\t\tvar object = this.getObjectById(uuid);\n\n\t\tif (!object) {\n\n\t\t\tconsole.warn(\"Node \\\"\" + uuid + \"\\\" not found.\");\n\t\t}\n\n\t\treturn object;\n\t},\n\n\tparse: function parse(json) {\n\n\t\tvar uuid, node, object, prop, i;\n\n\t\tfor (uuid in json.nodes) {\n\n\t\t\tnode = json.nodes[uuid];\n\n\t\t\tobject = new THREE[node.type]();\n\n\t\t\tif (node.name) {\n\n\t\t\t\tobject.name = node.name;\n\n\t\t\t\tthis.names[object.name] = object;\n\t\t\t} else {\n\n\t\t\t\t// ignore \"uniform\" shader input ( for optimization )\n\t\t\t\tobject.readonly = true;\n\t\t\t}\n\n\t\t\tif (node.readonly !== undefined) object.readonly = node.readonly;\n\n\t\t\tthis.nodes[uuid] = object;\n\t\t}\n\n\t\tfor (uuid in json.materials) {\n\n\t\t\tnode = json.materials[uuid];\n\n\t\t\tobject = new THREE[node.type]();\n\n\t\t\tif (node.name) {\n\n\t\t\t\tobject.name = node.name;\n\n\t\t\t\tthis.names[object.name] = object;\n\t\t\t}\n\n\t\t\tthis.materials[uuid] = object;\n\t\t}\n\n\t\tfor (uuid in json.passes) {\n\n\t\t\tnode = json.passes[uuid];\n\n\t\t\tobject = new THREE[node.type]();\n\n\t\t\tif (node.name) {\n\n\t\t\t\tobject.name = node.name;\n\n\t\t\t\tthis.names[object.name] = object;\n\t\t\t}\n\n\t\t\tthis.passes[uuid] = object;\n\t\t}\n\n\t\tif (json.material) this.material = this.materials[uuid];\n\t\tif (json.pass) this.pass = this.passes[uuid];\n\n\t\tfor (uuid in json.nodes) {\n\n\t\t\tnode = json.nodes[uuid];\n\t\t\tobject = this.nodes[uuid];\n\n\t\t\tswitch (node.type) {\n\n\t\t\t\tcase \"FloatNode\":\n\n\t\t\t\t\tobject.number = node.number;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ColorNode\":\n\n\t\t\t\t\tobject.value.copy(node);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Vector2Node\":\n\n\t\t\t\t\tobject.x = node.x;\n\t\t\t\t\tobject.y = node.y;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Vector3Node\":\n\n\t\t\t\t\tobject.x = node.x;\n\t\t\t\t\tobject.y = node.y;\n\t\t\t\t\tobject.z = node.z;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Vector4Node\":\n\n\t\t\t\t\tobject.x = node.x;\n\t\t\t\t\tobject.y = node.y;\n\t\t\t\t\tobject.z = node.z;\n\t\t\t\t\tobject.w = node.w;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Matrix3Node\":\n\t\t\t\tcase \"Matrix4Node\":\n\n\t\t\t\t\tobject.value.fromArray(node.elements);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"OperatorNode\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.b = this.getNode(node.b);\n\t\t\t\t\tobject.op = node.op;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Math1Node\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Math2Node\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.b = this.getNode(node.b);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Math3Node\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.b = this.getNode(node.b);\n\t\t\t\t\tobject.c = this.getNode(node.c);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"UVNode\":\n\t\t\t\tcase \"ColorsNode\":\n\n\t\t\t\t\tobject.index = node.index;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"LuminanceNode\":\n\n\t\t\t\t\tobject.rgb = this.getNode(node.rgb);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"PositionNode\":\n\t\t\t\tcase \"NormalNode\":\n\t\t\t\tcase \"ReflectNode\":\n\t\t\t\tcase \"LightNode\":\n\n\t\t\t\t\tobject.scope = node.scope;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"SwitchNode\":\n\n\t\t\t\t\tobject.node = this.getNode(node.node);\n\t\t\t\t\tobject.components = node.components;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"JoinNode\":\n\n\t\t\t\t\tfor (prop in node.inputs) {\n\n\t\t\t\t\t\tobject[prop] = this.getNode(node.inputs[prop]);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"CameraNode\":\n\n\t\t\t\t\tobject.setScope(node.scope);\n\n\t\t\t\t\tif (node.camera) object.setCamera(this.getNode(node.camera));\n\n\t\t\t\t\tswitch (node.scope) {\n\n\t\t\t\t\t\tcase THREE.CameraNode.DEPTH:\n\n\t\t\t\t\t\t\tobject.near.number = node.near;\n\t\t\t\t\t\t\tobject.far.number = node.far;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ColorAdjustmentNode\":\n\n\t\t\t\t\tobject.rgb = this.getNode(node.rgb);\n\t\t\t\t\tobject.adjustment = this.getNode(node.adjustment);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"UVTransformNode\":\n\n\t\t\t\t\tobject.uv = this.getNode(node.uv);\n\t\t\t\t\tobject.transform = this.getNode(node.transform);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"BumpNode\":\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\t\t\t\t\tobject.scale = this.getNode(node.scale);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"BlurNode\":\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\t\t\t\t\tobject.scale = this.getNode(node.scale);\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\t\t\t\t\tobject.radius = this.getNode(node.radius);\n\n\t\t\t\t\tif (node.size !== undefined) object.size = new THREE.Vector2(node.size.x, node.size.y);\n\n\t\t\t\t\tobject.blurX = node.blurX;\n\t\t\t\t\tobject.blurY = node.blurY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ResolutionNode\":\n\n\t\t\t\t\tobject.renderer = this.getNode(node.renderer);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ScreenUVNode\":\n\n\t\t\t\t\tobject.resolution = this.getNode(node.resolution);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"VelocityNode\":\n\n\t\t\t\t\tif (node.target) object.setTarget(this.getNode(node.target));\n\t\t\t\t\tobject.setParams(node.params);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"TimerNode\":\n\n\t\t\t\t\tobject.scope = node.scope;\n\t\t\t\t\tobject.scale = node.scale;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ConstNode\":\n\n\t\t\t\t\tobject.name = node.name;\n\t\t\t\t\tobject.type = node.out;\n\t\t\t\t\tobject.value = node.value;\n\t\t\t\t\tobject.useDefine = node.useDefine === true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"AttributeNode\":\n\t\t\t\tcase \"VarNode\":\n\n\t\t\t\t\tobject.type = node.out;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ReflectorNode\":\n\n\t\t\t\t\tobject.setMirror(this.getNode(node.mirror));\n\n\t\t\t\t\tif (node.offset) object.offset = this.getNode(node.offset);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"NoiseNode\":\n\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"FunctionNode\":\n\n\t\t\t\t\tobject.isMethod = node.isMethod;\n\t\t\t\t\tobject.useKeywords = node.useKeywords;\n\n\t\t\t\t\tobject.extensions = node.extensions;\n\t\t\t\t\tobject.keywords = {};\n\n\t\t\t\t\tfor (prop in node.keywords) {\n\n\t\t\t\t\t\tobject.keywords[prop] = this.getNode(node.keywords[prop]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node.includes) {\n\n\t\t\t\t\t\tfor (i = 0; i < node.includes.length; i++) {\n\n\t\t\t\t\t\t\tobject.includes.push(this.getNode(node.includes[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.eval(node.src, object.includes, object.extensions, object.keywords);\n\n\t\t\t\t\tif (!object.isMethod) object.type = node.out;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"FunctionCallNode\":\n\n\t\t\t\t\tfor (prop in node.inputs) {\n\n\t\t\t\t\t\tobject.inputs[prop] = this.getNode(node.inputs[prop]);\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"TextureNode\":\n\t\t\t\tcase \"CubeTextureNode\":\n\t\t\t\tcase \"ScreenNode\":\n\n\t\t\t\t\tif (node.value) object.value = this.getNode(node.value);\n\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\n\t\t\t\t\tif (node.bias) object.bias = this.getNode(node.bias);\n\t\t\t\t\tif (object.project !== undefined) object.project = node.project;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"RoughnessToBlinnExponentNode\":\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"RawNode\":\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"StandardNode\":\n\t\t\t\tcase \"PhongNode\":\n\t\t\t\tcase \"SpriteNode\":\n\n\t\t\t\t\tobject.color = this.getNode(node.color);\n\n\t\t\t\t\tif (node.alpha) object.alpha = this.getNode(node.alpha);\n\n\t\t\t\t\tif (node.specular) object.specular = this.getNode(node.specular);\n\t\t\t\t\tif (node.shininess) object.shininess = this.getNode(node.shininess);\n\n\t\t\t\t\tif (node.roughness) object.roughness = this.getNode(node.roughness);\n\t\t\t\t\tif (node.metalness) object.metalness = this.getNode(node.metalness);\n\n\t\t\t\t\tif (node.reflectivity) object.reflectivity = this.getNode(node.reflectivity);\n\n\t\t\t\t\tif (node.clearCoat) object.clearCoat = this.getNode(node.clearCoat);\n\t\t\t\t\tif (node.clearCoatRoughness) object.clearCoatRoughness = this.getNode(node.clearCoatRoughness);\n\n\t\t\t\t\tif (node.normal) object.normal = this.getNode(node.normal);\n\t\t\t\t\tif (node.normalScale) object.normalScale = this.getNode(node.normalScale);\n\n\t\t\t\t\tif (node.emissive) object.emissive = this.getNode(node.emissive);\n\t\t\t\t\tif (node.ambient) object.ambient = this.getNode(node.ambient);\n\n\t\t\t\t\tif (node.shadow) object.shadow = this.getNode(node.shadow);\n\t\t\t\t\tif (node.light) object.light = this.getNode(node.light);\n\n\t\t\t\t\tif (node.ao) object.ao = this.getNode(node.ao);\n\n\t\t\t\t\tif (node.environment) object.environment = this.getNode(node.environment);\n\t\t\t\t\tif (node.environmentAlpha) object.environmentAlpha = this.getNode(node.environmentAlpha);\n\n\t\t\t\t\tif (node.transform) object.transform = this.getNode(node.transform);\n\n\t\t\t\t\tif (node.spherical === false) object.spherical = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn(node.type, \"not supported.\");\n\n\t\t\t}\n\t\t}\n\n\t\tfor (uuid in json.materials) {\n\n\t\t\tnode = json.materials[uuid];\n\t\t\tobject = this.materials[uuid];\n\n\t\t\tif (node.name !== undefined) object.name = node.name;\n\n\t\t\tif (node.blending !== undefined) object.blending = node.blending;\n\t\t\tif (node.flatShading !== undefined) object.flatShading = node.flatShading;\n\t\t\tif (node.side !== undefined) object.side = node.side;\n\n\t\t\tobject.depthFunc = node.depthFunc;\n\t\t\tobject.depthTest = node.depthTest;\n\t\t\tobject.depthWrite = node.depthWrite;\n\n\t\t\tif (node.wireframe !== undefined) object.wireframe = node.wireframe;\n\t\t\tif (node.wireframeLinewidth !== undefined) object.wireframeLinewidth = node.wireframeLinewidth;\n\t\t\tif (node.wireframeLinecap !== undefined) object.wireframeLinecap = node.wireframeLinecap;\n\t\t\tif (node.wireframeLinejoin !== undefined) object.wireframeLinejoin = node.wireframeLinejoin;\n\n\t\t\tif (node.skinning !== undefined) object.skinning = node.skinning;\n\t\t\tif (node.morphTargets !== undefined) object.morphTargets = node.morphTargets;\n\n\t\t\tif (node.visible !== undefined) object.visible = node.visible;\n\t\t\tif (node.userData !== undefined) object.userData = node.userData;\n\n\t\t\tobject.vertex = this.getNode(node.vertex);\n\t\t\tobject.fragment = this.getNode(node.fragment);\n\n\t\t\tif (object.vertex === object.fragment) {\n\n\t\t\t\t// replace main node\n\n\t\t\t\tobject.node = object.vertex;\n\t\t\t}\n\n\t\t\tobject.build();\n\n\t\t\tif (node.fog !== undefined) object.fog = node.fog;\n\t\t\tif (node.lights !== undefined) object.lights = node.lights;\n\n\t\t\tif (node.transparent !== undefined) object.transparent = node.transparent;\n\t\t}\n\n\t\tfor (uuid in json.passes) {\n\n\t\t\tnode = json.passes[uuid];\n\t\t\tobject = this.passes[uuid];\n\n\t\t\tobject.value = this.getNode(node.value);\n\n\t\t\tobject.build();\n\t\t}\n\n\t\treturn this.material || this.pass || this;\n\t}\n\n});\n\nexports.default = NodeMaterialLoader;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Volume = __webpack_require__(10);\n\nvar _Volume2 = _interopRequireDefault(_Volume);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar NRRDLoader = function NRRDLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nNRRDLoader.prototype = {\n\n\tconstructor: NRRDLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (data) {\n\n\t\t\tonLoad(scope.parse(data));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\t// this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n\t\tvar _data = data;\n\n\t\tvar _dataPointer = 0;\n\n\t\tvar _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n\n\t\tvar _littleEndian = true;\n\n\t\tvar headerObject = {};\n\n\t\tfunction scan(type, chunks) {\n\n\t\t\tif (chunks === undefined || chunks === null) {\n\n\t\t\t\tchunks = 1;\n\t\t\t}\n\n\t\t\tvar _chunkSize = 1;\n\t\t\tvar _array_type = Uint8Array;\n\n\t\t\tswitch (type) {\n\n\t\t\t\t// 1 byte data types\n\t\t\t\tcase 'uchar':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'schar':\n\t\t\t\t\t_array_type = Int8Array;\n\t\t\t\t\tbreak;\n\t\t\t\t// 2 byte data types\n\t\t\t\tcase 'ushort':\n\t\t\t\t\t_array_type = Uint16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sshort':\n\t\t\t\t\t_array_type = Int16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t// 4 byte data types\n\t\t\t\tcase 'uint':\n\t\t\t\t\t_array_type = Uint32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sint':\n\t\t\t\t\t_array_type = Int32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\t\t_array_type = Float32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complex':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'double':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// increase the data pointer in-place\n\t\t\tvar _bytes = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n\n\t\t\t// if required, flip the endianness of the bytes\n\t\t\tif (_nativeLittleEndian != _littleEndian) {\n\n\t\t\t\t// we need to flip here since the format doesn't match the native endianness\n\t\t\t\t_bytes = flipEndianness(_bytes, _chunkSize);\n\t\t\t}\n\n\t\t\tif (chunks == 1) {\n\n\t\t\t\t// if only one chunk was requested, just return one value\n\t\t\t\treturn _bytes[0];\n\t\t\t}\n\n\t\t\t// return the byte array\n\t\t\treturn _bytes;\n\t\t}\n\n\t\t//Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n\t\tfunction flipEndianness(array, chunkSize) {\n\n\t\t\tvar u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n\t\t\tfor (var i = 0; i < array.byteLength; i += chunkSize) {\n\n\t\t\t\tfor (var j = i + chunkSize - 1, k = i; j > k; j--, k++) {\n\n\t\t\t\t\tvar tmp = u8[k];\n\t\t\t\t\tu8[k] = u8[j];\n\t\t\t\t\tu8[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\t//parse the header\n\t\tfunction parseHeader(header) {\n\n\t\t\tvar data, field, fn, i, l, lines, m, _i, _len;\n\t\t\tlines = header.split(/\\r?\\n/);\n\t\t\tfor (_i = 0, _len = lines.length; _i < _len; _i++) {\n\n\t\t\t\tl = lines[_i];\n\t\t\t\tif (l.match(/NRRD\\d+/)) {\n\n\t\t\t\t\theaderObject.isNrrd = true;\n\t\t\t\t} else if (l.match(/^#/)) {} else if (m = l.match(/(.*):(.*)/)) {\n\n\t\t\t\t\tfield = m[1].trim();\n\t\t\t\t\tdata = m[2].trim();\n\t\t\t\t\tfn = THREE.NRRDLoader.prototype.fieldFunctions[field];\n\t\t\t\t\tif (fn) {\n\n\t\t\t\t\t\tfn.call(headerObject, data);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\theaderObject[field] = data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!headerObject.isNrrd) {\n\n\t\t\t\tthrow new Error('Not an NRRD file');\n\t\t\t}\n\t\t\tif (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n\n\t\t\t\tthrow new Error('Bzip is not supported');\n\t\t\t}\n\t\t\tif (!headerObject.vectors) {\n\n\t\t\t\t//if no space direction is set, let's use the identity\n\t\t\t\theaderObject.vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];\n\t\t\t\t//apply spacing if defined\n\t\t\t\tif (headerObject.spacings) {\n\n\t\t\t\t\tfor (i = 0; i <= 2; i++) {\n\n\t\t\t\t\t\tif (!isNaN(headerObject.spacings[i])) {\n\n\t\t\t\t\t\t\theaderObject.vectors[i].multiplyScalar(headerObject.spacings[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n\t\tfunction parseDataAsText(data, start, end) {\n\n\t\t\tvar number = '';\n\t\t\tstart = start || 0;\n\t\t\tend = end || data.length;\n\t\t\tvar value;\n\t\t\t//length of the result is the product of the sizes\n\t\t\tvar lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n\n\t\t\t\treturn previous * current;\n\t\t\t}, 1);\n\n\t\t\tvar base = 10;\n\t\t\tif (headerObject.encoding === 'hex') {\n\n\t\t\t\tbase = 16;\n\t\t\t}\n\n\t\t\tvar result = new headerObject.__array(lengthOfTheResult);\n\t\t\tvar resultIndex = 0;\n\t\t\tvar parsingFunction = parseInt;\n\t\t\tif (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n\n\t\t\t\tparsingFunction = parseFloat;\n\t\t\t}\n\t\t\tfor (var i = start; i < end; i++) {\n\n\t\t\t\tvalue = data[i];\n\t\t\t\t//if value is not a space\n\t\t\t\tif ((value < 9 || value > 13) && value !== 32) {\n\n\t\t\t\t\tnumber += String.fromCharCode(value);\n\t\t\t\t} else {\n\n\t\t\t\t\tif (number !== '') {\n\n\t\t\t\t\t\tresult[resultIndex] = parsingFunction(number, base);\n\t\t\t\t\t\tresultIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tnumber = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (number !== '') {\n\n\t\t\t\tresult[resultIndex] = parsingFunction(number, base);\n\t\t\t\tresultIndex++;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar _bytes = scan('uchar', data.byteLength);\n\t\tvar _length = _bytes.length;\n\t\tvar _header = null;\n\t\tvar _data_start = 0;\n\t\tvar i;\n\t\tfor (i = 1; i < _length; i++) {\n\n\t\t\tif (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n\n\t\t\t\t// we found two line breaks in a row\n\t\t\t\t// now we know what the header is\n\t\t\t\t_header = this.parseChars(_bytes, 0, i - 2);\n\t\t\t\t// this is were the data starts\n\t\t\t\t_data_start = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// parse the header\n\t\tparseHeader(_header);\n\n\t\tvar _data = _bytes.subarray(_data_start); // the data without header\n\t\tif (headerObject.encoding === 'gzip' || headerObject.encoding === 'gz') {\n\n\t\t\t// we need to decompress the datastream\n\t\t\t// here we start the unzipping and get a typed Uint8Array back\n\t\t\tvar inflate = new Zlib.Gunzip(new Uint8Array(_data)); // eslint-disable-line no-undef\n\t\t\t_data = inflate.decompress();\n\t\t} else if (headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex') {\n\n\t\t\t_data = parseDataAsText(_data);\n\t\t} else if (headerObject.encoding === 'raw') {\n\n\t\t\t//we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n\t\t\tvar _copy = new Uint8Array(_data.length);\n\n\t\t\tfor (var i = 0; i < _data.length; i++) {\n\n\t\t\t\t_copy[i] = _data[i];\n\t\t\t}\n\n\t\t\t_data = _copy;\n\t\t}\n\t\t// .. let's use the underlying array buffer\n\t\t_data = _data.buffer;\n\n\t\tvar volume = new _Volume2.default();\n\t\tvolume.header = headerObject;\n\t\t//\n\t\t// parse the (unzipped) data to a datastream of the correct type\n\t\t//\n\t\tvolume.data = new headerObject.__array(_data);\n\t\t// get the min and max intensities\n\t\tvar min_max = volume.computeMinMax();\n\t\tvar min = min_max[0];\n\t\tvar max = min_max[1];\n\t\t// attach the scalar range to the volume\n\t\tvolume.windowLow = min;\n\t\tvolume.windowHigh = max;\n\n\t\t// get the image dimensions\n\t\tvolume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n\t\tvolume.xLength = volume.dimensions[0];\n\t\tvolume.yLength = volume.dimensions[1];\n\t\tvolume.zLength = volume.dimensions[2];\n\t\t// spacing\n\t\tvar spacingX = new THREE.Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n\t\tvar spacingY = new THREE.Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n\t\tvar spacingZ = new THREE.Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n\t\tvolume.spacing = [spacingX, spacingY, spacingZ];\n\n\t\t// Create IJKtoRAS matrix\n\t\tvolume.matrix = new THREE.Matrix4();\n\n\t\tvar _spaceX = 1;\n\t\tvar _spaceY = 1;\n\t\tvar _spaceZ = 1;\n\n\t\tif (headerObject.space == \"left-posterior-superior\") {\n\n\t\t\t_spaceX = -1;\n\t\t\t_spaceY = -1;\n\t\t} else if (headerObject.space === 'left-anterior-superior') {\n\n\t\t\t_spaceX = -1;\n\t\t}\n\n\t\tif (!headerObject.vectors) {\n\n\t\t\tvolume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n\t\t} else {\n\n\t\t\tvar v = headerObject.vectors;\n\n\t\t\tvolume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n\t\t}\n\n\t\tvolume.inverseMatrix = new THREE.Matrix4();\n\t\tvolume.inverseMatrix.getInverse(volume.matrix);\n\t\tvolume.RASDimensions = new THREE.Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);\n\n\t\t// .. and set the default threshold\n\t\t// only if the threshold was not already set\n\t\tif (volume.lowerThreshold === -Infinity) {\n\n\t\t\tvolume.lowerThreshold = min;\n\t\t}\n\t\tif (volume.upperThreshold === Infinity) {\n\n\t\t\tvolume.upperThreshold = max;\n\t\t}\n\n\t\treturn volume;\n\t},\n\n\tparseChars: function parseChars(array, start, end) {\n\n\t\t// without borders, use the whole array\n\t\tif (start === undefined) {\n\n\t\t\tstart = 0;\n\t\t}\n\t\tif (end === undefined) {\n\n\t\t\tend = array.length;\n\t\t}\n\n\t\tvar output = '';\n\t\t// create and append the chars\n\t\tvar i = 0;\n\t\tfor (i = start; i < end; ++i) {\n\n\t\t\toutput += String.fromCharCode(array[i]);\n\t\t}\n\n\t\treturn output;\n\t},\n\n\tfieldFunctions: {\n\n\t\ttype: function type(data) {\n\n\t\t\tswitch (data) {\n\n\t\t\t\tcase 'uchar':\n\t\t\t\tcase 'unsigned char':\n\t\t\t\tcase 'uint8':\n\t\t\t\tcase 'uint8_t':\n\t\t\t\t\tthis.__array = Uint8Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'signed char':\n\t\t\t\tcase 'int8':\n\t\t\t\tcase 'int8_t':\n\t\t\t\t\tthis.__array = Int8Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'short':\n\t\t\t\tcase 'short int':\n\t\t\t\tcase 'signed short':\n\t\t\t\tcase 'signed short int':\n\t\t\t\tcase 'int16':\n\t\t\t\tcase 'int16_t':\n\t\t\t\t\tthis.__array = Int16Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ushort':\n\t\t\t\tcase 'unsigned short':\n\t\t\t\tcase 'unsigned short int':\n\t\t\t\tcase 'uint16':\n\t\t\t\tcase 'uint16_t':\n\t\t\t\t\tthis.__array = Uint16Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'signed int':\n\t\t\t\tcase 'int32':\n\t\t\t\tcase 'int32_t':\n\t\t\t\t\tthis.__array = Int32Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'uint':\n\t\t\t\tcase 'unsigned int':\n\t\t\t\tcase 'uint32':\n\t\t\t\tcase 'uint32_t':\n\t\t\t\t\tthis.__array = Uint32Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\t\tthis.__array = Float32Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'double':\n\t\t\t\t\tthis.__array = Float64Array;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unsupported NRRD data type: ' + data);\n\n\t\t\t}\n\n\t\t\treturn this.type = data;\n\t\t},\n\n\t\tendian: function endian(data) {\n\n\t\t\treturn this.endian = data;\n\t\t},\n\n\t\tencoding: function encoding(data) {\n\n\t\t\treturn this.encoding = data;\n\t\t},\n\n\t\tdimension: function dimension(data) {\n\n\t\t\treturn this.dim = parseInt(data, 10);\n\t\t},\n\n\t\tsizes: function sizes(data) {\n\n\t\t\tvar i;\n\t\t\treturn this.sizes = function () {\n\n\t\t\t\tvar _i, _len, _ref, _results;\n\t\t\t\t_ref = data.split(/\\s+/);\n\t\t\t\t_results = [];\n\t\t\t\tfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n\n\t\t\t\t\ti = _ref[_i];\n\t\t\t\t\t_results.push(parseInt(i, 10));\n\t\t\t\t}\n\t\t\t\treturn _results;\n\t\t\t}();\n\t\t},\n\n\t\tspace: function space(data) {\n\n\t\t\treturn this.space = data;\n\t\t},\n\n\t\t'space origin': function spaceOrigin(data) {\n\n\t\t\treturn this.space_origin = data.split(\"(\")[1].split(\")\")[0].split(\",\");\n\t\t},\n\n\t\t'space directions': function spaceDirections(data) {\n\n\t\t\tvar f, parts, v;\n\t\t\tparts = data.match(/\\(.*?\\)/g);\n\t\t\treturn this.vectors = function () {\n\n\t\t\t\tvar _i, _len, _results;\n\t\t\t\t_results = [];\n\t\t\t\tfor (_i = 0, _len = parts.length; _i < _len; _i++) {\n\n\t\t\t\t\tv = parts[_i];\n\t\t\t\t\t_results.push(function () {\n\n\t\t\t\t\t\tvar _j, _len2, _ref, _results2;\n\t\t\t\t\t\t_ref = v.slice(1, -1).split(/,/);\n\t\t\t\t\t\t_results2 = [];\n\t\t\t\t\t\tfor (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n\n\t\t\t\t\t\t\tf = _ref[_j];\n\t\t\t\t\t\t\t_results2.push(parseFloat(f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn _results2;\n\t\t\t\t\t}());\n\t\t\t\t}\n\t\t\t\treturn _results;\n\t\t\t}();\n\t\t},\n\n\t\tspacings: function spacings(data) {\n\n\t\t\tvar f, parts;\n\t\t\tparts = data.split(/\\s+/);\n\t\t\treturn this.spacings = function () {\n\n\t\t\t\tvar _i,\n\t\t\t\t    _len,\n\t\t\t\t    _results = [];\n\n\t\t\t\tfor (_i = 0, _len = parts.length; _i < _len; _i++) {\n\n\t\t\t\t\tf = parts[_i];\n\t\t\t\t\t_results.push(parseFloat(f));\n\t\t\t\t}\n\t\t\t\treturn _results;\n\t\t\t}();\n\t\t}\n\t}\n\n};\n\nexports.default = NRRDLoader;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar OBJLoader = function () {\n\n\t// o object_name | g group_name\n\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t// mtllib file_reference\n\tvar material_library_pattern = /^mtllib /;\n\t// usemtl material_name\n\tvar material_use_pattern = /^usemtl /;\n\n\tfunction ParserState() {\n\n\t\tvar state = {\n\t\t\tobjects: [],\n\t\t\tobject: {},\n\n\t\t\tvertices: [],\n\t\t\tnormals: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\n\t\t\tmaterialLibraries: [],\n\n\t\t\tstartObject: function startObject(name, fromDeclaration) {\n\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\tif (this.object && this.object.fromDeclaration === false) {\n\n\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\tthis.object.fromDeclaration = fromDeclaration !== false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t}\n\n\t\t\t\tthis.object = {\n\t\t\t\t\tname: name || '',\n\t\t\t\t\tfromDeclaration: fromDeclaration !== false,\n\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\tuvs: []\n\t\t\t\t\t},\n\t\t\t\t\tmaterials: [],\n\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\tstartMaterial: function startMaterial(name, libraries) {\n\n\t\t\t\t\t\tvar previous = this._finalize(false);\n\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\tif (previous && (previous.inherited || previous.groupCount <= 0)) {\n\n\t\t\t\t\t\t\tthis.materials.splice(previous.index, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\tmtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n\t\t\t\t\t\t\tsmooth: previous !== undefined ? previous.smooth : this.smooth,\n\t\t\t\t\t\t\tgroupStart: previous !== undefined ? previous.groupEnd : 0,\n\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\tclone: function clone(index) {\n\n\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\tindex: typeof index === 'number' ? index : this.index,\n\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\n\t\t\t\t\t\t\t\treturn cloned;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.materials.push(material);\n\n\t\t\t\t\t\treturn material;\n\t\t\t\t\t},\n\n\t\t\t\t\tcurrentMaterial: function currentMaterial() {\n\n\t\t\t\t\t\tif (this.materials.length > 0) {\n\n\t\t\t\t\t\t\treturn this.materials[this.materials.length - 1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t},\n\n\t\t\t\t\t_finalize: function _finalize(end) {\n\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\tif (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\tif (end && this.materials.length > 1) {\n\n\t\t\t\t\t\t\tfor (var mi = this.materials.length - 1; mi >= 0; mi--) {\n\n\t\t\t\t\t\t\t\tif (this.materials[mi].groupCount <= 0) {\n\n\t\t\t\t\t\t\t\t\tthis.materials.splice(mi, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\tif (end && this.materials.length === 0) {\n\n\t\t\t\t\t\t\tthis.materials.push({\n\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastMultiMaterial;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Inherit previous objects material.\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\tif (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n\n\t\t\t\t\tvar declared = previousMaterial.clone(0);\n\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\tthis.object.materials.push(declared);\n\t\t\t\t}\n\n\t\t\t\tthis.objects.push(this.object);\n\t\t\t},\n\n\t\t\tfinalize: function finalize() {\n\n\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tparseVertexIndex: function parseVertexIndex(value, len) {\n\n\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t},\n\n\t\t\tparseNormalIndex: function parseNormalIndex(value, len) {\n\n\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t},\n\n\t\t\tparseUVIndex: function parseUVIndex(value, len) {\n\n\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 2) * 2;\n\t\t\t},\n\n\t\t\taddVertex: function addVertex(a, b, c) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t},\n\n\t\t\taddVertexPoint: function addVertexPoint(a) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t},\n\n\t\t\taddVertexLine: function addVertexLine(a) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t},\n\n\t\t\taddNormal: function addNormal(a, b, c) {\n\n\t\t\t\tvar src = this.normals;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t},\n\n\t\t\taddColor: function addColor(a, b, c) {\n\n\t\t\t\tvar src = this.colors;\n\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t},\n\n\t\t\taddUV: function addUV(a, b, c) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1]);\n\t\t\t},\n\n\t\t\taddUVLine: function addUVLine(a) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t},\n\n\t\t\taddFace: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tvar ia = this.parseVertexIndex(a, vLen);\n\t\t\t\tvar ib = this.parseVertexIndex(b, vLen);\n\t\t\t\tvar ic = this.parseVertexIndex(c, vLen);\n\n\t\t\t\tthis.addVertex(ia, ib, ic);\n\n\t\t\t\tif (ua !== undefined && ua !== '') {\n\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\t\t\t\t\tia = this.parseUVIndex(ua, uvLen);\n\t\t\t\t\tib = this.parseUVIndex(ub, uvLen);\n\t\t\t\t\tic = this.parseUVIndex(uc, uvLen);\n\t\t\t\t\tthis.addUV(ia, ib, ic);\n\t\t\t\t}\n\n\t\t\t\tif (na !== undefined && na !== '') {\n\n\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\tia = this.parseNormalIndex(na, nLen);\n\n\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n\t\t\t\t\tthis.addNormal(ia, ib, ic);\n\t\t\t\t}\n\n\t\t\t\tif (this.colors.length > 0) {\n\n\t\t\t\t\tthis.addColor(ia, ib, ic);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddPointGeometry: function addPointGeometry(vertices) {\n\n\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\tthis.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddLineGeometry: function addLineGeometry(vertices, uvs) {\n\n\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\tthis.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t}\n\n\t\t\t\tfor (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n\n\t\t\t\t\tthis.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\tstate.startObject('', false);\n\n\t\treturn state;\n\t}\n\n\t//\n\n\tfunction OBJLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\t\tthis.materials = null;\n\t}\n\n\tOBJLoader.prototype = {\n\n\t\tconstructor: OBJLoader,\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.load(url, function (text) {\n\n\t\t\t\tonLoad(scope.parse(text));\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tsetPath: function setPath(value) {\n\n\t\t\tthis.path = value;\n\n\t\t\treturn this;\n\t\t},\n\n\t\tsetMaterials: function setMaterials(materials) {\n\n\t\t\tthis.materials = materials;\n\n\t\t\treturn this;\n\t\t},\n\n\t\tparse: function parse(text) {\n\n\t\t\tconsole.time('OBJLoader');\n\n\t\t\tvar state = new ParserState();\n\n\t\t\tif (text.indexOf('\\r\\n') !== -1) {\n\n\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\ttext = text.replace(/\\r\\n/g, '\\n');\n\t\t\t}\n\n\t\t\tif (text.indexOf('\\\\\\n') !== -1) {\n\n\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\ttext = text.replace(/\\\\\\n/g, '');\n\t\t\t}\n\n\t\t\tvar lines = text.split('\\n');\n\t\t\tvar line = '',\n\t\t\t    lineFirstChar = '';\n\t\t\tvar lineLength = 0;\n\t\t\tvar result = [];\n\n\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\tvar trimLeft = typeof ''.trimLeft === 'function';\n\n\t\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\t\tline = lines[i];\n\n\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\tlineLength = line.length;\n\n\t\t\t\tif (lineLength === 0) continue;\n\n\t\t\t\tlineFirstChar = line.charAt(0);\n\n\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\tif (lineFirstChar === '#') continue;\n\n\t\t\t\tif (lineFirstChar === 'v') {\n\n\t\t\t\t\tvar data = line.split(/\\s+/);\n\n\t\t\t\t\tswitch (data[0]) {\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tstate.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\tif (data.length === 8) {\n\n\t\t\t\t\t\t\t\tstate.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\tstate.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\tstate.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t} else if (lineFirstChar === 'f') {\n\n\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\tvar vertexData = lineData.split(/\\s+/);\n\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\tfor (var j = 0, jl = vertexData.length; j < jl; j++) {\n\n\t\t\t\t\t\tvar vertex = vertexData[j];\n\n\t\t\t\t\t\tif (vertex.length > 0) {\n\n\t\t\t\t\t\t\tvar vertexParts = vertex.split('/');\n\t\t\t\t\t\t\tfaceVertices.push(vertexParts);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\tvar v1 = faceVertices[0];\n\n\t\t\t\t\tfor (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n\n\t\t\t\t\t\tvar v2 = faceVertices[j];\n\t\t\t\t\t\tvar v3 = faceVertices[j + 1];\n\n\t\t\t\t\t\tstate.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n\t\t\t\t\t}\n\t\t\t\t} else if (lineFirstChar === 'l') {\n\n\t\t\t\t\tvar lineParts = line.substring(1).trim().split(\" \");\n\t\t\t\t\tvar lineVertices = [],\n\t\t\t\t\t    lineUVs = [];\n\n\t\t\t\t\tif (line.indexOf(\"/\") === -1) {\n\n\t\t\t\t\t\tlineVertices = lineParts;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor (var li = 0, llen = lineParts.length; li < llen; li++) {\n\n\t\t\t\t\t\t\tvar parts = lineParts[li].split(\"/\");\n\n\t\t\t\t\t\t\tif (parts[0] !== \"\") lineVertices.push(parts[0]);\n\t\t\t\t\t\t\tif (parts[1] !== \"\") lineUVs.push(parts[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstate.addLineGeometry(lineVertices, lineUVs);\n\t\t\t\t} else if (lineFirstChar === 'p') {\n\n\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\tvar pointData = lineData.split(\" \");\n\n\t\t\t\t\tstate.addPointGeometry(pointData);\n\t\t\t\t} else if ((result = object_pattern.exec(line)) !== null) {\n\n\t\t\t\t\t// o object_name\n\t\t\t\t\t// or\n\t\t\t\t\t// g group_name\n\n\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\tvar name = (\" \" + result[0].substr(1).trim()).substr(1);\n\n\t\t\t\t\tstate.startObject(name);\n\t\t\t\t} else if (material_use_pattern.test(line)) {\n\n\t\t\t\t\t// material\n\n\t\t\t\t\tstate.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n\t\t\t\t} else if (material_library_pattern.test(line)) {\n\n\t\t\t\t\t// mtl file\n\n\t\t\t\t\tstate.materialLibraries.push(line.substring(7).trim());\n\t\t\t\t} else if (lineFirstChar === 's') {\n\n\t\t\t\t\tresult = line.split(' ');\n\n\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t/*\n      * http://paulbourke.net/dataformats/obj/\n      * or\n      * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n      *\n      * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n      * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n      * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n      * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n      * than 0.\"\n      */\n\t\t\t\t\tif (result.length > 1) {\n\n\t\t\t\t\t\tvar value = result[1].trim().toLowerCase();\n\t\t\t\t\t\tstate.object.smooth = value !== '0' && value !== 'off';\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\tstate.object.smooth = true;\n\t\t\t\t\t}\n\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\tif (material) material.smooth = state.object.smooth;\n\t\t\t\t} else {\n\n\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\tif (line === '\\0') continue;\n\n\t\t\t\t\tthrow new Error('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.finalize();\n\n\t\t\tvar container = new THREE.Group();\n\t\t\tcontainer.materialLibraries = [].concat(state.materialLibraries);\n\n\t\t\tfor (var i = 0, l = state.objects.length; i < l; i++) {\n\n\t\t\t\tvar object = state.objects[i];\n\t\t\t\tvar geometry = object.geometry;\n\t\t\t\tvar materials = object.materials;\n\t\t\t\tvar isLine = geometry.type === 'Line';\n\t\t\t\tvar isPoints = geometry.type === 'Points';\n\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\tif (geometry.vertices.length === 0) continue;\n\n\t\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\t\tbuffergeometry.addAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));\n\n\t\t\t\tif (geometry.normals.length > 0) {\n\n\t\t\t\t\tbuffergeometry.addAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\n\t\t\t\t} else {\n\n\t\t\t\t\tbuffergeometry.computeVertexNormals();\n\t\t\t\t}\n\n\t\t\t\tif (geometry.colors.length > 0) {\n\n\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\tbuffergeometry.addAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));\n\t\t\t\t}\n\n\t\t\t\tif (geometry.uvs.length > 0) {\n\n\t\t\t\t\tbuffergeometry.addAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));\n\t\t\t\t}\n\n\t\t\t\t// Create materials\n\n\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\tvar material = undefined;\n\n\t\t\t\t\tif (this.materials !== null) {\n\n\t\t\t\t\t\tmaterial = this.materials.create(sourceMaterial.name);\n\n\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\tif (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n\n\t\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\tmaterialLine.copy(material);\n\t\t\t\t\t\t\tmaterialLine.lights = false; // TOFIX\n\t\t\t\t\t\t\tmaterial = materialLine;\n\t\t\t\t\t\t} else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {\n\n\t\t\t\t\t\t\tvar materialPoints = new THREE.PointsMaterial({ size: 10, sizeAttenuation: false });\n\t\t\t\t\t\t\tmaterialLine.copy(material);\n\t\t\t\t\t\t\tmaterial = materialPoints;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!material) {\n\n\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial({ size: 1, sizeAttenuation: false });\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\tmaterial.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;\n\n\t\t\t\t\tcreatedMaterials.push(material);\n\t\t\t\t}\n\n\t\t\t\t// Create mesh\n\n\t\t\t\tvar mesh;\n\n\t\t\t\tif (createdMaterials.length > 1) {\n\n\t\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\t\tbuffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials);\n\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmesh.name = object.name;\n\n\t\t\t\tcontainer.add(mesh);\n\t\t\t}\n\n\t\t\tconsole.timeEnd('OBJLoader');\n\n\t\t\treturn container;\n\t\t}\n\n\t};\n\n\treturn OBJLoader;\n}();\n\nexports.default = OBJLoader;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _LoaderSupport = __webpack_require__(7);\n\nvar _LoaderSupport2 = _interopRequireDefault(_LoaderSupport);\n\nvar _MTLLoader = __webpack_require__(9);\n\nvar _MTLLoader2 = _interopRequireDefault(_MTLLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n  * @author Kai Salmen / https://kaisalmen.de\n  * Development repository: https://github.com/kaisalmen/WWOBJLoader\n  */\n\n'use strict';\n\n// if ( THREE.OBJLoader2 === undefined ) { THREE.OBJLoader2 = {} }\n\n// if ( THREE.LoaderSupport === undefined ) console.error( '\"THREE.LoaderSupport\" is not available. \"THREE.OBJLoader2\" requires it. Please include \"LoaderSupport.js\" in your HTML.' );\n\n/**\n * Use this class to load OBJ data from files or to parse OBJ data from an arraybuffer\n * @class\n *\n * @param {THREE.DefaultLoadingManager} [manager] The loadingManager for the loader to use. Default is {@link THREE.DefaultLoadingManager}\n */\nvar OBJLoader2 = function () {\n\n\tvar OBJLOADER2_VERSION = '2.4.0';\n\tvar Validator = _LoaderSupport2.default.Validator;\n\n\tfunction OBJLoader2(manager) {\n\t\tconsole.info('Using THREE.OBJLoader2 version: ' + OBJLOADER2_VERSION);\n\n\t\tthis.manager = Validator.verifyInput(manager, THREE.DefaultLoadingManager);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\tthis.modelName = '';\n\t\tthis.instanceNo = 0;\n\t\tthis.path = '';\n\t\tthis.useIndices = false;\n\t\tthis.disregardNormals = false;\n\t\tthis.materialPerSmoothingGroup = false;\n\t\tthis.loaderRootNode = new THREE.Group();\n\n\t\tthis.meshBuilder = new _LoaderSupport2.default.MeshBuilder();\n\t\tthis.callbacks = new _LoaderSupport2.default.Callbacks();\n\t\tthis.workerSupport = new _LoaderSupport2.default.WorkerSupport();\n\t\tthis.terminateWorkerOnLoad = true;\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tOBJLoader2.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\tthis.meshBuilder.setLogging(this.logging.enabled, this.logging.debug);\n\t};\n\n\t/**\n  * Set the name of the model.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string} modelName\n  */\n\tOBJLoader2.prototype.setModelName = function (modelName) {\n\t\tthis.modelName = Validator.verifyInput(modelName, this.modelName);\n\t};\n\n\t/**\n  * The URL of the base path.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string} path URL\n  */\n\tOBJLoader2.prototype.setPath = function (path) {\n\t\tthis.path = Validator.verifyInput(path, this.path);\n\t};\n\n\t/**\n  * Set the node where the loaded objects will be attached directly.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {THREE.Object3D} streamMeshesTo Object already attached to scenegraph where new meshes will be attached to\n  */\n\tOBJLoader2.prototype.setStreamMeshesTo = function (streamMeshesTo) {\n\t\tthis.loaderRootNode = Validator.verifyInput(streamMeshesTo, this.loaderRootNode);\n\t};\n\n\t/**\n  * Set materials loaded by MTLLoader or any other supplier of an Array of {@link THREE.Material}.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {THREE.Material[]} materials Array of {@link THREE.Material}\n  */\n\tOBJLoader2.prototype.setMaterials = function (materials) {\n\t\tthis.meshBuilder.setMaterials(materials);\n\t};\n\n\t/**\n  * Instructs loaders to create indexed {@link THREE.BufferGeometry}.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} useIndices=false\n  */\n\tOBJLoader2.prototype.setUseIndices = function (useIndices) {\n\t\tthis.useIndices = useIndices === true;\n\t};\n\n\t/**\n  * Tells whether normals should be completely disregarded and regenerated.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} disregardNormals=false\n  */\n\tOBJLoader2.prototype.setDisregardNormals = function (disregardNormals) {\n\t\tthis.disregardNormals = disregardNormals === true;\n\t};\n\n\t/**\n  * Tells whether a material shall be created per smoothing group.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} materialPerSmoothingGroup=false\n  */\n\tOBJLoader2.prototype.setMaterialPerSmoothingGroup = function (materialPerSmoothingGroup) {\n\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n\t};\n\n\tOBJLoader2.prototype._setCallbacks = function (callbacks) {\n\t\tif (Validator.isValid(callbacks.onProgress)) this.callbacks.setCallbackOnProgress(callbacks.onProgress);\n\t\tif (Validator.isValid(callbacks.onMeshAlter)) this.callbacks.setCallbackOnMeshAlter(callbacks.onMeshAlter);\n\t\tif (Validator.isValid(callbacks.onLoad)) this.callbacks.setCallbackOnLoad(callbacks.onLoad);\n\t\tif (Validator.isValid(callbacks.onLoadMaterials)) this.callbacks.setCallbackOnLoadMaterials(callbacks.onLoadMaterials);\n\n\t\tthis.meshBuilder._setCallbacks(this.callbacks);\n\t};\n\n\t/**\n  * Announce feedback which is give to the registered callbacks.\n  * @memberOf THREE.OBJLoader2\n  * @private\n  *\n  * @param {string} type The type of event\n  * @param {string} text Textual description of the event\n  * @param {number} numericalValue Numerical value describing the progress\n  */\n\tOBJLoader2.prototype.onProgress = function (type, text, numericalValue) {\n\t\tvar content = Validator.isValid(text) ? text : '';\n\t\tvar event = {\n\t\t\tdetail: {\n\t\t\t\ttype: type,\n\t\t\t\tmodelName: this.modelName,\n\t\t\t\tinstanceNo: this.instanceNo,\n\t\t\t\ttext: content,\n\t\t\t\tnumericalValue: numericalValue\n\t\t\t}\n\t\t};\n\n\t\tif (Validator.isValid(this.callbacks.onProgress)) this.callbacks.onProgress(event);\n\n\t\tif (this.logging.enabled && this.logging.debug) console.debug(content);\n\t};\n\n\tOBJLoader2.prototype._onError = function (event) {\n\t\tvar output = 'Error occurred while downloading!';\n\n\t\tif (event.currentTarget && event.currentTarget.statusText !== null) {\n\n\t\t\toutput += '\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\n\t\t}\n\t\tthis.onProgress('error', output, -1);\n\t\tthrow output;\n\t};\n\n\t/**\n  * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string}  url A string containing the path/URL of the file to be loaded.\n  * @param {callback} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.\n  * @param {callback} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n  * @param {callback} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n  * @param {callback} [onMeshAlter] A function to be called after a new mesh raw data becomes available for alteration.\n  * @param {boolean} [useAsync] If true, uses async loading with worker, if false loads data synchronously.\n  */\n\tOBJLoader2.prototype.load = function (url, onLoad, onProgress, onError, onMeshAlter, useAsync) {\n\t\tvar resource = new _LoaderSupport2.default.ResourceDescriptor(url, 'OBJ');\n\t\tthis._loadObj(resource, onLoad, onProgress, onError, onMeshAlter, useAsync);\n\t};\n\n\tOBJLoader2.prototype._loadObj = function (resource, onLoad, onProgress, onError, onMeshAlter, useAsync) {\n\t\tif (!Validator.isValid(onError)) onError = this._onError;\n\n\t\t// fast-fail\n\t\tif (!Validator.isValid(resource)) onError('An invalid ResourceDescriptor was provided. Unable to continue!');\n\t\tvar scope = this;\n\t\tvar fileLoaderOnLoad = function fileLoaderOnLoad(content) {\n\n\t\t\tresource.content = content;\n\t\t\tif (useAsync) {\n\n\t\t\t\tscope.parseAsync(content, onLoad);\n\t\t\t} else {\n\n\t\t\t\tvar callbacks = new _LoaderSupport2.default.Callbacks();\n\t\t\t\tcallbacks.setCallbackOnMeshAlter(onMeshAlter);\n\t\t\t\tscope._setCallbacks(callbacks);\n\t\t\t\tonLoad({\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tloaderRootNode: scope.parse(content),\n\t\t\t\t\t\tmodelName: scope.modelName,\n\t\t\t\t\t\tinstanceNo: scope.instanceNo\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// fast-fail\n\t\tif (!Validator.isValid(resource.url) || Validator.isValid(resource.content)) {\n\n\t\t\tfileLoaderOnLoad(Validator.isValid(resource.content) ? resource.content : null);\n\t\t} else {\n\n\t\t\tif (!Validator.isValid(onProgress)) {\n\t\t\t\tvar numericalValueRef = 0;\n\t\t\t\tvar numericalValue = 0;\n\t\t\t\tonProgress = function onProgress(event) {\n\t\t\t\t\tif (!event.lengthComputable) return;\n\n\t\t\t\t\tnumericalValue = event.loaded / event.total;\n\t\t\t\t\tif (numericalValue > numericalValueRef) {\n\n\t\t\t\t\t\tnumericalValueRef = numericalValue;\n\t\t\t\t\t\tvar output = 'Download of \"' + resource.url + '\": ' + (numericalValue * 100).toFixed(2) + '%';\n\t\t\t\t\t\tscope.onProgress('progressLoad', output, numericalValue);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar fileLoader = new THREE.FileLoader(this.manager);\n\t\t\tfileLoader.setPath(this.path);\n\t\t\tfileLoader.setResponseType('arraybuffer');\n\t\t\tfileLoader.load(resource.url, fileLoaderOnLoad, onProgress, onError);\n\t\t}\n\t};\n\n\t/**\n  * Run the loader according the provided instructions.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {LoaderSupport.PrepData} prepData All parameters and resources required for execution\n  * @param {LoaderSupport.WorkerSupport} [workerSupportExternal] Use pre-existing WorkerSupport\n  */\n\tOBJLoader2.prototype.run = function (prepData, workerSupportExternal) {\n\t\tthis._applyPrepData(prepData);\n\t\tvar available = prepData.checkResourceDescriptorFiles(prepData.resources, [{ ext: \"obj\", type: \"ArrayBuffer\", ignore: false }, { ext: \"mtl\", type: \"String\", ignore: false }, { ext: \"zip\", type: \"String\", ignore: true }]);\n\t\tif (Validator.isValid(workerSupportExternal)) {\n\n\t\t\tthis.terminateWorkerOnLoad = false;\n\t\t\tthis.workerSupport = workerSupportExternal;\n\t\t\tthis.logging.enabled = this.workerSupport.logging.enabled;\n\t\t\tthis.logging.debug = this.workerSupport.logging.debug;\n\t\t}\n\t\tvar scope = this;\n\t\tvar onMaterialsLoaded = function onMaterialsLoaded(materials) {\n\t\t\tif (materials !== null) scope.meshBuilder.setMaterials(materials);\n\t\t\tscope._loadObj(available.obj, scope.callbacks.onLoad, null, null, scope.callbacks.onMeshAlter, prepData.useAsync);\n\t\t};\n\t\tthis._loadMtl(available.mtl, onMaterialsLoaded, prepData.crossOrigin, prepData.materialOptions);\n\t};\n\n\tOBJLoader2.prototype._applyPrepData = function (prepData) {\n\t\tif (Validator.isValid(prepData)) {\n\n\t\t\tthis.setLogging(prepData.logging.enabled, prepData.logging.debug);\n\t\t\tthis.setModelName(prepData.modelName);\n\t\t\tthis.setStreamMeshesTo(prepData.streamMeshesTo);\n\t\t\tthis.meshBuilder.setMaterials(prepData.materials);\n\t\t\tthis.setUseIndices(prepData.useIndices);\n\t\t\tthis.setDisregardNormals(prepData.disregardNormals);\n\t\t\tthis.setMaterialPerSmoothingGroup(prepData.materialPerSmoothingGroup);\n\n\t\t\tthis._setCallbacks(prepData.getCallbacks());\n\t\t}\n\t};\n\n\t/**\n  * Parses OBJ data synchronously from arraybuffer or string.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {arraybuffer|string} content OBJ data as Uint8Array or String\n  */\n\tOBJLoader2.prototype.parse = function (content) {\n\t\t// fast-fail in case of illegal data\n\t\tif (!Validator.isValid(content)) {\n\n\t\t\tconsole.warn('Provided content is not a valid ArrayBuffer or String.');\n\t\t\treturn this.loaderRootNode;\n\t\t}\n\t\tif (this.logging.enabled) console.time('OBJLoader2 parse: ' + this.modelName);\n\t\tthis.meshBuilder.init();\n\n\t\tvar parser = new Parser();\n\t\tparser.setLogging(this.logging.enabled, this.logging.debug);\n\t\tparser.setMaterialPerSmoothingGroup(this.materialPerSmoothingGroup);\n\t\tparser.setUseIndices(this.useIndices);\n\t\tparser.setDisregardNormals(this.disregardNormals);\n\t\t// sync code works directly on the material references\n\t\tparser.setMaterials(this.meshBuilder.getMaterials());\n\n\t\tvar scope = this;\n\t\tvar onMeshLoaded = function onMeshLoaded(payload) {\n\t\t\tvar meshes = scope.meshBuilder.processPayload(payload);\n\t\t\tvar mesh;\n\t\t\tfor (var i in meshes) {\n\t\t\t\tmesh = meshes[i];\n\t\t\t\tscope.loaderRootNode.add(mesh);\n\t\t\t}\n\t\t};\n\t\tparser.setCallbackMeshBuilder(onMeshLoaded);\n\t\tvar onProgressScoped = function onProgressScoped(text, numericalValue) {\n\t\t\tscope.onProgress('progressParse', text, numericalValue);\n\t\t};\n\t\tparser.setCallbackProgress(onProgressScoped);\n\n\t\tif (content instanceof ArrayBuffer || content instanceof Uint8Array) {\n\n\t\t\tif (this.logging.enabled) console.info('Parsing arrayBuffer...');\n\t\t\tparser.parse(content);\n\t\t} else if (typeof content === 'string' || content instanceof String) {\n\n\t\t\tif (this.logging.enabled) console.info('Parsing text...');\n\t\t\tparser.parseText(content);\n\t\t} else {\n\n\t\t\tthrow 'Provided content was neither of type String nor Uint8Array! Aborting...';\n\t\t}\n\t\tif (this.logging.enabled) console.timeEnd('OBJLoader2 parse: ' + this.modelName);\n\n\t\treturn this.loaderRootNode;\n\t};\n\n\t/**\n  * Parses OBJ content asynchronously from arraybuffer.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {arraybuffer} content OBJ data as Uint8Array\n  * @param {callback} onLoad Called after worker successfully completed loading\n  */\n\tOBJLoader2.prototype.parseAsync = function (content, onLoad) {\n\t\tvar scope = this;\n\t\tvar measureTime = false;\n\t\tvar scopedOnLoad = function scopedOnLoad() {\n\t\t\tonLoad({\n\t\t\t\tdetail: {\n\t\t\t\t\tloaderRootNode: scope.loaderRootNode,\n\t\t\t\t\tmodelName: scope.modelName,\n\t\t\t\t\tinstanceNo: scope.instanceNo\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (measureTime && scope.logging.enabled) console.timeEnd('OBJLoader2 parseAsync: ' + scope.modelName);\n\t\t};\n\t\t// fast-fail in case of illegal data\n\t\tif (!Validator.isValid(content)) {\n\n\t\t\tconsole.warn('Provided content is not a valid ArrayBuffer.');\n\t\t\tscopedOnLoad();\n\t\t} else {\n\n\t\t\tmeasureTime = true;\n\t\t}\n\t\tif (measureTime && this.logging.enabled) console.time('OBJLoader2 parseAsync: ' + this.modelName);\n\t\tthis.meshBuilder.init();\n\n\t\tvar scopedOnMeshLoaded = function scopedOnMeshLoaded(payload) {\n\t\t\tvar meshes = scope.meshBuilder.processPayload(payload);\n\t\t\tvar mesh;\n\t\t\tfor (var i in meshes) {\n\t\t\t\tmesh = meshes[i];\n\t\t\t\tscope.loaderRootNode.add(mesh);\n\t\t\t}\n\t\t};\n\t\tvar buildCode = function buildCode(funcBuildObject, funcBuildSingleton) {\n\t\t\tvar workerCode = '';\n\t\t\tworkerCode += '/**\\n';\n\t\t\tworkerCode += '  * This code was constructed by OBJLoader2 buildCode.\\n';\n\t\t\tworkerCode += '  */\\n\\n';\n\t\t\tworkerCode += 'THREE = { LoaderSupport: {} };\\n\\n';\n\t\t\tworkerCode += funcBuildObject('LoaderSupport.Validator', Validator);\n\t\t\tworkerCode += funcBuildSingleton('Parser', Parser);\n\n\t\t\treturn workerCode;\n\t\t};\n\t\tthis.workerSupport.validate(buildCode, 'Parser');\n\t\tthis.workerSupport.setCallbacks(scopedOnMeshLoaded, scopedOnLoad);\n\t\tif (scope.terminateWorkerOnLoad) this.workerSupport.setTerminateRequested(true);\n\n\t\tvar materialNames = {};\n\t\tvar materials = this.meshBuilder.getMaterials();\n\t\tfor (var materialName in materials) {\n\n\t\t\tmaterialNames[materialName] = materialName;\n\t\t}\n\t\tthis.workerSupport.run({\n\t\t\tparams: {\n\t\t\t\tuseAsync: true,\n\t\t\t\tmaterialPerSmoothingGroup: this.materialPerSmoothingGroup,\n\t\t\t\tuseIndices: this.useIndices,\n\t\t\t\tdisregardNormals: this.disregardNormals\n\t\t\t},\n\t\t\tlogging: {\n\t\t\t\tenabled: this.logging.enabled,\n\t\t\t\tdebug: this.logging.debug\n\t\t\t},\n\t\t\tmaterials: {\n\t\t\t\t// in async case only material names are supplied to parser\n\t\t\t\tmaterials: materialNames\n\t\t\t},\n\t\t\tdata: {\n\t\t\t\tinput: content,\n\t\t\t\toptions: null\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n  * Parse OBJ data either from ArrayBuffer or string\n  * @class\n  */\n\tvar Parser = function () {\n\n\t\tfunction Parser() {\n\t\t\tthis.callbackProgress = null;\n\t\t\tthis.callbackMeshBuilder = null;\n\t\t\tthis.contentRef = null;\n\t\t\tthis.legacyMode = false;\n\n\t\t\tthis.materials = {};\n\t\t\tthis.useAsync = false;\n\t\t\tthis.materialPerSmoothingGroup = false;\n\t\t\tthis.useIndices = false;\n\t\t\tthis.disregardNormals = false;\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.normals = [];\n\t\t\tthis.uvs = [];\n\n\t\t\tthis.rawMesh = {\n\t\t\t\tobjectName: '',\n\t\t\t\tgroupName: '',\n\t\t\t\tactiveMtlName: '',\n\t\t\t\tmtllibName: '',\n\n\t\t\t\t// reset with new mesh\n\t\t\t\tfaceType: -1,\n\t\t\t\tsubGroups: [],\n\t\t\t\tsubGroupInUse: null,\n\t\t\t\tsmoothingGroup: {\n\t\t\t\t\tsplitMaterials: false,\n\t\t\t\t\tnormalized: -1,\n\t\t\t\t\treal: -1\n\t\t\t\t},\n\t\t\t\tcounts: {\n\t\t\t\t\tdoubleIndicesCount: 0,\n\t\t\t\t\tfaceCount: 0,\n\t\t\t\t\tmtlCount: 0,\n\t\t\t\t\tsmoothingGroupCount: 0\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.inputObjectCount = 1;\n\t\t\tthis.outputObjectCount = 1;\n\t\t\tthis.globalCounts = {\n\t\t\t\tvertices: 0,\n\t\t\t\tfaces: 0,\n\t\t\t\tdoubleIndicesCount: 0,\n\t\t\t\tlineByte: 0,\n\t\t\t\tcurrentByte: 0,\n\t\t\t\ttotalBytes: 0\n\t\t\t};\n\n\t\t\tthis.logging = {\n\t\t\t\tenabled: true,\n\t\t\t\tdebug: false\n\t\t\t};\n\t\t}\n\n\t\tParser.prototype.resetRawMesh = function () {\n\t\t\t// faces are stored according combined index of group, material and smoothingGroup (0 or not)\n\t\t\tthis.rawMesh.subGroups = [];\n\t\t\tthis.rawMesh.subGroupInUse = null;\n\t\t\tthis.rawMesh.smoothingGroup.normalized = -1;\n\t\t\tthis.rawMesh.smoothingGroup.real = -1;\n\n\t\t\t// this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\t\t\tthis.pushSmoothingGroup(1);\n\n\t\t\tthis.rawMesh.counts.doubleIndicesCount = 0;\n\t\t\tthis.rawMesh.counts.faceCount = 0;\n\t\t\tthis.rawMesh.counts.mtlCount = 0;\n\t\t\tthis.rawMesh.counts.smoothingGroupCount = 0;\n\t\t};\n\n\t\tParser.prototype.setUseAsync = function (useAsync) {\n\t\t\tthis.useAsync = useAsync;\n\t\t};\n\n\t\tParser.prototype.setMaterialPerSmoothingGroup = function (materialPerSmoothingGroup) {\n\t\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup;\n\t\t};\n\n\t\tParser.prototype.setUseIndices = function (useIndices) {\n\t\t\tthis.useIndices = useIndices;\n\t\t};\n\n\t\tParser.prototype.setDisregardNormals = function (disregardNormals) {\n\t\t\tthis.disregardNormals = disregardNormals;\n\t\t};\n\n\t\tParser.prototype.setMaterials = function (materials) {\n\t\t\tthis.materials = _LoaderSupport2.default.Validator.verifyInput(materials, this.materials);\n\t\t\tthis.materials = _LoaderSupport2.default.Validator.verifyInput(this.materials, {});\n\t\t};\n\n\t\tParser.prototype.setCallbackMeshBuilder = function (callbackMeshBuilder) {\n\t\t\tif (!_LoaderSupport2.default.Validator.isValid(callbackMeshBuilder)) throw 'Unable to run as no \"MeshBuilder\" callback is set.';\n\t\t\tthis.callbackMeshBuilder = callbackMeshBuilder;\n\t\t};\n\n\t\tParser.prototype.setCallbackProgress = function (callbackProgress) {\n\t\t\tthis.callbackProgress = callbackProgress;\n\t\t};\n\n\t\tParser.prototype.setLogging = function (enabled, debug) {\n\t\t\tthis.logging.enabled = enabled === true;\n\t\t\tthis.logging.debug = debug === true;\n\t\t};\n\n\t\tParser.prototype.configure = function () {\n\t\t\tthis.pushSmoothingGroup(1);\n\n\t\t\tif (this.logging.enabled) {\n\n\t\t\t\tvar matKeys = Object.keys(this.materials);\n\t\t\t\tvar matNames = matKeys.length > 0 ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join('\\n\\t\\t- ') : '\\n\\tmaterialNames: None';\n\t\t\t\tvar printedConfig = 'OBJLoader2.Parser configuration:' + matNames + '\\n\\tuseAsync: ' + this.useAsync + '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup + '\\n\\tuseIndices: ' + this.useIndices + '\\n\\tdisregardNormals: ' + this.disregardNormals + '\\n\\tcallbackMeshBuilderName: ' + this.callbackMeshBuilder.name + '\\n\\tcallbackProgressName: ' + this.callbackProgress.name;\n\t\t\t\tconsole.info(printedConfig);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Parse the provided arraybuffer\n   * @memberOf Parser\n   *\n   * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n   */\n\t\tParser.prototype.parse = function (arrayBuffer) {\n\t\t\tif (this.logging.enabled) console.time('OBJLoader2.Parser.parse');\n\t\t\tthis.configure();\n\n\t\t\tvar arrayBufferView = new Uint8Array(arrayBuffer);\n\t\t\tthis.contentRef = arrayBufferView;\n\t\t\tvar length = arrayBufferView.byteLength;\n\t\t\tthis.globalCounts.totalBytes = length;\n\t\t\tvar buffer = new Array(128);\n\n\t\t\tfor (var code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {\n\n\t\t\t\tcode = arrayBufferView[i];\n\t\t\t\tswitch (code) {\n\t\t\t\t\t// space\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// slash\n\t\t\t\t\tcase 47:\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tslashesCount++;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// LF\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\t\t\t\t\tthis.globalCounts.currentByte = i;\n\t\t\t\t\t\tthis.processLine(buffer, bufferPointer, slashesCount);\n\t\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// CR\n\t\t\t\t\tcase 13:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tword += String.fromCharCode(code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.finalizeParsing();\n\t\t\tif (this.logging.enabled) console.timeEnd('OBJLoader2.Parser.parse');\n\t\t};\n\n\t\t/**\n   * Parse the provided text\n   * @memberOf Parser\n   *\n   * @param {string} text OBJ data as string\n   */\n\t\tParser.prototype.parseText = function (text) {\n\t\t\tif (this.logging.enabled) console.time('OBJLoader2.Parser.parseText');\n\t\t\tthis.configure();\n\t\t\tthis.legacyMode = true;\n\t\t\tthis.contentRef = text;\n\t\t\tvar length = text.length;\n\t\t\tthis.globalCounts.totalBytes = length;\n\t\t\tvar buffer = new Array(128);\n\n\t\t\tfor (var char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {\n\n\t\t\t\tchar = text[i];\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase ' ':\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tslashesCount++;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\t\t\t\t\tthis.globalCounts.currentByte = i;\n\t\t\t\t\t\tthis.processLine(buffer, bufferPointer, slashesCount);\n\t\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\r':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tword += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.finalizeParsing();\n\t\t\tif (this.logging.enabled) console.timeEnd('OBJLoader2.Parser.parseText');\n\t\t};\n\n\t\tParser.prototype.processLine = function (buffer, bufferPointer, slashesCount) {\n\t\t\tif (bufferPointer < 1) return;\n\n\t\t\tvar reconstructString = function reconstructString(content, legacyMode, start, stop) {\n\t\t\t\tvar line = '';\n\t\t\t\tif (stop > start) {\n\n\t\t\t\t\tvar i;\n\t\t\t\t\tif (legacyMode) {\n\n\t\t\t\t\t\tfor (i = start; i < stop; i++) {\n\t\t\t\t\t\t\tline += content[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor (i = start; i < stop; i++) {\n\t\t\t\t\t\t\tline += String.fromCharCode(content[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tline = line.trim();\n\t\t\t\t}\n\t\t\t\treturn line;\n\t\t\t};\n\n\t\t\tvar bufferLength, length, i, lineDesignation;\n\t\t\tlineDesignation = buffer[0];\n\t\t\tswitch (lineDesignation) {\n\t\t\t\tcase 'v':\n\t\t\t\t\tthis.vertices.push(parseFloat(buffer[1]));\n\t\t\t\t\tthis.vertices.push(parseFloat(buffer[2]));\n\t\t\t\t\tthis.vertices.push(parseFloat(buffer[3]));\n\t\t\t\t\tif (bufferPointer > 4) {\n\n\t\t\t\t\t\tthis.colors.push(parseFloat(buffer[4]));\n\t\t\t\t\t\tthis.colors.push(parseFloat(buffer[5]));\n\t\t\t\t\t\tthis.colors.push(parseFloat(buffer[6]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vt':\n\t\t\t\t\tthis.uvs.push(parseFloat(buffer[1]));\n\t\t\t\t\tthis.uvs.push(parseFloat(buffer[2]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vn':\n\t\t\t\t\tthis.normals.push(parseFloat(buffer[1]));\n\t\t\t\t\tthis.normals.push(parseFloat(buffer[2]));\n\t\t\t\t\tthis.normals.push(parseFloat(buffer[3]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'f':\n\t\t\t\t\tbufferLength = bufferPointer - 1;\n\n\t\t\t\t\t// \"f vertex ...\"\n\t\t\t\t\tif (slashesCount === 0) {\n\n\t\t\t\t\t\tthis.checkFaceType(0);\n\t\t\t\t\t\tfor (i = 2, length = bufferLength; i < length; i++) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 1]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \"f vertex/uv ...\"\n\t\t\t\t\t} else if (bufferLength === slashesCount * 2) {\n\n\t\t\t\t\t\tthis.checkFaceType(1);\n\t\t\t\t\t\tfor (i = 3, length = bufferLength - 2; i < length; i += 2) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1], buffer[2]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], buffer[i + 1]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 2], buffer[i + 3]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \"f vertex/uv/normal ...\"\n\t\t\t\t\t} else if (bufferLength * 2 === slashesCount * 3) {\n\n\t\t\t\t\t\tthis.checkFaceType(2);\n\t\t\t\t\t\tfor (i = 4, length = bufferLength - 3; i < length; i += 3) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1], buffer[2], buffer[3]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], buffer[i + 1], buffer[i + 2]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 3], buffer[i + 4], buffer[i + 5]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \"f vertex//normal ...\"\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.checkFaceType(3);\n\t\t\t\t\t\tfor (i = 3, length = bufferLength - 2; i < length; i += 2) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1], undefined, buffer[2]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], undefined, buffer[i + 1]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 2], undefined, buffer[i + 3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\t\t\t\tcase 'p':\n\t\t\t\t\tbufferLength = bufferPointer - 1;\n\t\t\t\t\tif (bufferLength === slashesCount * 2) {\n\n\t\t\t\t\t\tthis.checkFaceType(4);\n\t\t\t\t\t\tfor (i = 1, length = bufferLength + 1; i < length; i += 2) {\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], buffer[i + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.checkFaceType(lineDesignation === 'l' ? 5 : 6);\n\t\t\t\t\t\tfor (i = 1, length = bufferLength + 1; i < length; i++) {\n\t\t\t\t\t\t\tthis.buildFace(buffer[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 's':\n\t\t\t\t\tthis.pushSmoothingGroup(buffer[1]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\t// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n\t\t\t\t\tthis.processCompletedMesh();\n\t\t\t\t\tthis.rawMesh.groupName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'o':\n\t\t\t\t\t// 'o' is pure meta-information and does not result in creation of new meshes\n\t\t\t\t\tthis.rawMesh.objectName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mtllib':\n\t\t\t\t\tthis.rawMesh.mtllibName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'usemtl':\n\t\t\t\t\tvar mtlName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n\t\t\t\t\tif (mtlName !== '' && this.rawMesh.activeMtlName !== mtlName) {\n\n\t\t\t\t\t\tthis.rawMesh.activeMtlName = mtlName;\n\t\t\t\t\t\tthis.rawMesh.counts.mtlCount++;\n\t\t\t\t\t\tthis.checkSubGroup();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tParser.prototype.pushSmoothingGroup = function (smoothingGroup) {\n\t\t\tvar smoothingGroupInt = parseInt(smoothingGroup);\n\t\t\tif (isNaN(smoothingGroupInt)) {\n\t\t\t\tsmoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n\t\t\t}\n\n\t\t\tvar smoothCheck = this.rawMesh.smoothingGroup.normalized;\n\t\t\tthis.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : smoothingGroupInt === 0 ? 0 : 1;\n\t\t\tthis.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n\t\t\tif (smoothCheck !== smoothingGroupInt) {\n\n\t\t\t\tthis.rawMesh.counts.smoothingGroupCount++;\n\t\t\t\tthis.checkSubGroup();\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Expanded faceTypes include all four face types, both line types and the point type\n   * faceType = 0: \"f vertex ...\"\n   * faceType = 1: \"f vertex/uv ...\"\n   * faceType = 2: \"f vertex/uv/normal ...\"\n   * faceType = 3: \"f vertex//normal ...\"\n   * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n   * faceType = 5: \"l vertex ...\"\n   * faceType = 6: \"p vertex ...\"\n   */\n\t\tParser.prototype.checkFaceType = function (faceType) {\n\t\t\tif (this.rawMesh.faceType !== faceType) {\n\n\t\t\t\tthis.processCompletedMesh();\n\t\t\t\tthis.rawMesh.faceType = faceType;\n\t\t\t\tthis.checkSubGroup();\n\t\t\t}\n\t\t};\n\n\t\tParser.prototype.checkSubGroup = function () {\n\t\t\tvar index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n\t\t\tthis.rawMesh.subGroupInUse = this.rawMesh.subGroups[index];\n\n\t\t\tif (!_LoaderSupport2.default.Validator.isValid(this.rawMesh.subGroupInUse)) {\n\n\t\t\t\tthis.rawMesh.subGroupInUse = {\n\t\t\t\t\tindex: index,\n\t\t\t\t\tobjectName: this.rawMesh.objectName,\n\t\t\t\t\tgroupName: this.rawMesh.groupName,\n\t\t\t\t\tmaterialName: this.rawMesh.activeMtlName,\n\t\t\t\t\tsmoothingGroup: this.rawMesh.smoothingGroup.normalized,\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tindexMappingsCount: 0,\n\t\t\t\t\tindexMappings: [],\n\t\t\t\t\tindices: [],\n\t\t\t\t\tcolors: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tnormals: []\n\t\t\t\t};\n\t\t\t\tthis.rawMesh.subGroups[index] = this.rawMesh.subGroupInUse;\n\t\t\t}\n\t\t};\n\n\t\tParser.prototype.buildFace = function (faceIndexV, faceIndexU, faceIndexN) {\n\t\t\tif (this.disregardNormals) faceIndexN = undefined;\n\t\t\tvar scope = this;\n\t\t\tvar updateSubGroupInUse = function updateSubGroupInUse() {\n\n\t\t\t\tvar faceIndexVi = parseInt(faceIndexV);\n\t\t\t\tvar indexPointerV = 3 * (faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3);\n\n\t\t\t\tvar vertices = scope.rawMesh.subGroupInUse.vertices;\n\t\t\t\tvertices.push(scope.vertices[indexPointerV++]);\n\t\t\t\tvertices.push(scope.vertices[indexPointerV++]);\n\t\t\t\tvertices.push(scope.vertices[indexPointerV]);\n\n\t\t\t\tvar indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n\t\t\t\tif (indexPointerC !== null) {\n\n\t\t\t\t\tvar colors = scope.rawMesh.subGroupInUse.colors;\n\t\t\t\t\tcolors.push(scope.colors[indexPointerC++]);\n\t\t\t\t\tcolors.push(scope.colors[indexPointerC++]);\n\t\t\t\t\tcolors.push(scope.colors[indexPointerC]);\n\t\t\t\t}\n\t\t\t\tif (faceIndexU) {\n\n\t\t\t\t\tvar faceIndexUi = parseInt(faceIndexU);\n\t\t\t\t\tvar indexPointerU = 2 * (faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2);\n\t\t\t\t\tvar uvs = scope.rawMesh.subGroupInUse.uvs;\n\t\t\t\t\tuvs.push(scope.uvs[indexPointerU++]);\n\t\t\t\t\tuvs.push(scope.uvs[indexPointerU]);\n\t\t\t\t}\n\t\t\t\tif (faceIndexN) {\n\n\t\t\t\t\tvar faceIndexNi = parseInt(faceIndexN);\n\t\t\t\t\tvar indexPointerN = 3 * (faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3);\n\t\t\t\t\tvar normals = scope.rawMesh.subGroupInUse.normals;\n\t\t\t\t\tnormals.push(scope.normals[indexPointerN++]);\n\t\t\t\t\tnormals.push(scope.normals[indexPointerN++]);\n\t\t\t\t\tnormals.push(scope.normals[indexPointerN]);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (this.useIndices) {\n\n\t\t\t\tvar mappingName = faceIndexV + (faceIndexU ? '_' + faceIndexU : '_n') + (faceIndexN ? '_' + faceIndexN : '_n');\n\t\t\t\tvar indicesPointer = this.rawMesh.subGroupInUse.indexMappings[mappingName];\n\t\t\t\tif (_LoaderSupport2.default.Validator.isValid(indicesPointer)) {\n\n\t\t\t\t\tthis.rawMesh.counts.doubleIndicesCount++;\n\t\t\t\t} else {\n\n\t\t\t\t\tindicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n\t\t\t\t\tupdateSubGroupInUse();\n\t\t\t\t\tthis.rawMesh.subGroupInUse.indexMappings[mappingName] = indicesPointer;\n\t\t\t\t\tthis.rawMesh.subGroupInUse.indexMappingsCount++;\n\t\t\t\t}\n\t\t\t\tthis.rawMesh.subGroupInUse.indices.push(indicesPointer);\n\t\t\t} else {\n\n\t\t\t\tupdateSubGroupInUse();\n\t\t\t}\n\t\t\tthis.rawMesh.counts.faceCount++;\n\t\t};\n\n\t\tParser.prototype.createRawMeshReport = function (inputObjectCount) {\n\t\t\treturn 'Input Object number: ' + inputObjectCount + '\\n\\tObject name: ' + this.rawMesh.objectName + '\\n\\tGroup name: ' + this.rawMesh.groupName + '\\n\\tMtllib name: ' + this.rawMesh.mtllibName + '\\n\\tVertex count: ' + this.vertices.length / 3 + '\\n\\tNormal count: ' + this.normals.length / 3 + '\\n\\tUV count: ' + this.uvs.length / 2 + '\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount + '\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount + '\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n\t\t};\n\n\t\t/**\n   * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n   */\n\t\tParser.prototype.finalizeRawMesh = function () {\n\t\t\tvar meshOutputGroupTemp = [];\n\t\t\tvar meshOutputGroup;\n\t\t\tvar absoluteVertexCount = 0;\n\t\t\tvar absoluteIndexMappingsCount = 0;\n\t\t\tvar absoluteIndexCount = 0;\n\t\t\tvar absoluteColorCount = 0;\n\t\t\tvar absoluteNormalCount = 0;\n\t\t\tvar absoluteUvCount = 0;\n\t\t\tvar indices;\n\t\t\tfor (var name in this.rawMesh.subGroups) {\n\n\t\t\t\tmeshOutputGroup = this.rawMesh.subGroups[name];\n\t\t\t\tif (meshOutputGroup.vertices.length > 0) {\n\n\t\t\t\t\tindices = meshOutputGroup.indices;\n\t\t\t\t\tif (indices.length > 0 && absoluteIndexMappingsCount > 0) {\n\n\t\t\t\t\t\tfor (var i in indices) {\n\t\t\t\t\t\t\tindices[i] = indices[i] + absoluteIndexMappingsCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmeshOutputGroupTemp.push(meshOutputGroup);\n\t\t\t\t\tabsoluteVertexCount += meshOutputGroup.vertices.length;\n\t\t\t\t\tabsoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n\t\t\t\t\tabsoluteIndexCount += meshOutputGroup.indices.length;\n\t\t\t\t\tabsoluteColorCount += meshOutputGroup.colors.length;\n\t\t\t\t\tabsoluteUvCount += meshOutputGroup.uvs.length;\n\t\t\t\t\tabsoluteNormalCount += meshOutputGroup.normals.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// do not continue if no result\n\t\t\tvar result = null;\n\t\t\tif (meshOutputGroupTemp.length > 0) {\n\n\t\t\t\tresult = {\n\t\t\t\t\tname: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n\t\t\t\t\tsubGroups: meshOutputGroupTemp,\n\t\t\t\t\tabsoluteVertexCount: absoluteVertexCount,\n\t\t\t\t\tabsoluteIndexCount: absoluteIndexCount,\n\t\t\t\t\tabsoluteColorCount: absoluteColorCount,\n\t\t\t\t\tabsoluteNormalCount: absoluteNormalCount,\n\t\t\t\t\tabsoluteUvCount: absoluteUvCount,\n\t\t\t\t\tfaceCount: this.rawMesh.counts.faceCount,\n\t\t\t\t\tdoubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tParser.prototype.processCompletedMesh = function () {\n\t\t\tvar result = this.finalizeRawMesh();\n\t\t\tif (_LoaderSupport2.default.Validator.isValid(result)) {\n\n\t\t\t\tif (this.colors.length > 0 && this.colors.length !== this.vertices.length) {\n\n\t\t\t\t\tthrow 'Vertex Colors were detected, but vertex count and color count do not match!';\n\t\t\t\t}\n\t\t\t\tif (this.logging.enabled && this.logging.debug) console.debug(this.createRawMeshReport(this.inputObjectCount));\n\t\t\t\tthis.inputObjectCount++;\n\n\t\t\t\tthis.buildMesh(result);\n\t\t\t\tvar progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\t\t\t\tthis.callbackProgress('Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '] Total progress: ' + (progressBytesPercent * 100).toFixed(2) + '%', progressBytesPercent);\n\t\t\t\tthis.resetRawMesh();\n\t\t\t\treturn true;\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * SubGroups are transformed to too intermediate format that is forwarded to the MeshBuilder.\n   * It is ensured that SubGroups only contain objects with vertices (no need to check).\n   *\n   * @param result\n   */\n\t\tParser.prototype.buildMesh = function (result) {\n\t\t\tvar meshOutputGroups = result.subGroups;\n\n\t\t\tvar vertexFA = new Float32Array(result.absoluteVertexCount);\n\t\t\tthis.globalCounts.vertices += result.absoluteVertexCount / 3;\n\t\t\tthis.globalCounts.faces += result.faceCount;\n\t\t\tthis.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n\t\t\tvar indexUA = result.absoluteIndexCount > 0 ? new Uint32Array(result.absoluteIndexCount) : null;\n\t\t\tvar colorFA = result.absoluteColorCount > 0 ? new Float32Array(result.absoluteColorCount) : null;\n\t\t\tvar normalFA = result.absoluteNormalCount > 0 ? new Float32Array(result.absoluteNormalCount) : null;\n\t\t\tvar uvFA = result.absoluteUvCount > 0 ? new Float32Array(result.absoluteUvCount) : null;\n\t\t\tvar haveVertexColors = _LoaderSupport2.default.Validator.isValid(colorFA);\n\n\t\t\tvar meshOutputGroup;\n\t\t\tvar materialNames = [];\n\n\t\t\tvar createMultiMaterial = meshOutputGroups.length > 1;\n\t\t\tvar materialIndex = 0;\n\t\t\tvar materialIndexMapping = [];\n\t\t\tvar selectedMaterialIndex;\n\t\t\tvar materialGroup;\n\t\t\tvar materialGroups = [];\n\n\t\t\tvar vertexFAOffset = 0;\n\t\t\tvar indexUAOffset = 0;\n\t\t\tvar colorFAOffset = 0;\n\t\t\tvar normalFAOffset = 0;\n\t\t\tvar uvFAOffset = 0;\n\t\t\tvar materialGroupOffset = 0;\n\t\t\tvar materialGroupLength = 0;\n\n\t\t\tvar materialOrg, material, materialName, materialNameOrg;\n\t\t\t// only one specific face type\n\t\t\tfor (var oodIndex in meshOutputGroups) {\n\n\t\t\t\tif (!meshOutputGroups.hasOwnProperty(oodIndex)) continue;\n\t\t\t\tmeshOutputGroup = meshOutputGroups[oodIndex];\n\n\t\t\t\tmaterialNameOrg = meshOutputGroup.materialName;\n\t\t\t\tif (this.rawMesh.faceType < 4) {\n\n\t\t\t\t\tmaterialName = materialNameOrg + (haveVertexColors ? '_vertexColor' : '') + (meshOutputGroup.smoothingGroup === 0 ? '_flat' : '');\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n\t\t\t\t}\n\t\t\t\tmaterialOrg = this.materials[materialNameOrg];\n\t\t\t\tmaterial = this.materials[materialName];\n\n\t\t\t\t// both original and derived names do not lead to an existing material => need to use a default material\n\t\t\t\tif (!_LoaderSupport2.default.Validator.isValid(materialOrg) && !_LoaderSupport2.default.Validator.isValid(material)) {\n\n\t\t\t\t\tvar defaultMaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n\t\t\t\t\tmaterialOrg = this.materials[defaultMaterialName];\n\t\t\t\t\tif (this.logging.enabled) console.warn('object_group \"' + meshOutputGroup.objectName + '_' + meshOutputGroup.groupName + '\" was defined with unresolvable material \"' + materialNameOrg + '\"! Assigning \"' + defaultMaterialName + '\".');\n\t\t\t\t\tmaterialNameOrg = defaultMaterialName;\n\n\t\t\t\t\t// if names are identical then there is no need for later manipulation\n\t\t\t\t\tif (materialNameOrg === materialName) {\n\n\t\t\t\t\t\tmaterial = materialOrg;\n\t\t\t\t\t\tmaterialName = defaultMaterialName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!_LoaderSupport2.default.Validator.isValid(material)) {\n\n\t\t\t\t\tvar materialCloneInstructions = {\n\t\t\t\t\t\tmaterialNameOrg: materialNameOrg,\n\t\t\t\t\t\tmaterialName: materialName,\n\t\t\t\t\t\tmaterialProperties: {\n\t\t\t\t\t\t\tvertexColors: haveVertexColors ? 2 : 0,\n\t\t\t\t\t\t\tflatShading: meshOutputGroup.smoothingGroup === 0\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tvar payload = {\n\t\t\t\t\t\tcmd: 'materialData',\n\t\t\t\t\t\tmaterials: {\n\t\t\t\t\t\t\tmaterialCloneInstructions: materialCloneInstructions\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tthis.callbackMeshBuilder(payload);\n\n\t\t\t\t\t// fake entry for async; sync Parser always works on material references (Builder update directly visible here)\n\t\t\t\t\tif (this.useAsync) this.materials[materialName] = materialCloneInstructions;\n\t\t\t\t}\n\n\t\t\t\tif (createMultiMaterial) {\n\n\t\t\t\t\t// re-use material if already used before. Reduces materials array size and eliminates duplicates\n\t\t\t\t\tselectedMaterialIndex = materialIndexMapping[materialName];\n\t\t\t\t\tif (!selectedMaterialIndex) {\n\n\t\t\t\t\t\tselectedMaterialIndex = materialIndex;\n\t\t\t\t\t\tmaterialIndexMapping[materialName] = materialIndex;\n\t\t\t\t\t\tmaterialNames.push(materialName);\n\t\t\t\t\t\tmaterialIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tmaterialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n\t\t\t\t\tmaterialGroup = {\n\t\t\t\t\t\tstart: materialGroupOffset,\n\t\t\t\t\t\tcount: materialGroupLength,\n\t\t\t\t\t\tindex: selectedMaterialIndex\n\t\t\t\t\t};\n\t\t\t\t\tmaterialGroups.push(materialGroup);\n\t\t\t\t\tmaterialGroupOffset += materialGroupLength;\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialNames.push(materialName);\n\t\t\t\t}\n\n\t\t\t\tvertexFA.set(meshOutputGroup.vertices, vertexFAOffset);\n\t\t\t\tvertexFAOffset += meshOutputGroup.vertices.length;\n\n\t\t\t\tif (indexUA) {\n\n\t\t\t\t\tindexUA.set(meshOutputGroup.indices, indexUAOffset);\n\t\t\t\t\tindexUAOffset += meshOutputGroup.indices.length;\n\t\t\t\t}\n\n\t\t\t\tif (colorFA) {\n\n\t\t\t\t\tcolorFA.set(meshOutputGroup.colors, colorFAOffset);\n\t\t\t\t\tcolorFAOffset += meshOutputGroup.colors.length;\n\t\t\t\t}\n\n\t\t\t\tif (normalFA) {\n\n\t\t\t\t\tnormalFA.set(meshOutputGroup.normals, normalFAOffset);\n\t\t\t\t\tnormalFAOffset += meshOutputGroup.normals.length;\n\t\t\t\t}\n\t\t\t\tif (uvFA) {\n\n\t\t\t\t\tuvFA.set(meshOutputGroup.uvs, uvFAOffset);\n\t\t\t\t\tuvFAOffset += meshOutputGroup.uvs.length;\n\t\t\t\t}\n\n\t\t\t\tif (this.logging.enabled && this.logging.debug) {\n\t\t\t\t\tvar materialIndexLine = _LoaderSupport2.default.Validator.isValid(selectedMaterialIndex) ? '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex : '';\n\t\t\t\t\tvar createdReport = '\\tOutput Object no.: ' + this.outputObjectCount + '\\n\\t\\tgroupName: ' + meshOutputGroup.groupName + '\\n\\t\\tIndex: ' + meshOutputGroup.index + '\\n\\t\\tfaceType: ' + this.rawMesh.faceType + '\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName + '\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup + materialIndexLine + '\\n\\t\\tobjectName: ' + meshOutputGroup.objectName + '\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 + '\\n\\t\\t#indices: ' + meshOutputGroup.indices.length + '\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 + '\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 + '\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n\t\t\t\t\tconsole.debug(createdReport);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.outputObjectCount++;\n\t\t\tthis.callbackMeshBuilder({\n\t\t\t\tcmd: 'meshData',\n\t\t\t\tprogress: {\n\t\t\t\t\tnumericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n\t\t\t\t},\n\t\t\t\tparams: {\n\t\t\t\t\tmeshName: result.name\n\t\t\t\t},\n\t\t\t\tmaterials: {\n\t\t\t\t\tmultiMaterial: createMultiMaterial,\n\t\t\t\t\tmaterialNames: materialNames,\n\t\t\t\t\tmaterialGroups: materialGroups\n\t\t\t\t},\n\t\t\t\tbuffers: {\n\t\t\t\t\tvertices: vertexFA,\n\t\t\t\t\tindices: indexUA,\n\t\t\t\t\tcolors: colorFA,\n\t\t\t\t\tnormals: normalFA,\n\t\t\t\t\tuvs: uvFA\n\t\t\t\t},\n\t\t\t\t// 0: mesh, 1: line, 2: point\n\t\t\t\tgeometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1\n\t\t\t}, [vertexFA.buffer], _LoaderSupport2.default.Validator.isValid(indexUA) ? [indexUA.buffer] : null, _LoaderSupport2.default.Validator.isValid(colorFA) ? [colorFA.buffer] : null, _LoaderSupport2.default.Validator.isValid(normalFA) ? [normalFA.buffer] : null, _LoaderSupport2.default.Validator.isValid(uvFA) ? [uvFA.buffer] : null);\n\t\t};\n\n\t\tParser.prototype.finalizeParsing = function () {\n\t\t\tif (this.logging.enabled) console.info('Global output object count: ' + this.outputObjectCount);\n\t\t\tif (this.processCompletedMesh() && this.logging.enabled) {\n\n\t\t\t\tvar parserFinalReport = 'Overall counts: ' + '\\n\\tVertices: ' + this.globalCounts.vertices + '\\n\\tFaces: ' + this.globalCounts.faces + '\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n\t\t\t\tconsole.info(parserFinalReport);\n\t\t\t}\n\t\t};\n\n\t\treturn Parser;\n\t}();\n\n\t/**\n  * Utility method for loading an mtl file according resource description. Provide url or content.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string} url URL to the file\n  * @param {Object} content The file content as arraybuffer or text\n  * @param {function} callbackOnLoad Callback to be called after successful load\n  * @param {string} [crossOrigin] CORS value\n \t * @param {Object} [materialOptions] Set material loading options for MTLLoader\n  */\n\tOBJLoader2.prototype.loadMtl = function (url, content, callbackOnLoad, crossOrigin, materialOptions) {\n\t\tvar resource = new _LoaderSupport2.default.ResourceDescriptor(url, 'MTL');\n\t\tresource.setContent(content);\n\t\tthis._loadMtl(resource, callbackOnLoad, crossOrigin, materialOptions);\n\t};\n\n\tOBJLoader2.prototype._loadMtl = function (resource, callbackOnLoad, crossOrigin, materialOptions) {\n\t\tif (_MTLLoader2.default === undefined) console.error('\"THREE.MTLLoader\" is not available. \"THREE.OBJLoader2\" requires it for loading MTL files.');\n\t\tif (Validator.isValid(resource) && this.logging.enabled) console.time('Loading MTL: ' + resource.name);\n\n\t\tvar materials = [];\n\t\tvar scope = this;\n\t\tvar processMaterials = function processMaterials(materialCreator) {\n\t\t\tvar materialCreatorMaterials = [];\n\t\t\tif (Validator.isValid(materialCreator)) {\n\n\t\t\t\tmaterialCreator.preload();\n\t\t\t\tmaterialCreatorMaterials = materialCreator.materials;\n\t\t\t\tfor (var materialName in materialCreatorMaterials) {\n\n\t\t\t\t\tif (materialCreatorMaterials.hasOwnProperty(materialName)) {\n\n\t\t\t\t\t\tmaterials[materialName] = materialCreatorMaterials[materialName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Validator.isValid(resource) && scope.logging.enabled) console.timeEnd('Loading MTL: ' + resource.name);\n\t\t\tcallbackOnLoad(materials, materialCreator);\n\t\t};\n\n\t\t// fast-fail\n\t\tif (!Validator.isValid(resource) || !Validator.isValid(resource.content) && !Validator.isValid(resource.url)) {\n\n\t\t\tprocessMaterials();\n\t\t} else {\n\n\t\t\tvar mtlLoader = new _MTLLoader2.default(this.manager);\n\t\t\tcrossOrigin = Validator.verifyInput(crossOrigin, 'anonymous');\n\t\t\tmtlLoader.setCrossOrigin(crossOrigin);\n\t\t\tmtlLoader.setPath(resource.path);\n\t\t\tif (Validator.isValid(materialOptions)) mtlLoader.setMaterialOptions(materialOptions);\n\n\t\t\tif (Validator.isValid(resource.content)) {\n\n\t\t\t\tprocessMaterials(Validator.isValid(resource.content) ? mtlLoader.parse(resource.content) : null);\n\t\t\t} else if (Validator.isValid(resource.url)) {\n\n\t\t\t\tvar fileLoader = new THREE.FileLoader(this.manager);\n\t\t\t\tfileLoader.load(resource.url, function (text) {\n\n\t\t\t\t\tresource.content = text;\n\t\t\t\t\tprocessMaterials(mtlLoader.parse(text));\n\t\t\t\t}, this._onProgress, this._onError);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn OBJLoader2;\n}();\n\nexports.default = OBJLoader2;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Filipe Caixeta / http://filipecaixeta.com.br\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for PCD ascii and binary files.\n *\n * Limitations: Compressed binary files are not supported.\n *\n */\n\nvar PCDLoader = function PCDLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.littleEndian = true;\n};\n\nPCDLoader.prototype = {\n\n\tconstructor: PCDLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (data) {\n\n\t\t\tonLoad(scope.parse(data, url));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data, url) {\n\n\t\tfunction parseHeader(data) {\n\n\t\t\tvar PCDheader = {};\n\t\t\tvar result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n\n\t\t\tPCDheader.data = result2[1];\n\t\t\tPCDheader.headerLen = result2[0].length + result1;\n\t\t\tPCDheader.str = data.substr(0, PCDheader.headerLen);\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace(/\\#.*/gi, '');\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.points = /POINTS (.*)/i.exec(PCDheader.str);\n\n\t\t\t// evaluate\n\n\t\t\tif (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n\n\t\t\tif (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n\n\t\t\tif (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n\n\t\t\tif (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n\n\t\t\tif (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n\n\t\t\tif (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n\n\t\t\tif (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n\n\t\t\tif (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif (PCDheader.size !== null) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n\n\t\t\t\t\treturn parseInt(x, 10);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (PCDheader.count !== null) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n\n\t\t\t\t\treturn parseInt(x, 10);\n\t\t\t\t});\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor (var i = 0, l = PCDheader.fields.length; i < l; i++) {\n\n\t\t\t\t\tPCDheader.count.push(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tvar sizeSum = 0;\n\n\t\t\tfor (var i = 0, l = PCDheader.fields.length; i < l; i++) {\n\n\t\t\t\tif (PCDheader.data === 'ascii') {\n\n\t\t\t\t\tPCDheader.offset[PCDheader.fields[i]] = i;\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[PCDheader.fields[i]] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\t\t}\n\n\t\tvar textData = THREE.LoaderUtils.decodeText(data);\n\n\t\t// parse header (always ascii format)\n\n\t\tvar PCDheader = parseHeader(textData);\n\n\t\t// parse data\n\n\t\tvar position = [];\n\t\tvar normal = [];\n\t\tvar color = [];\n\n\t\t// ascii\n\n\t\tif (PCDheader.data === 'ascii') {\n\n\t\t\tvar offset = PCDheader.offset;\n\t\t\tvar pcdData = textData.substr(PCDheader.headerLen);\n\t\t\tvar lines = pcdData.split('\\n');\n\n\t\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\t\tif (lines[i] === '') continue;\n\n\t\t\t\tvar line = lines[i].split(' ');\n\n\t\t\t\tif (offset.x !== undefined) {\n\n\t\t\t\t\tposition.push(parseFloat(line[offset.x]));\n\t\t\t\t\tposition.push(parseFloat(line[offset.y]));\n\t\t\t\t\tposition.push(parseFloat(line[offset.z]));\n\t\t\t\t}\n\n\t\t\t\tif (offset.rgb !== undefined) {\n\n\t\t\t\t\tvar c = new Float32Array([parseFloat(line[offset.rgb])]);\n\t\t\t\t\tvar dataview = new DataView(c.buffer, 0);\n\t\t\t\t\tcolor.push(dataview.getUint8(0) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(1) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(2) / 255.0);\n\t\t\t\t}\n\n\t\t\t\tif (offset.normal_x !== undefined) {\n\n\t\t\t\t\tnormal.push(parseFloat(line[offset.normal_x]));\n\t\t\t\t\tnormal.push(parseFloat(line[offset.normal_y]));\n\t\t\t\t\tnormal.push(parseFloat(line[offset.normal_z]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// binary\n\n\t\tif (PCDheader.data === 'binary_compressed') {\n\n\t\t\tconsole.error('THREE.PCDLoader: binary_compressed files are not supported');\n\t\t\treturn;\n\t\t}\n\n\t\tif (PCDheader.data === 'binary') {\n\n\t\t\tvar dataview = new DataView(data, PCDheader.headerLen);\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor (var i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n\n\t\t\t\tif (offset.x !== undefined) {\n\n\t\t\t\t\tposition.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n\t\t\t\t\tposition.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n\t\t\t\t\tposition.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n\t\t\t\t}\n\n\t\t\t\tif (offset.rgb !== undefined) {\n\n\t\t\t\t\tcolor.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);\n\t\t\t\t}\n\n\t\t\t\tif (offset.normal_x !== undefined) {\n\n\t\t\t\t\tnormal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n\t\t\t\t\tnormal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n\t\t\t\t\tnormal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build geometry\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tif (position.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position, 3));\n\t\tif (normal.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal, 3));\n\t\tif (color.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color, 3));\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tvar material = new THREE.PointsMaterial({ size: 0.005 });\n\n\t\tif (color.length > 0) {\n\n\t\t\tmaterial.vertexColors = true;\n\t\t} else {\n\n\t\t\tmaterial.color.setHex(Math.random() * 0xffffff);\n\t\t}\n\n\t\t// build mesh\n\n\t\tvar mesh = new THREE.Points(geometry, material);\n\t\tvar name = url.split('').reverse().join('');\n\t\tname = /([^\\/]*)/.exec(name);\n\t\tname = name[1].split('').reverse().join('');\n\t\tmesh.name = name;\n\n\t\treturn mesh;\n\t}\n\n};\n\nexports.default = PCDLoader;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar PDBLoader = function PDBLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nPDBLoader.prototype = {\n\n\tconstructor: PDBLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\t// Based on CanvasMol PDB parser\n\n\tparse: function parse(text) {\n\n\t\tfunction trim(text) {\n\n\t\t\treturn text.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t\t}\n\n\t\tfunction capitalize(text) {\n\n\t\t\treturn text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();\n\t\t}\n\n\t\tfunction hash(s, e) {\n\n\t\t\treturn 's' + Math.min(s, e) + 'e' + Math.max(s, e);\n\t\t}\n\n\t\tfunction parseBond(start, length) {\n\n\t\t\tvar eatom = parseInt(lines[i].substr(start, length));\n\n\t\t\tif (eatom) {\n\n\t\t\t\tvar h = hash(satom, eatom);\n\n\t\t\t\tif (bhash[h] === undefined) {\n\n\t\t\t\t\tbonds.push([satom - 1, eatom - 1, 1]);\n\t\t\t\t\tbhash[h] = bonds.length - 1;\n\t\t\t\t} else {\n\n\t\t\t\t\t// doesn't really work as almost all PDBs\n\t\t\t\t\t// have just normal bonds appearing multiple\n\t\t\t\t\t// times instead of being double/triple bonds\n\t\t\t\t\t// bonds[bhash[h]][2] += 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction buildGeometry() {\n\n\t\t\tvar build = {\n\t\t\t\tgeometryAtoms: new THREE.BufferGeometry(),\n\t\t\t\tgeometryBonds: new THREE.BufferGeometry(),\n\t\t\t\tjson: {\n\t\t\t\t\tatoms: atoms,\n\t\t\t\t\tbonds: bonds\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar geometryAtoms = build.geometryAtoms;\n\t\t\tvar geometryBonds = build.geometryBonds;\n\n\t\t\tvar i, l;\n\n\t\t\tvar verticesAtoms = [];\n\t\t\tvar colorsAtoms = [];\n\t\t\tvar verticesBonds = [];\n\n\t\t\t// atoms\n\n\t\t\tfor (i = 0, l = atoms.length; i < l; i++) {\n\n\t\t\t\tvar atom = atoms[i];\n\n\t\t\t\tvar x = atom[0];\n\t\t\t\tvar y = atom[1];\n\t\t\t\tvar z = atom[2];\n\n\t\t\t\tverticesAtoms.push(x, y, z);\n\n\t\t\t\tvar r = atom[3][0] / 255;\n\t\t\t\tvar g = atom[3][1] / 255;\n\t\t\t\tvar b = atom[3][2] / 255;\n\n\t\t\t\tcolorsAtoms.push(r, g, b);\n\t\t\t}\n\n\t\t\t// bonds\n\n\t\t\tfor (i = 0, l = bonds.length; i < l; i++) {\n\n\t\t\t\tvar bond = bonds[i];\n\n\t\t\t\tvar start = bond[0];\n\t\t\t\tvar end = bond[1];\n\n\t\t\t\tverticesBonds.push(verticesAtoms[start * 3 + 0]);\n\t\t\t\tverticesBonds.push(verticesAtoms[start * 3 + 1]);\n\t\t\t\tverticesBonds.push(verticesAtoms[start * 3 + 2]);\n\n\t\t\t\tverticesBonds.push(verticesAtoms[end * 3 + 0]);\n\t\t\t\tverticesBonds.push(verticesAtoms[end * 3 + 1]);\n\t\t\t\tverticesBonds.push(verticesAtoms[end * 3 + 2]);\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tgeometryAtoms.addAttribute('position', new THREE.Float32BufferAttribute(verticesAtoms, 3));\n\t\t\tgeometryAtoms.addAttribute('color', new THREE.Float32BufferAttribute(colorsAtoms, 3));\n\n\t\t\tgeometryBonds.addAttribute('position', new THREE.Float32BufferAttribute(verticesBonds, 3));\n\n\t\t\treturn build;\n\t\t}\n\n\t\tvar CPK = { h: [255, 255, 255], he: [217, 255, 255], li: [204, 128, 255], be: [194, 255, 0], b: [255, 181, 181], c: [144, 144, 144], n: [48, 80, 248], o: [255, 13, 13], f: [144, 224, 80], ne: [179, 227, 245], na: [171, 92, 242], mg: [138, 255, 0], al: [191, 166, 166], si: [240, 200, 160], p: [255, 128, 0], s: [255, 255, 48], cl: [31, 240, 31], ar: [128, 209, 227], k: [143, 64, 212], ca: [61, 255, 0], sc: [230, 230, 230], ti: [191, 194, 199], v: [166, 166, 171], cr: [138, 153, 199], mn: [156, 122, 199], fe: [224, 102, 51], co: [240, 144, 160], ni: [80, 208, 80], cu: [200, 128, 51], zn: [125, 128, 176], ga: [194, 143, 143], ge: [102, 143, 143], as: [189, 128, 227], se: [255, 161, 0], br: [166, 41, 41], kr: [92, 184, 209], rb: [112, 46, 176], sr: [0, 255, 0], y: [148, 255, 255], zr: [148, 224, 224], nb: [115, 194, 201], mo: [84, 181, 181], tc: [59, 158, 158], ru: [36, 143, 143], rh: [10, 125, 140], pd: [0, 105, 133], ag: [192, 192, 192], cd: [255, 217, 143], in: [166, 117, 115], sn: [102, 128, 128], sb: [158, 99, 181], te: [212, 122, 0], i: [148, 0, 148], xe: [66, 158, 176], cs: [87, 23, 143], ba: [0, 201, 0], la: [112, 212, 255], ce: [255, 255, 199], pr: [217, 255, 199], nd: [199, 255, 199], pm: [163, 255, 199], sm: [143, 255, 199], eu: [97, 255, 199], gd: [69, 255, 199], tb: [48, 255, 199], dy: [31, 255, 199], ho: [0, 255, 156], er: [0, 230, 117], tm: [0, 212, 82], yb: [0, 191, 56], lu: [0, 171, 36], hf: [77, 194, 255], ta: [77, 166, 255], w: [33, 148, 214], re: [38, 125, 171], os: [38, 102, 150], ir: [23, 84, 135], pt: [208, 208, 224], au: [255, 209, 35], hg: [184, 184, 208], tl: [166, 84, 77], pb: [87, 89, 97], bi: [158, 79, 181], po: [171, 92, 0], at: [117, 79, 69], rn: [66, 130, 150], fr: [66, 0, 102], ra: [0, 125, 0], ac: [112, 171, 250], th: [0, 186, 255], pa: [0, 161, 255], u: [0, 143, 255], np: [0, 128, 255], pu: [0, 107, 255], am: [84, 92, 242], cm: [120, 92, 227], bk: [138, 79, 227], cf: [161, 54, 212], es: [179, 31, 212], fm: [179, 31, 186], md: [179, 13, 166], no: [189, 13, 135], lr: [199, 0, 102], rf: [204, 0, 89], db: [209, 0, 79], sg: [217, 0, 69], bh: [224, 0, 56], hs: [230, 0, 46], mt: [235, 0, 38], ds: [235, 0, 38], rg: [235, 0, 38], cn: [235, 0, 38], uut: [235, 0, 38], uuq: [235, 0, 38], uup: [235, 0, 38], uuh: [235, 0, 38], uus: [235, 0, 38], uuo: [235, 0, 38] };\n\n\t\tvar atoms = [];\n\t\tvar bonds = [];\n\t\tvar histogram = {};\n\n\t\tvar bhash = {};\n\n\t\tvar x, y, z, index, e;\n\n\t\t// parse\n\n\t\tvar lines = text.split('\\n');\n\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\tif (lines[i].substr(0, 4) === 'ATOM' || lines[i].substr(0, 6) === 'HETATM') {\n\n\t\t\t\tx = parseFloat(lines[i].substr(30, 7));\n\t\t\t\ty = parseFloat(lines[i].substr(38, 7));\n\t\t\t\tz = parseFloat(lines[i].substr(46, 7));\n\t\t\t\tindex = parseInt(lines[i].substr(6, 5)) - 1;\n\n\t\t\t\te = trim(lines[i].substr(76, 2)).toLowerCase();\n\n\t\t\t\tif (e === '') {\n\n\t\t\t\t\te = trim(lines[i].substr(12, 2)).toLowerCase();\n\t\t\t\t}\n\n\t\t\t\tatoms[index] = [x, y, z, CPK[e], capitalize(e)];\n\n\t\t\t\tif (histogram[e] === undefined) {\n\n\t\t\t\t\thistogram[e] = 1;\n\t\t\t\t} else {\n\n\t\t\t\t\thistogram[e] += 1;\n\t\t\t\t}\n\t\t\t} else if (lines[i].substr(0, 6) === 'CONECT') {\n\n\t\t\t\tvar satom = parseInt(lines[i].substr(6, 5));\n\n\t\t\t\tparseBond(11, 5);\n\t\t\t\tparseBond(16, 5);\n\t\t\t\tparseBond(21, 5);\n\t\t\t\tparseBond(26, 5);\n\t\t\t}\n\t\t}\n\n\t\t// build and return geometry\n\n\t\treturn buildGeometry();\n\t}\n\n};\n\nexports.default = PDBLoader;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar PlayCanvasLoader = function PlayCanvasLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nPlayCanvasLoader.prototype = {\n\n\tconstructor: PlayCanvasLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(json) {\n\n\t\tfunction parseVertices(data) {\n\n\t\t\tvar attributes = {};\n\n\t\t\t// create a buffer attribute for each array that contains vertex information\n\n\t\t\tfor (var name in data) {\n\n\t\t\t\tvar array = data[name];\n\n\t\t\t\tvar type = array.type;\n\t\t\t\tvar size = array.components;\n\n\t\t\t\tvar attribute;\n\n\t\t\t\tswitch (type) {\n\n\t\t\t\t\tcase 'float32':\n\t\t\t\t\t\tattribute = new THREE.Float32BufferAttribute(array.data, size);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'uint8':\n\t\t\t\t\t\tattribute = new THREE.Uint8BufferAttribute(array.data, size);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'uint16':\n\t\t\t\t\t\tattribute = new THREE.Uint16BufferAttribute(array.data, size);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log('THREE.PlayCanvasLoader: Array type \"%s\" not yet supported.', type);\n\n\t\t\t\t}\n\n\t\t\t\tattributes[name] = attribute;\n\t\t\t}\n\n\t\t\tdata._attributes = attributes;\n\t\t}\n\n\t\tfunction parseMeshes(data) {\n\n\t\t\t// create buffer geometry\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tgeometry.setIndex(data.indices);\n\n\t\t\tvar attributes = model.vertices[data.vertices]._attributes;\n\n\t\t\tfor (var name in attributes) {\n\n\t\t\t\tvar attribute = attributes[name];\n\n\t\t\t\tif (name === 'texCoord0') name = 'uv';\n\n\t\t\t\tgeometry.addAttribute(name, attribute);\n\t\t\t}\n\n\t\t\tdata._geometry = geometry;\n\t\t}\n\n\t\tfunction parseMeshInstances(data) {\n\n\t\t\tvar node = model.nodes[data.node];\n\t\t\tvar mesh = model.meshes[data.mesh];\n\n\t\t\tif (node._geometries === undefined) {\n\n\t\t\t\tnode._geometries = [];\n\t\t\t}\n\n\t\t\tnode._geometries.push(mesh._geometry);\n\t\t}\n\n\t\tfunction parseNodes(data) {\n\n\t\t\tvar object = new THREE.Group();\n\n\t\t\tvar geometries = data._geometries;\n\n\t\t\tif (geometries !== undefined) {\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\t\tfor (var i = 0, l = geometries.length; i < l; i++) {\n\n\t\t\t\t\tvar geometry = geometries[i];\n\n\t\t\t\t\tobject.add(new THREE.Mesh(geometry, material));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = data.rotation.length; i < l; i++) {\n\n\t\t\t\tdata.rotation[i] *= Math.PI / 180;\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tobject.name = data.name;\n\n\t\t\tobject.position.fromArray(data.position);\n\t\t\tobject.quaternion.setFromEuler(new THREE.Euler().fromArray(data.rotation));\n\t\t\tobject.scale.fromArray(data.scale);\n\n\t\t\tdata._object = object;\n\t\t}\n\n\t\t//\n\n\t\tvar model = json.model;\n\n\t\tfor (var i = 0, l = model.vertices.length; i < l; i++) {\n\n\t\t\tparseVertices(model.vertices[i]);\n\t\t}\n\n\t\tfor (var i = 0, l = model.meshes.length; i < l; i++) {\n\n\t\t\tparseMeshes(model.meshes[i]);\n\t\t}\n\n\t\tfor (var i = 0, l = model.meshInstances.length; i < l; i++) {\n\n\t\t\tparseMeshInstances(model.meshInstances[i]);\n\t\t}\n\n\t\tfor (var i = 0, l = model.nodes.length; i < l; i++) {\n\n\t\t\tparseNodes(model.nodes[i]);\n\t\t}\n\n\t\t// setup scene hierarchy\n\n\t\tfor (var i = 0, l = model.parents.length; i < l; i++) {\n\n\t\t\tvar parent = model.parents[i];\n\n\t\t\tif (parent === -1) continue;\n\n\t\t\tmodel.nodes[parent]._object.add(model.nodes[i]._object);\n\t\t}\n\n\t\treturn model.nodes[0]._object;\n\t}\n\n};\n\nexports.default = PlayCanvasLoader;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Wei Meng / http://about.me/menway\n *\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new THREE.PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * ‚Äúdiffuse_(red|green|blue)‚Äù in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nvar PLYLoader = function PLYLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.propertyNameMapping = {};\n};\n\nPLYLoader.prototype = {\n\n\tconstructor: PLYLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetPropertyNameMapping: function setPropertyNameMapping(mapping) {\n\n\t\tthis.propertyNameMapping = mapping;\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction parseHeader(data) {\n\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\s/;\n\t\t\tvar headerText = '';\n\t\t\tvar headerLength = 0;\n\t\t\tvar result = patternHeader.exec(data);\n\n\t\t\tif (result !== null) {\n\n\t\t\t\theaderText = result[1];\n\t\t\t\theaderLength = result[0].length;\n\t\t\t}\n\n\t\t\tvar header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength\n\t\t\t};\n\n\t\t\tvar lines = headerText.split('\\n');\n\t\t\tvar currentElement;\n\t\t\tvar lineType, lineValues;\n\n\t\t\tfunction make_ply_element_property(propertValues, propertyNameMapping) {\n\n\t\t\t\tvar property = { type: propertValues[0] };\n\n\t\t\t\tif (property.type === 'list') {\n\n\t\t\t\t\tproperty.name = propertValues[3];\n\t\t\t\t\tproperty.countType = propertValues[1];\n\t\t\t\t\tproperty.itemType = propertValues[2];\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[1];\n\t\t\t\t}\n\n\t\t\t\tif (property.name in propertyNameMapping) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[property.name];\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\t\tvar line = lines[i];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif (line === '') continue;\n\n\t\t\t\tlineValues = line.split(/\\s+/);\n\t\t\t\tlineType = lineValues.shift();\n\t\t\t\tline = lineValues.join(' ');\n\n\t\t\t\tswitch (lineType) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[0];\n\t\t\t\t\t\theader.version = lineValues[1];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push(line);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif (currentElement !== undefined) {\n\n\t\t\t\t\t\t\theader.elements.push(currentElement);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[0];\n\t\t\t\t\t\tcurrentElement.count = parseInt(lineValues[1]);\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log('unhandled', lineType, lineValues);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentElement !== undefined) {\n\n\t\t\t\theader.elements.push(currentElement);\n\t\t\t}\n\n\t\t\treturn header;\n\t\t}\n\n\t\tfunction parseASCIINumber(n, type) {\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'char':case 'uchar':case 'short':case 'ushort':case 'int':case 'uint':\n\t\t\t\tcase 'int8':case 'uint8':case 'int16':case 'uint16':case 'int32':case 'uint32':\n\n\t\t\t\t\treturn parseInt(n);\n\n\t\t\t\tcase 'float':case 'double':case 'float32':case 'float64':\n\n\t\t\t\t\treturn parseFloat(n);\n\n\t\t\t}\n\t\t}\n\n\t\tfunction parseASCIIElement(properties, line) {\n\n\t\t\tvar values = line.split(/\\s+/);\n\n\t\t\tvar element = {};\n\n\t\t\tfor (var i = 0; i < properties.length; i++) {\n\n\t\t\t\tif (properties[i].type === 'list') {\n\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tvar n = parseASCIINumber(values.shift(), properties[i].countType);\n\n\t\t\t\t\tfor (var j = 0; j < n; j++) {\n\n\t\t\t\t\t\tlist.push(parseASCIINumber(values.shift(), properties[i].itemType));\n\t\t\t\t\t}\n\n\t\t\t\t\telement[properties[i].name] = list;\n\t\t\t\t} else {\n\n\t\t\t\t\telement[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction parseASCII(data, header) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar result;\n\n\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tvar body = '';\n\t\t\tif ((result = patternBody.exec(data)) !== null) {\n\n\t\t\t\tbody = result[1];\n\t\t\t}\n\n\t\t\tvar lines = body.split('\\n');\n\t\t\tvar currentElement = 0;\n\t\t\tvar currentElementCount = 0;\n\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\t\tvar line = lines[i];\n\t\t\t\tline = line.trim();\n\t\t\t\tif (line === '') {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (currentElementCount >= header.elements[currentElement].count) {\n\n\t\t\t\t\tcurrentElement++;\n\t\t\t\t\tcurrentElementCount = 0;\n\t\t\t\t}\n\n\t\t\t\tvar element = parseASCIIElement(header.elements[currentElement].properties, line);\n\n\t\t\t\thandleElement(buffer, header.elements[currentElement].name, element);\n\n\t\t\t\tcurrentElementCount++;\n\t\t\t}\n\n\t\t\treturn postProcess(buffer);\n\t\t}\n\n\t\tfunction postProcess(buffer) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif (buffer.indices.length > 0) {\n\n\t\t\t\tgeometry.setIndex(buffer.indices);\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(buffer.vertices, 3));\n\n\t\t\t// optional buffer data\n\n\t\t\tif (buffer.normals.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(buffer.normals, 3));\n\t\t\t}\n\n\t\t\tif (buffer.uvs.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(buffer.uvs, 2));\n\t\t\t}\n\n\t\t\tif (buffer.colors.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.Float32BufferAttribute(buffer.colors, 3));\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction handleElement(buffer, elementName, element) {\n\n\t\t\tif (elementName === 'vertex') {\n\n\t\t\t\tbuffer.vertices.push(element.x, element.y, element.z);\n\n\t\t\t\tif ('nx' in element && 'ny' in element && 'nz' in element) {\n\n\t\t\t\t\tbuffer.normals.push(element.nx, element.ny, element.nz);\n\t\t\t\t}\n\n\t\t\t\tif ('s' in element && 't' in element) {\n\n\t\t\t\t\tbuffer.uvs.push(element.s, element.t);\n\t\t\t\t}\n\n\t\t\t\tif ('red' in element && 'green' in element && 'blue' in element) {\n\n\t\t\t\t\tbuffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n\t\t\t\t}\n\t\t\t} else if (elementName === 'face') {\n\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n\t\t\t\tif (vertex_indices.length === 3) {\n\n\t\t\t\t\tbuffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n\t\t\t\t} else if (vertex_indices.length === 4) {\n\n\t\t\t\t\tbuffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n\t\t\t\t\tbuffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction binaryRead(dataview, at, type, little_endian) {\n\n\t\t\tswitch (type) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':case 'char':\n\t\t\t\t\treturn [dataview.getInt8(at), 1];\n\t\t\t\tcase 'uint8':case 'uchar':\n\t\t\t\t\treturn [dataview.getUint8(at), 1];\n\t\t\t\tcase 'int16':case 'short':\n\t\t\t\t\treturn [dataview.getInt16(at, little_endian), 2];\n\t\t\t\tcase 'uint16':case 'ushort':\n\t\t\t\t\treturn [dataview.getUint16(at, little_endian), 2];\n\t\t\t\tcase 'int32':case 'int':\n\t\t\t\t\treturn [dataview.getInt32(at, little_endian), 4];\n\t\t\t\tcase 'uint32':case 'uint':\n\t\t\t\t\treturn [dataview.getUint32(at, little_endian), 4];\n\t\t\t\tcase 'float32':case 'float':\n\t\t\t\t\treturn [dataview.getFloat32(at, little_endian), 4];\n\t\t\t\tcase 'float64':case 'double':\n\t\t\t\t\treturn [dataview.getFloat64(at, little_endian), 8];\n\n\t\t\t}\n\t\t}\n\n\t\tfunction binaryReadElement(dataview, at, properties, little_endian) {\n\n\t\t\tvar element = {};\n\t\t\tvar result,\n\t\t\t    read = 0;\n\n\t\t\tfor (var i = 0; i < properties.length; i++) {\n\n\t\t\t\tif (properties[i].type === 'list') {\n\n\t\t\t\t\tvar list = [];\n\n\t\t\t\t\tresult = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n\t\t\t\t\tvar n = result[0];\n\t\t\t\t\tread += result[1];\n\n\t\t\t\t\tfor (var j = 0; j < n; j++) {\n\n\t\t\t\t\t\tresult = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n\t\t\t\t\t\tlist.push(result[0]);\n\t\t\t\t\t\tread += result[1];\n\t\t\t\t\t}\n\n\t\t\t\t\telement[properties[i].name] = list;\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead(dataview, at + read, properties[i].type, little_endian);\n\t\t\t\t\telement[properties[i].name] = result[0];\n\t\t\t\t\tread += result[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [element, read];\n\t\t}\n\n\t\tfunction parseBinary(data, header) {\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar little_endian = header.format === 'binary_little_endian';\n\t\t\tvar body = new DataView(data, header.headerLength);\n\t\t\tvar result,\n\t\t\t    loc = 0;\n\n\t\t\tfor (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n\n\t\t\t\tfor (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n\n\t\t\t\t\tresult = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n\t\t\t\t\tloc += result[1];\n\t\t\t\t\tvar element = result[0];\n\n\t\t\t\t\thandleElement(buffer, header.elements[currentElement].name, element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn postProcess(buffer);\n\t\t}\n\n\t\t//\n\n\t\tvar geometry;\n\t\tvar scope = this;\n\n\t\tif (data instanceof ArrayBuffer) {\n\n\t\t\tvar text = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n\t\t\tvar header = parseHeader(text);\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n\t\t} else {\n\n\t\t\tgeometry = parseASCII(data, parseHeader(data));\n\t\t}\n\n\t\treturn geometry;\n\t}\n\n};\n\nexports.default = PLYLoader;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Kevin Chapelier / https://github.com/kchapelier\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nexports.default = function () {\n\n\t'use strict';\n\n\tvar bigEndianPlatform = null;\n\n\t/**\n  * Check if the endianness of the platform is big-endian (most significant bit first)\n  * @returns {boolean} True if big-endian, false if little-endian\n  */\n\tfunction isBigEndianPlatform() {\n\n\t\tif (bigEndianPlatform === null) {\n\n\t\t\tvar buffer = new ArrayBuffer(2),\n\t\t\t    uint8Array = new Uint8Array(buffer),\n\t\t\t    uint16Array = new Uint16Array(buffer);\n\n\t\t\tuint8Array[0] = 0xAA; // set first byte\n\t\t\tuint8Array[1] = 0xBB; // set second byte\n\t\t\tbigEndianPlatform = uint16Array[0] === 0xAABB;\n\t\t}\n\n\t\treturn bigEndianPlatform;\n\t}\n\n\t// match the values defined in the spec to the TypedArray types\n\tvar InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array];\n\n\t// define the method to use on a DataView, corresponding the TypedArray type\n\tvar getMethods = {\n\t\tUint16Array: 'getUint16',\n\t\tUint32Array: 'getUint32',\n\t\tInt16Array: 'getInt16',\n\t\tInt32Array: 'getInt32',\n\t\tFloat32Array: 'getFloat32',\n\t\tFloat64Array: 'getFloat64'\n\t};\n\n\tfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n\n\t\tvar bytesPerElement = viewType.BYTES_PER_ELEMENT,\n\t\t    result;\n\n\t\tif (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n\n\t\t\tresult = new viewType(sourceArrayBuffer, position, length);\n\t\t} else {\n\n\t\t\tvar readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n\t\t\t    getMethod = getMethods[viewType.name],\n\t\t\t    littleEndian = !fromBigEndian,\n\t\t\t    i = 0;\n\n\t\t\tresult = new viewType(length);\n\n\t\t\tfor (; i < length; i++) {\n\n\t\t\t\tresult[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction decodePrwm(buffer) {\n\n\t\tvar array = new Uint8Array(buffer),\n\t\t    version = array[0],\n\t\t    flags = array[1],\n\t\t    indexedGeometry = !!(flags >> 7 & 0x01),\n\t\t    indicesType = flags >> 6 & 0x01,\n\t\t    bigEndian = (flags >> 5 & 0x01) === 1,\n\t\t    attributesNumber = flags & 0x1F,\n\t\t    valuesNumber = 0,\n\t\t    indicesNumber = 0;\n\n\t\tif (bigEndian) {\n\n\t\t\tvaluesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n\t\t\tindicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n\t\t} else {\n\n\t\t\tvaluesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n\t\t\tindicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n\t\t}\n\n\t\t/** PRELIMINARY CHECKS **/\n\n\t\tif (version === 0) {\n\n\t\t\tthrow new Error('PRWM decoder: Invalid format version: 0');\n\t\t} else if (version !== 1) {\n\n\t\t\tthrow new Error('PRWM decoder: Unsupported format version: ' + version);\n\t\t}\n\n\t\tif (!indexedGeometry) {\n\n\t\t\tif (indicesType !== 0) {\n\n\t\t\t\tthrow new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n\t\t\t} else if (indicesNumber !== 0) {\n\n\t\t\t\tthrow new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n\t\t\t}\n\t\t}\n\n\t\t/** PARSING **/\n\n\t\tvar pos = 8;\n\n\t\tvar attributes = {},\n\t\t    attributeName,\n\t\t    char,\n\t\t    attributeType,\n\t\t    cardinality,\n\t\t    encodingType,\n\t\t    arrayType,\n\t\t    values,\n\t\t    indices,\n\t\t    i;\n\n\t\tfor (i = 0; i < attributesNumber; i++) {\n\n\t\t\tattributeName = '';\n\n\t\t\twhile (pos < array.length) {\n\n\t\t\t\tchar = array[pos];\n\t\t\t\tpos++;\n\n\t\t\t\tif (char === 0) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\n\t\t\t\t\tattributeName += String.fromCharCode(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflags = array[pos];\n\n\t\t\tattributeType = flags >> 7 & 0x01;\n\t\t\tcardinality = (flags >> 4 & 0x03) + 1;\n\t\t\tencodingType = flags & 0x0F;\n\t\t\tarrayType = InvertedEncodingTypes[encodingType];\n\n\t\t\tpos++;\n\n\t\t\t// padding to next multiple of 4\n\t\t\tpos = Math.ceil(pos / 4) * 4;\n\n\t\t\tvalues = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n\n\t\t\tpos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n\n\t\t\tattributes[attributeName] = {\n\t\t\t\ttype: attributeType,\n\t\t\t\tcardinality: cardinality,\n\t\t\t\tvalues: values\n\t\t\t};\n\t\t}\n\n\t\tpos = Math.ceil(pos / 4) * 4;\n\n\t\tindices = null;\n\n\t\tif (indexedGeometry) {\n\n\t\t\tindices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n\t\t}\n\n\t\treturn {\n\t\t\tversion: version,\n\t\t\tattributes: attributes,\n\t\t\tindices: indices\n\t\t};\n\t}\n\n\t// Define the public interface\n\n\tvar PRWMLoader = function PRWMLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t};\n\n\tPRWMLoader.prototype = {\n\n\t\tconstructor: PRWMLoader,\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\n\t\t\turl = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n\n\t\t\tloader.load(url, function (arrayBuffer) {\n\n\t\t\t\tonLoad(scope.parse(arrayBuffer));\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tparse: function parse(arrayBuffer) {\n\n\t\t\tconsole.time('PRWMLoader');\n\n\t\t\tvar data = decodePrwm(arrayBuffer),\n\t\t\t    attributesKey = Object.keys(data.attributes),\n\t\t\t    bufferGeometry = new THREE.BufferGeometry(),\n\t\t\t    attribute,\n\t\t\t    i;\n\n\t\t\tfor (i = 0; i < attributesKey.length; i++) {\n\n\t\t\t\tattribute = data.attributes[attributesKey[i]];\n\t\t\t\tbufferGeometry.addAttribute(attributesKey[i], new THREE.BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n\t\t\t}\n\n\t\t\tif (data.indices !== null) {\n\n\t\t\t\tbufferGeometry.setIndex(new THREE.BufferAttribute(data.indices, 1));\n\t\t\t}\n\n\t\t\tconsole.timeEnd('PRWMLoader');\n\n\t\t\treturn bufferGeometry;\n\t\t}\n\n\t};\n\n\tPRWMLoader.isBigEndianPlatform = function () {\n\n\t\treturn isBigEndianPlatform();\n\t};\n\n\treturn PRWMLoader;\n}();\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n *\t PVRLoader\n *   Author: pierre lepers\n *   Date: 17/09/2014 11:09\n *\n *\t PVR v2 (legacy) parser\n *   TODO : Add Support for PVR v3 format\n *   TODO : implement loadMipmaps option\n */\n\nvar PVRLoader = function PVRLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis._parser = PVRLoader.parse;\n};\n\nPVRLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);\nPVRLoader.prototype.constructor = PVRLoader;\n\nPVRLoader.parse = function (buffer, loadMipmaps) {\n\n\tvar headerLengthInt = 13;\n\tvar header = new Uint32Array(buffer, 0, headerLengthInt);\n\n\tvar pvrDatas = {\n\t\tbuffer: buffer,\n\t\theader: header,\n\t\tloadMipmaps: loadMipmaps\n\t};\n\n\tif (header[0] === 0x03525650) {\n\n\t\t// PVR v3\n\n\t\treturn PVRLoader._parseV3(pvrDatas);\n\t} else if (header[11] === 0x21525650) {\n\n\t\t// PVR v2\n\n\t\treturn PVRLoader._parseV2(pvrDatas);\n\t} else {\n\n\t\tconsole.error('THREE.PVRLoader: Unknown PVR format.');\n\t}\n};\n\nPVRLoader._parseV3 = function (pvrDatas) {\n\n\tvar header = pvrDatas.header;\n\tvar bpp, format;\n\n\tvar metaLen = header[12],\n\t    pixelFormat = header[2],\n\t    height = header[6],\n\t    width = header[7],\n\n\t// numSurfs = header[ 9 ],\n\tnumFaces = header[10],\n\t    numMipmaps = header[11];\n\n\tswitch (pixelFormat) {\n\n\t\tcase 0:\n\t\t\t// PVRTC 2bpp RGB\n\t\t\tbpp = 2;\n\t\t\tformat = THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t// PVRTC 2bpp RGBA\n\t\t\tbpp = 2;\n\t\t\tformat = THREE.RGBA_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t// PVRTC 4bpp RGB\n\t\t\tbpp = 4;\n\t\t\tformat = THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t// PVRTC 4bpp RGBA\n\t\t\tbpp = 4;\n\t\t\tformat = THREE.RGBA_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat);\n\n\t}\n\n\tpvrDatas.dataPtr = 52 + metaLen;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numFaces;\n\tpvrDatas.numMipmaps = numMipmaps;\n\tpvrDatas.isCubemap = numFaces === 6;\n\n\treturn PVRLoader._extract(pvrDatas);\n};\n\nPVRLoader._parseV2 = function (pvrDatas) {\n\n\tvar header = pvrDatas.header;\n\n\tvar headerLength = header[0],\n\t    height = header[1],\n\t    width = header[2],\n\t    numMipmaps = header[3],\n\t    flags = header[4],\n\n\t// dataLength = header[ 5 ],\n\t// bpp =  header[ 6 ],\n\t// bitmaskRed = header[ 7 ],\n\t// bitmaskGreen = header[ 8 ],\n\t// bitmaskBlue = header[ 9 ],\n\tbitmaskAlpha = header[10],\n\n\t// pvrTag = header[ 11 ],\n\tnumSurfs = header[12];\n\n\tvar TYPE_MASK = 0xff;\n\tvar PVRTC_2 = 24,\n\t    PVRTC_4 = 25;\n\n\tvar formatFlags = flags & TYPE_MASK;\n\n\tvar bpp, format;\n\tvar _hasAlpha = bitmaskAlpha > 0;\n\n\tif (formatFlags === PVRTC_4) {\n\n\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;\n\t\tbpp = 4;\n\t} else if (formatFlags === PVRTC_2) {\n\n\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;\n\t\tbpp = 2;\n\t} else {\n\n\t\tconsole.error('THREE.PVRLoader: Unknown PVR format:', formatFlags);\n\t}\n\n\tpvrDatas.dataPtr = headerLength;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numSurfs;\n\tpvrDatas.numMipmaps = numMipmaps + 1;\n\n\t// guess cubemap type seems tricky in v2\n\t// it juste a pvr containing 6 surface (no explicit cubemap type)\n\tpvrDatas.isCubemap = numSurfs === 6;\n\n\treturn PVRLoader._extract(pvrDatas);\n};\n\nPVRLoader._extract = function (pvrDatas) {\n\n\tvar pvr = {\n\t\tmipmaps: [],\n\t\twidth: pvrDatas.width,\n\t\theight: pvrDatas.height,\n\t\tformat: pvrDatas.format,\n\t\tmipmapCount: pvrDatas.numMipmaps,\n\t\tisCubemap: pvrDatas.isCubemap\n\t};\n\n\tvar buffer = pvrDatas.buffer;\n\n\tvar dataOffset = pvrDatas.dataPtr,\n\t    bpp = pvrDatas.bpp,\n\t    numSurfs = pvrDatas.numSurfaces,\n\t    dataSize = 0,\n\t    blockSize = 0,\n\t    blockWidth = 0,\n\t    blockHeight = 0,\n\t    widthBlocks = 0,\n\t    heightBlocks = 0;\n\n\tif (bpp === 2) {\n\n\t\tblockWidth = 8;\n\t\tblockHeight = 4;\n\t} else {\n\n\t\tblockWidth = 4;\n\t\tblockHeight = 4;\n\t}\n\n\tblockSize = blockWidth * blockHeight * bpp / 8;\n\n\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n\n\tvar mipLevel = 0;\n\n\twhile (mipLevel < pvrDatas.numMipmaps) {\n\n\t\tvar sWidth = pvrDatas.width >> mipLevel,\n\t\t    sHeight = pvrDatas.height >> mipLevel;\n\n\t\twidthBlocks = sWidth / blockWidth;\n\t\theightBlocks = sHeight / blockHeight;\n\n\t\t// Clamp to minimum number of blocks\n\t\tif (widthBlocks < 2) widthBlocks = 2;\n\t\tif (heightBlocks < 2) heightBlocks = 2;\n\n\t\tdataSize = widthBlocks * heightBlocks * blockSize;\n\n\t\tfor (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {\n\n\t\t\tvar byteArray = new Uint8Array(buffer, dataOffset, dataSize);\n\n\t\t\tvar mipmap = {\n\t\t\t\tdata: byteArray,\n\t\t\t\twidth: sWidth,\n\t\t\t\theight: sHeight\n\t\t\t};\n\n\t\t\tpvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;\n\n\t\t\tdataOffset += dataSize;\n\t\t}\n\n\t\tmipLevel++;\n\t}\n\n\treturn pvr;\n};\n\nexports.default = PVRLoader;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\n\nvar STLLoader = function STLLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nSTLLoader.prototype = {\n\n\tconstructor: STLLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad(scope.parse(text));\n\t\t\t} catch (exception) {\n\n\t\t\t\tif (onError) {\n\n\t\t\t\t\tonError(exception);\n\t\t\t\t}\n\t\t\t}\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction isBinary(data) {\n\n\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\treader = new DataView(data);\n\t\t\tface_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n\t\t\tn_faces = reader.getUint32(80, true);\n\t\t\texpect = 80 + 32 / 8 + n_faces * face_size;\n\n\t\t\tif (expect === reader.byteLength) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tvar solid = [115, 111, 108, 105, 100];\n\n\t\t\tfor (var i = 0; i < 5; i++) {\n\n\t\t\t\t// If solid[ i ] does not match the i-th byte, then it is not an\n\t\t\t\t// ASCII STL; hence, it is binary and return true.\n\n\t\t\t\tif (solid[i] != reader.getUint8(i, false)) return true;\n\t\t\t}\n\n\t\t\t// First 5 bytes read \"solid\"; declare it to be an ASCII STL\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction parseBinary(data) {\n\n\t\t\tvar reader = new DataView(data);\n\t\t\tvar faces = reader.getUint32(80, true);\n\n\t\t\tvar r,\n\t\t\t    g,\n\t\t\t    b,\n\t\t\t    hasColors = false,\n\t\t\t    colors;\n\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor (var index = 0; index < 80 - 10; index++) {\n\n\t\t\t\tif (reader.getUint32(index, false) == 0x434F4C4F /*COLO*/ && reader.getUint8(index + 4) == 0x52 /*'R'*/ && reader.getUint8(index + 5) == 0x3D /*'='*/) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = [];\n\n\t\t\t\t\tdefaultR = reader.getUint8(index + 6) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8(index + 7) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8(index + 8) / 255;\n\t\t\t\t\talpha = reader.getUint8(index + 9) / 255;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dataOffset = 84;\n\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\n\t\t\tfor (var face = 0; face < faces; face++) {\n\n\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\tvar normalX = reader.getFloat32(start, true);\n\t\t\t\tvar normalY = reader.getFloat32(start + 4, true);\n\t\t\t\tvar normalZ = reader.getFloat32(start + 8, true);\n\n\t\t\t\tif (hasColors) {\n\n\t\t\t\t\tvar packedColor = reader.getUint16(start + 48, true);\n\n\t\t\t\t\tif ((packedColor & 0x8000) === 0) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = (packedColor & 0x1F) / 31;\n\t\t\t\t\t\tg = (packedColor >> 5 & 0x1F) / 31;\n\t\t\t\t\t\tb = (packedColor >> 10 & 0x1F) / 31;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 1; i <= 3; i++) {\n\n\t\t\t\t\tvar vertexstart = start + i * 12;\n\n\t\t\t\t\tvertices.push(reader.getFloat32(vertexstart, true));\n\t\t\t\t\tvertices.push(reader.getFloat32(vertexstart + 4, true));\n\t\t\t\t\tvertices.push(reader.getFloat32(vertexstart + 8, true));\n\n\t\t\t\t\tnormals.push(normalX, normalY, normalZ);\n\n\t\t\t\t\tif (hasColors) {\n\n\t\t\t\t\t\tcolors.push(r, g, b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));\n\n\t\t\tif (hasColors) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseASCII(data) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tvar faceCounter = 0;\n\n\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tvar patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\n\t\t\tvar patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\n\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\n\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\tvar result;\n\n\t\t\twhile ((result = patternFace.exec(data)) !== null) {\n\n\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\tvar text = result[0];\n\n\t\t\t\twhile ((result = patternNormal.exec(text)) !== null) {\n\n\t\t\t\t\tnormal.x = parseFloat(result[1]);\n\t\t\t\t\tnormal.y = parseFloat(result[2]);\n\t\t\t\t\tnormal.z = parseFloat(result[3]);\n\t\t\t\t\tnormalCountPerFace++;\n\t\t\t\t}\n\n\t\t\t\twhile ((result = patternVertex.exec(text)) !== null) {\n\n\t\t\t\t\tvertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z);\n\t\t\t\t\tvertexCountPerFace++;\n\t\t\t\t}\n\n\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\tif (normalCountPerFace !== 1) {\n\n\t\t\t\t\tconsole.error('THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter);\n\t\t\t\t}\n\n\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\tif (vertexCountPerFace !== 3) {\n\n\t\t\t\t\tconsole.error('THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter);\n\t\t\t\t}\n\n\t\t\t\tfaceCounter++;\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction ensureString(buffer) {\n\n\t\t\tif (typeof buffer !== 'string') {\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(buffer));\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t}\n\n\t\tfunction ensureBinary(buffer) {\n\n\t\t\tif (typeof buffer === 'string') {\n\n\t\t\t\tvar array_buffer = new Uint8Array(buffer.length);\n\t\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\n\t\t\t\t\tarray_buffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n\t\t\t\t}\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\n\t\t// start\n\n\t\tvar binData = ensureBinary(data);\n\n\t\treturn isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\n\t}\n\n};\n\nexports.default = STLLoader;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author zz85 / http://joshuakoo.com/\n */\n\nvar SVGLoader = function SVGLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nSVGLoader.prototype = {\n\n\tconstructor: SVGLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(text) {\n\n\t\tfunction parseNode(node, style) {\n\n\t\t\tif (node.nodeType !== 1) return;\n\n\t\t\tswitch (node.nodeName) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (node.hasAttribute('d') && isVisible(style)) paths.push(parsePathNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseRectNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parsePolygonNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parsePolylineNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseCircleNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseEllipseNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseLineNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(node);\n\n\t\t\t}\n\n\t\t\tvar nodes = node.childNodes;\n\n\t\t\tfor (var i = 0; i < nodes.length; i++) {\n\n\t\t\t\tparseNode(nodes[i], style);\n\t\t\t}\n\t\t}\n\n\t\tfunction parsePathNode(node, style) {\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\n\t\t\tvar point = new THREE.Vector2();\n\t\t\tvar control = new THREE.Vector2();\n\n\t\t\tvar d = node.getAttribute('d');\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match(/[a-df-z][^a-df-z]*/ig);\n\n\t\t\tfor (var i = 0, l = commands.length; i < l; i++) {\n\n\t\t\t\tvar command = commands[i];\n\n\t\t\t\tvar type = command.charAt(0);\n\t\t\t\tvar data = command.substr(1).trim();\n\n\t\t\t\tswitch (type) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x = numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.moveTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.x = numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.y = numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x = numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 6) {\n\t\t\t\t\t\t\tpath.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n\t\t\t\t\t\t\tcontrol.x = numbers[j + 2];\n\t\t\t\t\t\t\tcontrol.y = numbers[j + 3];\n\t\t\t\t\t\t\tpoint.x = numbers[j + 4];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 5];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[0], numbers[1], numbers[2], numbers[3]);\n\t\t\t\t\t\tcontrol.x = numbers[0];\n\t\t\t\t\t\tcontrol.y = numbers[1];\n\t\t\t\t\t\tpoint.x = numbers[2];\n\t\t\t\t\t\tpoint.y = numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.quadraticCurveTo(numbers[0], numbers[1], numbers[2], numbers[3]);\n\t\t\t\t\t\tcontrol.x = numbers[0];\n\t\t\t\t\t\tcontrol.y = numbers[1];\n\t\t\t\t\t\tpoint.x = numbers[2];\n\t\t\t\t\t\tpoint.y = numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tvar rx = getReflection(point.x, control.x);\n\t\t\t\t\t\tvar ry = getReflection(point.y, control.y);\n\t\t\t\t\t\tpath.quadraticCurveTo(rx, ry, numbers[0], numbers[1]);\n\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\tpoint.x = numbers[0];\n\t\t\t\t\t\tpoint.y = numbers[1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 7) {\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[j + 5];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 6];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x += numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.moveTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.x += numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.y += numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x += numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 6) {\n\t\t\t\t\t\t\tpath.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n\t\t\t\t\t\t\tpoint.x += numbers[j + 4];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 5];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t// TODO: Not sure if point needs\n\t\t\t\t\t\t// to be added to reflection...\n\t\t\t\t\t\tgetReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[0], point.y + numbers[1], point.x + numbers[2], point.y + numbers[3]);\n\t\t\t\t\t\tcontrol.x = point.x + numbers[0];\n\t\t\t\t\t\tcontrol.y = point.y + numbers[1];\n\t\t\t\t\t\tpoint.x += numbers[2];\n\t\t\t\t\t\tpoint.y += numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.quadraticCurveTo(point.x + numbers[0], point.y + numbers[1], point.x + numbers[2], point.y + numbers[3]);\n\t\t\t\t\t\tcontrol.x = point.x + numbers[0];\n\t\t\t\t\t\tcontrol.y = point.y + numbers[1];\n\t\t\t\t\t\tpoint.x += numbers[2];\n\t\t\t\t\t\tpoint.y += numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tvar rx = getReflection(point.x, control.x);\n\t\t\t\t\t\tvar ry = getReflection(point.y, control.y);\n\t\t\t\t\t\tpath.quadraticCurveTo(rx, ry, point.x + numbers[0], point.y + numbers[1]);\n\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\tpoint.x = point.x + numbers[0];\n\t\t\t\t\t\tpoint.y = point.y + numbers[1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 7) {\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[j + 5];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 6];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn(command);\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\t\t\t}\n\n\t\t\treturn path;\n\t\t}\n\n\t\t/**\n   * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n   * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n   * From\n   * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n   * To\n   * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n   */\n\n\t\tfunction parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs(rx);\n\t\t\try = Math.abs(ry);\n\n\t\t\t// Compute (x1‚Ä≤, y1‚Ä≤)\n\t\t\tvar dx2 = (start.x - end.x) / 2.0;\n\t\t\tvar dy2 = (start.y - end.y) / 2.0;\n\t\t\tvar x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n\t\t\tvar y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n\n\t\t\t// Compute (cx‚Ä≤, cy‚Ä≤)\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif (cr > 1) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt(cr);\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\t\t\t}\n\n\t\t\tvar dq = rxs * y1ps + rys * x1ps;\n\t\t\tvar pq = (rxs * rys - dq) / dq;\n\t\t\tvar q = Math.sqrt(Math.max(0, pq));\n\t\t\tif (large_arc_flag === sweep_flag) q = -q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = -q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx‚Ä≤, cy‚Ä≤)\n\t\t\tvar cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n\t\t\tvar cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n\n\t\t\t// Step 4: Compute Œ∏1 and ŒîŒ∏\n\t\t\tvar theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n\t\t\tvar delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n\n\t\t\tpath.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n\t\t}\n\n\t\tfunction svgAngle(ux, uy, vx, vy) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\t\t\tvar ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\t\t\tif (ux * vy - uy * vx < 0) ang = -ang;\n\t\t\treturn ang;\n\t\t}\n\n\t\t/*\n  * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n  * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n  */\n\t\tfunction parseRectNode(node, style) {\n\n\t\t\tvar x = parseFloat(node.getAttribute('x') || 0);\n\t\t\tvar y = parseFloat(node.getAttribute('y') || 0);\n\t\t\tvar rx = parseFloat(node.getAttribute('rx') || 0);\n\t\t\tvar ry = parseFloat(node.getAttribute('ry') || 0);\n\t\t\tvar w = parseFloat(node.getAttribute('width'));\n\t\t\tvar h = parseFloat(node.getAttribute('height'));\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\t\t\tpath.moveTo(x + 2 * rx, y);\n\t\t\tpath.lineTo(x + w - 2 * rx, y);\n\t\t\tif (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n\t\t\tpath.lineTo(x + w, y + h - 2 * ry);\n\t\t\tif (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n\t\t\tpath.lineTo(x + 2 * rx, y + h);\n\n\t\t\tif (rx !== 0 || ry !== 0) {\n\n\t\t\t\tpath.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n\t\t\t\tpath.lineTo(x, y + 2 * ry);\n\t\t\t\tpath.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n\t\t\t}\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parsePolygonNode(node, style) {\n\n\t\t\tfunction iterator(match, a, b) {\n\n\t\t\t\tvar x = parseFloat(a);\n\t\t\t\tvar y = parseFloat(b);\n\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tpath.moveTo(x, y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(x, y);\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute('points').replace(regex, iterator);\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parsePolylineNode(node, style) {\n\n\t\t\tfunction iterator(match, a, b) {\n\n\t\t\t\tvar x = parseFloat(a);\n\t\t\t\tvar y = parseFloat(b);\n\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tpath.moveTo(x, y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(x, y);\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute('points').replace(regex, iterator);\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parseCircleNode(node, style) {\n\n\t\t\tvar x = parseFloat(node.getAttribute('cx'));\n\t\t\tvar y = parseFloat(node.getAttribute('cy'));\n\t\t\tvar r = parseFloat(node.getAttribute('r'));\n\n\t\t\tvar subpath = new THREE.Path();\n\t\t\tsubpath.absarc(x, y, r, 0, Math.PI * 2);\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\t\t\tpath.subPaths.push(subpath);\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parseEllipseNode(node, style) {\n\n\t\t\tvar x = parseFloat(node.getAttribute('cx'));\n\t\t\tvar y = parseFloat(node.getAttribute('cy'));\n\t\t\tvar rx = parseFloat(node.getAttribute('rx'));\n\t\t\tvar ry = parseFloat(node.getAttribute('ry'));\n\n\t\t\tvar subpath = new THREE.Path();\n\t\t\tsubpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\t\t\tpath.subPaths.push(subpath);\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parseLineNode(node, style) {\n\n\t\t\tvar x1 = parseFloat(node.getAttribute('x1'));\n\t\t\tvar y1 = parseFloat(node.getAttribute('y1'));\n\t\t\tvar x2 = parseFloat(node.getAttribute('x2'));\n\t\t\tvar y2 = parseFloat(node.getAttribute('y2'));\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.moveTo(x1, y1);\n\t\t\tpath.lineTo(x2, y2);\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle(node, style) {\n\n\t\t\tstyle = Object.assign({}, style); // clone style\n\n\t\t\tif (node.hasAttribute('fill')) style.fill = node.getAttribute('fill');\n\t\t\tif (node.style.fill !== '') style.fill = node.style.fill;\n\n\t\t\treturn style;\n\t\t}\n\n\t\tfunction isVisible(style) {\n\n\t\t\treturn style.fill !== 'none' && style.fill !== 'transparent';\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection(a, b) {\n\n\t\t\treturn 2 * a - (b - a);\n\t\t}\n\n\t\tfunction parseFloats(string) {\n\n\t\t\tvar array = string.split(/[\\s,]+|(?=\\s?[+\\-])/);\n\n\t\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\t\tarray[i] = parseFloat(array[i]);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\t//\n\n\t\tconsole.log('THREE.SVGLoader');\n\n\t\tvar paths = [];\n\n\t\tconsole.time('THREE.SVGLoader: DOMParser');\n\n\t\tvar xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n\t\tconsole.timeEnd('THREE.SVGLoader: DOMParser');\n\n\t\tconsole.time('THREE.SVGLoader: Parse');\n\n\t\tparseNode(xml.documentElement, { fill: '#000' });\n\n\t\t// console.log( paths );\n\n\t\tconsole.timeEnd('THREE.SVGLoader: Parse');\n\n\t\treturn paths;\n\t}\n\n};\n\nexports.default = SVGLoader;\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * Autodesk 3DS threee.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @author @tentone\n * @author @timknip\n * @class TDSLoader\n * @constructor\n */\n\n'use strict';\n\nvar TDSLoader = function TDSLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.debug = false;\n\n\tthis.group = null;\n\tthis.position = 0;\n\n\tthis.materials = [];\n\tthis.meshes = [];\n};\n\nTDSLoader.prototype = {\n\n\tconstructor: TDSLoader,\n\n\t/**\n  * Load 3ds file from url.\n  *\n  * @method load\n  * @param {[type]} url URL for the file.\n  * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n  * @param {Function} onProgress onProgress callback.\n  * @param {Function} onError onError callback.\n  */\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\n\t\tloader.setResponseType('arraybuffer');\n\n\t\tloader.load(url, function (data) {\n\n\t\t\tonLoad(scope.parse(data, path));\n\t\t}, onProgress, onError);\n\t},\n\n\t/**\n  * Parse arraybuffer data and load 3ds file.\n  *\n  * @method parse\n  * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n  * @param {String} path Path for external resources.\n  * @return {Object3D} Group loaded from 3ds file.\n  */\n\tparse: function parse(arraybuffer, path) {\n\n\t\tthis.group = new THREE.Group();\n\t\tthis.position = 0;\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t\tthis.readFile(arraybuffer, path);\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.group.add(this.meshes[i]);\n\t\t}\n\n\t\treturn this.group;\n\t},\n\n\t/**\n  * Decode file content to read 3ds data.\n  *\n  * @method readFile\n  * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n  */\n\treadFile: function readFile(arraybuffer, path) {\n\n\t\tvar data = new DataView(arraybuffer);\n\t\tvar chunk = this.readChunk(data);\n\n\t\tif (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n\n\t\t\tvar next = this.nextChunk(data, chunk);\n\n\t\t\twhile (next !== 0) {\n\n\t\t\t\tif (next === M3D_VERSION) {\n\n\t\t\t\t\tvar version = this.readDWord(data);\n\t\t\t\t\tthis.debugMessage('3DS file version: ' + version);\n\t\t\t\t} else if (next === MDATA) {\n\n\t\t\t\t\tthis.resetPosition(data);\n\t\t\t\t\tthis.readMeshData(data, path);\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage('Unknown main chunk: ' + next.toString(16));\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk(data, chunk);\n\t\t\t}\n\t\t}\n\n\t\tthis.debugMessage('Parsed ' + this.meshes.length + ' meshes');\n\t},\n\n\t/**\n  * Read mesh data chunk.\n  *\n  * @method readMeshData\n  * @param {Dataview} data Dataview in use.\n  */\n\treadMeshData: function readMeshData(data, path) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === MESH_VERSION) {\n\n\t\t\t\tvar version = +this.readDWord(data);\n\t\t\t\tthis.debugMessage('Mesh Version: ' + version);\n\t\t\t} else if (next === MASTER_SCALE) {\n\n\t\t\t\tvar scale = this.readFloat(data);\n\t\t\t\tthis.debugMessage('Master scale: ' + scale);\n\t\t\t\tthis.group.scale.set(scale, scale, scale);\n\t\t\t} else if (next === NAMED_OBJECT) {\n\n\t\t\t\tthis.debugMessage('Named Object');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tthis.readNamedObject(data);\n\t\t\t} else if (next === MAT_ENTRY) {\n\n\t\t\t\tthis.debugMessage('Material');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tthis.readMaterialEntry(data, path);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('Unknown MDATA chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\t},\n\n\t/**\n  * Read named object chunk.\n  *\n  * @method readNamedObject\n  * @param {Dataview} data Dataview in use.\n  */\n\treadNamedObject: function readNamedObject(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar name = this.readString(data, 64);\n\t\tchunk.cur = this.position;\n\n\t\tvar next = this.nextChunk(data, chunk);\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === N_TRI_OBJECT) {\n\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tvar mesh = this.readMesh(data);\n\t\t\t\tmesh.name = name;\n\t\t\t\tthis.meshes.push(mesh);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('Unknown named object chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\t},\n\n\t/**\n  * Read material data chunk and add it to the material list.\n  *\n  * @method readMaterialEntry\n  * @param {Dataview} data Dataview in use.\n  */\n\treadMaterialEntry: function readMaterialEntry(data, path) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === MAT_NAME) {\n\n\t\t\t\tmaterial.name = this.readString(data, 64);\n\t\t\t\tthis.debugMessage('   Name: ' + material.name);\n\t\t\t} else if (next === MAT_WIRE) {\n\n\t\t\t\tthis.debugMessage('   Wireframe');\n\t\t\t\tmaterial.wireframe = true;\n\t\t\t} else if (next === MAT_WIRE_SIZE) {\n\n\t\t\t\tvar value = this.readByte(data);\n\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\tthis.debugMessage('   Wireframe Thickness: ' + value);\n\t\t\t} else if (next === MAT_TWO_SIDE) {\n\n\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t\tthis.debugMessage('   DoubleSided');\n\t\t\t} else if (next === MAT_ADDITIVE) {\n\n\t\t\t\tthis.debugMessage('   Additive Blending');\n\t\t\t\tmaterial.blending = THREE.AdditiveBlending;\n\t\t\t} else if (next === MAT_DIFFUSE) {\n\n\t\t\t\tthis.debugMessage('   Diffuse Color');\n\t\t\t\tmaterial.color = this.readColor(data);\n\t\t\t} else if (next === MAT_SPECULAR) {\n\n\t\t\t\tthis.debugMessage('   Specular Color');\n\t\t\t\tmaterial.specular = this.readColor(data);\n\t\t\t} else if (next === MAT_AMBIENT) {\n\n\t\t\t\tthis.debugMessage('   Ambient color');\n\t\t\t\tmaterial.color = this.readColor(data);\n\t\t\t} else if (next === MAT_SHININESS) {\n\n\t\t\t\tvar shininess = this.readWord(data);\n\t\t\t\tmaterial.shininess = shininess;\n\t\t\t\tthis.debugMessage('   Shininess : ' + shininess);\n\t\t\t} else if (next === MAT_TEXMAP) {\n\n\t\t\t\tthis.debugMessage('   ColorMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.map = this.readMap(data, path);\n\t\t\t} else if (next === MAT_BUMPMAP) {\n\n\t\t\t\tthis.debugMessage('   BumpMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.bumpMap = this.readMap(data, path);\n\t\t\t} else if (next === MAT_OPACMAP) {\n\n\t\t\t\tthis.debugMessage('   OpacityMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.alphaMap = this.readMap(data, path);\n\t\t\t} else if (next === MAT_SPECMAP) {\n\n\t\t\t\tthis.debugMessage('   SpecularMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.specularMap = this.readMap(data, path);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('   Unknown material chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\n\t\tthis.materials[material.name] = material;\n\t},\n\n\t/**\n  * Read mesh data chunk.\n  *\n  * @method readMesh\n  * @param {Dataview} data Dataview in use.\n  */\n\treadMesh: function readMesh(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\n\t\tvar useBufferGeometry = false;\n\t\tvar geometry = null;\n\t\tvar uvs = [];\n\n\t\tif (useBufferGeometry) {\n\n\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t} else {\n\n\t\t\tgeometry = new THREE.Geometry();\n\t\t}\n\n\t\tvar material = new THREE.MeshPhongMaterial();\n\t\tvar mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.name = 'mesh';\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === POINT_ARRAY) {\n\n\t\t\t\tvar points = this.readWord(data);\n\n\t\t\t\tthis.debugMessage('   Vertex: ' + points);\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tif (useBufferGeometry) {\n\n\t\t\t\t\tvar vertices = [];\n\t\t\t\t\tfor (var i = 0; i < points; i++) {\n\n\t\t\t\t\t\tvertices.push(this.readFloat(data));\n\t\t\t\t\t\tvertices.push(this.readFloat(data));\n\t\t\t\t\t\tvertices.push(this.readFloat(data));\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n\t\t\t\t} else {\n\t\t\t\t\t//Geometry\n\n\t\t\t\t\tfor (var i = 0; i < points; i++) {\n\n\t\t\t\t\t\tgeometry.vertices.push(new THREE.Vector3(this.readFloat(data), this.readFloat(data), this.readFloat(data)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (next === FACE_ARRAY) {\n\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tthis.readFaceArray(data, mesh);\n\t\t\t} else if (next === TEX_VERTS) {\n\n\t\t\t\tvar texels = this.readWord(data);\n\n\t\t\t\tthis.debugMessage('   UV: ' + texels);\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tif (useBufferGeometry) {\n\n\t\t\t\t\tvar uvs = [];\n\t\t\t\t\tfor (var i = 0; i < texels; i++) {\n\n\t\t\t\t\t\tuvs.push(this.readFloat(data));\n\t\t\t\t\t\tuvs.push(this.readFloat(data));\n\t\t\t\t\t}\n\t\t\t\t\tgeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));\n\t\t\t\t} else {\n\t\t\t\t\t//Geometry\n\n\t\t\t\t\tuvs = [];\n\t\t\t\t\tfor (var i = 0; i < texels; i++) {\n\n\t\t\t\t\t\tuvs.push(new THREE.Vector2(this.readFloat(data), this.readFloat(data)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (next === MESH_MATRIX) {\n\n\t\t\t\tthis.debugMessage('   Tranformation Matrix (TODO)');\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor (var i = 0; i < 12; i++) {\n\n\t\t\t\t\tvalues[i] = this.readFloat(data);\n\t\t\t\t}\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\n\t\t\t\t//X Line\n\t\t\t\tmatrix.elements[0] = values[0];\n\t\t\t\tmatrix.elements[1] = values[6];\n\t\t\t\tmatrix.elements[2] = values[3];\n\t\t\t\tmatrix.elements[3] = values[9];\n\n\t\t\t\t//Y Line\n\t\t\t\tmatrix.elements[4] = values[2];\n\t\t\t\tmatrix.elements[5] = values[8];\n\t\t\t\tmatrix.elements[6] = values[5];\n\t\t\t\tmatrix.elements[7] = values[11];\n\n\t\t\t\t//Z Line\n\t\t\t\tmatrix.elements[8] = values[1];\n\t\t\t\tmatrix.elements[9] = values[7];\n\t\t\t\tmatrix.elements[10] = values[4];\n\t\t\t\tmatrix.elements[11] = values[10];\n\n\t\t\t\t//W Line\n\t\t\t\tmatrix.elements[12] = 0;\n\t\t\t\tmatrix.elements[13] = 0;\n\t\t\t\tmatrix.elements[14] = 0;\n\t\t\t\tmatrix.elements[15] = 1;\n\n\t\t\t\tmatrix.transpose();\n\n\t\t\t\tvar inverse = new THREE.Matrix4();\n\t\t\t\tinverse.getInverse(matrix, true);\n\t\t\t\tgeometry.applyMatrix(inverse);\n\n\t\t\t\tmatrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('   Unknown mesh chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\n\t\tif (!useBufferGeometry) {\n\n\t\t\t//geometry.faceVertexUvs[0][faceIndex][vertexIndex]\n\n\t\t\tif (uvs.length > 0) {\n\n\t\t\t\tvar faceUV = [];\n\n\t\t\t\tfor (var i = 0; i < geometry.faces.length; i++) {\n\n\t\t\t\t\tfaceUV.push([uvs[geometry.faces[i].a], uvs[geometry.faces[i].b], uvs[geometry.faces[i].c]]);\n\t\t\t\t}\n\n\t\t\t\tgeometry.faceVertexUvs[0] = faceUV;\n\t\t\t}\n\n\t\t\tgeometry.computeVertexNormals();\n\t\t}\n\n\t\treturn mesh;\n\t},\n\n\t/**\n  * Read face array data chunk.\n  *\n  * @method readFaceArray\n  * @param {Dataview} data Dataview in use.\n  * @param {Mesh} mesh Mesh to be filled with the data read.\n  */\n\treadFaceArray: function readFaceArray(data, mesh) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar faces = this.readWord(data);\n\n\t\tthis.debugMessage('   Faces: ' + faces);\n\n\t\tfor (var i = 0; i < faces; ++i) {\n\n\t\t\tmesh.geometry.faces.push(new THREE.Face3(this.readWord(data), this.readWord(data), this.readWord(data)));\n\n\t\t\tvar visibility = this.readWord(data);\n\t\t}\n\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\twhile (this.position < chunk.end) {\n\n\t\t\tvar chunk = this.readChunk(data);\n\n\t\t\tif (chunk.id === MSH_MAT_GROUP) {\n\n\t\t\t\tthis.debugMessage('      Material Group');\n\n\t\t\t\tthis.resetPosition(data);\n\n\t\t\t\tvar group = this.readMaterialGroup(data);\n\n\t\t\t\tvar material = this.materials[group.name];\n\n\t\t\t\tif (material !== undefined) {\n\n\t\t\t\t\tmesh.material = material;\n\n\t\t\t\t\tif (material.name === '') {\n\n\t\t\t\t\t\tmaterial.name = mesh.name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('      Unknown face array chunk: ' + chunk.toString(16));\n\t\t\t}\n\n\t\t\tthis.endChunk(chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\t},\n\n\t/**\n  * Read texture map data chunk.\n  *\n  * @method readMap\n  * @param {Dataview} data Dataview in use.\n  * @return {Texture} Texture read from this data chunk.\n  */\n\treadMap: function readMap(data, path) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\t\tvar texture = {};\n\n\t\tvar loader = new THREE.TextureLoader(this.manager);\n\t\tloader.setPath(path);\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === MAT_MAPNAME) {\n\n\t\t\t\tvar name = this.readString(data, 128);\n\t\t\t\ttexture = loader.load(name);\n\n\t\t\t\tthis.debugMessage('      File: ' + path + name);\n\t\t\t} else if (next === MAT_MAP_UOFFSET) {\n\n\t\t\t\ttexture.offset.x = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      OffsetX: ' + texture.offset.x);\n\t\t\t} else if (next === MAT_MAP_VOFFSET) {\n\n\t\t\t\ttexture.offset.y = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      OffsetY: ' + texture.offset.y);\n\t\t\t} else if (next === MAT_MAP_USCALE) {\n\n\t\t\t\ttexture.repeat.x = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      RepeatX: ' + texture.repeat.x);\n\t\t\t} else if (next === MAT_MAP_VSCALE) {\n\n\t\t\t\ttexture.repeat.y = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      RepeatY: ' + texture.repeat.y);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('      Unknown map chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\n\t\treturn texture;\n\t},\n\n\t/**\n  * Read material group data chunk.\n  *\n  * @method readMaterialGroup\n  * @param {Dataview} data Dataview in use.\n  * @return {Object} Object with name and index of the object.\n  */\n\treadMaterialGroup: function readMaterialGroup(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar name = this.readString(data, 64);\n\t\tvar numFaces = this.readWord(data);\n\n\t\tthis.debugMessage('         Name: ' + name);\n\t\tthis.debugMessage('         Faces: ' + numFaces);\n\n\t\tvar index = [];\n\t\tfor (var i = 0; i < numFaces; ++i) {\n\n\t\t\tindex.push(this.readWord(data));\n\t\t}\n\n\t\treturn { name: name, index: index };\n\t},\n\n\t/**\n  * Read a color value.\n  *\n  * @method readColor\n  * @param {DataView} data Dataview.\n  * @return {Color} Color value read..\n  */\n\treadColor: function readColor(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar color = new THREE.Color();\n\n\t\tif (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n\n\t\t\tvar r = this.readByte(data);\n\t\t\tvar g = this.readByte(data);\n\t\t\tvar b = this.readByte(data);\n\n\t\t\tcolor.setRGB(r / 255, g / 255, b / 255);\n\n\t\t\tthis.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n\t\t} else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n\n\t\t\tvar r = this.readFloat(data);\n\t\t\tvar g = this.readFloat(data);\n\t\t\tvar b = this.readFloat(data);\n\n\t\t\tcolor.setRGB(r, g, b);\n\n\t\t\tthis.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n\t\t} else {\n\n\t\t\tthis.debugMessage('      Unknown color chunk: ' + chunk.toString(16));\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\t\treturn color;\n\t},\n\n\t/**\n  * Read next chunk of data.\n  *\n  * @method readChunk\n  * @param {DataView} data Dataview.\n  * @return {Object} Chunk of data read.\n  */\n\treadChunk: function readChunk(data) {\n\n\t\tvar chunk = {};\n\n\t\tchunk.cur = this.position;\n\t\tchunk.id = this.readWord(data);\n\t\tchunk.size = this.readDWord(data);\n\t\tchunk.end = chunk.cur + chunk.size;\n\t\tchunk.cur += 6;\n\n\t\treturn chunk;\n\t},\n\n\t/**\n  * Set position to the end of the current chunk of data.\n  *\n  * @method endChunk\n  * @param {Object} chunk Data chunk.\n  */\n\tendChunk: function endChunk(chunk) {\n\n\t\tthis.position = chunk.end;\n\t},\n\n\t/**\n  * Move to the next data chunk.\n  *\n  * @method nextChunk\n  * @param {DataView} data Dataview.\n  * @param {Object} chunk Data chunk.\n  */\n\tnextChunk: function nextChunk(data, chunk) {\n\n\t\tif (chunk.cur >= chunk.end) {\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tthis.position = chunk.cur;\n\n\t\ttry {\n\n\t\t\tvar next = this.readChunk(data);\n\t\t\tchunk.cur += next.size;\n\t\t\treturn next.id;\n\t\t} catch (e) {\n\n\t\t\tthis.debugMessage('Unable to read chunk at ' + this.position);\n\t\t\treturn 0;\n\t\t}\n\t},\n\n\t/**\n  * Reset dataview position.\n  *\n  * @method resetPosition\n  * @param {DataView} data Dataview.\n  */\n\tresetPosition: function resetPosition() {\n\n\t\tthis.position -= 6;\n\t},\n\n\t/**\n  * Read byte value.\n  *\n  * @method readByte\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadByte: function readByte(data) {\n\n\t\tvar v = data.getUint8(this.position, true);\n\t\tthis.position += 1;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 32 bit float value.\n  *\n  * @method readFloat\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadFloat: function readFloat(data) {\n\n\t\ttry {\n\n\t\t\tvar v = data.getFloat32(this.position, true);\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\t\t} catch (e) {\n\n\t\t\tthis.debugMessage(e + ' ' + this.position + ' ' + data.byteLength);\n\t\t}\n\t},\n\n\t/**\n  * Read 32 bit signed integer value.\n  *\n  * @method readInt\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadInt: function readInt(data) {\n\n\t\tvar v = data.getInt32(this.position, true);\n\t\tthis.position += 4;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 16 bit signed integer value.\n  *\n  * @method readShort\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadShort: function readShort(data) {\n\n\t\tvar v = data.getInt16(this.position, true);\n\t\tthis.position += 2;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 64 bit unsigned integer value.\n  *\n  * @method readDWord\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadDWord: function readDWord(data) {\n\n\t\tvar v = data.getUint32(this.position, true);\n\t\tthis.position += 4;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 32 bit unsigned integer value.\n  *\n  * @method readWord\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadWord: function readWord(data) {\n\n\t\tvar v = data.getUint16(this.position, true);\n\t\tthis.position += 2;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read string value.\n  *\n  * @method readString\n  * @param {DataView} data Dataview to read data from.\n  * @param {Number} maxLength Max size of the string to be read.\n  * @return {String} Data read from the dataview.\n  */\n\treadString: function readString(data, maxLength) {\n\n\t\tvar s = '';\n\n\t\tfor (var i = 0; i < maxLength; i++) {\n\n\t\t\tvar c = this.readByte(data);\n\t\t\tif (!c) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts += String.fromCharCode(c);\n\t\t}\n\n\t\treturn s;\n\t},\n\n\t/**\n  * Set resource path used to determine the file path to attached resources.\n  *\n  * @method setPath\n  * @param {String} path Path to resources.\n  * @return Self for chaining.\n  */\n\tsetPath: function setPath(path) {\n\n\t\tthis.path = path;\n\n\t\treturn this;\n\t},\n\n\t/**\n  * Print debug message to the console.\n  *\n  * Is controlled by a flag to show or hide debug messages.\n  *\n  * @method debugMessage\n  * @param {Object} message Debug message to print to the console.\n  */\n\tdebugMessage: function debugMessage(message) {\n\n\t\tif (this.debug) {\n\n\t\t\tconsole.log(message);\n\t\t}\n\t}\n};\n\nvar NULL_CHUNK = 0x0000;\nvar M3DMAGIC = 0x4D4D;\nvar SMAGIC = 0x2D2D;\nvar LMAGIC = 0x2D3D;\nvar MLIBMAGIC = 0x3DAA;\nvar MATMAGIC = 0x3DFF;\nvar CMAGIC = 0xC23D;\nvar M3D_VERSION = 0x0002;\nvar M3D_KFVERSION = 0x0005;\nvar COLOR_F = 0x0010;\nvar COLOR_24 = 0x0011;\nvar LIN_COLOR_24 = 0x0012;\nvar LIN_COLOR_F = 0x0013;\nvar INT_PERCENTAGE = 0x0030;\nvar FLOAT_PERCENTAGE = 0x0031;\nvar MDATA = 0x3D3D;\nvar MESH_VERSION = 0x3D3E;\nvar MASTER_SCALE = 0x0100;\nvar LO_SHADOW_BIAS = 0x1400;\nvar HI_SHADOW_BIAS = 0x1410;\nvar SHADOW_MAP_SIZE = 0x1420;\nvar SHADOW_SAMPLES = 0x1430;\nvar SHADOW_RANGE = 0x1440;\nvar SHADOW_FILTER = 0x1450;\nvar RAY_BIAS = 0x1460;\nvar O_CONSTS = 0x1500;\nvar AMBIENT_LIGHT = 0x2100;\nvar BIT_MAP = 0x1100;\nvar SOLID_BGND = 0x1200;\nvar V_GRADIENT = 0x1300;\nvar USE_BIT_MAP = 0x1101;\nvar USE_SOLID_BGND = 0x1201;\nvar USE_V_GRADIENT = 0x1301;\nvar FOG = 0x2200;\nvar FOG_BGND = 0x2210;\nvar LAYER_FOG = 0x2302;\nvar DISTANCE_CUE = 0x2300;\nvar DCUE_BGND = 0x2310;\nvar USE_FOG = 0x2201;\nvar USE_LAYER_FOG = 0x2303;\nvar USE_DISTANCE_CUE = 0x2301;\nvar MAT_ENTRY = 0xAFFF;\nvar MAT_NAME = 0xA000;\nvar MAT_AMBIENT = 0xA010;\nvar MAT_DIFFUSE = 0xA020;\nvar MAT_SPECULAR = 0xA030;\nvar MAT_SHININESS = 0xA040;\nvar MAT_SHIN2PCT = 0xA041;\nvar MAT_TRANSPARENCY = 0xA050;\nvar MAT_XPFALL = 0xA052;\nvar MAT_USE_XPFALL = 0xA240;\nvar MAT_REFBLUR = 0xA053;\nvar MAT_SHADING = 0xA100;\nvar MAT_USE_REFBLUR = 0xA250;\nvar MAT_SELF_ILLUM = 0xA084;\nvar MAT_TWO_SIDE = 0xA081;\nvar MAT_DECAL = 0xA082;\nvar MAT_ADDITIVE = 0xA083;\nvar MAT_WIRE = 0xA085;\nvar MAT_FACEMAP = 0xA088;\nvar MAT_TRANSFALLOFF_IN = 0xA08A;\nvar MAT_PHONGSOFT = 0xA08C;\nvar MAT_WIREABS = 0xA08E;\nvar MAT_WIRE_SIZE = 0xA087;\nvar MAT_TEXMAP = 0xA200;\nvar MAT_SXP_TEXT_DATA = 0xA320;\nvar MAT_TEXMASK = 0xA33E;\nvar MAT_SXP_TEXTMASK_DATA = 0xA32A;\nvar MAT_TEX2MAP = 0xA33A;\nvar MAT_SXP_TEXT2_DATA = 0xA321;\nvar MAT_TEX2MASK = 0xA340;\nvar MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nvar MAT_OPACMAP = 0xA210;\nvar MAT_SXP_OPAC_DATA = 0xA322;\nvar MAT_OPACMASK = 0xA342;\nvar MAT_SXP_OPACMASK_DATA = 0xA32E;\nvar MAT_BUMPMAP = 0xA230;\nvar MAT_SXP_BUMP_DATA = 0xA324;\nvar MAT_BUMPMASK = 0xA344;\nvar MAT_SXP_BUMPMASK_DATA = 0xA330;\nvar MAT_SPECMAP = 0xA204;\nvar MAT_SXP_SPEC_DATA = 0xA325;\nvar MAT_SPECMASK = 0xA348;\nvar MAT_SXP_SPECMASK_DATA = 0xA332;\nvar MAT_SHINMAP = 0xA33C;\nvar MAT_SXP_SHIN_DATA = 0xA326;\nvar MAT_SHINMASK = 0xA346;\nvar MAT_SXP_SHINMASK_DATA = 0xA334;\nvar MAT_SELFIMAP = 0xA33D;\nvar MAT_SXP_SELFI_DATA = 0xA328;\nvar MAT_SELFIMASK = 0xA34A;\nvar MAT_SXP_SELFIMASK_DATA = 0xA336;\nvar MAT_REFLMAP = 0xA220;\nvar MAT_REFLMASK = 0xA34C;\nvar MAT_SXP_REFLMASK_DATA = 0xA338;\nvar MAT_ACUBIC = 0xA310;\nvar MAT_MAPNAME = 0xA300;\nvar MAT_MAP_TILING = 0xA351;\nvar MAT_MAP_TEXBLUR = 0xA353;\nvar MAT_MAP_USCALE = 0xA354;\nvar MAT_MAP_VSCALE = 0xA356;\nvar MAT_MAP_UOFFSET = 0xA358;\nvar MAT_MAP_VOFFSET = 0xA35A;\nvar MAT_MAP_ANG = 0xA35C;\nvar MAT_MAP_COL1 = 0xA360;\nvar MAT_MAP_COL2 = 0xA362;\nvar MAT_MAP_RCOL = 0xA364;\nvar MAT_MAP_GCOL = 0xA366;\nvar MAT_MAP_BCOL = 0xA368;\nvar NAMED_OBJECT = 0x4000;\nvar N_DIRECT_LIGHT = 0x4600;\nvar DL_OFF = 0x4620;\nvar DL_OUTER_RANGE = 0x465A;\nvar DL_INNER_RANGE = 0x4659;\nvar DL_MULTIPLIER = 0x465B;\nvar DL_EXCLUDE = 0x4654;\nvar DL_ATTENUATE = 0x4625;\nvar DL_SPOTLIGHT = 0x4610;\nvar DL_SPOT_ROLL = 0x4656;\nvar DL_SHADOWED = 0x4630;\nvar DL_LOCAL_SHADOW2 = 0x4641;\nvar DL_SEE_CONE = 0x4650;\nvar DL_SPOT_RECTANGULAR = 0x4651;\nvar DL_SPOT_ASPECT = 0x4657;\nvar DL_SPOT_PROJECTOR = 0x4653;\nvar DL_SPOT_OVERSHOOT = 0x4652;\nvar DL_RAY_BIAS = 0x4658;\nvar DL_RAYSHAD = 0x4627;\nvar N_CAMERA = 0x4700;\nvar CAM_SEE_CONE = 0x4710;\nvar CAM_RANGES = 0x4720;\nvar OBJ_HIDDEN = 0x4010;\nvar OBJ_VIS_LOFTER = 0x4011;\nvar OBJ_DOESNT_CAST = 0x4012;\nvar OBJ_DONT_RECVSHADOW = 0x4017;\nvar OBJ_MATTE = 0x4013;\nvar OBJ_FAST = 0x4014;\nvar OBJ_PROCEDURAL = 0x4015;\nvar OBJ_FROZEN = 0x4016;\nvar N_TRI_OBJECT = 0x4100;\nvar POINT_ARRAY = 0x4110;\nvar POINT_FLAG_ARRAY = 0x4111;\nvar FACE_ARRAY = 0x4120;\nvar MSH_MAT_GROUP = 0x4130;\nvar SMOOTH_GROUP = 0x4150;\nvar MSH_BOXMAP = 0x4190;\nvar TEX_VERTS = 0x4140;\nvar MESH_MATRIX = 0x4160;\nvar MESH_COLOR = 0x4165;\nvar MESH_TEXTURE_INFO = 0x4170;\nvar KFDATA = 0xB000;\nvar KFHDR = 0xB00A;\nvar KFSEG = 0xB008;\nvar KFCURTIME = 0xB009;\nvar AMBIENT_NODE_TAG = 0xB001;\nvar OBJECT_NODE_TAG = 0xB002;\nvar CAMERA_NODE_TAG = 0xB003;\nvar TARGET_NODE_TAG = 0xB004;\nvar LIGHT_NODE_TAG = 0xB005;\nvar L_TARGET_NODE_TAG = 0xB006;\nvar SPOTLIGHT_NODE_TAG = 0xB007;\nvar NODE_ID = 0xB030;\nvar NODE_HDR = 0xB010;\nvar PIVOT = 0xB013;\nvar INSTANCE_NAME = 0xB011;\nvar MORPH_SMOOTH = 0xB015;\nvar BOUNDBOX = 0xB014;\nvar POS_TRACK_TAG = 0xB020;\nvar COL_TRACK_TAG = 0xB025;\nvar ROT_TRACK_TAG = 0xB021;\nvar SCL_TRACK_TAG = 0xB022;\nvar MORPH_TRACK_TAG = 0xB026;\nvar FOV_TRACK_TAG = 0xB023;\nvar ROLL_TRACK_TAG = 0xB024;\nvar HOT_TRACK_TAG = 0xB027;\nvar FALL_TRACK_TAG = 0xB028;\nvar HIDE_TRACK_TAG = 0xB029;\nvar POLY_2D = 0x5000;\nvar SHAPE_OK = 0x5010;\nvar SHAPE_NOT_OK = 0x5011;\nvar SHAPE_HOOK = 0x5020;\nvar PATH_3D = 0x6000;\nvar PATH_MATRIX = 0x6005;\nvar SHAPE_2D = 0x6010;\nvar M_SCALE = 0x6020;\nvar M_TWIST = 0x6030;\nvar M_TEETER = 0x6040;\nvar M_FIT = 0x6050;\nvar M_BEVEL = 0x6060;\nvar XZ_CURVE = 0x6070;\nvar YZ_CURVE = 0x6080;\nvar INTERPCT = 0x6090;\nvar DEFORM_LIMIT = 0x60A0;\nvar USE_CONTOUR = 0x6100;\nvar USE_TWEEN = 0x6110;\nvar USE_SCALE = 0x6120;\nvar USE_TWIST = 0x6130;\nvar USE_TEETER = 0x6140;\nvar USE_FIT = 0x6150;\nvar USE_BEVEL = 0x6160;\nvar DEFAULT_VIEW = 0x3000;\nvar VIEW_TOP = 0x3010;\nvar VIEW_BOTTOM = 0x3020;\nvar VIEW_LEFT = 0x3030;\nvar VIEW_RIGHT = 0x3040;\nvar VIEW_FRONT = 0x3050;\nvar VIEW_BACK = 0x3060;\nvar VIEW_USER = 0x3070;\nvar VIEW_CAMERA = 0x3080;\nvar VIEW_WINDOW = 0x3090;\nvar VIEWPORT_LAYOUT_OLD = 0x7000;\nvar VIEWPORT_DATA_OLD = 0x7010;\nvar VIEWPORT_LAYOUT = 0x7001;\nvar VIEWPORT_DATA = 0x7011;\nvar VIEWPORT_DATA_3 = 0x7012;\nvar VIEWPORT_SIZE = 0x7020;\nvar NETWORK_VIEW = 0x7030;\n\nexports.default = TDSLoader;\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author Daosheng Mu / https://github.com/DaoshengMu/\n * @author mrdoob / http://mrdoob.com/\n * @author takahirox / https://github.com/takahirox/\n */\n\nvar TGALoader = function TGALoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTGALoader.prototype = {\n\n\tconstructor: TGALoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\n\t\tloader.load(url, function (buffer) {\n\n\t\t\ttexture.image = scope.parse(buffer);\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif (onLoad !== undefined) {\n\n\t\t\t\tonLoad(texture);\n\t\t\t}\n\t\t}, onProgress, onError);\n\n\t\treturn texture;\n\t},\n\n\tparse: function parse(buffer) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader(header) {\n\n\t\t\tswitch (header.image_type) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif (header.colormap_type) {\n\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error('THREE.TGALoader: No data.');\n\n\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif (header.width <= 0 || header.height <= 0) {\n\n\t\t\t\tconsole.error('THREE.TGALoader: Invalid image size.');\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n\n\t\t\t\tconsole.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n\t\t\t}\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse(use_rle, use_pal, header, offset, data) {\n\n\t\t\tvar pixel_data, pixel_size, pixel_total, palettes;\n\n\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t// read palettes\n\n\t\t\tif (use_pal) {\n\n\t\t\t\tpalettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n\t\t\t}\n\n\t\t\t// read RLE\n\n\t\t\tif (use_rle) {\n\n\t\t\t\tpixel_data = new Uint8Array(pixel_total);\n\n\t\t\t\tvar c, count, i;\n\t\t\t\tvar shift = 0;\n\t\t\t\tvar pixels = new Uint8Array(pixel_size);\n\n\t\t\t\twhile (shift < pixel_total) {\n\n\t\t\t\t\tc = data[offset++];\n\t\t\t\t\tcount = (c & 0x7f) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif (c & 0x80) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor (i = 0; i < pixel_size; ++i) {\n\n\t\t\t\t\t\t\tpixels[i] = data[offset++];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\n\t\t\t\t\t\t\tpixel_data.set(pixels, shift + i * pixel_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\n\t\t\t\t\t\t\tpixel_data[shift + i] = data[offset++];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tshift += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t};\n\t\t}\n\n\t\tfunction tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n\n\t\t\tvar colormap = palettes;\n\t\t\tvar color,\n\t\t\t    i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i++) {\n\n\t\t\t\t\tcolor = image[i];\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar color,\n\t\t\t    i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 2) {\n\n\t\t\t\t\tcolor = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 3) {\n\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 1];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 4) {\n\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 1];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 2];\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = image[i + 3];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar color,\n\t\t\t    i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i++) {\n\n\t\t\t\t\tcolor = image[i];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = color;\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = color;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = color;\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 2) {\n\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = image[i + 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction getTgaRGBA(data, width, height, image, palette) {\n\n\t\t\tvar x_start, y_start, x_step, y_step, x_end, y_end;\n\n\t\t\tswitch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = -1;\n\t\t\t\t\ty_end = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = -1;\n\t\t\t\t\tx_end = -1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = -1;\n\t\t\t\t\tx_end = -1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = -1;\n\t\t\t\t\ty_end = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (use_grey) {\n\n\t\t\t\tswitch (header.pixel_size) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Format not supported.');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tswitch (header.pixel_size) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Format not supported.');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\t\t}\n\n\t\t// TGA constants\n\n\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t    TGA_TYPE_INDEXED = 1,\n\t\t    TGA_TYPE_RGB = 2,\n\t\t    TGA_TYPE_GREY = 3,\n\t\t    TGA_TYPE_RLE_INDEXED = 9,\n\t\t    TGA_TYPE_RLE_RGB = 10,\n\t\t    TGA_TYPE_RLE_GREY = 11,\n\t\t    TGA_ORIGIN_MASK = 0x30,\n\t\t    TGA_ORIGIN_SHIFT = 0x04,\n\t\t    TGA_ORIGIN_BL = 0x00,\n\t\t    TGA_ORIGIN_BR = 0x01,\n\t\t    TGA_ORIGIN_UL = 0x02,\n\t\t    TGA_ORIGIN_UR = 0x03;\n\n\t\tif (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n\n\t\tvar content = new Uint8Array(buffer),\n\t\t    offset = 0,\n\t\t    header = {\n\t\t\tid_length: content[offset++],\n\t\t\tcolormap_type: content[offset++],\n\t\t\timage_type: content[offset++],\n\t\t\tcolormap_index: content[offset++] | content[offset++] << 8,\n\t\t\tcolormap_length: content[offset++] | content[offset++] << 8,\n\t\t\tcolormap_size: content[offset++],\n\t\t\torigin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n\t\t\twidth: content[offset++] | content[offset++] << 8,\n\t\t\theight: content[offset++] | content[offset++] << 8,\n\t\t\tpixel_size: content[offset++],\n\t\t\tflags: content[offset++]\n\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader(header);\n\n\t\tif (header.id_length + offset > buffer.length) {\n\n\t\t\tconsole.error('THREE.TGALoader: No data.');\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tvar use_rle = false,\n\t\t    use_pal = false,\n\t\t    use_grey = false;\n\n\t\tswitch (header.image_type) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = header.width;\n\t\tcanvas.height = header.height;\n\n\t\tvar context = canvas.getContext('2d');\n\t\tvar imageData = context.createImageData(header.width, header.height);\n\n\t\tvar result = tgaParse(use_rle, use_pal, header, offset, content);\n\t\tvar rgbaData = getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);\n\n\t\tcontext.putImageData(imageData, 0, 0);\n\n\t\treturn canvas;\n\t}\n\n};\n\nexports.default = TGALoader;\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author gero3 / https://github.com/gero3\n * @author tentone / https://github.com/tentone\n *\n * Requires opentype.js to be included in the project.\n * Loads TTF files and converts them into typeface JSON that can be used directly\n * to create THREE.Font objects.\n */\n\nvar TTFLoader = function TTFLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.reversed = false;\n};\n\nTTFLoader.prototype = {\n\n\tconstructor: TTFLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(arraybuffer) {\n\n\t\tfunction convert(font, reversed) {\n\n\t\t\tvar round = Math.round;\n\n\t\t\tvar glyphs = {};\n\t\t\tvar scale = 100000 / ((font.unitsPerEm || 2048) * 72);\n\n\t\t\tfor (var i = 0; i < font.glyphs.length; i++) {\n\n\t\t\t\tvar glyph = font.glyphs.glyphs[i];\n\n\t\t\t\tif (glyph.unicode !== undefined) {\n\n\t\t\t\t\tvar token = {\n\t\t\t\t\t\tha: round(glyph.advanceWidth * scale),\n\t\t\t\t\t\tx_min: round(glyph.xMin * scale),\n\t\t\t\t\t\tx_max: round(glyph.xMax * scale),\n\t\t\t\t\t\to: ''\n\t\t\t\t\t};\n\n\t\t\t\t\tif (reversed) {\n\n\t\t\t\t\t\tglyph.path.commands = reverseCommands(glyph.path.commands);\n\t\t\t\t\t}\n\n\t\t\t\t\tglyph.path.commands.forEach(function (command, i) {\n\n\t\t\t\t\t\tif (command.type.toLowerCase() === 'c') {\n\n\t\t\t\t\t\t\tcommand.type = 'b';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttoken.o += command.type.toLowerCase() + ' ';\n\n\t\t\t\t\t\tif (command.x !== undefined && command.y !== undefined) {\n\n\t\t\t\t\t\t\ttoken.o += round(command.x * scale) + ' ' + round(command.y * scale) + ' ';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (command.x1 !== undefined && command.y1 !== undefined) {\n\n\t\t\t\t\t\t\ttoken.o += round(command.x1 * scale) + ' ' + round(command.y1 * scale) + ' ';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (command.x2 !== undefined && command.y2 !== undefined) {\n\n\t\t\t\t\t\t\ttoken.o += round(command.x2 * scale) + ' ' + round(command.y2 * scale) + ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tglyphs[String.fromCharCode(glyph.unicode)] = token;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tglyphs: glyphs,\n\t\t\t\tfamilyName: font.familyName,\n\t\t\t\tascender: round(font.ascender * scale),\n\t\t\t\tdescender: round(font.descender * scale),\n\t\t\t\tunderlinePosition: font.tables.post.underlinePosition,\n\t\t\t\tunderlineThickness: font.tables.post.underlineThickness,\n\t\t\t\tboundingBox: {\n\t\t\t\t\txMin: font.tables.head.xMin,\n\t\t\t\t\txMax: font.tables.head.xMax,\n\t\t\t\t\tyMin: font.tables.head.yMin,\n\t\t\t\t\tyMax: font.tables.head.yMax\n\t\t\t\t},\n\t\t\t\tresolution: 1000,\n\t\t\t\toriginal_font_information: font.tables.name\n\t\t\t};\n\t\t}\n\n\t\tfunction reverseCommands(commands) {\n\n\t\t\tvar paths = [];\n\t\t\tvar path;\n\n\t\t\tcommands.forEach(function (c) {\n\n\t\t\t\tif (c.type.toLowerCase() === 'm') {\n\n\t\t\t\t\tpath = [c];\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t} else if (c.type.toLowerCase() !== 'z') {\n\n\t\t\t\t\tpath.push(c);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar reversed = [];\n\n\t\t\tpaths.forEach(function (p) {\n\n\t\t\t\tvar result = {\n\t\t\t\t\ttype: 'm',\n\t\t\t\t\tx: p[p.length - 1].x,\n\t\t\t\t\ty: p[p.length - 1].y\n\t\t\t\t};\n\n\t\t\t\treversed.push(result);\n\n\t\t\t\tfor (var i = p.length - 1; i > 0; i--) {\n\n\t\t\t\t\tvar command = p[i];\n\t\t\t\t\tvar result = { type: command.type };\n\n\t\t\t\t\tif (command.x2 !== undefined && command.y2 !== undefined) {\n\n\t\t\t\t\t\tresult.x1 = command.x2;\n\t\t\t\t\t\tresult.y1 = command.y2;\n\t\t\t\t\t\tresult.x2 = command.x1;\n\t\t\t\t\t\tresult.y2 = command.y1;\n\t\t\t\t\t} else if (command.x1 !== undefined && command.y1 !== undefined) {\n\n\t\t\t\t\t\tresult.x1 = command.x1;\n\t\t\t\t\t\tresult.y1 = command.y1;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.x = p[i - 1].x;\n\t\t\t\t\tresult.y = p[i - 1].y;\n\t\t\t\t\treversed.push(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn reversed;\n\t\t}\n\n\t\tif (typeof opentype === 'undefined') {\n\n\t\t\tconsole.warn('THREE.TTFLoader: The loader requires opentype.js. Make sure it\\'s included before using the loader.');\n\t\t\treturn null;\n\t\t}\n\n\t\treturn convert(opentype.parse(arraybuffer), this.reversed);\n\t}\n\n};\n\nexports.default = TTFLoader;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar VRMLLoader = function VRMLLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nVRMLLoader.prototype = {\n\n\tconstructor: VRMLLoader,\n\n\t// for IndexedFaceSet support\n\tisRecordingPoints: false,\n\tisRecordingFaces: false,\n\tpoints: [],\n\tindexes: [],\n\n\t// for Background support\n\tisRecordingAngles: false,\n\tisRecordingColors: false,\n\tangles: [],\n\tcolors: [],\n\n\trecordingFieldname: null,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(data) {\n\n\t\tvar texturePath = this.texturePath || '';\n\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setCrossOrigin(this.crossOrigin);\n\n\t\tfunction parseV2(lines, scene) {\n\n\t\t\tvar defines = {};\n\t\t\tvar float_pattern = /(\\b|\\-|\\+)([\\d\\.e]+)/;\n\t\t\tvar float2_pattern = /([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)/g;\n\t\t\tvar float3_pattern = /([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)/g;\n\n\t\t\t/**\n    * Vertically paints the faces interpolating between the\n    * specified colors at the specified angels. This is used for the Background\n    * node, but could be applied to other nodes with multiple faces as well.\n    *\n    * When used with the Background node, default is directionIsDown is true if\n    * interpolating the skyColor down from the Zenith. When interpolationg up from\n    * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n    *\n    * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n    * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n    * is linear along the Y axis in any case.\n    *\n    * You must specify one more color than you have angles at the beginning of the colors array.\n    * This is the color of the Zenith (the top of the shape).\n    *\n    * @param geometry\n    * @param radius\n    * @param angles\n    * @param colors\n    * @param boolean topDown Whether to work top down or bottom up.\n    */\n\t\t\tfunction paintFaces(geometry, radius, angles, colors, topDown) {\n\n\t\t\t\tvar direction = topDown === true ? 1 : -1;\n\n\t\t\t\tvar coord = [],\n\t\t\t\t    A = {},\n\t\t\t\t    B = {},\n\t\t\t\t    applyColor = false;\n\n\t\t\t\tfor (var k = 0; k < angles.length; k++) {\n\n\t\t\t\t\t// push the vector at which the color changes\n\n\t\t\t\t\tvar vec = {\n\t\t\t\t\t\tx: direction * (Math.cos(angles[k]) * radius),\n\t\t\t\t\t\ty: direction * (Math.sin(angles[k]) * radius)\n\t\t\t\t\t};\n\n\t\t\t\t\tcoord.push(vec);\n\t\t\t\t}\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\tvar colorAttribute = new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n\n\t\t\t\tvar position = new THREE.Vector3();\n\t\t\t\tvar color = new THREE.Color();\n\n\t\t\t\tfor (var i = 0; i < index.count; i++) {\n\n\t\t\t\t\tvar vertexIndex = index.getX(i);\n\n\t\t\t\t\tposition.fromBufferAttribute(positionAttribute, vertexIndex);\n\n\t\t\t\t\tfor (var j = 0; j < colors.length; j++) {\n\n\t\t\t\t\t\t// linear interpolation between aColor and bColor, calculate proportion\n\t\t\t\t\t\t// A is previous point (angle)\n\n\t\t\t\t\t\tif (j === 0) {\n\n\t\t\t\t\t\t\tA.x = 0;\n\t\t\t\t\t\t\tA.y = topDown === true ? radius : -1 * radius;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tA.x = coord[j - 1].x;\n\t\t\t\t\t\t\tA.y = coord[j - 1].y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// B is current point (angle)\n\n\t\t\t\t\t\tB = coord[j];\n\n\t\t\t\t\t\tif (B !== undefined) {\n\n\t\t\t\t\t\t\t// p has to be between the points A and B which we interpolate\n\n\t\t\t\t\t\t\tapplyColor = topDown === true ? position.y <= A.y && position.y > B.y : position.y >= A.y && position.y < B.y;\n\n\t\t\t\t\t\t\tif (applyColor === true) {\n\n\t\t\t\t\t\t\t\tvar aColor = colors[j];\n\t\t\t\t\t\t\t\tvar bColor = colors[j + 1];\n\n\t\t\t\t\t\t\t\t// below is simple linear interpolation\n\n\t\t\t\t\t\t\t\tvar t = Math.abs(position.y - A.y) / (A.y - B.y);\n\n\t\t\t\t\t\t\t\t// to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y\n\n\t\t\t\t\t\t\t\tcolor.copy(aColor).lerp(bColor, t);\n\n\t\t\t\t\t\t\t\tcolorAttribute.setXYZ(vertexIndex, color.r, color.g, color.b);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar colorIndex = topDown === true ? colors.length - 1 : 0;\n\t\t\t\t\t\t\t\tvar c = colors[colorIndex];\n\t\t\t\t\t\t\t\tcolorAttribute.setXYZ(vertexIndex, c.r, c.g, c.b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgeometry.addAttribute('color', colorAttribute);\n\t\t\t}\n\n\t\t\tvar index = [];\n\n\t\t\tfunction parseProperty(node, line) {\n\n\t\t\t\tvar parts = [],\n\t\t\t\t    part,\n\t\t\t\t    property = {},\n\t\t\t\t    fieldName;\n\n\t\t\t\t/**\n     * Expression for matching relevant information, such as a name or value, but not the separators\n     * @type {RegExp}\n     */\n\t\t\t\tvar regex = /[^\\s,\\[\\]]+/g;\n\n\t\t\t\tvar point;\n\n\t\t\t\twhile (null !== (part = regex.exec(line))) {\n\n\t\t\t\t\tparts.push(part[0]);\n\t\t\t\t}\n\n\t\t\t\tfieldName = parts[0];\n\n\t\t\t\t// trigger several recorders\n\t\t\t\tswitch (fieldName) {\n\n\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingAngles = true;\n\t\t\t\t\t\tthis.angles = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingColors = true;\n\t\t\t\t\t\tthis.colors = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'point':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingPoints = true;\n\t\t\t\t\t\tthis.points = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingFaces = true;\n\t\t\t\t\t\tthis.indexes = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (this.isRecordingFaces) {\n\n\t\t\t\t\t// the parts hold the indexes as strings\n\t\t\t\t\tif (parts.length > 0) {\n\n\t\t\t\t\t\tfor (var ind = 0; ind < parts.length; ind++) {\n\n\t\t\t\t\t\t\t// the part should either be positive integer or -1\n\t\t\t\t\t\t\tif (!/(-?\\d+)/.test(parts[ind])) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// end of current face\n\t\t\t\t\t\t\tif (parts[ind] === '-1') {\n\n\t\t\t\t\t\t\t\tif (index.length > 0) {\n\n\t\t\t\t\t\t\t\t\tthis.indexes.push(index);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// start new one\n\t\t\t\t\t\t\t\tindex = [];\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindex.push(parseInt(parts[ind]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tif (index.length > 0) {\n\n\t\t\t\t\t\t\tthis.indexes.push(index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// start new one\n\t\t\t\t\t\tindex = [];\n\n\t\t\t\t\t\tthis.isRecordingFaces = false;\n\t\t\t\t\t\tnode[this.recordingFieldname] = this.indexes;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.isRecordingPoints) {\n\n\t\t\t\t\tif (node.nodeType == 'Coordinate') {\n\n\t\t\t\t\t\twhile (null !== (parts = float3_pattern.exec(line))) {\n\n\t\t\t\t\t\t\tpoint = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tz: parseFloat(parts[3])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis.points.push(point);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node.nodeType == 'TextureCoordinate') {\n\n\t\t\t\t\t\twhile (null !== (parts = float2_pattern.exec(line))) {\n\n\t\t\t\t\t\t\tpoint = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis.points.push(point);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tthis.isRecordingPoints = false;\n\t\t\t\t\t\tnode.points = this.points;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.isRecordingAngles) {\n\n\t\t\t\t\t// the parts hold the angles as strings\n\t\t\t\t\tif (parts.length > 0) {\n\n\t\t\t\t\t\tfor (var ind = 0; ind < parts.length; ind++) {\n\n\t\t\t\t\t\t\t// the part should be a float\n\t\t\t\t\t\t\tif (!float_pattern.test(parts[ind])) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.angles.push(parseFloat(parts[ind]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tthis.isRecordingAngles = false;\n\t\t\t\t\t\tnode[this.recordingFieldname] = this.angles;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.isRecordingColors) {\n\n\t\t\t\t\twhile (null !== (parts = float3_pattern.exec(line))) {\n\n\t\t\t\t\t\tvar color = {\n\t\t\t\t\t\t\tr: parseFloat(parts[1]),\n\t\t\t\t\t\t\tg: parseFloat(parts[2]),\n\t\t\t\t\t\t\tb: parseFloat(parts[3])\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.colors.push(color);\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tthis.isRecordingColors = false;\n\t\t\t\t\t\tnode[this.recordingFieldname] = this.colors;\n\t\t\t\t\t}\n\t\t\t\t} else if (parts[parts.length - 1] !== 'NULL' && fieldName !== 'children') {\n\n\t\t\t\t\tswitch (fieldName) {\n\n\t\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\tcase 'color':\n\n\t\t\t\t\t\t\tif (parts.length !== 4) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid color format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = {\n\t\t\t\t\t\t\t\tr: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\tg: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tb: parseFloat(parts[3])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'location':\n\t\t\t\t\t\tcase 'direction':\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tcase 'size':\n\t\t\t\t\t\t\tif (parts.length !== 4) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid vector format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tz: parseFloat(parts[3])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'intensity':\n\t\t\t\t\t\tcase 'cutOffAngle':\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tcase 'topRadius':\n\t\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t\tif (parts.length !== 2) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid single float value specification detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = parseFloat(parts[1]);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\tif (parts.length !== 5) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid quaternion format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tz: parseFloat(parts[3]),\n\t\t\t\t\t\t\t\tw: parseFloat(parts[4])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'on':\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\tif (parts.length !== 2) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = parts[1] === 'TRUE' ? true : false;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[fieldName] = property;\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tfunction getTree(lines) {\n\n\t\t\t\tvar tree = { 'string': 'Scene', children: [] };\n\t\t\t\tvar current = tree;\n\t\t\t\tvar matches;\n\t\t\t\tvar specification;\n\n\t\t\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\t\t\tvar comment = '';\n\n\t\t\t\t\tvar line = lines[i];\n\n\t\t\t\t\t// omit whitespace only lines\n\t\t\t\t\tif (null !== /^\\s+?$/g.exec(line)) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tline = line.trim();\n\n\t\t\t\t\t// skip empty lines\n\t\t\t\t\tif (line === '') {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (/#/.exec(line)) {\n\n\t\t\t\t\t\tvar parts = line.split('#');\n\n\t\t\t\t\t\t// discard everything after the #, it is a comment\n\t\t\t\t\t\tline = parts[0];\n\n\t\t\t\t\t\t// well, let's also keep the comment\n\t\t\t\t\t\tcomment = parts[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (matches = /([^\\s]*){1}(?:\\s+)?{/.exec(line)) {\n\n\t\t\t\t\t\t// first subpattern should match the Node name\n\n\t\t\t\t\t\tvar block = { 'nodeType': matches[1], 'string': line, 'parent': current, 'children': [], 'comment': comment };\n\t\t\t\t\t\tcurrent.children.push(block);\n\t\t\t\t\t\tcurrent = block;\n\n\t\t\t\t\t\tif (/}/.exec(line)) {\n\n\t\t\t\t\t\t\t// example: geometry Box { size 1 1 1 } # all on the same line\n\t\t\t\t\t\t\tspecification = /{(.*)}/.exec(line)[1];\n\n\t\t\t\t\t\t\t// todo: remove once new parsing is complete?\n\t\t\t\t\t\t\tblock.children.push(specification);\n\n\t\t\t\t\t\t\tparseProperty(current, specification);\n\n\t\t\t\t\t\t\tcurrent = current.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (/}/.exec(line)) {\n\n\t\t\t\t\t\tcurrent = current.parent;\n\t\t\t\t\t} else if (line !== '') {\n\n\t\t\t\t\t\tparseProperty(current, line);\n\t\t\t\t\t\t// todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way\n\t\t\t\t\t\tcurrent.children.push(line);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tree;\n\t\t\t}\n\n\t\t\tfunction parseNode(data, parent) {\n\n\t\t\t\tvar object;\n\n\t\t\t\tif (typeof data === 'string') {\n\n\t\t\t\t\tif (/USE/.exec(data)) {\n\n\t\t\t\t\t\tvar defineKey = /USE\\s+?([^\\s]+)/.exec(data)[1];\n\n\t\t\t\t\t\tif (undefined == defines[defineKey]) {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: %s is not defined.', defineKey);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (/appearance/.exec(data) && defineKey) {\n\n\t\t\t\t\t\t\t\tparent.material = defines[defineKey].clone();\n\t\t\t\t\t\t\t} else if (/geometry/.exec(data) && defineKey) {\n\n\t\t\t\t\t\t\t\tparent.geometry = defines[defineKey].clone();\n\n\t\t\t\t\t\t\t\t// the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it\n\t\t\t\t\t\t\t\tif (undefined !== defines[defineKey].solid && defines[defineKey].solid === false) {\n\n\t\t\t\t\t\t\t\t\tparent.geometry.solid = false;\n\t\t\t\t\t\t\t\t\tparent.material.side = THREE.DoubleSide;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (defineKey) {\n\n\t\t\t\t\t\t\t\tobject = defines[defineKey].clone();\n\t\t\t\t\t\t\t\tparent.add(object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tobject = parent;\n\n\t\t\t\tif (data.string.indexOf('AmbientLight') > -1 && data.nodeType === 'PointLight') {\n\n\t\t\t\t\tdata.nodeType = 'AmbientLight';\n\t\t\t\t}\n\n\t\t\t\tvar l_visible = data.on !== undefined ? data.on : true;\n\t\t\t\tvar l_intensity = data.intensity !== undefined ? data.intensity : 1;\n\t\t\t\tvar l_color = new THREE.Color();\n\n\t\t\t\tif (data.color) {\n\n\t\t\t\t\tl_color.copy(data.color);\n\t\t\t\t}\n\n\t\t\t\tif (data.nodeType === 'AmbientLight') {\n\n\t\t\t\t\tobject = new THREE.AmbientLight(l_color, l_intensity);\n\t\t\t\t\tobject.visible = l_visible;\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'PointLight') {\n\n\t\t\t\t\tvar l_distance = 0;\n\n\t\t\t\t\tif (data.radius !== undefined && data.radius < 1000) {\n\n\t\t\t\t\t\tl_distance = data.radius;\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.PointLight(l_color, l_intensity, l_distance);\n\t\t\t\t\tobject.visible = l_visible;\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'SpotLight') {\n\n\t\t\t\t\tvar l_intensity = 1;\n\t\t\t\t\tvar l_distance = 0;\n\t\t\t\t\tvar l_angle = Math.PI / 3;\n\t\t\t\t\tvar l_penumbra = 0;\n\t\t\t\t\tvar l_visible = true;\n\n\t\t\t\t\tif (data.radius !== undefined && data.radius < 1000) {\n\n\t\t\t\t\t\tl_distance = data.radius;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.cutOffAngle !== undefined) {\n\n\t\t\t\t\t\tl_angle = data.cutOffAngle;\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.SpotLight(l_color, l_intensity, l_distance, l_angle, l_penumbra);\n\t\t\t\t\tobject.visible = l_visible;\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'Transform' || data.nodeType === 'Group') {\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\tobject.name = /DEF\\s+([^\\s]+)/.exec(data.string)[1];\n\t\t\t\t\t\tdefines[object.name] = object;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.translation !== undefined) {\n\n\t\t\t\t\t\tvar t = data.translation;\n\n\t\t\t\t\t\tobject.position.set(t.x, t.y, t.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.rotation !== undefined) {\n\n\t\t\t\t\t\tvar r = data.rotation;\n\n\t\t\t\t\t\tobject.quaternion.setFromAxisAngle(new THREE.Vector3(r.x, r.y, r.z), r.w);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.scale !== undefined) {\n\n\t\t\t\t\t\tvar s = data.scale;\n\n\t\t\t\t\t\tobject.scale.set(s.x, s.y, s.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'Shape') {\n\n\t\t\t\t\tobject = new THREE.Mesh();\n\n\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\tobject.name = /DEF\\s+([^\\s]+)/.exec(data.string)[1];\n\n\t\t\t\t\t\tdefines[object.name] = object;\n\t\t\t\t\t}\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'Background') {\n\n\t\t\t\t\tvar segments = 20;\n\n\t\t\t\t\t// sky (full sphere):\n\n\t\t\t\t\tvar radius = 2e4;\n\n\t\t\t\t\tvar skyGeometry = new THREE.SphereBufferGeometry(radius, segments, segments);\n\t\t\t\t\tvar skyMaterial = new THREE.MeshBasicMaterial({ fog: false, side: THREE.BackSide });\n\n\t\t\t\t\tif (data.skyColor.length > 1) {\n\n\t\t\t\t\t\tpaintFaces(skyGeometry, radius, data.skyAngle, data.skyColor, true);\n\n\t\t\t\t\t\tskyMaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar color = data.skyColor[0];\n\t\t\t\t\t\tskyMaterial.color.setRGB(color.r, color.b, color.g);\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add(new THREE.Mesh(skyGeometry, skyMaterial));\n\n\t\t\t\t\t// ground (half sphere):\n\n\t\t\t\t\tif (data.groundColor !== undefined) {\n\n\t\t\t\t\t\tradius = 1.2e4;\n\n\t\t\t\t\t\tvar groundGeometry = new THREE.SphereBufferGeometry(radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n\t\t\t\t\t\tvar groundMaterial = new THREE.MeshBasicMaterial({ fog: false, side: THREE.BackSide, vertexColors: THREE.VertexColors });\n\n\t\t\t\t\t\tpaintFaces(groundGeometry, radius, data.groundAngle, data.groundColor, false);\n\n\t\t\t\t\t\tscene.add(new THREE.Mesh(groundGeometry, groundMaterial));\n\t\t\t\t\t}\n\t\t\t\t} else if (/geometry/.exec(data.string)) {\n\n\t\t\t\t\tif (data.nodeType === 'Box') {\n\n\t\t\t\t\t\tvar s = data.size;\n\n\t\t\t\t\t\tparent.geometry = new THREE.BoxBufferGeometry(s.x, s.y, s.z);\n\t\t\t\t\t} else if (data.nodeType === 'Cylinder') {\n\n\t\t\t\t\t\tparent.geometry = new THREE.CylinderBufferGeometry(data.radius, data.radius, data.height);\n\t\t\t\t\t} else if (data.nodeType === 'Cone') {\n\n\t\t\t\t\t\tparent.geometry = new THREE.CylinderBufferGeometry(data.topRadius, data.bottomRadius, data.height);\n\t\t\t\t\t} else if (data.nodeType === 'Sphere') {\n\n\t\t\t\t\t\tparent.geometry = new THREE.SphereBufferGeometry(data.radius);\n\t\t\t\t\t} else if (data.nodeType === 'IndexedFaceSet') {\n\n\t\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\t\tvar positions = [];\n\t\t\t\t\t\tvar uvs = [];\n\n\t\t\t\t\t\tvar position, uv;\n\n\t\t\t\t\t\tvar i, il, j, jl;\n\n\t\t\t\t\t\tfor (i = 0, il = data.children.length; i < il; i++) {\n\n\t\t\t\t\t\t\tvar child = data.children[i];\n\n\t\t\t\t\t\t\t// uvs\n\n\t\t\t\t\t\t\tif (child.nodeType === 'TextureCoordinate') {\n\n\t\t\t\t\t\t\t\tif (child.points) {\n\n\t\t\t\t\t\t\t\t\tfor (j = 0, jl = child.points.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\tuv = child.points[j];\n\t\t\t\t\t\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// positions\n\n\t\t\t\t\t\t\tif (child.nodeType === 'Coordinate') {\n\n\t\t\t\t\t\t\t\tif (child.points) {\n\n\t\t\t\t\t\t\t\t\tfor (j = 0, jl = child.points.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\tposition = child.points[j];\n\t\t\t\t\t\t\t\t\t\tpositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (child.string.indexOf('DEF') > -1) {\n\n\t\t\t\t\t\t\t\t\tvar name = /DEF\\s+([^\\s]+)/.exec(child.string)[1];\n\n\t\t\t\t\t\t\t\t\tdefines[name] = positions.slice(0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (child.string.indexOf('USE') > -1) {\n\n\t\t\t\t\t\t\t\t\tvar defineKey = /USE\\s+([^\\s]+)/.exec(child.string)[1];\n\n\t\t\t\t\t\t\t\t\tpositions = defines[defineKey];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar skip = 0;\n\n\t\t\t\t\t\t// some shapes only have vertices for use in other shapes\n\n\t\t\t\t\t\tif (data.coordIndex) {\n\n\t\t\t\t\t\t\tvar newPositions = [];\n\t\t\t\t\t\t\tvar newUvs = [];\n\n\t\t\t\t\t\t\tposition = new THREE.Vector3();\n\t\t\t\t\t\t\tuv = new THREE.Vector2();\n\n\t\t\t\t\t\t\tfor (i = 0, il = data.coordIndex.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\tvar indexes = data.coordIndex[i];\n\n\t\t\t\t\t\t\t\t// VRML support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here\n\n\t\t\t\t\t\t\t\tskip = 0;\n\n\t\t\t\t\t\t\t\twhile (indexes.length >= 3 && skip < indexes.length - 2) {\n\n\t\t\t\t\t\t\t\t\tif (data.ccw === undefined) data.ccw = true; // ccw is true by default\n\n\t\t\t\t\t\t\t\t\tvar i1 = indexes[0];\n\t\t\t\t\t\t\t\t\tvar i2 = indexes[skip + (data.ccw ? 1 : 2)];\n\t\t\t\t\t\t\t\t\tvar i3 = indexes[skip + (data.ccw ? 2 : 1)];\n\n\t\t\t\t\t\t\t\t\t// create non indexed geometry, necessary for face normal generation\n\n\t\t\t\t\t\t\t\t\tposition.fromArray(positions, i1 * 3);\n\t\t\t\t\t\t\t\t\tuv.fromArray(uvs, i1 * 2);\n\t\t\t\t\t\t\t\t\tnewPositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\tnewUvs.push(uv.x, uv.y);\n\n\t\t\t\t\t\t\t\t\tposition.fromArray(positions, i2 * 3);\n\t\t\t\t\t\t\t\t\tuv.fromArray(uvs, i2 * 2);\n\t\t\t\t\t\t\t\t\tnewPositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\tnewUvs.push(uv.x, uv.y);\n\n\t\t\t\t\t\t\t\t\tposition.fromArray(positions, i3 * 3);\n\t\t\t\t\t\t\t\t\tuv.fromArray(uvs, i3 * 2);\n\t\t\t\t\t\t\t\t\tnewPositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\tnewUvs.push(uv.x, uv.y);\n\n\t\t\t\t\t\t\t\t\tskip++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositions = newPositions;\n\t\t\t\t\t\t\tuvs = newUvs;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// do not add dummy mesh to the scene\n\n\t\t\t\t\t\t\tparent.parent.remove(parent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (false === data.solid) {\n\n\t\t\t\t\t\t\tparent.material.side = THREE.DoubleSide;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// we need to store it on the geometry for use with defines\n\t\t\t\t\t\tgeometry.solid = data.solid;\n\n\t\t\t\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n\n\t\t\t\t\t\tif (uvs.length > 0) {\n\n\t\t\t\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\t\t\t// see if it's a define\n\t\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\t\tgeometry.name = /DEF ([^\\s]+)/.exec(data.string)[1];\n\t\t\t\t\t\t\tdefines[geometry.name] = geometry;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent.geometry = geometry;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t} else if (/appearance/.exec(data.string)) {\n\n\t\t\t\t\tfor (var i = 0; i < data.children.length; i++) {\n\n\t\t\t\t\t\tvar child = data.children[i];\n\n\t\t\t\t\t\tif (child.nodeType === 'Material') {\n\n\t\t\t\t\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\t\t\tif (child.diffuseColor !== undefined) {\n\n\t\t\t\t\t\t\t\tvar d = child.diffuseColor;\n\n\t\t\t\t\t\t\t\tmaterial.color.setRGB(d.r, d.g, d.b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (child.emissiveColor !== undefined) {\n\n\t\t\t\t\t\t\t\tvar e = child.emissiveColor;\n\n\t\t\t\t\t\t\t\tmaterial.emissive.setRGB(e.r, e.g, e.b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (child.specularColor !== undefined) {\n\n\t\t\t\t\t\t\t\tvar s = child.specularColor;\n\n\t\t\t\t\t\t\t\tmaterial.specular.setRGB(s.r, s.g, s.b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (child.transparency !== undefined) {\n\n\t\t\t\t\t\t\t\tvar t = child.transparency;\n\n\t\t\t\t\t\t\t\t// transparency is opposite of opacity\n\t\t\t\t\t\t\t\tmaterial.opacity = Math.abs(1 - t);\n\n\t\t\t\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\t\t\tmaterial.name = /DEF ([^\\s]+)/.exec(data.string)[1];\n\n\t\t\t\t\t\t\t\tdefines[material.name] = material;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tparent.material = material;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (child.nodeType === 'ImageTexture') {\n\n\t\t\t\t\t\t\tvar textureName = /\"([^\"]+)\"/.exec(child.children[0]);\n\n\t\t\t\t\t\t\tif (textureName) {\n\n\t\t\t\t\t\t\t\tparent.material.name = textureName[1];\n\n\t\t\t\t\t\t\t\tparent.material.map = textureLoader.load(texturePath + textureName[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, l = data.children.length; i < l; i++) {\n\n\t\t\t\t\tparseNode(data.children[i], object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparseNode(getTree(lines), scene);\n\t\t}\n\n\t\tvar scene = new THREE.Scene();\n\n\t\tvar lines = data.split('\\n');\n\n\t\t// some lines do not have breaks\n\n\t\tfor (var i = lines.length - 1; i > -1; i--) {\n\n\t\t\tvar line = lines[i];\n\n\t\t\t// split lines with {..{ or {..[ - some have both\n\t\t\tif (/{.*[{\\[]/.test(line)) {\n\n\t\t\t\tvar parts = line.split('{').join('{\\n').split('\\n');\n\t\t\t\tparts.unshift(1);\n\t\t\t\tparts.unshift(i);\n\t\t\t\tlines.splice.apply(lines, parts);\n\t\t\t} else if (/\\].*}/.test(line)) {\n\n\t\t\t\t// split lines with ]..}\n\t\t\t\tvar parts = line.split(']').join(']\\n').split('\\n');\n\t\t\t\tparts.unshift(1);\n\t\t\t\tparts.unshift(i);\n\t\t\t\tlines.splice.apply(lines, parts);\n\t\t\t}\n\n\t\t\tif (/}.*}/.test(line)) {\n\n\t\t\t\t// split lines with }..}\n\t\t\t\tvar parts = line.split('}').join('}\\n').split('\\n');\n\t\t\t\tparts.unshift(1);\n\t\t\t\tparts.unshift(i);\n\t\t\t\tlines.splice.apply(lines, parts);\n\t\t\t}\n\n\t\t\tif (/^\\b[^\\s]+\\b$/.test(line.trim())) {\n\n\t\t\t\t// prevent lines with single words like \"coord\" or \"geometry\", see #12209\n\t\t\t\tlines[i + 1] = line + ' ' + lines[i + 1].trim();\n\t\t\t\tlines.splice(i, 1);\n\t\t\t} else if (line.indexOf('coord') > -1 && line.indexOf('[') < 0 && line.indexOf('{') < 0) {\n\n\t\t\t\t// force the parser to create Coordinate node for empty coords\n\t\t\t\t// coord USE something -> coord USE something Coordinate {}\n\n\t\t\t\tlines[i] += ' Coordinate {}';\n\t\t\t}\n\t\t}\n\n\t\tvar header = lines.shift();\n\n\t\tif (/V1.0/.exec(header)) {\n\n\t\t\tconsole.warn('THREE.VRMLLoader: V1.0 not supported yet.');\n\t\t} else if (/V2.0/.exec(header)) {\n\n\t\t\tparseV2(lines, scene);\n\t\t}\n\n\t\treturn scene;\n\t}\n\n};\n\nexports.default = VRMLLoader;\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(5);\n\nvar _GLTFLoader2 = _interopRequireDefault(_GLTFLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Takahiro / https://github.com/takahirox\n */\n\n// VRM Specification: https://dwango.github.io/vrm/vrm_spec/\n//\n// VRM is based on glTF 2.0 and VRM extension is defined\n// in top-level json.extensions.VRM\n\nvar VRMLoader = function () {\n\n\tfunction VRMLoader(manager) {\n\n\t\tif (_GLTFLoader2.default === undefined) {\n\n\t\t\tthrow new Error('VRMLoader: Import GLTFLoader.');\n\t\t}\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\tthis.gltfLoader = new _GLTFLoader2.default(this.manager);\n\t}\n\n\tVRMLoader.prototype = {\n\n\t\tconstructor: VRMLoader,\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tthis.gltfLoader.load(url, onLoad, onProgress, onError);\n\t\t},\n\n\t\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\t\tthis.glTFLoader.setCrossOrigin(value);\n\t\t\treturn this;\n\t\t},\n\n\t\tsetPath: function setPath(value) {\n\n\t\t\tthis.glTFLoader.setPath(value);\n\t\t\treturn this;\n\t\t},\n\n\t\tsetDRACOLoader: function setDRACOLoader(dracoLoader) {\n\n\t\t\tthis.glTFLoader.setDRACOLoader(dracoLoader);\n\t\t\treturn this;\n\t\t}\n\n\t};\n\n\treturn VRMLoader;\n}();\n\nexports.default = VRMLoader;\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Loader for UTF8 version2 (after r51) encoded models generated by:\n *\thttp://code.google.com/p/webgl-loader/\n *\n * Code to load/decompress mesh is taken from r100 of this webgl-loader\n */\n\nvar UTF8Loader = function UTF8Loader() {};\n\n/**\n * Load UTF8 encoded model\n * @param jsonUrl - URL from which to load json containing information about model\n * @param callback - Callback(THREE.Object3D) on successful loading of model\n * @param options - options on how to load model (see THREE.MTLLoader.MaterialCreator for basic options)\n *                  Additional options include\n *                   geometryBase: Base url from which to load referenced geometries\n *                   materialBase: Base url from which to load referenced textures\n */\n\nUTF8Loader.prototype.load = function (jsonUrl, callback, options) {\n\n\tthis.downloadModelJson(jsonUrl, callback, options);\n};\n\n// BufferGeometryCreator\n\nUTF8Loader.BufferGeometryCreator = function () {};\n\nUTF8Loader.BufferGeometryCreator.prototype.create = function (attribArray, indices) {\n\n\tvar ntris = indices.length / 3;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new Float32Array(ntris * 3 * 3);\n\tvar normals = new Float32Array(ntris * 3 * 3);\n\tvar uvs = new Float32Array(ntris * 3 * 2);\n\n\tvar i, j, offset;\n\n\tvar end = attribArray.length;\n\tvar stride = 8;\n\n\t// extract positions\n\n\tj = 0;\n\toffset = 0;\n\n\tfor (i = offset; i < end; i += stride) {\n\n\t\tpositions[j++] = attribArray[i];\n\t\tpositions[j++] = attribArray[i + 1];\n\t\tpositions[j++] = attribArray[i + 2];\n\t}\n\n\t// extract uvs\n\n\tj = 0;\n\toffset = 3;\n\n\tfor (i = offset; i < end; i += stride) {\n\n\t\tuvs[j++] = attribArray[i];\n\t\tuvs[j++] = attribArray[i + 1];\n\t}\n\n\t// extract normals\n\n\tj = 0;\n\toffset = 5;\n\n\tfor (i = offset; i < end; i += stride) {\n\n\t\tnormals[j++] = attribArray[i];\n\t\tnormals[j++] = attribArray[i + 1];\n\t\tnormals[j++] = attribArray[i + 2];\n\t}\n\n\tgeometry.setIndex(new THREE.BufferAttribute(indices, 1));\n\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\tgeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\tgeometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n\n\tgeometry.computeBoundingSphere();\n\n\treturn geometry;\n};\n\n// UTF-8 decoder from webgl-loader (r100)\n// http://code.google.com/p/webgl-loader/\n\n// Model manifest description. Contains objects like:\n// name: {\n//   materials: { 'material_name': { ... } ... },\n//   decodeParams: {\n//     decodeOffsets: [ ... ],\n//     decodeScales: [ ... ],\n//   },\n//   urls: {\n//     'url': [\n//       { material: 'material_name',\n//         attribRange: [#, #],\n//         indexRange: [#, #],\n//         names: [ 'object names' ... ],\n//         lengths: [#, #, # ... ]\n//       }\n//     ],\n//     ...\n//   }\n// }\n\nvar DEFAULT_DECODE_PARAMS = {\n\n\tdecodeOffsets: [-4095, -4095, -4095, 0, 0, -511, -511, -511],\n\tdecodeScales: [1 / 8191, 1 / 8191, 1 / 8191, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023]\n\n\t// TODO: normal decoding? (see walt.js)\n\t// needs to know: input, output (from vertex format!)\n\t//\n\t// Should split attrib/index.\n\t// 1) Decode position and non-normal attributes.\n\t// 2) Decode indices, computing normals\n\t// 3) Maybe normalize normals? Only necessary for refinement, or fixed?\n\t// 4) Maybe refine normals? Should this be part of regular refinement?\n\t// 5) Morphing\n\n};\n\n// Triangle strips!\n\n// TODO: will it be an optimization to specialize this method at\n// runtime for different combinations of stride, decodeOffset and\n// decodeScale?\n\nUTF8Loader.prototype.decompressAttribsInner_ = function (str, inputStart, inputEnd, output, outputStart, stride, decodeOffset, decodeScale) {\n\n\tvar prev = 0;\n\n\tfor (var j = inputStart; j < inputEnd; j++) {\n\n\t\tvar code = str.charCodeAt(j);\n\t\tprev += code >> 1 ^ -(code & 1);\n\n\t\toutput[outputStart] = decodeScale * (prev + decodeOffset);\n\t\toutputStart += stride;\n\t}\n};\n\nUTF8Loader.prototype.decompressIndices_ = function (str, inputStart, numIndices, output, outputStart) {\n\n\tvar highest = 0;\n\n\tfor (var i = 0; i < numIndices; i++) {\n\n\t\tvar code = str.charCodeAt(inputStart++);\n\n\t\toutput[outputStart++] = highest - code;\n\n\t\tif (code === 0) {\n\n\t\t\thighest++;\n\t\t}\n\t}\n};\n\nUTF8Loader.prototype.decompressAABBs_ = function (str, inputStart, numBBoxen, decodeOffsets, decodeScales) {\n\n\tvar numFloats = 6 * numBBoxen;\n\n\tvar inputEnd = inputStart + numFloats;\n\tvar outputStart = 0;\n\n\tvar bboxen = new Float32Array(numFloats);\n\n\tfor (var i = inputStart; i < inputEnd; i += 6) {\n\n\t\tvar minX = str.charCodeAt(i + 0) + decodeOffsets[0];\n\t\tvar minY = str.charCodeAt(i + 1) + decodeOffsets[1];\n\t\tvar minZ = str.charCodeAt(i + 2) + decodeOffsets[2];\n\n\t\tvar radiusX = str.charCodeAt(i + 3) + 1 >> 1;\n\t\tvar radiusY = str.charCodeAt(i + 4) + 1 >> 1;\n\t\tvar radiusZ = str.charCodeAt(i + 5) + 1 >> 1;\n\n\t\tbboxen[outputStart++] = decodeScales[0] * (minX + radiusX);\n\t\tbboxen[outputStart++] = decodeScales[1] * (minY + radiusY);\n\t\tbboxen[outputStart++] = decodeScales[2] * (minZ + radiusZ);\n\n\t\tbboxen[outputStart++] = decodeScales[0] * radiusX;\n\t\tbboxen[outputStart++] = decodeScales[1] * radiusY;\n\t\tbboxen[outputStart++] = decodeScales[2] * radiusZ;\n\t}\n\n\treturn bboxen;\n};\n\nUTF8Loader.prototype.decompressMesh = function (str, meshParams, decodeParams, name, idx, callback) {\n\n\t// Extract conversion parameters from attribArrays.\n\n\tvar stride = decodeParams.decodeScales.length;\n\n\tvar decodeOffsets = decodeParams.decodeOffsets;\n\tvar decodeScales = decodeParams.decodeScales;\n\n\tvar attribStart = meshParams.attribRange[0];\n\tvar numVerts = meshParams.attribRange[1];\n\n\t// Decode attributes.\n\n\tvar inputOffset = attribStart;\n\tvar attribsOut = new Float32Array(stride * numVerts);\n\n\tfor (var j = 0; j < stride; j++) {\n\n\t\tvar end = inputOffset + numVerts;\n\n\t\tvar decodeScale = decodeScales[j];\n\n\t\tif (decodeScale) {\n\n\t\t\t// Assume if decodeScale is never set, simply ignore the\n\t\t\t// attribute.\n\n\t\t\tthis.decompressAttribsInner_(str, inputOffset, end, attribsOut, j, stride, decodeOffsets[j], decodeScale);\n\t\t}\n\n\t\tinputOffset = end;\n\t}\n\n\tvar numIndices = 3 * meshParams.indexRange[1];\n\n\tvar indicesOut = new Uint16Array(numIndices);\n\n\tthis.decompressIndices_(str, inputOffset, numIndices, indicesOut, 0);\n\n\t// Decode bboxen.\n\n\tvar bboxen = undefined;\n\tvar bboxOffset = meshParams.bboxes;\n\n\tif (bboxOffset) {\n\n\t\tbboxen = this.decompressAABBs_(str, bboxOffset, meshParams.names.length, decodeOffsets, decodeScales);\n\t}\n\n\tcallback(name, idx, attribsOut, indicesOut, bboxen, meshParams);\n};\n\nUTF8Loader.prototype.copyAttrib = function (stride, attribsOutFixed, lastAttrib, index) {\n\n\tfor (var j = 0; j < stride; j++) {\n\n\t\tlastAttrib[j] = attribsOutFixed[stride * index + j];\n\t}\n};\n\nUTF8Loader.prototype.decodeAttrib2 = function (str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, index) {\n\n\tfor (var j = 0; j < 5; j++) {\n\n\t\tvar code = str.charCodeAt(deltaStart + numVerts * j + index);\n\t\tvar delta = code >> 1 ^ -(code & 1);\n\n\t\tlastAttrib[j] += delta;\n\t\tattribsOutFixed[stride * index + j] = lastAttrib[j];\n\t\tattribsOut[stride * index + j] = decodeScales[j] * (lastAttrib[j] + decodeOffsets[j]);\n\t}\n};\n\nUTF8Loader.prototype.accumulateNormal = function (i0, i1, i2, attribsOutFixed, crosses) {\n\n\tvar p0x = attribsOutFixed[8 * i0];\n\tvar p0y = attribsOutFixed[8 * i0 + 1];\n\tvar p0z = attribsOutFixed[8 * i0 + 2];\n\n\tvar p1x = attribsOutFixed[8 * i1];\n\tvar p1y = attribsOutFixed[8 * i1 + 1];\n\tvar p1z = attribsOutFixed[8 * i1 + 2];\n\n\tvar p2x = attribsOutFixed[8 * i2];\n\tvar p2y = attribsOutFixed[8 * i2 + 1];\n\tvar p2z = attribsOutFixed[8 * i2 + 2];\n\n\tp1x -= p0x;\n\tp1y -= p0y;\n\tp1z -= p0z;\n\n\tp2x -= p0x;\n\tp2y -= p0y;\n\tp2z -= p0z;\n\n\tp0x = p1y * p2z - p1z * p2y;\n\tp0y = p1z * p2x - p1x * p2z;\n\tp0z = p1x * p2y - p1y * p2x;\n\n\tcrosses[3 * i0] += p0x;\n\tcrosses[3 * i0 + 1] += p0y;\n\tcrosses[3 * i0 + 2] += p0z;\n\n\tcrosses[3 * i1] += p0x;\n\tcrosses[3 * i1 + 1] += p0y;\n\tcrosses[3 * i1 + 2] += p0z;\n\n\tcrosses[3 * i2] += p0x;\n\tcrosses[3 * i2 + 1] += p0y;\n\tcrosses[3 * i2 + 2] += p0z;\n};\n\nUTF8Loader.prototype.decompressMesh2 = function (str, meshParams, decodeParams, name, idx, callback) {\n\n\tvar MAX_BACKREF = 96;\n\n\t// Extract conversion parameters from attribArrays.\n\n\tvar stride = decodeParams.decodeScales.length;\n\n\tvar decodeOffsets = decodeParams.decodeOffsets;\n\tvar decodeScales = decodeParams.decodeScales;\n\n\tvar deltaStart = meshParams.attribRange[0];\n\tvar numVerts = meshParams.attribRange[1];\n\n\tvar codeStart = meshParams.codeRange[0];\n\n\tvar numIndices = 3 * meshParams.codeRange[2];\n\n\tvar indicesOut = new Uint16Array(numIndices);\n\n\tvar crosses = new Int32Array(3 * numVerts);\n\n\tvar lastAttrib = new Uint16Array(stride);\n\n\tvar attribsOutFixed = new Uint16Array(stride * numVerts);\n\tvar attribsOut = new Float32Array(stride * numVerts);\n\n\tvar highest = 0;\n\tvar outputStart = 0;\n\n\tfor (var i = 0; i < numIndices; i += 3) {\n\n\t\tvar code = str.charCodeAt(codeStart++);\n\n\t\tvar max_backref = Math.min(i, MAX_BACKREF);\n\n\t\tif (code < max_backref) {\n\n\t\t\t// Parallelogram\n\n\t\t\tvar winding = code % 3;\n\t\t\tvar backref = i - (code - winding);\n\t\t\tvar i0, i1, i2;\n\n\t\t\tswitch (winding) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\ti0 = indicesOut[backref + 2];\n\t\t\t\t\ti1 = indicesOut[backref + 1];\n\t\t\t\t\ti2 = indicesOut[backref + 0];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\ti0 = indicesOut[backref + 0];\n\t\t\t\t\ti1 = indicesOut[backref + 2];\n\t\t\t\t\ti2 = indicesOut[backref + 1];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\ti0 = indicesOut[backref + 1];\n\t\t\t\t\ti1 = indicesOut[backref + 0];\n\t\t\t\t\ti2 = indicesOut[backref + 2];\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tindicesOut[outputStart++] = i0;\n\t\t\tindicesOut[outputStart++] = i1;\n\n\t\t\tcode = str.charCodeAt(codeStart++);\n\n\t\t\tvar index = highest - code;\n\t\t\tindicesOut[outputStart++] = index;\n\n\t\t\tif (code === 0) {\n\n\t\t\t\tfor (var j = 0; j < 5; j++) {\n\n\t\t\t\t\tvar deltaCode = str.charCodeAt(deltaStart + numVerts * j + highest);\n\n\t\t\t\t\tvar prediction = (deltaCode >> 1 ^ -(deltaCode & 1)) + attribsOutFixed[stride * i0 + j] + attribsOutFixed[stride * i1 + j] - attribsOutFixed[stride * i2 + j];\n\n\t\t\t\t\tlastAttrib[j] = prediction;\n\n\t\t\t\t\tattribsOutFixed[stride * highest + j] = prediction;\n\t\t\t\t\tattribsOut[stride * highest + j] = decodeScales[j] * (prediction + decodeOffsets[j]);\n\t\t\t\t}\n\n\t\t\t\thighest++;\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index);\n\t\t\t}\n\n\t\t\tthis.accumulateNormal(i0, i1, index, attribsOutFixed, crosses);\n\t\t} else {\n\n\t\t\t// Simple\n\n\t\t\tvar index0 = highest - (code - max_backref);\n\n\t\t\tindicesOut[outputStart++] = index0;\n\n\t\t\tif (code === max_backref) {\n\n\t\t\t\tthis.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index0);\n\t\t\t}\n\n\t\t\tcode = str.charCodeAt(codeStart++);\n\n\t\t\tvar index1 = highest - code;\n\t\t\tindicesOut[outputStart++] = index1;\n\n\t\t\tif (code === 0) {\n\n\t\t\t\tthis.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index1);\n\t\t\t}\n\n\t\t\tcode = str.charCodeAt(codeStart++);\n\n\t\t\tvar index2 = highest - code;\n\t\t\tindicesOut[outputStart++] = index2;\n\n\t\t\tif (code === 0) {\n\n\t\t\t\tfor (var j = 0; j < 5; j++) {\n\n\t\t\t\t\tlastAttrib[j] = (attribsOutFixed[stride * index0 + j] + attribsOutFixed[stride * index1 + j]) / 2;\n\t\t\t\t}\n\n\t\t\t\tthis.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index2);\n\t\t\t}\n\n\t\t\tthis.accumulateNormal(index0, index1, index2, attribsOutFixed, crosses);\n\t\t}\n\t}\n\n\tfor (var i = 0; i < numVerts; i++) {\n\n\t\tvar nx = crosses[3 * i];\n\t\tvar ny = crosses[3 * i + 1];\n\t\tvar nz = crosses[3 * i + 2];\n\n\t\tvar norm = 511.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n\n\t\tvar cx = str.charCodeAt(deltaStart + 5 * numVerts + i);\n\t\tvar cy = str.charCodeAt(deltaStart + 6 * numVerts + i);\n\t\tvar cz = str.charCodeAt(deltaStart + 7 * numVerts + i);\n\n\t\tattribsOut[stride * i + 5] = norm * nx + (cx >> 1 ^ -(cx & 1));\n\t\tattribsOut[stride * i + 6] = norm * ny + (cy >> 1 ^ -(cy & 1));\n\t\tattribsOut[stride * i + 7] = norm * nz + (cz >> 1 ^ -(cz & 1));\n\t}\n\n\tcallback(name, idx, attribsOut, indicesOut, undefined, meshParams);\n};\n\nUTF8Loader.prototype.downloadMesh = function (path, name, meshEntry, decodeParams, callback) {\n\n\tvar loader = this;\n\tvar idx = 0;\n\n\tfunction onprogress(data) {\n\n\t\twhile (idx < meshEntry.length) {\n\n\t\t\tvar meshParams = meshEntry[idx];\n\t\t\tvar indexRange = meshParams.indexRange;\n\n\t\t\tif (indexRange) {\n\n\t\t\t\tvar meshEnd = indexRange[0] + 3 * indexRange[1];\n\n\t\t\t\tif (data.length < meshEnd) break;\n\n\t\t\t\tloader.decompressMesh(data, meshParams, decodeParams, name, idx, callback);\n\t\t\t} else {\n\n\t\t\t\tvar codeRange = meshParams.codeRange;\n\t\t\t\tvar meshEnd = codeRange[0] + codeRange[1];\n\n\t\t\t\tif (data.length < meshEnd) break;\n\n\t\t\t\tloader.decompressMesh2(data, meshParams, decodeParams, name, idx, callback);\n\t\t\t}\n\n\t\t\t++idx;\n\t\t}\n\t}\n\n\tgetHttpRequest(path, function (data) {\n\n\t\tonprogress(data);\n\n\t\t// TODO: handle errors.\n\t});\n};\n\nUTF8Loader.prototype.downloadMeshes = function (path, meshUrlMap, decodeParams, callback) {\n\n\tfor (var url in meshUrlMap) {\n\n\t\tvar meshEntry = meshUrlMap[url];\n\t\tthis.downloadMesh(path + url, url, meshEntry, decodeParams, callback);\n\t}\n};\n\nUTF8Loader.prototype.createMeshCallback = function (materialBaseUrl, loadModelInfo, allDoneCallback) {\n\n\tvar nCompletedUrls = 0;\n\tvar nExpectedUrls = 0;\n\n\tvar expectedMeshesPerUrl = {};\n\tvar decodedMeshesPerUrl = {};\n\n\tvar modelParts = {};\n\n\tvar meshUrlMap = loadModelInfo.urls;\n\n\tfor (var url in meshUrlMap) {\n\n\t\texpectedMeshesPerUrl[url] = meshUrlMap[url].length;\n\t\tdecodedMeshesPerUrl[url] = 0;\n\n\t\tnExpectedUrls++;\n\n\t\tmodelParts[url] = new THREE.Object3D();\n\t}\n\n\tvar model = new THREE.Object3D();\n\n\t// Prepare materials first...\n\n\tvar materialCreator = new THREE.MTLLoader.MaterialCreator(materialBaseUrl, loadModelInfo.options);\n\tmaterialCreator.setMaterials(loadModelInfo.materials);\n\n\tmaterialCreator.preload();\n\n\t// Create callback for creating mesh parts\n\n\tvar bufferGeometryCreator = new UTF8Loader.BufferGeometryCreator();\n\n\tvar meshCallback = function meshCallback(name, idx, attribArray, indexArray, bboxen, meshParams) {\n\n\t\t// Got ourselves a new mesh\n\n\t\t// name identifies this part of the model (url)\n\t\t// idx is the mesh index of this mesh of the part\n\t\t// attribArray defines the vertices\n\t\t// indexArray defines the faces\n\t\t// bboxen defines the bounding box\n\t\t// meshParams contains the material info\n\n\t\tvar geometry = bufferGeometryCreator.create(attribArray, indexArray);\n\t\tvar material = materialCreator.create(meshParams.material);\n\n\t\tvar mesh = new THREE.Mesh(geometry, material);\n\t\tmodelParts[name].add(mesh);\n\n\t\t//model.add(new THREE.Mesh(geometry, material));\n\n\t\tdecodedMeshesPerUrl[name]++;\n\n\t\tif (decodedMeshesPerUrl[name] === expectedMeshesPerUrl[name]) {\n\n\t\t\tnCompletedUrls++;\n\n\t\t\tmodel.add(modelParts[name]);\n\n\t\t\tif (nCompletedUrls === nExpectedUrls) {\n\n\t\t\t\t// ALL DONE!!!\n\n\t\t\t\tallDoneCallback(model);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn meshCallback;\n};\n\nUTF8Loader.prototype.downloadModel = function (geometryBase, materialBase, model, callback) {\n\n\tvar meshCallback = this.createMeshCallback(materialBase, model, callback);\n\tthis.downloadMeshes(geometryBase, model.urls, model.decodeParams, meshCallback);\n};\n\nUTF8Loader.prototype.downloadModelJson = function (jsonUrl, callback, options) {\n\n\tgetJsonRequest(jsonUrl, function (loaded) {\n\n\t\tif (!loaded.decodeParams) {\n\n\t\t\tif (options && options.decodeParams) {\n\n\t\t\t\tloaded.decodeParams = options.decodeParams;\n\t\t\t} else {\n\n\t\t\t\tloaded.decodeParams = DEFAULT_DECODE_PARAMS;\n\t\t\t}\n\t\t}\n\n\t\tloaded.options = options;\n\n\t\tvar geometryBase = jsonUrl.substr(0, jsonUrl.lastIndexOf(\"/\") + 1);\n\t\tvar materialBase = geometryBase;\n\n\t\tif (options && options.geometryBase) {\n\n\t\t\tgeometryBase = options.geometryBase;\n\n\t\t\tif (geometryBase.charAt(geometryBase.length - 1) !== \"/\") {\n\n\t\t\t\tgeometryBase = geometryBase + \"/\";\n\t\t\t}\n\t\t}\n\n\t\tif (options && options.materialBase) {\n\n\t\t\tmaterialBase = options.materialBase;\n\n\t\t\tif (materialBase.charAt(materialBase.length - 1) !== \"/\") {\n\n\t\t\t\tmaterialBase = materialBase + \"/\";\n\t\t\t}\n\t\t}\n\n\t\tthis.downloadModel(geometryBase, materialBase, loaded, callback);\n\t}.bind(this));\n};\n\n// XMLHttpRequest stuff\n\nfunction getHttpRequest(url, onload, opt_onprogress) {\n\n\tvar req = new THREE.FileLoader();\n\treq.load(url, onload, opt_onprogress);\n}\n\nfunction getJsonRequest(url, onjson) {\n\n\tgetHttpRequest(url, function (e) {\n\n\t\tonjson(JSON.parse(e));\n\t}, function () {});\n}\n\nfunction addListeners(dom, listeners) {\n\n\t// TODO: handle event capture, object binding.\n\n\tfor (var key in listeners) {\n\n\t\tdom.addEventListener(key, listeners[key]);\n\t}\n}\n\nexports.default = UTF8Loader;\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Alex Pletzer\n *\n * Updated on 22.03.2017\n * VTK header is now parsed and used to extract all the compressed data\n * @author Andrii Iudin https://github.com/andreyyudin\n * @author Paul Kibet Korir https://github.com/polarise\n * @author Sriram Somasundharam https://github.com/raamssundar\n */\n\nvar VTKLoader = function VTKLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nObject.assign(VTKLoader.prototype, THREE.EventDispatcher.prototype, {\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction parseASCII(data) {\n\n\t\t\t// connectivity of the triangles\n\t\t\tvar indices = [];\n\n\t\t\t// triangles vertices\n\t\t\tvar positions = [];\n\n\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\tvar colors = [];\n\n\t\t\t// normal vector, one per vertex\n\t\t\tvar normals = [];\n\n\t\t\tvar result;\n\n\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\tvar pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t// the first integer is the number of polygon nodes\n\t\t\tvar patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t// indicates start of vertex data section\n\t\t\tvar patPOINTS = /^POINTS /;\n\n\t\t\t// indicates start of polygon connectivity section\n\t\t\tvar patPOLYGONS = /^POLYGONS /;\n\n\t\t\t// indicates start of triangle strips section\n\t\t\tvar patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t// POINT_DATA number_of_values\n\t\t\tvar patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t// CELL_DATA number_of_polys\n\t\t\tvar patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t// Start of color section\n\t\t\tvar patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t// NORMALS Normals float\n\t\t\tvar patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\tvar inPointsSection = false;\n\t\t\tvar inPolygonsSection = false;\n\t\t\tvar inTriangleStripSection = false;\n\t\t\tvar inPointDataSection = false;\n\t\t\tvar inCellDataSection = false;\n\t\t\tvar inColorSection = false;\n\t\t\tvar inNormalsSection = false;\n\n\t\t\tvar lines = data.split('\\n');\n\n\t\t\tfor (var i in lines) {\n\n\t\t\t\tvar line = lines[i];\n\n\t\t\t\tif (inPointsSection) {\n\n\t\t\t\t\t// get the vertices\n\t\t\t\t\twhile ((result = pat3Floats.exec(line)) !== null) {\n\n\t\t\t\t\t\tvar x = parseFloat(result[1]);\n\t\t\t\t\t\tvar y = parseFloat(result[2]);\n\t\t\t\t\t\tvar z = parseFloat(result[3]);\n\t\t\t\t\t\tpositions.push(x, y, z);\n\t\t\t\t\t}\n\t\t\t\t} else if (inPolygonsSection) {\n\n\t\t\t\t\tif ((result = patConnectivity.exec(line)) !== null) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tvar numVertices = parseInt(result[1]);\n\t\t\t\t\t\tvar inds = result[2].split(/\\s+/);\n\n\t\t\t\t\t\tif (numVertices >= 3) {\n\n\t\t\t\t\t\t\tvar i0 = parseInt(inds[0]);\n\t\t\t\t\t\t\tvar i1, i2;\n\t\t\t\t\t\t\tvar k = 1;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor (var j = 0; j < numVertices - 2; ++j) {\n\n\t\t\t\t\t\t\t\ti1 = parseInt(inds[k]);\n\t\t\t\t\t\t\t\ti2 = parseInt(inds[k + 1]);\n\t\t\t\t\t\t\t\tindices.push(i0, i1, i2);\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (inTriangleStripSection) {\n\n\t\t\t\t\tif ((result = patConnectivity.exec(line)) !== null) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tvar numVertices = parseInt(result[1]);\n\t\t\t\t\t\tvar inds = result[2].split(/\\s+/);\n\n\t\t\t\t\t\tif (numVertices >= 3) {\n\n\t\t\t\t\t\t\tvar i0, i1, i2;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor (var j = 0; j < numVertices - 2; j++) {\n\n\t\t\t\t\t\t\t\tif (j % 2 === 1) {\n\n\t\t\t\t\t\t\t\t\ti0 = parseInt(inds[j]);\n\t\t\t\t\t\t\t\t\ti1 = parseInt(inds[j + 2]);\n\t\t\t\t\t\t\t\t\ti2 = parseInt(inds[j + 1]);\n\t\t\t\t\t\t\t\t\tindices.push(i0, i1, i2);\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ti0 = parseInt(inds[j]);\n\t\t\t\t\t\t\t\t\ti1 = parseInt(inds[j + 1]);\n\t\t\t\t\t\t\t\t\ti2 = parseInt(inds[j + 2]);\n\t\t\t\t\t\t\t\t\tindices.push(i0, i1, i2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (inPointDataSection || inCellDataSection) {\n\n\t\t\t\t\tif (inColorSection) {\n\n\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\twhile ((result = pat3Floats.exec(line)) !== null) {\n\n\t\t\t\t\t\t\tvar r = parseFloat(result[1]);\n\t\t\t\t\t\t\tvar g = parseFloat(result[2]);\n\t\t\t\t\t\t\tvar b = parseFloat(result[3]);\n\t\t\t\t\t\t\tcolors.push(r, g, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (inNormalsSection) {\n\n\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\twhile ((result = pat3Floats.exec(line)) !== null) {\n\n\t\t\t\t\t\t\tvar nx = parseFloat(result[1]);\n\t\t\t\t\t\t\tvar ny = parseFloat(result[2]);\n\t\t\t\t\t\t\tvar nz = parseFloat(result[3]);\n\t\t\t\t\t\t\tnormals.push(nx, ny, nz);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (patPOLYGONS.exec(line) !== null) {\n\n\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patPOINTS.exec(line) !== null) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = true;\n\t\t\t\t} else if (patPOINT_DATA.exec(line) !== null) {\n\n\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patCELL_DATA.exec(line) !== null) {\n\n\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patCOLOR_SCALARS.exec(line) !== null) {\n\n\t\t\t\t\tinColorSection = true;\n\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patNORMALS.exec(line) !== null) {\n\n\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\tinColorSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar geometry;\n\t\t\tvar stagger = 'point';\n\n\t\t\tif (colors.length === indices.length) {\n\n\t\t\t\tstagger = 'cell';\n\t\t\t}\n\n\t\t\tif (stagger === 'point') {\n\n\t\t\t\t// Nodal. Use BufferGeometry\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));\n\n\t\t\t\tif (colors.length === positions.length) {\n\n\t\t\t\t\tgeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));\n\t\t\t\t}\n\n\t\t\t\tif (normals.length === positions.length) {\n\n\t\t\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Cell centered colors. The only way to attach a solid color to each triangle\n\t\t\t\t// is to use Geometry, which is less efficient than BufferGeometry\n\t\t\t\tgeometry = new THREE.Geometry();\n\n\t\t\t\tvar numTriangles = indices.length / 3;\n\t\t\t\tvar numPoints = positions.length / 3;\n\t\t\t\tvar face;\n\t\t\t\tvar ia, ib, ic;\n\t\t\t\tvar x, y, z;\n\t\t\t\tvar r, g, b;\n\n\t\t\t\tfor (var j = 0; j < numPoints; ++j) {\n\n\t\t\t\t\tx = positions[3 * j + 0];\n\t\t\t\t\ty = positions[3 * j + 1];\n\t\t\t\t\tz = positions[3 * j + 2];\n\t\t\t\t\tgeometry.vertices.push(new THREE.Vector3(x, y, z));\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < numTriangles; ++i) {\n\n\t\t\t\t\tia = indices[3 * i + 0];\n\t\t\t\t\tib = indices[3 * i + 1];\n\t\t\t\t\tic = indices[3 * i + 2];\n\t\t\t\t\tgeometry.faces.push(new THREE.Face3(ia, ib, ic));\n\t\t\t\t}\n\n\t\t\t\tif (colors.length === numTriangles * 3) {\n\n\t\t\t\t\tfor (var i = 0; i < numTriangles; ++i) {\n\n\t\t\t\t\t\tface = geometry.faces[i];\n\t\t\t\t\t\tr = colors[3 * i + 0];\n\t\t\t\t\t\tg = colors[3 * i + 1];\n\t\t\t\t\t\tb = colors[3 * i + 2];\n\t\t\t\t\t\tface.color = new THREE.Color().setRGB(r, g, b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseBinary(data) {\n\n\t\t\tvar count, pointIndex, i, numberOfPoints, s;\n\t\t\tvar buffer = new Uint8Array(data);\n\t\t\tvar dataView = new DataView(data);\n\n\t\t\t// Points and normals, by default, are empty\n\t\t\tvar points = [];\n\t\t\tvar normals = [];\n\t\t\tvar indices = [];\n\n\t\t\t// Going to make a big array of strings\n\t\t\tvar vtk = [];\n\t\t\tvar index = 0;\n\n\t\t\tfunction findString(buffer, start) {\n\n\t\t\t\tvar index = start;\n\t\t\t\tvar c = buffer[index];\n\t\t\t\tvar s = [];\n\t\t\t\twhile (c !== 10) {\n\n\t\t\t\t\ts.push(String.fromCharCode(c));\n\t\t\t\t\tindex++;\n\t\t\t\t\tc = buffer[index];\n\t\t\t\t}\n\n\t\t\t\treturn { start: start,\n\t\t\t\t\tend: index,\n\t\t\t\t\tnext: index + 1,\n\t\t\t\t\tparsedString: s.join('') };\n\t\t\t}\n\n\t\t\tvar state, line;\n\n\t\t\twhile (true) {\n\n\t\t\t\t// Get a string\n\t\t\t\tstate = findString(buffer, index);\n\t\t\t\tline = state.parsedString;\n\n\t\t\t\tif (line.indexOf('POINTS') === 0) {\n\n\t\t\t\t\tvtk.push(line);\n\t\t\t\t\t// Add the points\n\t\t\t\t\tnumberOfPoints = parseInt(line.split(' ')[1], 10);\n\n\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tpoints = new Float32Array(numberOfPoints * 3);\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfPoints; i++) {\n\n\t\t\t\t\t\tpoints[3 * i] = dataView.getFloat32(pointIndex, false);\n\t\t\t\t\t\tpoints[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n\t\t\t\t\t\tpoints[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\t\t\t\t\t}\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\t\t\t\t} else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n\n\t\t\t\t\tvar numberOfStrips = parseInt(line.split(' ')[1], 10);\n\t\t\t\t\tvar size = parseInt(line.split(' ')[2], 10);\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfStrips);\n\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfStrips; i++) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tvar indexCount = dataView.getInt32(pointIndex, false);\n\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor (s = 0; s < indexCount; s++) {\n\n\t\t\t\t\t\t\tstrip.push(dataView.getInt32(pointIndex, false));\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\tfor (var j = 0; j < indexCount - 2; j++) {\n\n\t\t\t\t\t\t\tif (j % 2) {\n\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\t\t\t\t} else if (line.indexOf('POLYGONS') === 0) {\n\n\t\t\t\t\tvar numberOfStrips = parseInt(line.split(' ')[1], 10);\n\t\t\t\t\tvar size = parseInt(line.split(' ')[2], 10);\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfStrips);\n\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfStrips; i++) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tvar indexCount = dataView.getInt32(pointIndex, false);\n\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor (s = 0; s < indexCount; s++) {\n\n\t\t\t\t\t\t\tstrip.push(dataView.getInt32(pointIndex, false));\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\tfor (var j = 1; j < indexCount - 1; j++) {\n\n\t\t\t\t\t\t\tindices[indicesIndex++] = strip[0];\n\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\t\t\t\t} else if (line.indexOf('POINT_DATA') === 0) {\n\n\t\t\t\t\tnumberOfPoints = parseInt(line.split(' ')[1], 10);\n\n\t\t\t\t\t// Grab the next line\n\t\t\t\t\tstate = findString(buffer, state.next);\n\n\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tnormals = new Float32Array(numberOfPoints * 3);\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfPoints; i++) {\n\n\t\t\t\t\t\tnormals[3 * i] = dataView.getFloat32(pointIndex, false);\n\t\t\t\t\t\tnormals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n\t\t\t\t\t\tnormals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n\t\t\t\t\t\tpointIndex += 12;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment past our data\n\t\t\t\t\tstate.next = state.next + count;\n\t\t\t\t}\n\n\t\t\t\t// Increment index\n\t\t\t\tindex = state.next;\n\n\t\t\t\tif (index >= buffer.byteLength) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tgeometry.setIndex(new THREE.BufferAttribute(indices, 1));\n\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(points, 3));\n\n\t\t\tif (normals.length === points.length) {\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction Float32Concat(first, second) {\n\n\t\t\tvar firstLength = first.length,\n\t\t\t    result = new Float32Array(firstLength + second.length);\n\n\t\t\tresult.set(first);\n\t\t\tresult.set(second, firstLength);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction Int32Concat(first, second) {\n\n\t\t\tvar firstLength = first.length,\n\t\t\t    result = new Int32Array(firstLength + second.length);\n\n\t\t\tresult.set(first);\n\t\t\tresult.set(second, firstLength);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction parseXML(stringFile) {\n\n\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\tfunction xmlToJson(xml) {\n\n\t\t\t\t// Create the return object\n\t\t\t\tvar obj = {};\n\n\t\t\t\tif (xml.nodeType === 1) {\n\t\t\t\t\t// element\n\n\t\t\t\t\t// do attributes\n\n\t\t\t\t\tif (xml.attributes) {\n\n\t\t\t\t\t\tif (xml.attributes.length > 0) {\n\n\t\t\t\t\t\t\tobj['attributes'] = {};\n\n\t\t\t\t\t\t\tfor (var j = 0; j < xml.attributes.length; j++) {\n\n\t\t\t\t\t\t\t\tvar attribute = xml.attributes.item(j);\n\t\t\t\t\t\t\t\tobj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (xml.nodeType === 3) {\n\t\t\t\t\t// text\n\n\t\t\t\t\tobj = xml.nodeValue.trim();\n\t\t\t\t}\n\n\t\t\t\t// do children\n\t\t\t\tif (xml.hasChildNodes()) {\n\n\t\t\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\t\t\tvar item = xml.childNodes.item(i);\n\t\t\t\t\t\tvar nodeName = item.nodeName;\n\n\t\t\t\t\t\tif (typeof obj[nodeName] === 'undefined') {\n\n\t\t\t\t\t\t\tvar tmp = xmlToJson(item);\n\n\t\t\t\t\t\t\tif (tmp !== '') obj[nodeName] = tmp;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (typeof obj[nodeName].push === 'undefined') {\n\n\t\t\t\t\t\t\t\tvar old = obj[nodeName];\n\t\t\t\t\t\t\t\tobj[nodeName] = [old];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar tmp = xmlToJson(item);\n\n\t\t\t\t\t\t\tif (tmp !== '') obj[nodeName].push(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\t// Taken from Base64-js\n\t\t\tfunction Base64toByteArray(b64) {\n\n\t\t\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\tvar i;\n\t\t\t\tvar lookup = [];\n\t\t\t\tvar revLookup = [];\n\t\t\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\t\tvar len = code.length;\n\n\t\t\t\tfor (i = 0; i < len; i++) {\n\n\t\t\t\t\tlookup[i] = code[i];\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < len; ++i) {\n\n\t\t\t\t\trevLookup[code.charCodeAt(i)] = i;\n\t\t\t\t}\n\n\t\t\t\trevLookup['-'.charCodeAt(0)] = 62;\n\t\t\t\trevLookup['_'.charCodeAt(0)] = 63;\n\n\t\t\t\tvar j, l, tmp, placeHolders, arr;\n\t\t\t\tvar len = b64.length;\n\n\t\t\t\tif (len % 4 > 0) {\n\n\t\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4');\n\t\t\t\t}\n\n\t\t\t\tplaceHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\t\t\t\tarr = new Arr(len * 3 / 4 - placeHolders);\n\t\t\t\tl = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\tvar L = 0;\n\n\t\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\n\t\t\t\t\ttmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n\t\t\t\t\tarr[L++] = (tmp & 0xFF0000) >> 16;\n\t\t\t\t\tarr[L++] = (tmp & 0xFF00) >> 8;\n\t\t\t\t\tarr[L++] = tmp & 0xFF;\n\t\t\t\t}\n\n\t\t\t\tif (placeHolders === 2) {\n\n\t\t\t\t\ttmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n\t\t\t\t\tarr[L++] = tmp & 0xFF;\n\t\t\t\t} else if (placeHolders === 1) {\n\n\t\t\t\t\ttmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n\t\t\t\t\tarr[L++] = tmp >> 8 & 0xFF;\n\t\t\t\t\tarr[L++] = tmp & 0xFF;\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\t\t\t}\n\n\t\t\tfunction parseDataArray(ele, compressed) {\n\n\t\t\t\tvar numBytes = 0;\n\n\t\t\t\tif (json.attributes.header_type === 'UInt64') {\n\n\t\t\t\t\tnumBytes = 8;\n\t\t\t\t} else if (json.attributes.header_type === 'UInt32') {\n\n\t\t\t\t\tnumBytes = 4;\n\t\t\t\t}\n\n\t\t\t\t// Check the format\n\t\t\t\tif (ele.attributes.format === 'binary' && compressed) {\n\n\t\t\t\t\tvar rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\tvar txt = new Float32Array();\n\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\tvar txt = new Int32Array();\n\t\t\t\t\t}\n\n\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t//\n\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t//\n\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\trawData = ele['#text'];\n\n\t\t\t\t\tbyteData = Base64toByteArray(rawData);\n\n\t\t\t\t\tblocks = byteData[0];\n\t\t\t\t\tfor (var i = 1; i < numBytes - 1; i++) {\n\n\t\t\t\t\t\tblocks = blocks | byteData[i] << i * numBytes;\n\t\t\t\t\t}\n\n\t\t\t\t\theaderSize = (blocks + 3) * numBytes;\n\t\t\t\t\tpadding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\tdataOffsets = [];\n\t\t\t\t\tcurrentOffset = headerSize;\n\t\t\t\t\tdataOffsets.push(currentOffset);\n\n\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\tcSizeStart = 3 * numBytes;\n\n\t\t\t\t\tfor (var i = 0; i < blocks; i++) {\n\n\t\t\t\t\t\tvar currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n\t\t\t\t\t\tfor (var j = 1; j < numBytes - 1; j++) {\n\n\t\t\t\t\t\t\t// Each data point consists of 8 bytes regardless of the header type\n\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\tdataOffsets.push(currentOffset);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < dataOffsets.length - 1; i++) {\n\n\t\t\t\t\t\tvar inflate = new Zlib.Inflate(byteData.slice(dataOffsets[i], dataOffsets[i + 1]), { resize: true, verify: true }); // eslint-disable-line no-undef\n\t\t\t\t\t\tcontent = inflate.decompress();\n\t\t\t\t\t\tcontent = content.buffer;\n\n\t\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\t\tcontent = new Float32Array(content);\n\t\t\t\t\t\t\ttxt = Float32Concat(txt, content);\n\t\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\t\tcontent = new Int32Array(content);\n\t\t\t\t\t\t\ttxt = Int32Concat(txt, content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele['#text'];\n\n\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\tif (ele.attributes.format === 'binary') {\n\n\t\t\t\t\t\t\tif (!compressed) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\t\tif (idx !== 0) return true;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\tif (ele.attributes.format === 'binary') {\n\n\t\t\t\t\t\t\tif (!compressed) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\t\tif (idx !== 0) return true;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\tif (idx % 2 !== 1) return true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (ele.attributes.format === 'binary' && !compressed) {\n\n\t\t\t\t\t\tvar content = Base64toByteArray(ele['#text']);\n\n\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\tcontent = content.slice(numBytes).buffer;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif (ele['#text']) {\n\n\t\t\t\t\t\t\tvar content = ele['#text'].split(/\\s+/).filter(function (el) {\n\n\t\t\t\t\t\t\t\tif (el !== '') return el;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar content = new Int32Array(0).buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele['#text'];\n\n\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\tvar txt = new Float32Array(content);\n\t\t\t\t\t} else if (ele.attributes.type === 'Int32') {\n\n\t\t\t\t\t\tvar txt = new Int32Array(content);\n\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\tvar txt = new Int32Array(content);\n\n\t\t\t\t\t\tif (ele.attributes.format === 'binary') {\n\n\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\tif (idx % 2 !== 1) return true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\treturn txt;\n\t\t\t}\n\n\t\t\t// Main part\n\t\t\t// Get Dom\n\t\t\tvar dom = null;\n\n\t\t\tif (window.DOMParser) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tdom = new DOMParser().parseFromString(stringFile, 'text/xml');\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tdom = null;\n\t\t\t\t}\n\t\t\t} else if (window.ActiveXObject) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tdom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\t\t\t\t\tdom.async = false;\n\n\t\t\t\t\tif (!dom.loadXML()) {\n\n\t\t\t\t\t\tthrow new Error(dom.parseError.reason + dom.parseError.srcText);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tdom = null;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('Cannot parse xml string!');\n\t\t\t}\n\n\t\t\t// Get the doc\n\t\t\tvar doc = dom.documentElement;\n\t\t\t// Convert to json\n\t\t\tvar json = xmlToJson(doc);\n\t\t\tvar points = [];\n\t\t\tvar normals = [];\n\t\t\tvar indices = [];\n\n\t\t\tif (json.PolyData) {\n\n\t\t\t\tvar piece = json.PolyData.Piece;\n\t\t\t\tvar compressed = json.attributes.hasOwnProperty('compressor');\n\n\t\t\t\t// Can be optimized\n\t\t\t\t// Loop through the sections\n\t\t\t\tvar sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\t\t\t\tvar sectionIndex = 0,\n\t\t\t\t    numberOfSections = sections.length;\n\n\t\t\t\twhile (sectionIndex < numberOfSections) {\n\n\t\t\t\t\tvar section = piece[sections[sectionIndex]];\n\n\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\tif (section && section.DataArray) {\n\n\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\tif (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n\n\t\t\t\t\t\t\tvar arr = section.DataArray;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar arr = [section.DataArray];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar dataArrayIndex = 0,\n\t\t\t\t\t\t    numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\twhile (dataArrayIndex < numberOfDataArrays) {\n\n\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\tif ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n\n\t\t\t\t\t\t\t\tarr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdataArrayIndex++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (sections[sectionIndex]) {\n\n\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\t\t\t\t\t\t\t\tvar normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\tif (numberOfPoints > 0) {\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, len = arr.length; i < len; i++) {\n\n\t\t\t\t\t\t\t\t\t\tif (normalsName === arr[i].attributes.Name) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar components = arr[i].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array(numberOfPoints * components);\n\t\t\t\t\t\t\t\t\t\t\tnormals.set(arr[i].text, 0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n\t\t\t\t\t\t\t\tif (numberOfPoints > 0) {\n\n\t\t\t\t\t\t\t\t\tvar components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\tpoints = new Float32Array(numberOfPoints * components);\n\t\t\t\t\t\t\t\t\tpoints.set(section.DataArray.text, 0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\tvar numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n\t\t\t\t\t\t\t\tif (numberOfStrips > 0) {\n\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array(section.DataArray[0].text.length);\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array(section.DataArray[1].text.length);\n\t\t\t\t\t\t\t\t\tconnectivity.set(section.DataArray[0].text, 0);\n\t\t\t\t\t\t\t\t\toffset.set(section.DataArray[1].text, 0);\n\n\t\t\t\t\t\t\t\t\tvar size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfStrips);\n\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, len = numberOfStrips; i < len; i++) {\n\n\t\t\t\t\t\t\t\t\t\tvar strip = [];\n\n\t\t\t\t\t\t\t\t\t\tfor (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n\n\t\t\t\t\t\t\t\t\t\t\tstrip.push(connectivity[s]);\n\n\t\t\t\t\t\t\t\t\t\t\tif (i > 0) len0 = offset[i - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tfor (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\tif (j % 2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (i > 0) len0 = offset[i - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\tvar numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n\t\t\t\t\t\t\t\tif (numberOfPolys > 0) {\n\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array(section.DataArray[0].text.length);\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array(section.DataArray[1].text.length);\n\t\t\t\t\t\t\t\t\tconnectivity.set(section.DataArray[0].text, 0);\n\t\t\t\t\t\t\t\t\toffset.set(section.DataArray[1].text, 0);\n\n\t\t\t\t\t\t\t\t\tvar size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfPolys);\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0,\n\t\t\t\t\t\t\t\t\t    connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\t\t\t\t    len = numberOfPolys,\n\t\t\t\t\t\t\t\t\t    len0 = 0;\n\n\t\t\t\t\t\t\t\t\twhile (i < len) {\n\n\t\t\t\t\t\t\t\t\t\tvar poly = [];\n\t\t\t\t\t\t\t\t\t\tvar s = 0,\n\t\t\t\t\t\t\t\t\t\t    len1 = offset[i];\n\n\t\t\t\t\t\t\t\t\t\twhile (s < len1 - len0) {\n\n\t\t\t\t\t\t\t\t\t\t\tpoly.push(connectivity[connectivityIndex++]);\n\t\t\t\t\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar j = 1;\n\n\t\t\t\t\t\t\t\t\t\twhile (j < len1 - len0 - 1) {\n\n\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = poly[0];\n\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = poly[j];\n\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = poly[j + 1];\n\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\tlen0 = offset[i - 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsectionIndex++;\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex(new THREE.BufferAttribute(indices, 1));\n\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(points, 3));\n\n\t\t\t\tif (normals.length === points.length) {\n\n\t\t\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\t\t\t} else {\n\n\t\t\t\t// TODO for vtu,vti,and other xml formats\n\n\t\t\t}\n\t\t}\n\n\t\tfunction getStringFile(data) {\n\n\t\t\tvar stringFile = '';\n\t\t\tvar charArray = new Uint8Array(data);\n\t\t\tvar i = 0;\n\t\t\tvar len = charArray.length;\n\n\t\t\twhile (len--) {\n\n\t\t\t\tstringFile += String.fromCharCode(charArray[i++]);\n\t\t\t}\n\n\t\t\treturn stringFile;\n\t\t}\n\n\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\tvar meta = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n\t\tif (meta[0].indexOf('xml') !== -1) {\n\n\t\t\treturn parseXML(getStringFile(data));\n\t\t} else if (meta[2].includes('ASCII')) {\n\n\t\t\treturn parseASCII(getStringFile(data));\n\t\t} else {\n\n\t\t\treturn parseBinary(data);\n\t\t}\n\t}\n\n});\n\nexports.default = VTKLoader;\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// ( function ( global, factory ) {\n//\n// \ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n// \t\ttypeof define === 'function' && define.amd ? define( factory ) :\n// \t\t\t( global.THREE = global.THREE || {}, global.THREE.XLoader = factory() );\n//\n// }( this, ( function () {\n\n'use strict';\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n\n\tif (!(instance instanceof Constructor)) {\n\n\t\tthrow new TypeError(\"Cannot call a class as a function\");\n\t}\n};\n\nvar createClass = function () {\n\n\tfunction defineProperties(target, props) {\n\n\t\tfor (var i = 0; i < props.length; i++) {\n\n\t\t\tvar descriptor = props[i];\n\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\tdescriptor.configurable = true;\n\t\t\tif (\"value\" in descriptor) descriptor.writable = true;\n\t\t\tObject.defineProperty(target, descriptor.key, descriptor);\n\t\t}\n\t}\n\n\treturn function (Constructor, protoProps, staticProps) {\n\n\t\tif (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\tif (staticProps) defineProperties(Constructor, staticProps);\n\t\treturn Constructor;\n\t};\n}();\n\nvar XboneInf = function XboneInf() {\n\n\tclassCallCheck(this, XboneInf);\n\n\tthis.boneName = \"\";\n\tthis.BoneIndex = 0;\n\tthis.Indeces = [];\n\tthis.Weights = [];\n\tthis.initMatrix = null;\n\tthis.OffsetMatrix = null;\n};\n\nvar XAnimationInfo = function XAnimationInfo() {\n\n\tclassCallCheck(this, XAnimationInfo);\n\n\tthis.animeName = \"\";\n\tthis.boneName = \"\";\n\tthis.targetBone = null;\n\tthis.keyType = 4;\n\tthis.frameStartLv = 0;\n\tthis.keyFrames = [];\n\tthis.InverseMx = null;\n};\n\nvar XAnimationObj = function () {\n\n\tfunction XAnimationObj(_flags) {\n\n\t\tclassCallCheck(this, XAnimationObj);\n\n\t\tthis.fps = 30;\n\t\tthis.name = 'xanimation';\n\t\tthis.length = 0;\n\t\tthis.hierarchy = [];\n\t\tthis.putFlags = _flags;\n\t\tif (this.putFlags.putPos === undefined) {\n\n\t\t\tthis.putFlags.putPos = true;\n\t\t}\n\t\tif (this.putFlags.putRot === undefined) {\n\n\t\t\tthis.putFlags.putRot = true;\n\t\t}\n\t\tif (this.putFlags.putScl === undefined) {\n\n\t\t\tthis.putFlags.putScl = true;\n\t\t}\n\t}\n\n\tcreateClass(XAnimationObj, [{\n\t\tkey: \"make\",\n\t\tvalue: function make(XAnimationInfoArray) {\n\n\t\t\tfor (var i = 0; i < XAnimationInfoArray.length; i++) {\n\n\t\t\t\tthis.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i]));\n\t\t\t}\n\t\t\tthis.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;\n\t\t}\n\t}, {\n\t\tkey: \"clone\",\n\t\tvalue: function clone() {\n\n\t\t\treturn Object.assign({}, this);\n\t\t}\n\t}, {\n\t\tkey: \"makeBonekeys\",\n\t\tvalue: function makeBonekeys(XAnimationInfo) {\n\n\t\t\tvar refObj = {};\n\t\t\trefObj.name = XAnimationInfo.boneName;\n\t\t\trefObj.parent = \"\";\n\t\t\trefObj.keys = this.keyFrameRefactor(XAnimationInfo);\n\t\t\trefObj.copy = function () {\n\n\t\t\t\treturn Object.assign({}, this);\n\t\t\t};\n\t\t\treturn refObj;\n\t\t}\n\t}, {\n\t\tkey: \"keyFrameRefactor\",\n\t\tvalue: function keyFrameRefactor(XAnimationInfo) {\n\n\t\t\tvar keys = [];\n\t\t\tfor (var i = 0; i < XAnimationInfo.keyFrames.length; i++) {\n\n\t\t\t\tvar keyframe = {};\n\t\t\t\tkeyframe.time = XAnimationInfo.keyFrames[i].time * this.fps;\n\t\t\t\tif (XAnimationInfo.keyFrames[i].pos && this.putFlags.putPos) {\n\n\t\t\t\t\tkeyframe.pos = XAnimationInfo.keyFrames[i].pos;\n\t\t\t\t}\n\t\t\t\tif (XAnimationInfo.keyFrames[i].rot && this.putFlags.putRot) {\n\n\t\t\t\t\tkeyframe.rot = XAnimationInfo.keyFrames[i].rot;\n\t\t\t\t}\n\t\t\t\tif (XAnimationInfo.keyFrames[i].scl && this.putFlags.putScl) {\n\n\t\t\t\t\tkeyframe.scl = XAnimationInfo.keyFrames[i].scl;\n\t\t\t\t}\n\t\t\t\tif (XAnimationInfo.keyFrames[i].matrix) {\n\n\t\t\t\t\tkeyframe.matrix = XAnimationInfo.keyFrames[i].matrix;\n\t\t\t\t\tif (this.putFlags.putPos) {\n\n\t\t\t\t\t\tkeyframe.pos = new THREE.Vector3().setFromMatrixPosition(keyframe.matrix);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.putFlags.putRot) {\n\n\t\t\t\t\t\tkeyframe.rot = new THREE.Quaternion().setFromRotationMatrix(keyframe.matrix);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.putFlags.putScl) {\n\n\t\t\t\t\t\tkeyframe.scl = new THREE.Vector3().setFromMatrixScale(keyframe.matrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeys.push(keyframe);\n\t\t\t}\n\t\t\treturn keys;\n\t\t}\n\t}]);\n\treturn XAnimationObj;\n}();\n\nvar XKeyFrameInfo = function XKeyFrameInfo() {\n\n\tclassCallCheck(this, XKeyFrameInfo);\n\n\tthis.index = 0;\n\tthis.Frame = 0;\n\tthis.time = 0.0;\n\tthis.matrix = null;\n};\n\nvar XLoader = function () {\n\n\tfunction XLoader(manager, texloader) {\n\n\t\tclassCallCheck(this, XLoader);\n\n\t\tthis.debug = false;\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\tthis.texloader = texloader !== undefined ? texloader : new THREE.TextureLoader();\n\t\tthis.url = \"\";\n\t\tthis.baseDir = \"\";\n\t\tthis._putMatLength = 0;\n\t\tthis._nowMat = null;\n\t\tthis._tmpUvArray = [];\n\t\tthis._facesNormal = [];\n\t\tthis._nowFrameName = \"\";\n\t\tthis.frameHierarchie = [];\n\t\tthis.Hierarchies = {};\n\t\tthis.HieStack = [];\n\t\tthis._currentObject = {};\n\t\tthis._currentFrame = {};\n\t\tthis._data = null;\n\t\tthis.onLoad = null;\n\t\tthis.IsUvYReverse = true;\n\t\tthis.Meshes = [];\n\t\tthis.animations = [];\n\t\tthis.animTicksPerSecond = 30;\n\t\tthis._currentGeo = null;\n\t\tthis._currentAnime = null;\n\t\tthis._currentAnimeFrames = null;\n\t}\n\n\tcreateClass(XLoader, [{\n\t\tkey: '_setArgOption',\n\t\tvalue: function _setArgOption(_arg) {\n\n\t\t\tvar _start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\t\tif (!_arg) {\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (var i = _start; i < _arg.length; i++) {\n\n\t\t\t\tswitch (i) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tthis.url = _arg[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tthis.options = _arg[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options === undefined) {\n\n\t\t\t\tthis.options = {};\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'load',\n\t\tvalue: function load(_arg, onLoad, onProgress, onError) {\n\n\t\t\tvar _this = this;\n\n\t\t\tthis._setArgOption(_arg);\n\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.load(this.url, function (response) {\n\n\t\t\t\t_this._parse(response, onLoad);\n\t\t\t}, onProgress, onError);\n\t\t}\n\t}, {\n\t\tkey: 'fromResponsedData',\n\t\tvalue: function fromResponsedData(_data, _arg, onLoad) {\n\n\t\t\tthis._setArgOption(_arg);\n\t\t\tthis._parse(_data, onLoad);\n\t\t}\n\t}, {\n\t\tkey: '_readLine',\n\t\tvalue: function _readLine(line) {\n\n\t\t\tvar readed = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tvar find = -1;\n\t\t\t\tfind = line.indexOf('//', readed);\n\t\t\t\tif (find === -1) {\n\n\t\t\t\t\tfind = line.indexOf('#', readed);\n\t\t\t\t}\n\t\t\t\tif (find > -1 && find < 2) {\n\n\t\t\t\t\tvar foundNewLine = -1;\n\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\\n\", readed);\n\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\treaded = foundNewLine + 2;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\", readed);\n\t\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treaded = line.indexOf(\"\\n\", readed) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn line.substr(readed);\n\t\t}\n\t}, {\n\t\tkey: '_readLine',\n\t\tvalue: function _readLine(line) {\n\n\t\t\tvar readed = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tvar find = -1;\n\t\t\t\tfind = line.indexOf('//', readed);\n\t\t\t\tif (find === -1) {\n\n\t\t\t\t\tfind = line.indexOf('#', readed);\n\t\t\t\t}\n\t\t\t\tif (find > -1 && find < 2) {\n\n\t\t\t\t\tvar foundNewLine = -1;\n\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\\n\", readed);\n\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\treaded = foundNewLine + 2;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\", readed);\n\t\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treaded = line.indexOf(\"\\n\", readed) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn line.substr(readed);\n\t\t}\n\t}, {\n\t\tkey: '_isBinary',\n\t\tvalue: function _isBinary(binData) {\n\n\t\t\tvar reader = new DataView(binData);\n\t\t\tvar face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n\t\t\tvar n_faces = reader.getUint32(80, true);\n\t\t\tvar expect = 80 + 32 / 8 + n_faces * face_size;\n\t\t\tif (expect === reader.byteLength) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar fileLength = reader.byteLength;\n\t\t\tfor (var index = 0; index < fileLength; index++) {\n\n\t\t\t\tif (reader.getUint8(index, false) > 127) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: 'ensureBinary',\n\t\tvalue: function ensureBinary(buf) {\n\n\t\t\tif (typeof buf === \"string\") {\n\n\t\t\t\tvar array_buffer = new Uint8Array(buf.length);\n\t\t\t\tfor (var i = 0; i < buf.length; i++) {\n\n\t\t\t\t\tarray_buffer[i] = buf.charCodeAt(i) & 0xff;\n\t\t\t\t}\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\t\t\t} else {\n\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'ensureString',\n\t\tvalue: function ensureString(buf) {\n\n\t\t\tif (typeof buf !== \"string\") {\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(buf));\n\t\t\t} else {\n\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_parse',\n\t\tvalue: function _parse(data, onLoad) {\n\n\t\t\tvar binData = this.ensureBinary(data);\n\t\t\tthis._data = this.ensureString(data);\n\t\t\tthis.onLoad = onLoad;\n\t\t\treturn this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();\n\t\t}\n\t}, {\n\t\tkey: '_parseBinary',\n\t\tvalue: function _parseBinary(data) {\n\n\t\t\treturn this._parseASCII(THREE.LoaderUtils.decodeText(new Uint8Array(data)));\n\t\t}\n\t}, {\n\t\tkey: '_parseASCII',\n\t\tvalue: function _parseASCII() {\n\n\t\t\tif (this.url.lastIndexOf(\"/\") > 0) {\n\n\t\t\t\tthis.baseDir = this.url.substr(0, this.url.lastIndexOf(\"/\") + 1);\n\t\t\t}\n\t\t\tvar endRead = 16;\n\t\t\tthis.Hierarchies.children = [];\n\t\t\tthis._hierarchieParse(this.Hierarchies, endRead);\n\t\t\tthis._changeRoot();\n\t\t\tthis._currentObject = this.Hierarchies.children.shift();\n\t\t\tthis.mainloop();\n\t\t}\n\t}, {\n\t\tkey: '_hierarchieParse',\n\t\tvalue: function _hierarchieParse(_parent, _end) {\n\n\t\t\tvar endRead = _end;\n\t\t\twhile (true) {\n\n\t\t\t\tvar find1 = this._data.indexOf('{', endRead) + 1;\n\t\t\t\tvar findEnd = this._data.indexOf('}', endRead);\n\t\t\t\tvar findNext = this._data.indexOf('{', find1) + 1;\n\t\t\t\tif (find1 > 0 && findEnd > find1) {\n\n\t\t\t\t\tvar _currentObject = {};\n\t\t\t\t\t_currentObject.children = [];\n\t\t\t\t\tvar nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();\n\t\t\t\t\tvar word = nameData.split(/ /g);\n\t\t\t\t\tif (word.length > 0) {\n\n\t\t\t\t\t\t_currentObject.type = word[0];\n\t\t\t\t\t\tif (word.length >= 2) {\n\n\t\t\t\t\t\t\t_currentObject.name = word[1];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_currentObject.name = word[0] + this.Hierarchies.children.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_currentObject.name = nameData;\n\t\t\t\t\t\t_currentObject.type = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif (_currentObject.type === \"Animation\") {\n\n\t\t\t\t\t\t_currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();\n\t\t\t\t\t\tvar refs = this._hierarchieParse(_currentObject, findEnd + 1);\n\t\t\t\t\t\tendRead = refs.end;\n\t\t\t\t\t\t_currentObject.children = refs.parent.children;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar DataEnder = this._data.lastIndexOf(';', findNext > 0 ? Math.min(findNext, findEnd) : findEnd);\n\t\t\t\t\t\t_currentObject.data = this._data.substr(find1, DataEnder - find1).trim();\n\t\t\t\t\t\tif (findNext <= 0 || findEnd < findNext) {\n\n\t\t\t\t\t\t\tendRead = findEnd + 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar nextStart = Math.max(DataEnder + 1, find1);\n\t\t\t\t\t\t\tvar _refs = this._hierarchieParse(_currentObject, nextStart);\n\t\t\t\t\t\t\tendRead = _refs.end;\n\t\t\t\t\t\t\t_currentObject.children = _refs.parent.children;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_currentObject.parent = _parent;\n\t\t\t\t\tif (_currentObject.type != \"template\") {\n\n\t\t\t\t\t\t_parent.children.push(_currentObject);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tendRead = find1 === -1 ? this._data.length : findEnd + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tparent: _parent,\n\t\t\t\tend: endRead\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: 'mainloop',\n\t\tvalue: function mainloop() {\n\n\t\t\tvar _this2 = this;\n\n\t\t\tthis.mainProc();\n\t\t\tif (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {\n\n\t\t\t\tsetTimeout(function () {\n\n\t\t\t\t\t_this2.mainloop();\n\t\t\t\t}, 1);\n\t\t\t} else {\n\n\t\t\t\tsetTimeout(function () {\n\n\t\t\t\t\t_this2.onLoad({\n\t\t\t\t\t\tmodels: _this2.Meshes,\n\t\t\t\t\t\tanimations: _this2.animations\n\t\t\t\t\t});\n\t\t\t\t}, 1);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'mainProc',\n\t\tvalue: function mainProc() {\n\n\t\t\tvar breakFlag = false;\n\t\t\twhile (true) {\n\n\t\t\t\tif (!this._currentObject.worked) {\n\n\t\t\t\t\tswitch (this._currentObject.type) {\n\n\t\t\t\t\t\tcase \"template\":\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"AnimTicksPerSecond\":\n\t\t\t\t\t\t\tthis.animTicksPerSecond = parseInt(this._currentObject.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Frame\":\n\t\t\t\t\t\t\tthis._setFrame();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"FrameTransformMatrix\":\n\t\t\t\t\t\t\tthis._setFrameTransformMatrix();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\tthis._currentGeo = {};\n\t\t\t\t\t\t\tthis._currentGeo.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\tthis._currentGeo.parentName = this._getParentName(this._currentObject).trim();\n\t\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount = [];\n\t\t\t\t\t\t\tthis._currentGeo.Geometry = new THREE.Geometry();\n\t\t\t\t\t\t\tthis._currentGeo.Materials = [];\n\t\t\t\t\t\t\tthis._currentGeo.normalVectors = [];\n\t\t\t\t\t\t\tthis._currentGeo.BoneInfs = [];\n\t\t\t\t\t\t\tthis._currentGeo.baseFrame = this._currentFrame;\n\t\t\t\t\t\t\tthis._makeBoneFrom_CurrentFrame();\n\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshTextureCoords\":\n\t\t\t\t\t\t\tthis._setMeshTextureCoords();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"VertexDuplicationIndices\":\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshMaterialList\":\n\t\t\t\t\t\t\tthis._setMeshMaterialList();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Material\":\n\t\t\t\t\t\t\tthis._setMaterial();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SkinWeights\":\n\t\t\t\t\t\t\tthis._setSkinWeights();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"AnimationSet\":\n\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\tthis._currentAnime = {};\n\t\t\t\t\t\t\tthis._currentAnime.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames = [];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Animation\":\n\t\t\t\t\t\t\tif (this._currentAnimeFrames) {\n\n\t\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._currentAnimeFrames = new XAnimationInfo();\n\t\t\t\t\t\t\tthis._currentAnimeFrames.boneName = this._currentObject.data.trim();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"AnimationKey\":\n\t\t\t\t\t\t\tthis._readAnimationKey();\n\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentObject.worked = true;\n\t\t\t\t}\n\t\t\t\tif (this._currentObject.children.length > 0) {\n\n\t\t\t\t\tthis._currentObject = this._currentObject.children.shift();\n\t\t\t\t\tif (this.debug) {\n\n\t\t\t\t\t\tconsole.log('processing ' + this._currentObject.name);\n\t\t\t\t\t}\n\t\t\t\t\tif (breakFlag) break;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (this._currentObject.worked) {\n\n\t\t\t\t\t\tif (this._currentObject.parent && !this._currentObject.parent.parent) {\n\n\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._currentObject.parent) {\n\n\t\t\t\t\t\tthis._currentObject = this._currentObject.parent;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (breakFlag) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}, {\n\t\tkey: '_changeRoot',\n\t\tvalue: function _changeRoot() {\n\n\t\t\tif (this._currentGeo != null && this._currentGeo.name) {\n\n\t\t\t\tthis._makeOutputGeometry();\n\t\t\t}\n\t\t\tthis._currentGeo = {};\n\t\t\tif (this._currentAnime != null && this._currentAnime.name) {\n\n\t\t\t\tif (this._currentAnimeFrames) {\n\n\t\t\t\t\tthis._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\n\t\t\t\t\tthis._currentAnimeFrames = null;\n\t\t\t\t}\n\t\t\t\tthis._makeOutputAnimation();\n\t\t\t}\n\t\t\tthis._currentAnime = {};\n\t\t}\n\t}, {\n\t\tkey: '_getParentName',\n\t\tvalue: function _getParentName(_obj) {\n\n\t\t\tif (_obj.parent) {\n\n\t\t\t\tif (_obj.parent.name) {\n\n\t\t\t\t\treturn _obj.parent.name;\n\t\t\t\t} else {\n\n\t\t\t\t\treturn this._getParentName(_obj.parent);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_setFrame',\n\t\tvalue: function _setFrame() {\n\n\t\t\tthis._nowFrameName = this._currentObject.name.trim();\n\t\t\tthis._currentFrame = {};\n\t\t\tthis._currentFrame.name = this._nowFrameName;\n\t\t\tthis._currentFrame.children = [];\n\t\t\tif (this._currentObject.parent && this._currentObject.parent.name) {\n\n\t\t\t\tthis._currentFrame.parentName = this._currentObject.parent.name;\n\t\t\t}\n\t\t\tthis.frameHierarchie.push(this._nowFrameName);\n\t\t\tthis.HieStack[this._nowFrameName] = this._currentFrame;\n\t\t}\n\t}, {\n\t\tkey: '_setFrameTransformMatrix',\n\t\tvalue: function _setFrameTransformMatrix() {\n\n\t\t\tthis._currentFrame.FrameTransformMatrix = new THREE.Matrix4();\n\t\t\tvar data = this._currentObject.data.split(\",\");\n\t\t\tthis._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);\n\t\t\tthis._makeBoneFrom_CurrentFrame();\n\t\t}\n\t}, {\n\t\tkey: '_makeBoneFrom_CurrentFrame',\n\t\tvalue: function _makeBoneFrom_CurrentFrame() {\n\n\t\t\tif (!this._currentFrame.FrameTransformMatrix) {\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar b = new THREE.Bone();\n\t\t\tb.name = this._currentFrame.name;\n\t\t\tb.applyMatrix(this._currentFrame.FrameTransformMatrix);\n\t\t\tb.matrixWorld = b.matrix;\n\t\t\tb.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;\n\t\t\tthis._currentFrame.putBone = b;\n\t\t\tif (this._currentFrame.parentName) {\n\n\t\t\t\tfor (var frame in this.HieStack) {\n\n\t\t\t\t\tif (this.HieStack[frame].name === this._currentFrame.parentName) {\n\n\t\t\t\t\t\tthis.HieStack[frame].putBone.add(this._currentFrame.putBone);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_readVertexDatas',\n\t\tvalue: function _readVertexDatas() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\tvar maxLength = 0;\n\t\t\tvar nowReadedLine = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tvar changeMode = false;\n\t\t\t\tif (mode_local === 0) {\n\n\t\t\t\t\tvar refO = this._readInt1(endRead);\n\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\tmode_local = 1;\n\t\t\t\t\tnowReadedLine = 0;\n\t\t\t\t\tmaxLength = this._currentObject.data.indexOf(';;', endRead) + 1;\n\t\t\t\t\tif (maxLength <= 0) {\n\n\t\t\t\t\t\tmaxLength = this._currentObject.data.length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tvar find = 0;\n\t\t\t\t\tswitch (mode) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf(',', endRead) + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf(';,', endRead) + 1;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (find === 0 || find > maxLength) {\n\n\t\t\t\t\t\tfind = maxLength;\n\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\tchangeMode = true;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (this._currentObject.type) {\n\n\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\tswitch (mode) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tthis._readVertex1(this._currentObject.data.substr(endRead, find - endRead));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tthis._readFace1(this._currentObject.data.substr(endRead, find - endRead));\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\tswitch (mode) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tthis._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tthis._readNormalFace1(this._currentObject.data.substr(endRead, find - endRead), nowReadedLine);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tnowReadedLine++;\n\t\t\t\t\tif (changeMode) {\n\n\t\t\t\t\t\tmode++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_readInt1',\n\t\tvalue: function _readInt1(start) {\n\n\t\t\tvar find = this._currentObject.data.indexOf(';', start);\n\t\t\treturn {\n\t\t\t\trefI: parseInt(this._currentObject.data.substr(start, find - start)),\n\t\t\t\tendRead: find + 1\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: '_readVertex1',\n\t\tvalue: function _readVertex1(line) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(0, line.length - 2).split(\";\");\n\t\t\tthis._currentGeo.Geometry.vertices.push(new THREE.Vector3(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])));\n\t\t\tthis._currentGeo.Geometry.skinIndices.push(new THREE.Vector4(0, 0, 0, 0));\n\t\t\tthis._currentGeo.Geometry.skinWeights.push(new THREE.Vector4(1, 0, 0, 0));\n\t\t\tthis._currentGeo.VertexSetedBoneCount.push(0);\n\t\t}\n\t}, {\n\t\tkey: '_readFace1',\n\t\tvalue: function _readFace1(line) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(2, line.length - 4).split(\",\");\n\t\t\tthis._currentGeo.Geometry.faces.push(new THREE.Face3(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10), new THREE.Vector3(1, 1, 1).normalize()));\n\t\t}\n\t}, {\n\t\tkey: '_readNormalVector1',\n\t\tvalue: function _readNormalVector1(line) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(0, line.length - 2).split(\";\");\n\t\t\tthis._currentGeo.normalVectors.push(new THREE.Vector3(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])));\n\t\t}\n\t}, {\n\t\tkey: '_readNormalFace1',\n\t\tvalue: function _readNormalFace1(line, nowReaded) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(2, line.length - 4).split(\",\");\n\t\t\tvar nowID = parseInt(data[0], 10);\n\t\t\tvar v1 = this._currentGeo.normalVectors[nowID];\n\t\t\tnowID = parseInt(data[1], 10);\n\t\t\tvar v2 = this._currentGeo.normalVectors[nowID];\n\t\t\tnowID = parseInt(data[2], 10);\n\t\t\tvar v3 = this._currentGeo.normalVectors[nowID];\n\t\t\tthis._currentGeo.Geometry.faces[nowReaded].vertexNormals = [v1, v2, v3];\n\t\t}\n\t}, {\n\t\tkey: '_setMeshNormals',\n\t\tvalue: function _setMeshNormals() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tswitch (mode) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (mode_local === 0) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1(0);\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local = 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf(',', endRead) + 1;\n\t\t\t\t\t\t\tif (find === -1) {\n\n\t\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf(';;', endRead) + 1;\n\t\t\t\t\t\t\t\tmode = 2;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t\t\t\t\tvar data = this._readLine(line.trim()).split(\";\");\n\t\t\t\t\t\t\tthis._currentGeo.normalVectors.push([parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])]);\n\t\t\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_setMeshTextureCoords',\n\t\tvalue: function _setMeshTextureCoords() {\n\n\t\t\tthis._tmpUvArray = [];\n\t\t\tthis._currentGeo.Geometry.faceVertexUvs = [];\n\t\t\tthis._currentGeo.Geometry.faceVertexUvs.push([]);\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tswitch (mode) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (mode_local === 0) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1(0);\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local = 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf(',', endRead) + 1;\n\t\t\t\t\t\t\tif (find === 0) {\n\n\t\t\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\t\t\tmode = 2;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t\t\t\t\tvar data = this._readLine(line.trim()).split(\";\");\n\t\t\t\t\t\t\tif (this.IsUvYReverse) {\n\n\t\t\t\t\t\t\t\tthis._tmpUvArray.push(new THREE.Vector2(parseFloat(data[0]), 1 - parseFloat(data[1])));\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis._tmpUvArray.push(new THREE.Vector2(parseFloat(data[0]), parseFloat(data[1])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0] = [];\n\t\t\tfor (var m = 0; m < this._currentGeo.Geometry.faces.length; m++) {\n\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m] = [];\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].a]);\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].b]);\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].c]);\n\t\t\t}\n\t\t\tthis._currentGeo.Geometry.uvsNeedUpdate = true;\n\t\t}\n\t}, {\n\t\tkey: '_setMeshMaterialList',\n\t\tvalue: function _setMeshMaterialList() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tif (mode_local < 2) {\n\n\t\t\t\t\tvar refO = this._readInt1(endRead);\n\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\tmode_local++;\n\t\t\t\t} else {\n\n\t\t\t\t\tvar find = this._currentObject.data.indexOf(';', endRead);\n\t\t\t\t\tif (find === -1) {\n\n\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\tmode = 3;\n\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t\t\tvar data = this._readLine(line.trim()).split(\",\");\n\t\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\n\t\t\t\t\t\tthis._currentGeo.Geometry.faces[i].materialIndex = parseInt(data[i]);\n\t\t\t\t\t}\n\t\t\t\t\tendRead = this._currentObject.data.length;\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length || mode >= 3) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_setMaterial',\n\t\tvalue: function _setMaterial() {\n\n\t\t\tvar _nowMat = new THREE.MeshPhongMaterial({\n\t\t\t\tcolor: Math.random() * 0xffffff\n\t\t\t});\n\t\t\t_nowMat.side = THREE.FrontSide;\n\t\t\t_nowMat.name = this._currentObject.name;\n\t\t\tvar endRead = 0;\n\t\t\tvar find = this._currentObject.data.indexOf(';;', endRead);\n\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data = this._readLine(line.trim()).split(\";\");\n\t\t\t_nowMat.color.r = parseFloat(data[0]);\n\t\t\t_nowMat.color.g = parseFloat(data[1]);\n\t\t\t_nowMat.color.b = parseFloat(data[2]);\n\t\t\tendRead = find + 2;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t_nowMat.shininess = parseFloat(this._readLine(line));\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';;', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data2 = this._readLine(line.trim()).split(\";\");\n\t\t\t_nowMat.specular.r = parseFloat(data2[0]);\n\t\t\t_nowMat.specular.g = parseFloat(data2[1]);\n\t\t\t_nowMat.specular.b = parseFloat(data2[2]);\n\t\t\tendRead = find + 2;\n\t\t\tfind = this._currentObject.data.indexOf(';;', endRead);\n\t\t\tif (find === -1) {\n\n\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t}\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data3 = this._readLine(line.trim()).split(\";\");\n\t\t\t_nowMat.emissive.r = parseFloat(data3[0]);\n\t\t\t_nowMat.emissive.g = parseFloat(data3[1]);\n\t\t\t_nowMat.emissive.b = parseFloat(data3[2]);\n\t\t\tvar localObject = null;\n\t\t\twhile (true) {\n\n\t\t\t\tif (this._currentObject.children.length > 0) {\n\n\t\t\t\t\tlocalObject = this._currentObject.children.shift();\n\t\t\t\t\tif (this.debug) {\n\n\t\t\t\t\t\tconsole.log('processing ' + localObject.name);\n\t\t\t\t\t}\n\t\t\t\t\tvar fileName = localObject.data.substr(1, localObject.data.length - 2);\n\t\t\t\t\tswitch (localObject.type) {\n\n\t\t\t\t\t\tcase \"TextureFilename\":\n\t\t\t\t\t\t\t_nowMat.map = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"BumpMapFilename\":\n\t\t\t\t\t\t\t_nowMat.bumpMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\t_nowMat.bumpScale = 0.05;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"NormalMapFilename\":\n\t\t\t\t\t\t\t_nowMat.normalMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\t_nowMat.normalScale = new THREE.Vector2(2, 2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"EmissiveMapFilename\":\n\t\t\t\t\t\t\t_nowMat.emissiveMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"LightMapFilename\":\n\t\t\t\t\t\t\t_nowMat.lightMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._currentGeo.Materials.push(_nowMat);\n\t\t}\n\t}, {\n\t\tkey: '_setSkinWeights',\n\t\tvalue: function _setSkinWeights() {\n\n\t\t\tvar boneInf = new XboneInf();\n\t\t\tvar endRead = 0;\n\t\t\tvar find = this._currentObject.data.indexOf(';', endRead);\n\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tendRead = find + 1;\n\t\t\tboneInf.boneName = line.substr(1, line.length - 2);\n\t\t\tboneInf.BoneIndex = this._currentGeo.BoneInfs.length;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data = this._readLine(line.trim()).split(\",\");\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\n\t\t\t\tboneInf.Indeces.push(parseInt(data[i]));\n\t\t\t}\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data2 = this._readLine(line.trim()).split(\",\");\n\t\t\tfor (var _i = 0; _i < data2.length; _i++) {\n\n\t\t\t\tboneInf.Weights.push(parseFloat(data2[_i]));\n\t\t\t}\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tif (find <= 0) {\n\n\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t}\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data3 = this._readLine(line.trim()).split(\",\");\n\t\t\tboneInf.OffsetMatrix = new THREE.Matrix4();\n\t\t\tthis._ParseMatrixData(boneInf.OffsetMatrix, data3);\n\t\t\tthis._currentGeo.BoneInfs.push(boneInf);\n\t\t}\n\t}, {\n\t\tkey: '_makePutBoneList',\n\t\tvalue: function _makePutBoneList(_RootName, _bones) {\n\n\t\t\tvar putting = false;\n\t\t\tfor (var frame in this.HieStack) {\n\n\t\t\t\tif (this.HieStack[frame].name === _RootName || putting) {\n\n\t\t\t\t\tputting = true;\n\t\t\t\t\tvar b = new THREE.Bone();\n\t\t\t\t\tb.name = this.HieStack[frame].name;\n\t\t\t\t\tb.applyMatrix(this.HieStack[frame].FrameTransformMatrix);\n\t\t\t\t\tb.matrixWorld = b.matrix;\n\t\t\t\t\tb.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;\n\t\t\t\t\tb.pos = new THREE.Vector3().setFromMatrixPosition(b.FrameTransformMatrix).toArray();\n\t\t\t\t\tb.rotq = new THREE.Quaternion().setFromRotationMatrix(b.FrameTransformMatrix).toArray();\n\t\t\t\t\tb.scl = new THREE.Vector3().setFromMatrixScale(b.FrameTransformMatrix).toArray();\n\t\t\t\t\tif (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {\n\n\t\t\t\t\t\tfor (var i = 0; i < _bones.length; i++) {\n\n\t\t\t\t\t\t\tif (this.HieStack[frame].parentName === _bones[i].name) {\n\n\t\t\t\t\t\t\t\t_bones[i].add(b);\n\t\t\t\t\t\t\t\tb.parent = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_bones.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_makeOutputGeometry',\n\t\tvalue: function _makeOutputGeometry() {\n\n\t\t\tthis._currentGeo.Geometry.computeBoundingBox();\n\t\t\tthis._currentGeo.Geometry.computeBoundingSphere();\n\t\t\tthis._currentGeo.Geometry.verticesNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.normalsNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.colorsNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.uvsNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.groupsNeedUpdate = true;\n\t\t\tvar mesh = null;\n\t\t\tif (this._currentGeo.BoneInfs.length > 0) {\n\n\t\t\t\tvar putBones = [];\n\t\t\t\tthis._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);\n\t\t\t\tfor (var bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {\n\n\t\t\t\t\tvar boneIndex = 0;\n\t\t\t\t\tfor (var bb = 0; bb < putBones.length; bb++) {\n\n\t\t\t\t\t\tif (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {\n\n\t\t\t\t\t\t\tboneIndex = bb;\n\t\t\t\t\t\t\tputBones[bb].OffsetMatrix = new THREE.Matrix4();\n\t\t\t\t\t\t\tputBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (var vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {\n\n\t\t\t\t\t\tvar nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];\n\t\t\t\t\t\tvar nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];\n\t\t\t\t\t\tswitch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {\n\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].x = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].x = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].y = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].y = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].z = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].z = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].w = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].w = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount[nowVertexID]++;\n\t\t\t\t\t\tif (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {\n\n\t\t\t\t\t\t\tconsole.log('warn! over 4 bone weight! :' + nowVertexID);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var sk = 0; sk < this._currentGeo.Materials.length; sk++) {\n\n\t\t\t\t\tthis._currentGeo.Materials[sk].skinning = true;\n\t\t\t\t}\n\t\t\t\tvar offsetList = [];\n\t\t\t\tfor (var _bi = 0; _bi < putBones.length; _bi++) {\n\n\t\t\t\t\tif (putBones[_bi].OffsetMatrix) {\n\n\t\t\t\t\t\toffsetList.push(putBones[_bi].OffsetMatrix);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toffsetList.push(new THREE.Matrix4());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar bufferGeometry = new THREE.BufferGeometry().fromGeometry(this._currentGeo.Geometry);\n\t\t\t\tbufferGeometry.bones = putBones;\n\t\t\t\tmesh = new THREE.SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\n\t\t\t\tmesh.skeleton.boneInverses = offsetList;\n\t\t\t} else {\n\n\t\t\t\tvar _bufferGeometry = new THREE.BufferGeometry().fromGeometry(this._currentGeo.Geometry);\n\t\t\t\tmesh = new THREE.Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\n\t\t\t}\n\t\t\tmesh.name = this._currentGeo.name;\n\t\t\tvar worldBaseMx = new THREE.Matrix4();\n\t\t\tvar currentMxFrame = this._currentGeo.baseFrame.putBone;\n\t\t\tif (currentMxFrame && currentMxFrame.parent) {\n\n\t\t\t\twhile (true) {\n\n\t\t\t\t\tcurrentMxFrame = currentMxFrame.parent;\n\t\t\t\t\tif (currentMxFrame) {\n\n\t\t\t\t\t\tworldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmesh.applyMatrix(worldBaseMx);\n\t\t\t}\n\t\t\tthis.Meshes.push(mesh);\n\t\t}\n\t}, {\n\t\tkey: '_readAnimationKey',\n\t\tvalue: function _readAnimationKey() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar find = this._currentObject.data.indexOf(';', endRead);\n\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tendRead = find + 1;\n\t\t\tvar nowKeyType = parseInt(this._readLine(line));\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tendRead = find + 1;\n\t\t\tline = this._currentObject.data.substr(endRead);\n\t\t\tvar data = this._readLine(line.trim()).split(\";;,\");\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\n\t\t\t\tvar data2 = data[i].split(\";\");\n\t\t\t\tvar keyInfo = new XKeyFrameInfo();\n\t\t\t\tkeyInfo.type = nowKeyType;\n\t\t\t\tkeyInfo.Frame = parseInt(data2[0]);\n\t\t\t\tkeyInfo.index = this._currentAnimeFrames.keyFrames.length;\n\t\t\t\tkeyInfo.time = keyInfo.Frame;\n\t\t\t\tif (nowKeyType != 4) {\n\n\t\t\t\t\tvar frameFound = false;\n\t\t\t\t\tfor (var mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {\n\n\t\t\t\t\t\tif (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {\n\n\t\t\t\t\t\t\tkeyInfo = this._currentAnimeFrames.keyFrames[mm];\n\t\t\t\t\t\t\tframeFound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar frameValue = data2[2].split(\",\");\n\t\t\t\t\tswitch (nowKeyType) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tkeyInfo.rot = new THREE.Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tkeyInfo.scl = new THREE.Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tkeyInfo.pos = new THREE.Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (!frameFound) {\n\n\t\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push(keyInfo);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tkeyInfo.matrix = new THREE.Matrix4();\n\t\t\t\t\tthis._ParseMatrixData(keyInfo.matrix, data2[2].split(\",\"));\n\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push(keyInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_makeOutputAnimation',\n\t\tvalue: function _makeOutputAnimation() {\n\n\t\t\tvar animationObj = new XAnimationObj(this.options);\n\t\t\tanimationObj.fps = this.animTicksPerSecond;\n\t\t\tanimationObj.name = this._currentAnime.name;\n\t\t\tanimationObj.make(this._currentAnime.AnimeFrames);\n\t\t\tthis.animations.push(animationObj);\n\t\t}\n\t}, {\n\t\tkey: 'assignAnimation',\n\t\tvalue: function assignAnimation(_model, _animation, _isBind) {\n\n\t\t\tvar model = _model;\n\t\t\tvar animation = _animation;\n\t\t\tif (!model) {\n\n\t\t\t\tmodel = this.Meshes[0];\n\t\t\t}\n\t\t\tif (!animation) {\n\n\t\t\t\tanimation = this.animations[0];\n\t\t\t}\n\t\t\tif (!model || !animation) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar put = {};\n\t\t\tput.fps = animation.fps;\n\t\t\tput.name = animation.name;\n\t\t\tput.length = animation.length;\n\t\t\tput.hierarchy = [];\n\t\t\tfor (var b = 0; b < model.skeleton.bones.length; b++) {\n\n\t\t\t\tvar findAnimation = false;\n\t\t\t\tfor (var i = 0; i < animation.hierarchy.length; i++) {\n\n\t\t\t\t\tif (model.skeleton.bones[b].name === animation.hierarchy[i].name) {\n\n\t\t\t\t\t\tfindAnimation = true;\n\t\t\t\t\t\tvar c_key = animation.hierarchy[i].copy();\n\t\t\t\t\t\tc_key.parent = -1;\n\t\t\t\t\t\tif (model.skeleton.bones[b].parent && model.skeleton.bones[b].parent.type === \"Bone\") {\n\n\t\t\t\t\t\t\tfor (var bb = 0; bb < put.hierarchy.length; bb++) {\n\n\t\t\t\t\t\t\t\tif (put.hierarchy[bb].name === model.skeleton.bones[b].parent.name) {\n\n\t\t\t\t\t\t\t\t\tc_key.parent = bb;\n\t\t\t\t\t\t\t\t\tc_key.parentName = model.skeleton.bones[b].parent.name;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tput.hierarchy.push(c_key);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!findAnimation) {\n\n\t\t\t\t\tvar _c_key = animation.hierarchy[0].copy();\n\t\t\t\t\t_c_key.name = model.skeleton.bones[b].name;\n\t\t\t\t\t_c_key.parent = -1;\n\t\t\t\t\tfor (var k = 0; k < _c_key.keys.length; k++) {\n\n\t\t\t\t\t\tif (_c_key.keys[k].pos) {\n\n\t\t\t\t\t\t\t_c_key.keys[k].pos.set(0, 0, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_c_key.keys[k].scl) {\n\n\t\t\t\t\t\t\t_c_key.keys[k].scl.set(1, 1, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_c_key.keys[k].rot) {\n\n\t\t\t\t\t\t\t_c_key.keys[k].rot.set(0, 0, 0, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tput.hierarchy.push(_c_key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!model.geometry.animations) {\n\n\t\t\t\tmodel.geometry.animations = [];\n\t\t\t}\n\n\t\t\tmodel.geometry.animations.push(THREE.AnimationClip.parseAnimation(put, model.skeleton.bones));\n\t\t\tif (!model.animationMixer) {\n\n\t\t\t\tmodel.animationMixer = new THREE.AnimationMixer(model);\n\t\t\t}\n\n\t\t\treturn put;\n\t\t}\n\t}, {\n\t\tkey: '_ParseMatrixData',\n\t\tvalue: function _ParseMatrixData(targetMatrix, data) {\n\n\t\t\ttargetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));\n\t\t}\n\t}]);\n\treturn XLoader;\n}();\n\n// \treturn XLoader;\n//\n// } ) ) );\n\nexports.default = XLoader;\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnrealBloomPass = exports.TexturePass = exports.TAARenderPass = exports.SSAOPass = exports.SSAARenderPass = exports.SMAAPass = exports.ShaderPass = exports.SavePass = exports.SAOPass = exports.RenderPass = exports.Pass = exports.OutlinePass = exports.MaskPass = exports.HalftonePass = exports.GlitchPass = exports.FilmPass = exports.EffectComposer = exports.DotScreenPass = exports.CubeTexturePass = exports.ClearPass = exports.ClearMaskPass = exports.BokehPass = exports.BloomPass = exports.AdaptiveToneMappingPass = undefined;\n\nvar _AdaptiveToneMappingPass = __webpack_require__(91);\n\nvar _AdaptiveToneMappingPass2 = _interopRequireDefault(_AdaptiveToneMappingPass);\n\nvar _BloomPass = __webpack_require__(92);\n\nvar _BloomPass2 = _interopRequireDefault(_BloomPass);\n\nvar _BokehPass = __webpack_require__(93);\n\nvar _BokehPass2 = _interopRequireDefault(_BokehPass);\n\nvar _ClearMaskPass = __webpack_require__(94);\n\nvar _ClearMaskPass2 = _interopRequireDefault(_ClearMaskPass);\n\nvar _ClearPass = __webpack_require__(95);\n\nvar _ClearPass2 = _interopRequireDefault(_ClearPass);\n\nvar _CubeTexturePass = __webpack_require__(96);\n\nvar _CubeTexturePass2 = _interopRequireDefault(_CubeTexturePass);\n\nvar _DotScreenPass = __webpack_require__(97);\n\nvar _DotScreenPass2 = _interopRequireDefault(_DotScreenPass);\n\nvar _EffectComposer = __webpack_require__(98);\n\nvar _EffectComposer2 = _interopRequireDefault(_EffectComposer);\n\nvar _FilmPass = __webpack_require__(99);\n\nvar _FilmPass2 = _interopRequireDefault(_FilmPass);\n\nvar _GlitchPass = __webpack_require__(100);\n\nvar _GlitchPass2 = _interopRequireDefault(_GlitchPass);\n\nvar _HalftonePass = __webpack_require__(101);\n\nvar _HalftonePass2 = _interopRequireDefault(_HalftonePass);\n\nvar _MaskPass = __webpack_require__(102);\n\nvar _MaskPass2 = _interopRequireDefault(_MaskPass);\n\nvar _OutlinePass = __webpack_require__(103);\n\nvar _OutlinePass2 = _interopRequireDefault(_OutlinePass);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _RenderPass = __webpack_require__(104);\n\nvar _RenderPass2 = _interopRequireDefault(_RenderPass);\n\nvar _SAOPass = __webpack_require__(105);\n\nvar _SAOPass2 = _interopRequireDefault(_SAOPass);\n\nvar _SavePass = __webpack_require__(106);\n\nvar _SavePass2 = _interopRequireDefault(_SavePass);\n\nvar _ShaderPass = __webpack_require__(3);\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nvar _SMAAPass = __webpack_require__(107);\n\nvar _SMAAPass2 = _interopRequireDefault(_SMAAPass);\n\nvar _SSAARenderPass = __webpack_require__(24);\n\nvar _SSAARenderPass2 = _interopRequireDefault(_SSAARenderPass);\n\nvar _SSAOPass = __webpack_require__(108);\n\nvar _SSAOPass2 = _interopRequireDefault(_SSAOPass);\n\nvar _TAARenderPass = __webpack_require__(109);\n\nvar _TAARenderPass2 = _interopRequireDefault(_TAARenderPass);\n\nvar _TexturePass = __webpack_require__(110);\n\nvar _TexturePass2 = _interopRequireDefault(_TexturePass);\n\nvar _UnrealBloomPass = __webpack_require__(111);\n\nvar _UnrealBloomPass2 = _interopRequireDefault(_UnrealBloomPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.AdaptiveToneMappingPass = _AdaptiveToneMappingPass2.default;\nexports.BloomPass = _BloomPass2.default;\nexports.BokehPass = _BokehPass2.default;\nexports.ClearMaskPass = _ClearMaskPass2.default;\nexports.ClearPass = _ClearPass2.default;\nexports.CubeTexturePass = _CubeTexturePass2.default;\nexports.DotScreenPass = _DotScreenPass2.default;\nexports.EffectComposer = _EffectComposer2.default;\nexports.FilmPass = _FilmPass2.default;\nexports.GlitchPass = _GlitchPass2.default;\nexports.HalftonePass = _HalftonePass2.default;\nexports.MaskPass = _MaskPass2.default;\nexports.OutlinePass = _OutlinePass2.default;\nexports.Pass = _Pass2.default;\nexports.RenderPass = _RenderPass2.default;\nexports.SAOPass = _SAOPass2.default;\nexports.SavePass = _SavePass2.default;\nexports.ShaderPass = _ShaderPass2.default;\nexports.SMAAPass = _SMAAPass2.default;\nexports.SSAARenderPass = _SSAARenderPass2.default;\nexports.SSAOPass = _SSAOPass2.default;\nexports.TAARenderPass = _TAARenderPass2.default;\nexports.TexturePass = _TexturePass2.default;\nexports.UnrealBloomPass = _UnrealBloomPass2.default;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _LuminosityShader = __webpack_require__(11);\n\nvar _LuminosityShader2 = _interopRequireDefault(_LuminosityShader);\n\nvar _ToneMapShader = __webpack_require__(12);\n\nvar _ToneMapShader2 = _interopRequireDefault(_ToneMapShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author miibond\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {\n\n\t_Pass2.default.call(this);\n\n\tthis.resolution = resolution !== undefined ? resolution : 256;\n\tthis.needsInit = true;\n\tthis.adaptive = adaptive !== undefined ? !!adaptive : true;\n\n\tthis.luminanceRT = null;\n\tthis.previousLuminanceRT = null;\n\tthis.currentLuminanceRT = null;\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.NoBlending,\n\t\tdepthTest: false\n\n\t});\n\n\tif (_LuminosityShader2.default === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader\");\n\n\tthis.materialLuminance = new THREE.ShaderMaterial({\n\n\t\tuniforms: THREE.UniformsUtils.clone(_LuminosityShader2.default.uniforms),\n\t\tvertexShader: _LuminosityShader2.default.vertexShader,\n\t\tfragmentShader: _LuminosityShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\n\tthis.adaptLuminanceShader = {\n\t\tdefines: {\n\t\t\t\"MIP_LEVEL_1X1\": (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n\t\t},\n\t\tuniforms: {\n\t\t\t\"lastLum\": { value: null },\n\t\t\t\"currentLum\": { value: null },\n\t\t\t\"minLuminance\": { value: 0.01 },\n\t\t\t\"delta\": { value: 0.016 },\n\t\t\t\"tau\": { value: 1.0 }\n\t\t},\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join('\\n'),\n\t\tfragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D lastLum;\", \"uniform sampler2D currentLum;\", \"uniform float minLuminance;\", \"uniform float delta;\", \"uniform float tau;\", \"void main() {\", \"vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\", \"vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\", \"float fLastLum = max( minLuminance, lastLum.r );\", \"float fCurrentLum = max( minLuminance, currentLum.r );\",\n\n\t\t//The adaption seems to work better in extreme lighting differences\n\t\t//if the input luminance is squared.\n\t\t\"fCurrentLum *= fCurrentLum;\",\n\n\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\",\n\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\",\n\t\t\"gl_FragColor.r = fAdaptedLum;\", \"}\"].join('\\n')\n\t};\n\n\tthis.materialAdaptiveLum = new THREE.ShaderMaterial({\n\n\t\tuniforms: THREE.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n\t\tvertexShader: this.adaptLuminanceShader.vertexShader,\n\t\tfragmentShader: this.adaptLuminanceShader.fragmentShader,\n\t\tdefines: Object.assign({}, this.adaptLuminanceShader.defines),\n\t\tblending: THREE.NoBlending\n\t});\n\n\tif (_ToneMapShader2.default === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader\");\n\n\tthis.materialToneMap = new THREE.ShaderMaterial({\n\n\t\tuniforms: THREE.UniformsUtils.clone(_ToneMapShader2.default.uniforms),\n\t\tvertexShader: _ToneMapShader2.default.vertexShader,\n\t\tfragmentShader: _ToneMapShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: AdaptiveToneMappingPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (this.needsInit) {\n\n\t\t\tthis.reset(renderer);\n\n\t\t\tthis.luminanceRT.texture.type = readBuffer.texture.type;\n\t\t\tthis.previousLuminanceRT.texture.type = readBuffer.texture.type;\n\t\t\tthis.currentLuminanceRT.texture.type = readBuffer.texture.type;\n\t\t\tthis.needsInit = false;\n\t\t}\n\n\t\tif (this.adaptive) {\n\n\t\t\t//Render the luminance of the current scene into a render target with mipmapping enabled\n\t\t\tthis.quad.material = this.materialLuminance;\n\t\t\tthis.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.currentLuminanceRT);\n\n\t\t\t//Use the new luminance values, the previous luminance and the frame delta to\n\t\t\t//adapt the luminance over time.\n\t\t\tthis.quad.material = this.materialAdaptiveLum;\n\t\t\tthis.materialAdaptiveLum.uniforms.delta.value = delta;\n\t\t\tthis.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n\t\t\tthis.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.luminanceRT);\n\n\t\t\t//Copy the new adapted luminance value so that it can be used by the next frame.\n\t\t\tthis.quad.material = this.materialCopy;\n\t\t\tthis.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.previousLuminanceRT);\n\t\t}\n\n\t\tthis.quad.material = this.materialToneMap;\n\t\tthis.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t},\n\n\treset: function reset(renderer) {\n\n\t\t// render targets\n\t\tif (this.luminanceRT) {\n\n\t\t\tthis.luminanceRT.dispose();\n\t\t}\n\t\tif (this.currentLuminanceRT) {\n\n\t\t\tthis.currentLuminanceRT.dispose();\n\t\t}\n\t\tif (this.previousLuminanceRT) {\n\n\t\t\tthis.previousLuminanceRT.dispose();\n\t\t}\n\n\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n\t\tthis.luminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n\t\tthis.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n\t\tthis.luminanceRT.texture.generateMipmaps = false;\n\n\t\tthis.previousLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n\t\tthis.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n\t\tthis.previousLuminanceRT.texture.generateMipmaps = false;\n\n\t\t// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\t\tpars.minFilter = THREE.LinearMipMapLinearFilter;\n\t\tthis.currentLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n\t\tthis.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n\n\t\tif (this.adaptive) {\n\n\t\t\tthis.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n\t\t}\n\t\t//Put something in the adaptive luminance texture so that the scene can render initially\n\t\tthis.quad.material = new THREE.MeshBasicMaterial({ color: 0x777777 });\n\t\tthis.materialLuminance.needsUpdate = true;\n\t\tthis.materialAdaptiveLum.needsUpdate = true;\n\t\tthis.materialToneMap.needsUpdate = true;\n\t\t// renderer.render( this.scene, this.camera, this.luminanceRT );\n\t\t// renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n\t\t// renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n\t},\n\n\tsetAdaptive: function setAdaptive(adaptive) {\n\n\t\tif (adaptive) {\n\n\t\t\tthis.adaptive = true;\n\t\t\tthis.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n\t\t} else {\n\n\t\t\tthis.adaptive = false;\n\t\t\tdelete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = null;\n\t\t}\n\t\tthis.materialToneMap.needsUpdate = true;\n\t},\n\n\tsetAdaptionRate: function setAdaptionRate(rate) {\n\n\t\tif (rate) {\n\n\t\t\tthis.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n\t\t}\n\t},\n\n\tsetMinLuminance: function setMinLuminance(minLum) {\n\n\t\tif (minLum) {\n\n\t\t\tthis.materialToneMap.uniforms.minLuminance.value = minLum;\n\t\t\tthis.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n\t\t}\n\t},\n\n\tsetMaxLuminance: function setMaxLuminance(maxLum) {\n\n\t\tif (maxLum) {\n\n\t\t\tthis.materialToneMap.uniforms.maxLuminance.value = maxLum;\n\t\t}\n\t},\n\n\tsetAverageLuminance: function setAverageLuminance(avgLum) {\n\n\t\tif (avgLum) {\n\n\t\t\tthis.materialToneMap.uniforms.averageLuminance.value = avgLum;\n\t\t}\n\t},\n\n\tsetMiddleGrey: function setMiddleGrey(middleGrey) {\n\n\t\tif (middleGrey) {\n\n\t\t\tthis.materialToneMap.uniforms.middleGrey.value = middleGrey;\n\t\t}\n\t},\n\n\tdispose: function dispose() {\n\n\t\tif (this.luminanceRT) {\n\n\t\t\tthis.luminanceRT.dispose();\n\t\t}\n\t\tif (this.previousLuminanceRT) {\n\n\t\t\tthis.previousLuminanceRT.dispose();\n\t\t}\n\t\tif (this.currentLuminanceRT) {\n\n\t\t\tthis.currentLuminanceRT.dispose();\n\t\t}\n\t\tif (this.materialLuminance) {\n\n\t\t\tthis.materialLuminance.dispose();\n\t\t}\n\t\tif (this.materialAdaptiveLum) {\n\n\t\t\tthis.materialAdaptiveLum.dispose();\n\t\t}\n\t\tif (this.materialCopy) {\n\n\t\t\tthis.materialCopy.dispose();\n\t\t}\n\t\tif (this.materialToneMap) {\n\n\t\t\tthis.materialToneMap.dispose();\n\t\t}\n\t}\n\n});\n\nexports.default = AdaptiveToneMappingPass;\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _ConvolutionShader = __webpack_require__(13);\n\nvar _ConvolutionShader2 = _interopRequireDefault(_ConvolutionShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar BloomPass = function BloomPass(strength, kernelSize, sigma, resolution) {\n\n\t_Pass2.default.call(this);\n\n\tstrength = strength !== undefined ? strength : 1;\n\tkernelSize = kernelSize !== undefined ? kernelSize : 25;\n\tsigma = sigma !== undefined ? sigma : 4.0;\n\tresolution = resolution !== undefined ? resolution : 256;\n\n\t// render targets\n\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\n\tthis.renderTargetX = new THREE.WebGLRenderTarget(resolution, resolution, pars);\n\tthis.renderTargetX.texture.name = \"BloomPass.x\";\n\tthis.renderTargetY = new THREE.WebGLRenderTarget(resolution, resolution, pars);\n\tthis.renderTargetY.texture.name = \"BloomPass.y\";\n\n\t// copy material\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.BloomPass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\n\tthis.copyUniforms[\"opacity\"].value = strength;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\ttransparent: true\n\n\t});\n\n\t// convolution material\n\n\tif (_ConvolutionShader2.default === undefined) console.error(\"THREE.BloomPass relies on THREE.ConvolutionShader\");\n\n\tvar convolutionShader = _ConvolutionShader2.default;\n\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone(convolutionShader.uniforms);\n\n\tthis.convolutionUniforms[\"uImageIncrement\"].value = BloomPass.blurX;\n\tthis.convolutionUniforms[\"cKernel\"].value = _ConvolutionShader2.default.buildKernel(sigma);\n\n\tthis.materialConvolution = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.convolutionUniforms,\n\t\tvertexShader: convolutionShader.vertexShader,\n\t\tfragmentShader: convolutionShader.fragmentShader,\n\t\tdefines: {\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed(1),\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed(0)\n\t\t}\n\n\t});\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nBloomPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: BloomPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t// Render quad with blured scene into texture (convolution pass 1)\n\n\t\tthis.quad.material = this.materialConvolution;\n\n\t\tthis.convolutionUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.convolutionUniforms[\"uImageIncrement\"].value = BloomPass.blurX;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetX, true);\n\n\t\t// Render quad with blured scene into texture (convolution pass 2)\n\n\t\tthis.convolutionUniforms[\"tDiffuse\"].value = this.renderTargetX.texture;\n\t\tthis.convolutionUniforms[\"uImageIncrement\"].value = BloomPass.blurY;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetY, true);\n\n\t\t// Render original scene with superimposed blur to texture\n\n\t\tthis.quad.material = this.materialCopy;\n\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetY.texture;\n\n\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\trenderer.render(this.scene, this.camera, readBuffer, this.clear);\n\t}\n\n});\n\nBloomPass.blurX = new THREE.Vector2(0.001953125, 0.0);\nBloomPass.blurY = new THREE.Vector2(0.0, 0.001953125);\n\nexports.default = BloomPass;\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _global = __webpack_require__(8);\n\nvar _global2 = _interopRequireDefault(_global);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _BokehShader = __webpack_require__(14);\n\nvar _BokehShader2 = _interopRequireDefault(_BokehShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar window = _global2.default;\n\n/**\n * Depth-of-field post-process with bokeh shader\n */\n\nvar BokehPass = function BokehPass(scene, camera, params) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tvar focus = params.focus !== undefined ? params.focus : 1.0;\n\tvar aspect = params.aspect !== undefined ? params.aspect : camera.aspect;\n\tvar aperture = params.aperture !== undefined ? params.aperture : 0.025;\n\tvar maxblur = params.maxblur !== undefined ? params.maxblur : 1.0;\n\n\t// render targets\n\n\tvar width = params.width || window.innerWidth || 1;\n\tvar height = params.height || window.innerHeight || 1;\n\n\tthis.renderTargetColor = new THREE.WebGLRenderTarget(width, height, {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t});\n\tthis.renderTargetColor.texture.name = \"BokehPass.color\";\n\n\tthis.renderTargetDepth = this.renderTargetColor.clone();\n\tthis.renderTargetDepth.texture.name = \"BokehPass.depth\";\n\n\t// depth material\n\n\tthis.materialDepth = new THREE.MeshDepthMaterial();\n\tthis.materialDepth.depthPacking = THREE.RGBADepthPacking;\n\tthis.materialDepth.blending = THREE.NoBlending;\n\n\t// bokeh material\n\n\tif (_BokehShader2.default === undefined) {\n\n\t\tconsole.error(\"THREE.BokehPass relies on THREE.BokehShader\");\n\t}\n\n\tvar bokehShader = _BokehShader2.default;\n\tvar bokehUniforms = THREE.UniformsUtils.clone(bokehShader.uniforms);\n\n\tbokehUniforms[\"tDepth\"].value = this.renderTargetDepth.texture;\n\n\tbokehUniforms[\"focus\"].value = focus;\n\tbokehUniforms[\"aspect\"].value = aspect;\n\tbokehUniforms[\"aperture\"].value = aperture;\n\tbokehUniforms[\"maxblur\"].value = maxblur;\n\tbokehUniforms[\"nearClip\"].value = camera.near;\n\tbokehUniforms[\"farClip\"].value = camera.far;\n\n\tthis.materialBokeh = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, bokehShader.defines),\n\t\tuniforms: bokehUniforms,\n\t\tvertexShader: bokehShader.vertexShader,\n\t\tfragmentShader: bokehShader.fragmentShader\n\t});\n\n\tthis.uniforms = bokehUniforms;\n\tthis.needsSwap = false;\n\n\tthis.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene2 = new THREE.Scene();\n\n\tthis.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad2.frustumCulled = false; // Avoid getting clipped\n\tthis.scene2.add(this.quad2);\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n};\n\nBokehPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: BokehPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.quad2.material = this.materialBokeh;\n\n\t\t// Render depth into texture\n\n\t\tthis.scene.overrideMaterial = this.materialDepth;\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor(0xffffff);\n\t\trenderer.setClearAlpha(1.0);\n\t\trenderer.render(this.scene, this.camera, this.renderTargetDepth, true);\n\n\t\t// Render bokeh composite\n\n\t\tthis.uniforms[\"tColor\"].value = readBuffer.texture;\n\t\tthis.uniforms[\"nearClip\"].value = this.camera.near;\n\t\tthis.uniforms[\"farClip\"].value = this.camera.far;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene2, this.camera2);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene2, this.camera2, writeBuffer, this.clear);\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\t\trenderer.setClearColor(this.oldClearColor);\n\t\trenderer.setClearAlpha(this.oldClearAlpha);\n\t\trenderer.autoClear = this.oldAutoClear;\n\t}\n\n});\n\nexports.default = BokehPass;\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar ClearMaskPass = function ClearMaskPass() {\n\n\t_Pass2.default.call(this);\n\n\tthis.needsSwap = false;\n};\n\nClearMaskPass.prototype = Object.create(_Pass2.default.prototype);\n\nObject.assign(ClearMaskPass.prototype, {\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\trenderer.state.buffers.stencil.setTest(false);\n\t}\n\n});\n\nexports.default = ClearMaskPass;\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar ClearPass = function ClearPass(clearColor, clearAlpha) {\n\n\t_Pass2.default.call(this);\n\n\tthis.needsSwap = false;\n\n\tthis.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n};\n\nClearPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: ClearPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldClearColor, oldClearAlpha;\n\n\t\tif (this.clearColor) {\n\n\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t}\n\n\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\t\trenderer.clear();\n\n\t\tif (this.clearColor) {\n\n\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t}\n\t}\n\n});\n\nexports.default = ClearPass;\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author bhouston / http://clara.io/\n */\n\nvar CubeTexturePass = function CubeTexturePass(camera, envMap, opacity) {\n\n\t_Pass2.default.call(this);\n\n\tthis.camera = camera;\n\n\tthis.needsSwap = false;\n\n\tthis.cubeShader = THREE.ShaderLib['cube'];\n\tthis.cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 10, 10), new THREE.ShaderMaterial({\n\t\tuniforms: this.cubeShader.uniforms,\n\t\tvertexShader: this.cubeShader.vertexShader,\n\t\tfragmentShader: this.cubeShader.fragmentShader,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\tside: THREE.BackSide\n\t}));\n\n\tthis.envMap = envMap;\n\tthis.opacity = opacity !== undefined ? opacity : 1.0;\n\n\tthis.cubeScene = new THREE.Scene();\n\tthis.cubeCamera = new THREE.PerspectiveCamera();\n\tthis.cubeScene.add(this.cubeMesh);\n};\n\nCubeTexturePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: CubeTexturePass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n\t\tthis.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n\n\t\tthis.cubeMesh.material.uniforms[\"tCube\"].value = this.envMap;\n\t\tthis.cubeMesh.material.uniforms[\"opacity\"].value = this.opacity;\n\t\tthis.cubeMesh.material.transparent = this.opacity < 1.0;\n\n\t\trenderer.render(this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\trenderer.autoClear = oldAutoClear;\n\t}\n\n});\n\nexports.default = CubeTexturePass;\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _DotScreenShader = __webpack_require__(15);\n\nvar _DotScreenShader2 = _interopRequireDefault(_DotScreenShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar DotScreenPass = function DotScreenPass(center, angle, scale) {\n\n\t_Pass2.default.call(this);\n\n\tif (_DotScreenShader2.default === undefined) console.error(\"THREE.DotScreenPass relies on THREE.DotScreenShader\");\n\n\tvar shader = _DotScreenShader2.default;\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tif (center !== undefined) this.uniforms[\"center\"].value.copy(center);\n\tif (angle !== undefined) this.uniforms[\"angle\"].value = angle;\n\tif (scale !== undefined) this.uniforms[\"scale\"].value = scale;\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t});\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nDotScreenPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: DotScreenPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.uniforms[\"tSize\"].value.set(readBuffer.width, readBuffer.height);\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n\n});\n\nexports.default = DotScreenPass;\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _ShaderPass = __webpack_require__(3);\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar EffectComposer = function EffectComposer(renderer, renderTarget) {\n\n\tthis.renderer = renderer;\n\n\tif (renderTarget === undefined) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar size = renderer.getDrawingBufferSize();\n\t\trenderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.CopyShader');\n\t}\n\n\tif (_ShaderPass2.default === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.ShaderPass');\n\t}\n\n\tthis.copyPass = new _ShaderPass2.default(_CopyShader2.default);\n};\n\nObject.assign(EffectComposer.prototype, {\n\n\tswapBuffers: function swapBuffers() {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\t},\n\n\taddPass: function addPass(pass) {\n\n\t\tthis.passes.push(pass);\n\n\t\tvar size = this.renderer.getDrawingBufferSize();\n\t\tpass.setSize(size.width, size.height);\n\t},\n\n\tinsertPass: function insertPass(pass, index) {\n\n\t\tthis.passes.splice(index, 0, pass);\n\t},\n\n\trender: function render(delta) {\n\n\t\tvar maskActive = false;\n\n\t\tvar pass,\n\t\t    i,\n\t\t    il = this.passes.length;\n\n\t\tfor (i = 0; i < il; i++) {\n\n\t\t\tpass = this.passes[i];\n\n\t\t\tif (pass.enabled === false) continue;\n\n\t\t\tpass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);\n\n\t\t\tif (pass.needsSwap) {\n\n\t\t\t\tif (maskActive) {\n\n\t\t\t\t\tvar context = this.renderer.context;\n\n\t\t\t\t\tcontext.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n\n\t\t\t\t\tthis.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);\n\n\t\t\t\t\tcontext.stencilFunc(context.EQUAL, 1, 0xffffffff);\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\t\t\t}\n\n\t\t\tif (THREE.MaskPass !== undefined) {\n\n\t\t\t\tif (pass instanceof THREE.MaskPass) {\n\n\t\t\t\t\tmaskActive = true;\n\t\t\t\t} else if (pass instanceof THREE.ClearMaskPass) {\n\n\t\t\t\t\tmaskActive = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\treset: function reset(renderTarget) {\n\n\t\tif (renderTarget === undefined) {\n\n\t\t\tvar size = this.renderer.getDrawingBufferSize();\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize(size.width, size.height);\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.renderTarget1.setSize(width, height);\n\t\tthis.renderTarget2.setSize(width, height);\n\n\t\tfor (var i = 0; i < this.passes.length; i++) {\n\n\t\t\tthis.passes[i].setSize(width, height);\n\t\t}\n\t}\n\n});\n\nexports.default = EffectComposer;\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _FilmShader = __webpack_require__(16);\n\nvar _FilmShader2 = _interopRequireDefault(_FilmShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar FilmPass = function FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {\n\n\t_Pass2.default.call(this);\n\n\tif (_FilmShader2.default === undefined) console.error(\"THREE.FilmPass relies on THREE.FilmShader\");\n\n\tvar shader = _FilmShader2.default;\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t});\n\n\tif (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;\n\tif (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;\n\tif (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;\n\tif (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nFilmPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: FilmPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.uniforms[\"time\"].value += delta;\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n\n});\n\nexports.default = FilmPass;\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _DigitalGlitch = __webpack_require__(17);\n\nvar _DigitalGlitch2 = _interopRequireDefault(_DigitalGlitch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar GlitchPass = function GlitchPass(dt_size) {\n\n\t_Pass2.default.call(this);\n\n\tif (_DigitalGlitch2.default === undefined) console.error(\"THREE.GlitchPass relies on THREE.DigitalGlitch\");\n\n\tvar shader = _DigitalGlitch2.default;\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tif (dt_size == undefined) dt_size = 64;\n\n\tthis.uniforms[\"tDisp\"].value = this.generateHeightmap(dt_size);\n\n\tthis.material = new THREE.ShaderMaterial({\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\t});\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n\n\tthis.goWild = false;\n\tthis.curF = 0;\n\tthis.generateTrigger();\n};\n\nGlitchPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: GlitchPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.uniforms['seed'].value = Math.random(); //default seeding\n\t\tthis.uniforms['byp'].value = 0;\n\n\t\tif (this.curF % this.randX == 0 || this.goWild == true) {\n\n\t\t\tthis.uniforms['amount'].value = Math.random() / 30;\n\t\t\tthis.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);\n\t\t\tthis.uniforms['seed_x'].value = THREE.Math.randFloat(-1, 1);\n\t\t\tthis.uniforms['seed_y'].value = THREE.Math.randFloat(-1, 1);\n\t\t\tthis.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.curF = 0;\n\t\t\tthis.generateTrigger();\n\t\t} else if (this.curF % this.randX < this.randX / 5) {\n\n\t\t\tthis.uniforms['amount'].value = Math.random() / 90;\n\t\t\tthis.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);\n\t\t\tthis.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.uniforms['seed_x'].value = THREE.Math.randFloat(-0.3, 0.3);\n\t\t\tthis.uniforms['seed_y'].value = THREE.Math.randFloat(-0.3, 0.3);\n\t\t} else if (this.goWild == false) {\n\n\t\t\tthis.uniforms['byp'].value = 1;\n\t\t}\n\n\t\tthis.curF++;\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t},\n\n\tgenerateTrigger: function generateTrigger() {\n\n\t\tthis.randX = THREE.Math.randInt(120, 240);\n\t},\n\n\tgenerateHeightmap: function generateHeightmap(dt_size) {\n\n\t\tvar data_arr = new Float32Array(dt_size * dt_size * 3);\n\t\tvar length = dt_size * dt_size;\n\n\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\tvar val = THREE.Math.randFloat(0, 1);\n\t\t\tdata_arr[i * 3 + 0] = val;\n\t\t\tdata_arr[i * 3 + 1] = val;\n\t\t\tdata_arr[i * 3 + 2] = val;\n\t\t}\n\n\t\tvar texture = new THREE.DataTexture(data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType);\n\t\ttexture.needsUpdate = true;\n\t\treturn texture;\n\t}\n\n});\n\nexports.default = GlitchPass;\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _HalftoneShader = __webpack_require__(18);\n\nvar _HalftoneShader2 = _interopRequireDefault(_HalftoneShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author meatbags / xavierburrow.com, github/meatbags\n *\n * RGB Halftone pass for three.js effects composer. Requires THREE.HalftoneShader.\n *\n */\n\nvar HalftonePass = function HalftonePass(width, height, params) {\n\n  _Pass2.default.call(this);\n\n  if (_HalftoneShader2.default === undefined) {\n\n    console.error('THREE.HalftonePass requires THREE.HalftoneShader');\n  }\n\n  this.uniforms = THREE.UniformsUtils.clone(_HalftoneShader2.default.uniforms);\n  this.material = new THREE.ShaderMaterial({\n    uniforms: this.uniforms,\n    fragmentShader: _HalftoneShader2.default.fragmentShader,\n    vertexShader: _HalftoneShader2.default.vertexShader\n  });\n\n  // set params\n  this.uniforms.width.value = width;\n  this.uniforms.height.value = height;\n\n  for (var key in params) {\n\n    if (params.hasOwnProperty(key) && this.uniforms.hasOwnProperty(key)) {\n\n      this.uniforms[key].value = params[key];\n    }\n  }\n\n  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new THREE.Scene();\n  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n  this.quad.frustumCulled = false;\n  this.scene.add(this.quad);\n};\n\nHalftonePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n  constructor: HalftonePass,\n\n  render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n    this.material.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n    this.quad.material = this.material;\n\n    if (this.renderToScreen) {\n\n      renderer.render(this.scene, this.camera);\n    } else {\n\n      renderer.render(this.scene, this.camera, writeBuffer, this.clear);\n    }\n  },\n\n  setSize: function setSize(width, height) {\n\n    this.uniforms.width.value = width;\n    this.uniforms.height.value = height;\n  }\n});\n\nexports.default = HalftonePass;\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar MaskPass = function MaskPass(scene, camera) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.inverse = false;\n};\n\nMaskPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: MaskPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar context = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask(false);\n\t\tstate.buffers.depth.setMask(false);\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked(true);\n\t\tstate.buffers.depth.setLocked(true);\n\n\t\t// set up stencil\n\n\t\tvar writeValue, clearValue;\n\n\t\tif (this.inverse) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\t\t}\n\n\t\tstate.buffers.stencil.setTest(true);\n\t\tstate.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n\t\tstate.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n\t\tstate.buffers.stencil.setClear(clearValue);\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.render(this.scene, this.camera, readBuffer, this.clear);\n\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\n\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\tstate.buffers.color.setLocked(false);\n\t\tstate.buffers.depth.setLocked(false);\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n\t\tstate.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n\t}\n\n});\n\nexports.default = MaskPass;\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author spidersharma / http://eduperiment.com/\n */\n\nvar OutlinePass = function OutlinePass(resolution, scene, camera, selectedObjects) {\n\n\tthis.renderScene = scene;\n\tthis.renderCamera = camera;\n\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\tthis.visibleEdgeColor = new THREE.Color(1, 1, 1);\n\tthis.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);\n\tthis.edgeGlow = 0.0;\n\tthis.usePatternTexture = false;\n\tthis.edgeThickness = 1.0;\n\tthis.edgeStrength = 3.0;\n\tthis.downSampleRatio = 2;\n\tthis.pulsePeriod = 0;\n\n\t_Pass2.default.call(this);\n\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\n\tvar resx = Math.round(this.resolution.x / this.downSampleRatio);\n\tvar resy = Math.round(this.resolution.y / this.downSampleRatio);\n\n\tthis.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\n\tthis.maskBufferMaterial.side = THREE.DoubleSide;\n\tthis.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n\tthis.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.side = THREE.DoubleSide;\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\tthis.prepareMaskMaterial.side = THREE.DoubleSide;\n\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n\n\tthis.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n\tthis.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\tthis.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\tthis.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\tthis.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n\tthis.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\tthis.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\tthis.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n\tthis.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\tvar MAX_EDGE_THICKNESS = 4;\n\tvar MAX_EDGE_GLOW = 4;\n\n\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n\tthis.separableBlurMaterial1.uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\tthis.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n\tthis.separableBlurMaterial2.uniforms[\"texSize\"].value = new THREE.Vector2(Math.round(resx / 2), Math.round(resy / 2));\n\tthis.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n\n\t// Overlay material\n\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t// copy material\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.OutlinePass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t});\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n\n\tthis.tempPulseColor1 = new THREE.Color();\n\tthis.tempPulseColor2 = new THREE.Color();\n\tthis.textureMatrix = new THREE.Matrix4();\n\n\tfunction replaceDepthToViewZ(string, camera) {\n\n\t\tvar type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\treturn string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n\t}\n};\n\nOutlinePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: OutlinePass,\n\n\tdispose: function dispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.renderTargetMaskBuffer.setSize(width, height);\n\n\t\tvar resx = Math.round(width / this.downSampleRatio);\n\t\tvar resy = Math.round(height / this.downSampleRatio);\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n\t\tthis.renderTargetBlurBuffer1.setSize(resx, resy);\n\t\tthis.renderTargetEdgeBuffer1.setSize(resx, resy);\n\t\tthis.separableBlurMaterial1.uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\tresx = Math.round(resx / 2);\n\t\tresy = Math.round(resy / 2);\n\n\t\tthis.renderTargetBlurBuffer2.setSize(resx, resy);\n\t\tthis.renderTargetEdgeBuffer2.setSize(resx, resy);\n\n\t\tthis.separableBlurMaterial2.uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\t},\n\n\tchangeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {\n\n\t\tfunction gatherSelectedMeshesCallBack(object) {\n\n\t\t\tif (object.isMesh) {\n\n\t\t\t\tif (bVisible) {\n\n\t\t\t\t\tobject.visible = object.userData.oldVisible;\n\t\t\t\t\tdelete object.userData.oldVisible;\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.userData.oldVisible = object.visible;\n\t\t\t\t\tobject.visible = bVisible;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < this.selectedObjects.length; i++) {\n\n\t\t\tvar selectedObject = this.selectedObjects[i];\n\t\t\tselectedObject.traverse(gatherSelectedMeshesCallBack);\n\t\t}\n\t},\n\n\tchangeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {\n\n\t\tvar selectedMeshes = [];\n\n\t\tfunction gatherSelectedMeshesCallBack(object) {\n\n\t\t\tif (object.isMesh) selectedMeshes.push(object);\n\t\t}\n\n\t\tfor (var i = 0; i < this.selectedObjects.length; i++) {\n\n\t\t\tvar selectedObject = this.selectedObjects[i];\n\t\t\tselectedObject.traverse(gatherSelectedMeshesCallBack);\n\t\t}\n\n\t\tfunction VisibilityChangeCallBack(object) {\n\n\t\t\tif (object.isMesh || object.isLine || object.isSprite) {\n\n\t\t\t\tvar bFound = false;\n\n\t\t\t\tfor (var i = 0; i < selectedMeshes.length; i++) {\n\n\t\t\t\t\tvar selectedObjectId = selectedMeshes[i].id;\n\n\t\t\t\t\tif (selectedObjectId === object.id) {\n\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!bFound) {\n\n\t\t\t\t\tvar visibility = object.visible;\n\n\t\t\t\t\tif (!bVisible || object.bVisible) object.visible = bVisible;\n\n\t\t\t\t\tobject.bVisible = visibility;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.renderScene.traverse(VisibilityChangeCallBack);\n\t},\n\n\tupdateTextureMatrix: function updateTextureMatrix() {\n\n\t\tthis.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\t\tthis.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n\t\tthis.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n\t},\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (this.selectedObjects.length > 0) {\n\n\t\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t\trenderer.setClearColor(0xffffff, 1);\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis.changeVisibilityOfSelectedObjects(false);\n\n\t\t\tvar currentBackground = this.renderScene.background;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.render(this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true);\n\n\t\t\t// Make selected objects visible\n\t\t\tthis.changeVisibilityOfSelectedObjects(true);\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis.updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis.changeVisibilityOfNonSelectedObjects(false);\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value = new THREE.Vector2(this.renderCamera.near, this.renderCamera.far);\n\t\t\tthis.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n\t\t\trenderer.render(this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true);\n\t\t\tthis.renderScene.overrideMaterial = null;\n\t\t\tthis.changeVisibilityOfNonSelectedObjects(true);\n\n\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis.quad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true);\n\n\t\t\tthis.tempPulseColor1.copy(this.visibleEdgeColor);\n\t\t\tthis.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n\t\t\tif (this.pulsePeriod > 0) {\n\n\t\t\t\tvar scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar(scalar);\n\t\t\t\tthis.tempPulseColor2.multiplyScalar(scalar);\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis.quad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"texSize\"].value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis.quad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetBlurBuffer1, true);\n\t\t\tthis.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis.quad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetBlurBuffer2, true);\n\t\t\tthis.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer2, true);\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis.quad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n\n\t\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\t\trenderer.render(this.scene, this.camera, readBuffer, false);\n\n\t\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.quad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t}\n\t},\n\n\tgetPrepareMaskMaterial: function getPrepareMaskMaterial() {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"depthTexture\": { value: null },\n\t\t\t\t\"cameraNearFar\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"textureMatrix\": { value: new THREE.Matrix4() }\n\t\t\t},\n\n\t\t\tvertexShader: ['varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\tvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tprojTexCoord = textureMatrix * worldPosition;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\t\t\tfragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\n')\n\n\t\t});\n\t},\n\n\tgetEdgeDetectionMaterial: function getEdgeDetectionMaterial() {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"visibleEdgeColor\": { value: new THREE.Vector3(1.0, 1.0, 1.0) },\n\t\t\t\t\"hiddenEdgeColor\": { value: new THREE.Vector3(1.0, 1.0, 1.0) }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"MAX_RADIUS\": maxRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"kernelRadius\": { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetOverlayMaterial: function getOverlayMaterial() {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\"edgeTexture1\": { value: null },\n\t\t\t\t\"edgeTexture2\": { value: null },\n\t\t\t\t\"patternTexture\": { value: null },\n\t\t\t\t\"edgeStrength\": { value: 1.0 },\n\t\t\t\t\"edgeGlow\": { value: 1.0 },\n\t\t\t\t\"usePatternTexture\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}\",\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t});\n\t}\n\n});\n\nOutlinePass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\nexports.default = OutlinePass;\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar RenderPass = function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.overrideMaterial = overrideMaterial;\n\n\tthis.clearColor = clearColor;\n\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\tthis.clear = true;\n\tthis.clearDepth = false;\n\tthis.needsSwap = false;\n};\n\nRenderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: RenderPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\tvar oldClearColor, oldClearAlpha;\n\n\t\tif (this.clearColor) {\n\n\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t}\n\n\t\tif (this.clearDepth) {\n\n\t\t\trenderer.clearDepth();\n\t\t}\n\n\t\trenderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\tif (this.clearColor) {\n\n\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\t\trenderer.autoClear = oldAutoClear;\n\t}\n\n});\n\nexports.default = RenderPass;\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _SAOShader = __webpack_require__(19);\n\nvar _SAOShader2 = _interopRequireDefault(_SAOShader);\n\nvar _DepthLimitedBlurShader = __webpack_require__(20);\n\nvar _DepthLimitedBlurShader2 = _interopRequireDefault(_DepthLimitedBlurShader);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _UnpackDepthRGBAShader = __webpack_require__(21);\n\nvar _UnpackDepthRGBAShader2 = _interopRequireDefault(_UnpackDepthRGBAShader);\n\nvar _BlurShaderUtils = __webpack_require__(22);\n\nvar _BlurShaderUtils2 = _interopRequireDefault(_BlurShaderUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author ludobaka / ludobaka.github.io\n * SAO implementation inspired from bhouston previous SAO work\n */\n\nvar SAOPass = function SAOPass(scene, camera, depthTexture, useNormals, resolution) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.supportsDepthTextureExtension = depthTexture !== undefined ? depthTexture : false;\n\tthis.supportsNormalTexture = useNormals !== undefined ? useNormals : false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.params = {\n\t\toutput: 0,\n\t\tsaoBias: 0.5,\n\t\tsaoIntensity: 0.18,\n\t\tsaoScale: 1,\n\t\tsaoKernelRadius: 100,\n\t\tsaoMinResolution: 0,\n\t\tsaoBlur: true,\n\t\tsaoBlurRadius: 8,\n\t\tsaoBlurStdDev: 4,\n\t\tsaoBlurDepthCutoff: 0.01\n\t};\n\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\tthis.saoRenderTarget = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBAFormat\n\t});\n\tthis.blurIntermediateRenderTarget = this.saoRenderTarget.clone();\n\tthis.beautyRenderTarget = this.saoRenderTarget.clone();\n\n\tthis.normalRenderTarget = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n\t\tminFilter: THREE.NearestFilter,\n\t\tmagFilter: THREE.NearestFilter,\n\t\tformat: THREE.RGBAFormat\n\t});\n\tthis.depthRenderTarget = this.normalRenderTarget.clone();\n\n\tif (this.supportsDepthTextureExtension) {\n\n\t\tvar depthTexture = new THREE.DepthTexture();\n\t\tdepthTexture.type = THREE.UnsignedShortType;\n\t\tdepthTexture.minFilter = THREE.NearestFilter;\n\t\tdepthTexture.maxFilter = THREE.NearestFilter;\n\n\t\tthis.beautyRenderTarget.depthTexture = depthTexture;\n\t\tthis.beautyRenderTarget.depthBuffer = true;\n\t}\n\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\tthis.normalMaterial = new THREE.MeshNormalMaterial();\n\tthis.normalMaterial.blending = THREE.NoBlending;\n\n\tif (_SAOShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.SAOShader');\n\t}\n\n\tthis.saoMaterial = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, _SAOShader2.default.defines),\n\t\tfragmentShader: _SAOShader2.default.fragmentShader,\n\t\tvertexShader: _SAOShader2.default.vertexShader,\n\t\tuniforms: THREE.UniformsUtils.clone(_SAOShader2.default.uniforms)\n\t});\n\tthis.saoMaterial.extensions.derivatives = true;\n\tthis.saoMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.saoMaterial.defines['NORMAL_TEXTURE'] = this.supportsNormalTexture ? 1 : 0;\n\tthis.saoMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.saoMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n\tthis.saoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;\n\tthis.saoMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n\tthis.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.getInverse(this.camera.projectionMatrix);\n\tthis.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\n\tthis.saoMaterial.blending = THREE.NoBlending;\n\n\tif (_DepthLimitedBlurShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.DepthLimitedBlurShader');\n\t}\n\n\tthis.vBlurMaterial = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_DepthLimitedBlurShader2.default.uniforms),\n\t\tdefines: Object.assign({}, _DepthLimitedBlurShader2.default.defines),\n\t\tvertexShader: _DepthLimitedBlurShader2.default.vertexShader,\n\t\tfragmentShader: _DepthLimitedBlurShader2.default.fragmentShader\n\t});\n\tthis.vBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.vBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.vBlurMaterial.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\n\tthis.vBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n\tthis.vBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n\tthis.vBlurMaterial.blending = THREE.NoBlending;\n\n\tthis.hBlurMaterial = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_DepthLimitedBlurShader2.default.uniforms),\n\t\tdefines: Object.assign({}, _DepthLimitedBlurShader2.default.defines),\n\t\tvertexShader: _DepthLimitedBlurShader2.default.vertexShader,\n\t\tfragmentShader: _DepthLimitedBlurShader2.default.fragmentShader\n\t});\n\tthis.hBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.hBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.hBlurMaterial.uniforms['tDiffuse'].value = this.blurIntermediateRenderTarget.texture;\n\tthis.hBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n\tthis.hBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n\tthis.hBlurMaterial.blending = THREE.NoBlending;\n\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.CopyShader');\n\t}\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_CopyShader2.default.uniforms),\n\t\tvertexShader: _CopyShader2.default.vertexShader,\n\t\tfragmentShader: _CopyShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\tthis.materialCopy.transparent = true;\n\tthis.materialCopy.depthTest = false;\n\tthis.materialCopy.depthWrite = false;\n\tthis.materialCopy.blending = THREE.CustomBlending;\n\tthis.materialCopy.blendSrc = THREE.DstColorFactor;\n\tthis.materialCopy.blendDst = THREE.ZeroFactor;\n\tthis.materialCopy.blendEquation = THREE.AddEquation;\n\tthis.materialCopy.blendSrcAlpha = THREE.DstAlphaFactor;\n\tthis.materialCopy.blendDstAlpha = THREE.ZeroFactor;\n\tthis.materialCopy.blendEquationAlpha = THREE.AddEquation;\n\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.UnpackDepthRGBAShader');\n\t}\n\n\tthis.depthCopy = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_UnpackDepthRGBAShader2.default.uniforms),\n\t\tvertexShader: _UnpackDepthRGBAShader2.default.vertexShader,\n\t\tfragmentShader: _UnpackDepthRGBAShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\n\tthis.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.quadScene = new THREE.Scene();\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quadScene.add(this.quad);\n};\n\nSAOPass.OUTPUT = {\n\t'Beauty': 1,\n\t'Default': 0,\n\t'SAO': 2,\n\t'Depth': 3,\n\t'Normal': 4\n};\n\nSAOPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\tconstructor: SAOPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t// Rendering readBuffer first when rendering to screen\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.materialCopy.blending = THREE.NoBlending;\n\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = readBuffer.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t\tthis.renderPass(renderer, this.materialCopy, null);\n\t\t}\n\n\t\tif (this.params.output === 1) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.clearTarget(this.depthRenderTarget);\n\n\t\tthis.saoMaterial.uniforms['bias'].value = this.params.saoBias;\n\t\tthis.saoMaterial.uniforms['intensity'].value = this.params.saoIntensity;\n\t\tthis.saoMaterial.uniforms['scale'].value = this.params.saoScale;\n\t\tthis.saoMaterial.uniforms['kernelRadius'].value = this.params.saoKernelRadius;\n\t\tthis.saoMaterial.uniforms['minResolution'].value = this.params.saoMinResolution;\n\t\tthis.saoMaterial.uniforms['cameraNear'].value = this.camera.near;\n\t\tthis.saoMaterial.uniforms['cameraFar'].value = this.camera.far;\n\t\t// this.saoMaterial.uniforms['randomSeed'].value = Math.random();\n\n\t\tvar depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);\n\t\tthis.vBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\n\t\tthis.hBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\n\n\t\tthis.vBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\n\t\tthis.vBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\n\t\tthis.hBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\n\t\tthis.hBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\n\n\t\tthis.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);\n\t\tif (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {\n\n\t\t\t_BlurShaderUtils2.default.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2(0, 1));\n\t\t\t_BlurShaderUtils2.default.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2(1, 0));\n\t\t\tthis.prevStdDev = this.params.saoBlurStdDev;\n\t\t\tthis.prevNumSamples = this.params.saoBlurRadius;\n\t\t}\n\n\t\t// Rendering scene to depth texture\n\t\trenderer.setClearColor(0x000000);\n\t\trenderer.render(this.scene, this.camera, this.beautyRenderTarget, true);\n\n\t\t// Re-render scene if depth texture extension is not supported\n\t\tif (!this.supportsDepthTextureExtension) {\n\n\t\t\t// Clear rule : far clipping plane in both RGBA and Basic encoding\n\t\t\tthis.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0);\n\t\t}\n\n\t\tif (this.supportsNormalTexture) {\n\n\t\t\t// Clear rule : default normal is facing the camera\n\t\t\tthis.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);\n\t\t}\n\n\t\t// Rendering SAO texture\n\t\tthis.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0);\n\n\t\t// Blurring SAO texture\n\t\tif (this.params.saoBlur) {\n\n\t\t\tthis.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0);\n\t\t\tthis.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0);\n\t\t}\n\n\t\tvar outputMaterial = this.materialCopy;\n\t\t// Setting up SAO rendering\n\t\tif (this.params.output === 3) {\n\n\t\t\tif (this.supportsDepthTextureExtension) {\n\n\t\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = this.beautyRenderTarget.depthTexture;\n\t\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t\t} else {\n\n\t\t\t\tthis.depthCopy.uniforms['tDiffuse'].value = this.depthRenderTarget.texture;\n\t\t\t\tthis.depthCopy.needsUpdate = true;\n\t\t\t\toutputMaterial = this.depthCopy;\n\t\t\t}\n\t\t} else if (this.params.output === 4) {\n\n\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t} else {\n\n\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t}\n\n\t\t// Blending depends on output, only want a CustomBlending when showing SAO\n\t\tif (this.params.output === 0) {\n\n\t\t\toutputMaterial.blending = THREE.CustomBlending;\n\t\t} else {\n\n\t\t\toutputMaterial.blending = THREE.NoBlending;\n\t\t}\n\n\t\t// Rendering SAOPass result on top of previous pass\n\t\tthis.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);\n\n\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\trenderer.autoClear = oldAutoClear;\n\t},\n\n\trenderPass: function renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n\n\t\t// save original state\n\t\tvar originalClearColor = renderer.getClearColor();\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\n\t\tvar originalAutoClear = renderer.autoClear;\n\n\t\t// setup pass state\n\t\trenderer.autoClear = false;\n\t\tvar clearNeeded = clearColor !== undefined && clearColor !== null;\n\t\tif (clearNeeded) {\n\n\t\t\trenderer.setClearColor(clearColor);\n\t\t\trenderer.setClearAlpha(clearAlpha || 0.0);\n\t\t}\n\n\t\tthis.quad.material = passMaterial;\n\t\trenderer.render(this.quadScene, this.quadCamera, renderTarget, clearNeeded);\n\n\t\t// restore original state\n\t\trenderer.autoClear = originalAutoClear;\n\t\trenderer.setClearColor(originalClearColor);\n\t\trenderer.setClearAlpha(originalClearAlpha);\n\t},\n\n\trenderOverride: function renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n\n\t\tvar originalClearColor = renderer.getClearColor();\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\n\t\tvar originalAutoClear = renderer.autoClear;\n\n\t\trenderer.autoClear = false;\n\n\t\tclearColor = overrideMaterial.clearColor || clearColor;\n\t\tclearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\t\tvar clearNeeded = clearColor !== undefined && clearColor !== null;\n\t\tif (clearNeeded) {\n\n\t\t\trenderer.setClearColor(clearColor);\n\t\t\trenderer.setClearAlpha(clearAlpha || 0.0);\n\t\t}\n\n\t\tthis.scene.overrideMaterial = overrideMaterial;\n\t\trenderer.render(this.scene, this.camera, renderTarget, clearNeeded);\n\t\tthis.scene.overrideMaterial = null;\n\n\t\t// restore original state\n\t\trenderer.autoClear = originalAutoClear;\n\t\trenderer.setClearColor(originalClearColor);\n\t\trenderer.setClearAlpha(originalClearAlpha);\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.beautyRenderTarget.setSize(width, height);\n\t\tthis.saoRenderTarget.setSize(width, height);\n\t\tthis.blurIntermediateRenderTarget.setSize(width, height);\n\t\tthis.normalRenderTarget.setSize(width, height);\n\t\tthis.depthRenderTarget.setSize(width, height);\n\n\t\tthis.saoMaterial.uniforms['size'].value.set(width, height);\n\t\tthis.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.getInverse(this.camera.projectionMatrix);\n\t\tthis.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\n\t\tthis.saoMaterial.needsUpdate = true;\n\n\t\tthis.vBlurMaterial.uniforms['size'].value.set(width, height);\n\t\tthis.vBlurMaterial.needsUpdate = true;\n\n\t\tthis.hBlurMaterial.uniforms['size'].value.set(width, height);\n\t\tthis.hBlurMaterial.needsUpdate = true;\n\t}\n\n});\n\nexports.default = SAOPass;\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar SavePass = function SavePass(renderTarget) {\n\n\t_Pass2.default.call(this);\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.SavePass relies on THREE.CopyShader\");\n\n\tvar shader = _CopyShader2.default;\n\n\tthis.textureID = \"tDiffuse\";\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t});\n\n\tthis.renderTarget = renderTarget;\n\n\tif (this.renderTarget === undefined) {\n\n\t\tthis.renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false });\n\t\tthis.renderTarget.texture.name = \"SavePass.rt\";\n\t}\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nSavePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: SavePass,\n\n\trender: function render(renderer, writeBuffer, readBuffer) {\n\n\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t}\n\n\t\tthis.quad.material = this.material;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTarget, this.clear);\n\t}\n\n});\n\nexports.default = SavePass;\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _SMAAShader = __webpack_require__(23);\n\nvar _SMAAShader2 = _interopRequireDefault(_SMAAShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mpk / http://polko.me/\n */\n\nvar SMAAPass = function SMAAPass(width, height) {\n\n\t_Pass2.default.call(this);\n\n\t// render targets\n\n\tthis.edgesRT = new THREE.WebGLRenderTarget(width, height, {\n\t\tdepthBuffer: false,\n\t\tstencilBuffer: false,\n\t\tgenerateMipmaps: false,\n\t\tminFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t});\n\tthis.edgesRT.texture.name = \"SMAAPass.edges\";\n\n\tthis.weightsRT = new THREE.WebGLRenderTarget(width, height, {\n\t\tdepthBuffer: false,\n\t\tstencilBuffer: false,\n\t\tgenerateMipmaps: false,\n\t\tminFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBAFormat\n\t});\n\tthis.weightsRT.texture.name = \"SMAAPass.weights\";\n\n\t// textures\n\n\tvar areaTextureImage = new Image();\n\tareaTextureImage.src = this.getAreaTexture();\n\n\tthis.areaTexture = new THREE.Texture();\n\tthis.areaTexture.name = \"SMAAPass.area\";\n\tthis.areaTexture.image = areaTextureImage;\n\tthis.areaTexture.format = THREE.RGBFormat;\n\tthis.areaTexture.minFilter = THREE.LinearFilter;\n\tthis.areaTexture.generateMipmaps = false;\n\tthis.areaTexture.needsUpdate = true;\n\tthis.areaTexture.flipY = false;\n\n\tvar searchTextureImage = new Image();\n\tsearchTextureImage.src = this.getSearchTexture();\n\n\tthis.searchTexture = new THREE.Texture();\n\tthis.searchTexture.name = \"SMAAPass.search\";\n\tthis.searchTexture.image = searchTextureImage;\n\tthis.searchTexture.magFilter = THREE.NearestFilter;\n\tthis.searchTexture.minFilter = THREE.NearestFilter;\n\tthis.searchTexture.generateMipmaps = false;\n\tthis.searchTexture.needsUpdate = true;\n\tthis.searchTexture.flipY = false;\n\n\t// materials - pass 1\n\n\tif (_SMAAShader2.default === undefined) {\n\t\tconsole.error(\"THREE.SMAAPass relies on THREE.SMAAShader\");\n\t}\n\n\tthis.uniformsEdges = THREE.UniformsUtils.clone(_SMAAShader2.default[0].uniforms);\n\n\tthis.uniformsEdges[\"resolution\"].value.set(1 / width, 1 / height);\n\n\tthis.materialEdges = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, _SMAAShader2.default[0].defines),\n\t\tuniforms: this.uniformsEdges,\n\t\tvertexShader: _SMAAShader2.default[0].vertexShader,\n\t\tfragmentShader: _SMAAShader2.default[0].fragmentShader\n\t});\n\n\t// materials - pass 2\n\n\tthis.uniformsWeights = THREE.UniformsUtils.clone(_SMAAShader2.default[1].uniforms);\n\n\tthis.uniformsWeights[\"resolution\"].value.set(1 / width, 1 / height);\n\tthis.uniformsWeights[\"tDiffuse\"].value = this.edgesRT.texture;\n\tthis.uniformsWeights[\"tArea\"].value = this.areaTexture;\n\tthis.uniformsWeights[\"tSearch\"].value = this.searchTexture;\n\n\tthis.materialWeights = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, _SMAAShader2.default[1].defines),\n\t\tuniforms: this.uniformsWeights,\n\t\tvertexShader: _SMAAShader2.default[1].vertexShader,\n\t\tfragmentShader: _SMAAShader2.default[1].fragmentShader\n\t});\n\n\t// materials - pass 3\n\n\tthis.uniformsBlend = THREE.UniformsUtils.clone(_SMAAShader2.default[2].uniforms);\n\n\tthis.uniformsBlend[\"resolution\"].value.set(1 / width, 1 / height);\n\tthis.uniformsBlend[\"tDiffuse\"].value = this.weightsRT.texture;\n\n\tthis.materialBlend = new THREE.ShaderMaterial({\n\t\tuniforms: this.uniformsBlend,\n\t\tvertexShader: _SMAAShader2.default[2].vertexShader,\n\t\tfragmentShader: _SMAAShader2.default[2].fragmentShader\n\t});\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nSMAAPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: SMAAPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t// pass 1\n\n\t\tthis.uniformsEdges[\"tDiffuse\"].value = readBuffer.texture;\n\n\t\tthis.quad.material = this.materialEdges;\n\n\t\trenderer.render(this.scene, this.camera, this.edgesRT, this.clear);\n\n\t\t// pass 2\n\n\t\tthis.quad.material = this.materialWeights;\n\n\t\trenderer.render(this.scene, this.camera, this.weightsRT, this.clear);\n\n\t\t// pass 3\n\n\t\tthis.uniformsBlend[\"tColor\"].value = readBuffer.texture;\n\n\t\tthis.quad.material = this.materialBlend;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.edgesRT.setSize(width, height);\n\t\tthis.weightsRT.setSize(width, height);\n\n\t\tthis.materialEdges.uniforms['resolution'].value.set(1 / width, 1 / height);\n\t\tthis.materialWeights.uniforms['resolution'].value.set(1 / width, 1 / height);\n\t\tthis.materialBlend.uniforms['resolution'].value.set(1 / width, 1 / height);\n\t},\n\n\tgetAreaTexture: function getAreaTexture() {\n\t\treturn 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';\n\t},\n\n\tgetSearchTexture: function getSearchTexture() {\n\t\treturn 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';\n\t}\n\n});\n\nexports.default = SMAAPass;\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _ShaderPass = __webpack_require__(3);\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nvar _SSAOShader = __webpack_require__(25);\n\nvar _SSAOShader2 = _interopRequireDefault(_SSAOShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n'use strict';\n\n/**\n * Screen-space ambient occlusion pass.\n *\n * Has the following parameters\n *  - radius\n *  \t- Ambient occlusion shadow radius (numeric value).\n *  - onlyAO\n *  \t- Display only ambient occlusion result (boolean value).\n *  - aoClamp\n *  \t- Ambient occlusion clamp (numeric value).\n *  - lumInfluence\n *  \t- Pixel luminosity influence in AO calculation (numeric value).\n *\n * To output to screen set renderToScreens true\n *\n * @author alteredq / http://alteredqualia.com/\n * @author tentone\n * @class SSAOPass\n */\nvar SSAOPass = function SSAOPass(scene, camera, width, height) {\n\n\tif (_SSAOShader2.default === undefined) {\n\n\t\tconsole.warn('THREE.SSAOPass depends on THREE.SSAOShader');\n\t\treturn new _ShaderPass2.default();\n\t}\n\n\t_ShaderPass2.default.call(this, _SSAOShader2.default);\n\n\tthis.width = width !== undefined ? width : 512;\n\tthis.height = height !== undefined ? height : 256;\n\n\tthis.renderToScreen = false;\n\n\tthis.camera2 = camera;\n\tthis.scene2 = scene;\n\n\t//Depth material\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\t//Depth render target\n\tthis.depthRenderTarget = new THREE.WebGLRenderTarget(this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter });\n\t//this.depthRenderTarget.texture.name = 'SSAOShader.rt';\n\n\t//Shader uniforms\n\tthis.uniforms['tDepth'].value = this.depthRenderTarget.texture;\n\tthis.uniforms['size'].value.set(this.width, this.height);\n\tthis.uniforms['cameraNear'].value = this.camera2.near;\n\tthis.uniforms['cameraFar'].value = this.camera2.far;\n\n\tthis.uniforms['radius'].value = 4;\n\tthis.uniforms['onlyAO'].value = false;\n\tthis.uniforms['aoClamp'].value = 0.25;\n\tthis.uniforms['lumInfluence'].value = 0.7;\n\n\t//Setters and getters for uniforms\n\tvar self = this;\n\tObject.defineProperties(this, {\n\n\t\tradius: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['radius'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['radius'].value = value;\n\t\t\t}\n\t\t},\n\n\t\tonlyAO: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['onlyAO'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['onlyAO'].value = value;\n\t\t\t}\n\t\t},\n\n\t\taoClamp: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['aoClamp'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['aoClamp'].value = value;\n\t\t\t}\n\t\t},\n\n\t\tlumInfluence: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['lumInfluence'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['lumInfluence'].value = value;\n\t\t\t}\n\t\t}\n\n\t});\n};\n\nSSAOPass.prototype = Object.create(_ShaderPass2.default.prototype);\n\n/**\n * Render using this pass.\n *\n * @method render\n * @param {WebGLRenderer} renderer\n * @param {WebGLRenderTarget} writeBuffer Buffer to write output.\n * @param {WebGLRenderTarget} readBuffer Input buffer.\n * @param {Number} delta Delta time in milliseconds.\n * @param {Boolean} maskActive Not used in this pass.\n */\nSSAOPass.prototype.render = function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t//Render depth into depthRenderTarget\n\tthis.scene2.overrideMaterial = this.depthMaterial;\n\n\trenderer.render(this.scene2, this.camera2, this.depthRenderTarget, true);\n\n\tthis.scene2.overrideMaterial = null;\n\n\t//SSAO shaderPass\n\t_ShaderPass2.default.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta, maskActive);\n};\n\n/**\n * Change scene to be renderer by this render pass.\n *\n * @method setScene\n * @param {Scene} scene\n */\nSSAOPass.prototype.setScene = function (scene) {\n\n\tthis.scene2 = scene;\n};\n\n/**\n * Set camera used by this render pass.\n *\n * @method setCamera\n * @param {Camera} camera\n */\nSSAOPass.prototype.setCamera = function (camera) {\n\n\tthis.camera2 = camera;\n\n\tthis.uniforms['cameraNear'].value = this.camera2.near;\n\tthis.uniforms['cameraFar'].value = this.camera2.far;\n};\n\n/**\n * Set resolution of this render pass.\n *\n * @method setSize\n * @param {Number} width\n * @param {Number} height\n */\nSSAOPass.prototype.setSize = function (width, height) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.uniforms['size'].value.set(this.width, this.height);\n\tthis.depthRenderTarget.setSize(this.width, this.height);\n};\n\nexports.default = SSAOPass;\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _SSAARenderPass = __webpack_require__(24);\n\nvar _SSAARenderPass2 = _interopRequireDefault(_SSAARenderPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * @author bhouston / http://clara.io/\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nvar TAARenderPass = function TAARenderPass(scene, camera, params) {\n\n\tif (_SSAARenderPass2.default === undefined) {\n\n\t\tconsole.error(\"THREE.TAARenderPass relies on THREE.SSAARenderPass\");\n\t}\n\n\t_SSAARenderPass2.default.call(this, scene, camera, params);\n\n\tthis.sampleLevel = 0;\n\tthis.accumulate = false;\n};\n\nTAARenderPass.JitterVectors = _SSAARenderPass2.default.JitterVectors;\n\nTAARenderPass.prototype = Object.assign(Object.create(_SSAARenderPass2.default.prototype), {\n\n\tconstructor: TAARenderPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta) {\n\n\t\tif (!this.accumulate) {\n\n\t\t\t_SSAARenderPass2.default.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta);\n\n\t\t\tthis.accumulateIndex = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tvar jitterOffsets = TAARenderPass.JitterVectors[5];\n\n\t\tif (!this.sampleRenderTarget) {\n\n\t\t\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n\t\t\tthis.sampleRenderTarget.texture.name = \"TAARenderPass.sample\";\n\t\t}\n\n\t\tif (!this.holdRenderTarget) {\n\n\t\t\tthis.holdRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n\t\t\tthis.holdRenderTarget.texture.name = \"TAARenderPass.hold\";\n\t\t}\n\n\t\tif (this.accumulate && this.accumulateIndex === -1) {\n\n\t\t\t_SSAARenderPass2.default.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, delta);\n\n\t\t\tthis.accumulateIndex = 0;\n\t\t}\n\n\t\tvar autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tvar sampleWeight = 1.0 / jitterOffsets.length;\n\n\t\tif (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = sampleWeight;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = writeBuffer.texture;\n\n\t\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\t\tvar numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\t\t\tfor (var i = 0; i < numSamplesPerFrame; i++) {\n\n\t\t\t\tvar j = this.accumulateIndex;\n\t\t\t\tvar jitterOffset = jitterOffsets[j];\n\n\t\t\t\tif (this.camera.setViewOffset) {\n\n\t\t\t\t\tthis.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\t\treadBuffer.width, readBuffer.height);\n\t\t\t\t}\n\n\t\t\t\trenderer.render(this.scene, this.camera, writeBuffer, true);\n\t\t\t\trenderer.render(this.scene2, this.camera2, this.sampleRenderTarget, this.accumulateIndex === 0);\n\n\t\t\t\tthis.accumulateIndex++;\n\n\t\t\t\tif (this.accumulateIndex >= jitterOffsets.length) break;\n\t\t\t}\n\n\t\t\tif (this.camera.clearViewOffset) this.camera.clearViewOffset();\n\t\t}\n\n\t\tvar accumulationWeight = this.accumulateIndex * sampleWeight;\n\n\t\tif (accumulationWeight > 0) {\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n\t\t\trenderer.render(this.scene2, this.camera2, writeBuffer, true);\n\t\t}\n\n\t\tif (accumulationWeight < 1.0) {\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = 1.0 - accumulationWeight;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = this.holdRenderTarget.texture;\n\t\t\trenderer.render(this.scene2, this.camera2, writeBuffer, accumulationWeight === 0);\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\t}\n\n});\n\nexports.default = TAARenderPass;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar TexturePass = function TexturePass(map, opacity) {\n\n\t_Pass2.default.call(this);\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.TexturePass relies on THREE.CopyShader\");\n\n\tvar shader = _CopyShader2.default;\n\n\tthis.map = map;\n\tthis.opacity = opacity !== undefined ? opacity : 1.0;\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t});\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nTexturePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: TexturePass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis.quad.material = this.material;\n\n\t\tthis.uniforms[\"opacity\"].value = this.opacity;\n\t\tthis.uniforms[\"tDiffuse\"].value = this.map;\n\t\tthis.material.transparent = this.opacity < 1.0;\n\n\t\trenderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\trenderer.autoClear = oldAutoClear;\n\t}\n\n});\n\nexports.default = TexturePass;\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _LuminosityHighPassShader = __webpack_require__(26);\n\nvar _LuminosityHighPassShader2 = _interopRequireDefault(_LuminosityHighPassShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author spidersharma / http://eduperiment.com/\n *\n * Inspired from Unreal Engine\n * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nvar UnrealBloomPass = function UnrealBloomPass(resolution, strength, radius, threshold) {\n\n\t_Pass2.default.call(this);\n\n\tthis.strength = strength !== undefined ? strength : 1;\n\tthis.radius = radius;\n\tthis.threshold = threshold;\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\t// render targets\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\tthis.renderTargetsHorizontal = [];\n\tthis.renderTargetsVertical = [];\n\tthis.nMips = 5;\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tthis.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.h\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsHorizontal.push(renderTarget);\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.v\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsVertical.push(renderTarget);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// luminosity high pass material\n\n\tif (_LuminosityHighPassShader2.default === undefined) console.error(\"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\");\n\n\tvar highPassShader = _LuminosityHighPassShader2.default;\n\tthis.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);\n\n\tthis.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n\tthis.highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n\tthis.materialHighPassFilter = new THREE.ShaderMaterial({\n\t\tuniforms: this.highPassUniforms,\n\t\tvertexShader: highPassShader.vertexShader,\n\t\tfragmentShader: highPassShader.fragmentShader,\n\t\tdefines: {}\n\t});\n\n\t// Gaussian Blur Materials\n\tthis.separableBlurMaterials = [];\n\tvar kernelSizeArray = [3, 5, 7, 9, 11];\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tthis.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n\n\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// Composite material\n\tthis.compositeMaterial = this.getCompositeMaterial(this.nMips);\n\tthis.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n\tthis.compositeMaterial.needsUpdate = true;\n\n\tvar bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n\tthis.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n\tthis.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];\n\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t// copy material\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error(\"THREE.BloomPass relies on THREE.CopyShader\");\n\t}\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t});\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.basic = new THREE.MeshBasicMaterial();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: UnrealBloomPass,\n\n\tdispose: function dispose() {\n\n\t\tfor (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].dispose();\n\t\t}\n\n\t\tfor (var i = 0; i < this.renderTargetsVertical.length; i++) {\n\n\t\t\tthis.renderTargetsVertical[i].dispose();\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tvar resx = Math.round(width / 2);\n\t\tvar resy = Math.round(height / 2);\n\n\t\tthis.renderTargetBright.setSize(resx, resy);\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].setSize(resx, resy);\n\t\t\tthis.renderTargetsVertical[i].setSize(resx, resy);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\t\tresx = Math.round(resx / 2);\n\t\t\tresy = Math.round(resy / 2);\n\t\t}\n\t},\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor(new THREE.Color(0, 0, 0), 0);\n\n\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t// Render input to screen\n\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.quad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, true);\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n\t\tthis.quad.material = this.materialHighPassFilter;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetBright, true);\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.quad.material = this.separableBlurMaterials[i];\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], true);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsVertical[i], true);\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[i];\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.quad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], true);\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.quad.material = this.materialCopy;\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n\n\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, false);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, readBuffer, false);\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\trenderer.autoClear = oldAutoClear;\n\t},\n\n\tgetSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2(0.5, 0.5) }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetCompositeMaterial: function getCompositeMaterial(nMips) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}\"\n\t\t});\n\t}\n\n});\n\nUnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\nexports.default = UnrealBloomPass;\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaterRefractionShader = exports.VignetteShader = exports.VerticalTiltShiftShader = exports.VerticalBlurShader = exports.UnpackDepthRGBAShader = exports.TriangleBlurShader = exports.ToneMapShader = exports.TechnicolorShader = exports.SSAOShader = exports.SobelOperatorShader = exports.SMAAShader = exports.SepiaShader = exports.SAOShader = exports.RGBShiftShader = exports.PixelShader = exports.ParallaxShader = exports.NormalMapShader = exports.MirrorShader = exports.LuminosityShader = exports.LuminosityHighPassShader = exports.KaleidoShader = exports.HueSaturationShader = exports.HorizontalTiltShiftShader = exports.HorizontalBlurShader = exports.HalftoneShader = exports.GammaCorrectionShader = exports.FXAAShader = exports.FresnelShader = exports.FreiChenShader = exports.FocusShader = exports.FilmShader = exports.DotScreenShader = exports.DOFMipMapShader = exports.DigitalGlitch = exports.DepthLimitedBlurShader = exports.CopyShader = exports.ConvolutionShader = exports.ColorifyShader = exports.ColorCorrectionShader = exports.BrightnessContrastShader = exports.BokehShader2 = exports.BokehShader = exports.BlurShaderUtils = exports.BlendShader = exports.BleachBypassShader = exports.BasicShader = undefined;\n\nvar _BasicShader = __webpack_require__(113);\n\nvar _BasicShader2 = _interopRequireDefault(_BasicShader);\n\nvar _BleachBypassShader = __webpack_require__(114);\n\nvar _BleachBypassShader2 = _interopRequireDefault(_BleachBypassShader);\n\nvar _BlendShader = __webpack_require__(115);\n\nvar _BlendShader2 = _interopRequireDefault(_BlendShader);\n\nvar _BlurShaderUtils = __webpack_require__(22);\n\nvar _BlurShaderUtils2 = _interopRequireDefault(_BlurShaderUtils);\n\nvar _BokehShader = __webpack_require__(14);\n\nvar _BokehShader2 = _interopRequireDefault(_BokehShader);\n\nvar _BokehShader3 = __webpack_require__(116);\n\nvar _BokehShader4 = _interopRequireDefault(_BokehShader3);\n\nvar _BrightnessContrastShader = __webpack_require__(117);\n\nvar _BrightnessContrastShader2 = _interopRequireDefault(_BrightnessContrastShader);\n\nvar _ColorCorrectionShader = __webpack_require__(118);\n\nvar _ColorCorrectionShader2 = _interopRequireDefault(_ColorCorrectionShader);\n\nvar _ColorifyShader = __webpack_require__(119);\n\nvar _ColorifyShader2 = _interopRequireDefault(_ColorifyShader);\n\nvar _ConvolutionShader = __webpack_require__(13);\n\nvar _ConvolutionShader2 = _interopRequireDefault(_ConvolutionShader);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _DepthLimitedBlurShader = __webpack_require__(20);\n\nvar _DepthLimitedBlurShader2 = _interopRequireDefault(_DepthLimitedBlurShader);\n\nvar _DigitalGlitch = __webpack_require__(17);\n\nvar _DigitalGlitch2 = _interopRequireDefault(_DigitalGlitch);\n\nvar _DOFMipMapShader = __webpack_require__(120);\n\nvar _DOFMipMapShader2 = _interopRequireDefault(_DOFMipMapShader);\n\nvar _DotScreenShader = __webpack_require__(15);\n\nvar _DotScreenShader2 = _interopRequireDefault(_DotScreenShader);\n\nvar _FilmShader = __webpack_require__(16);\n\nvar _FilmShader2 = _interopRequireDefault(_FilmShader);\n\nvar _FocusShader = __webpack_require__(121);\n\nvar _FocusShader2 = _interopRequireDefault(_FocusShader);\n\nvar _FreiChenShader = __webpack_require__(122);\n\nvar _FreiChenShader2 = _interopRequireDefault(_FreiChenShader);\n\nvar _FresnelShader = __webpack_require__(123);\n\nvar _FresnelShader2 = _interopRequireDefault(_FresnelShader);\n\nvar _FXAAShader = __webpack_require__(124);\n\nvar _FXAAShader2 = _interopRequireDefault(_FXAAShader);\n\nvar _GammaCorrectionShader = __webpack_require__(125);\n\nvar _GammaCorrectionShader2 = _interopRequireDefault(_GammaCorrectionShader);\n\nvar _HalftoneShader = __webpack_require__(18);\n\nvar _HalftoneShader2 = _interopRequireDefault(_HalftoneShader);\n\nvar _HorizontalBlurShader = __webpack_require__(126);\n\nvar _HorizontalBlurShader2 = _interopRequireDefault(_HorizontalBlurShader);\n\nvar _HorizontalTiltShiftShader = __webpack_require__(127);\n\nvar _HorizontalTiltShiftShader2 = _interopRequireDefault(_HorizontalTiltShiftShader);\n\nvar _HueSaturationShader = __webpack_require__(128);\n\nvar _HueSaturationShader2 = _interopRequireDefault(_HueSaturationShader);\n\nvar _KaleidoShader = __webpack_require__(129);\n\nvar _KaleidoShader2 = _interopRequireDefault(_KaleidoShader);\n\nvar _LuminosityHighPassShader = __webpack_require__(26);\n\nvar _LuminosityHighPassShader2 = _interopRequireDefault(_LuminosityHighPassShader);\n\nvar _LuminosityShader = __webpack_require__(11);\n\nvar _LuminosityShader2 = _interopRequireDefault(_LuminosityShader);\n\nvar _MirrorShader = __webpack_require__(130);\n\nvar _MirrorShader2 = _interopRequireDefault(_MirrorShader);\n\nvar _NormalMapShader = __webpack_require__(131);\n\nvar _NormalMapShader2 = _interopRequireDefault(_NormalMapShader);\n\nvar _OceanShaders = __webpack_require__(132);\n\nvar _OceanShaders2 = _interopRequireDefault(_OceanShaders);\n\nvar _ParallaxShader = __webpack_require__(133);\n\nvar _ParallaxShader2 = _interopRequireDefault(_ParallaxShader);\n\nvar _PixelShader = __webpack_require__(134);\n\nvar _PixelShader2 = _interopRequireDefault(_PixelShader);\n\nvar _RGBShiftShader = __webpack_require__(135);\n\nvar _RGBShiftShader2 = _interopRequireDefault(_RGBShiftShader);\n\nvar _SAOShader = __webpack_require__(19);\n\nvar _SAOShader2 = _interopRequireDefault(_SAOShader);\n\nvar _SepiaShader = __webpack_require__(136);\n\nvar _SepiaShader2 = _interopRequireDefault(_SepiaShader);\n\nvar _SMAAShader = __webpack_require__(23);\n\nvar _SMAAShader2 = _interopRequireDefault(_SMAAShader);\n\nvar _SobelOperatorShader = __webpack_require__(137);\n\nvar _SobelOperatorShader2 = _interopRequireDefault(_SobelOperatorShader);\n\nvar _SSAOShader = __webpack_require__(25);\n\nvar _SSAOShader2 = _interopRequireDefault(_SSAOShader);\n\nvar _TechnicolorShader = __webpack_require__(138);\n\nvar _TechnicolorShader2 = _interopRequireDefault(_TechnicolorShader);\n\nvar _ToneMapShader = __webpack_require__(12);\n\nvar _ToneMapShader2 = _interopRequireDefault(_ToneMapShader);\n\nvar _TriangleBlurShader = __webpack_require__(139);\n\nvar _TriangleBlurShader2 = _interopRequireDefault(_TriangleBlurShader);\n\nvar _UnpackDepthRGBAShader = __webpack_require__(21);\n\nvar _UnpackDepthRGBAShader2 = _interopRequireDefault(_UnpackDepthRGBAShader);\n\nvar _VerticalBlurShader = __webpack_require__(140);\n\nvar _VerticalBlurShader2 = _interopRequireDefault(_VerticalBlurShader);\n\nvar _VerticalTiltShiftShader = __webpack_require__(141);\n\nvar _VerticalTiltShiftShader2 = _interopRequireDefault(_VerticalTiltShiftShader);\n\nvar _VignetteShader = __webpack_require__(142);\n\nvar _VignetteShader2 = _interopRequireDefault(_VignetteShader);\n\nvar _WaterRefractionShader = __webpack_require__(143);\n\nvar _WaterRefractionShader2 = _interopRequireDefault(_WaterRefractionShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.BasicShader = _BasicShader2.default;\nexports.BleachBypassShader = _BleachBypassShader2.default;\nexports.BlendShader = _BlendShader2.default;\nexports.BlurShaderUtils = _BlurShaderUtils2.default;\nexports.BokehShader = _BokehShader2.default;\nexports.BokehShader2 = _BokehShader4.default;\nexports.BrightnessContrastShader = _BrightnessContrastShader2.default;\nexports.ColorCorrectionShader = _ColorCorrectionShader2.default;\nexports.ColorifyShader = _ColorifyShader2.default;\nexports.ConvolutionShader = _ConvolutionShader2.default;\nexports.CopyShader = _CopyShader2.default;\nexports.DepthLimitedBlurShader = _DepthLimitedBlurShader2.default;\nexports.DigitalGlitch = _DigitalGlitch2.default;\nexports.DOFMipMapShader = _DOFMipMapShader2.default;\nexports.DotScreenShader = _DotScreenShader2.default;\nexports.FilmShader = _FilmShader2.default;\nexports.FocusShader = _FocusShader2.default;\nexports.FreiChenShader = _FreiChenShader2.default;\nexports.FresnelShader = _FresnelShader2.default;\nexports.FXAAShader = _FXAAShader2.default;\nexports.GammaCorrectionShader = _GammaCorrectionShader2.default;\nexports.HalftoneShader = _HalftoneShader2.default;\nexports.HorizontalBlurShader = _HorizontalBlurShader2.default;\nexports.HorizontalTiltShiftShader = _HorizontalTiltShiftShader2.default;\nexports.HueSaturationShader = _HueSaturationShader2.default;\nexports.KaleidoShader = _KaleidoShader2.default;\nexports.LuminosityHighPassShader = _LuminosityHighPassShader2.default;\nexports.LuminosityShader = _LuminosityShader2.default;\nexports.MirrorShader = _MirrorShader2.default;\nexports.NormalMapShader = _NormalMapShader2.default;\nexports.ParallaxShader = _ParallaxShader2.default;\nexports.PixelShader = _PixelShader2.default;\nexports.RGBShiftShader = _RGBShiftShader2.default;\nexports.SAOShader = _SAOShader2.default;\nexports.SepiaShader = _SepiaShader2.default;\nexports.SMAAShader = _SMAAShader2.default;\nexports.SobelOperatorShader = _SobelOperatorShader2.default;\nexports.SSAOShader = _SSAOShader2.default;\nexports.TechnicolorShader = _TechnicolorShader2.default;\nexports.ToneMapShader = _ToneMapShader2.default;\nexports.TriangleBlurShader = _TriangleBlurShader2.default;\nexports.UnpackDepthRGBAShader = _UnpackDepthRGBAShader2.default;\nexports.VerticalBlurShader = _VerticalBlurShader2.default;\nexports.VerticalTiltShiftShader = _VerticalTiltShiftShader2.default;\nexports.VignetteShader = _VignetteShader2.default;\nexports.WaterRefractionShader = _WaterRefractionShader2.default;\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author mrdoob / http://www.mrdoob.com\n *\n * Simple test shader\n */\n\nvar BasicShader = {\n\n\tuniforms: {},\n\n\tvertexShader: [\"void main() {\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"void main() {\", \"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BasicShader;\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\n * - based on Nvidia example\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\n */\n\nvar BleachBypassShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 base = texture2D( tDiffuse, vUv );\", \"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\", \"float lum = dot( lumCoeff, base.rgb );\", \"vec3 blend = vec3( lum );\", \"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\", \"vec3 result1 = 2.0 * base.rgb * blend;\", \"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\", \"vec3 newColor = mix( result1, result2, L );\", \"float A2 = opacity * base.a;\", \"vec3 mixRGB = A2 * newColor.rgb;\", \"mixRGB += ( ( 1.0 - A2 ) * base.rgb );\", \"gl_FragColor = vec4( mixRGB, base.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BleachBypassShader;\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Blend two textures\n */\n\nvar BlendShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse1\": { value: null },\n\t\t\"tDiffuse2\": { value: null },\n\t\t\"mixRatio\": { value: 0.5 },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform float mixRatio;\", \"uniform sampler2D tDiffuse1;\", \"uniform sampler2D tDiffuse2;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel1 = texture2D( tDiffuse1, vUv );\", \"vec4 texel2 = texture2D( tDiffuse2, vUv );\", \"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BlendShader;\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvar BokehShader2 = {\n\n\tuniforms: {\n\n\t\t\"textureWidth\": { value: 1.0 },\n\t\t\"textureHeight\": { value: 1.0 },\n\n\t\t\"focalDepth\": { value: 1.0 },\n\t\t\"focalLength\": { value: 24.0 },\n\t\t\"fstop\": { value: 0.9 },\n\n\t\t\"tColor\": { value: null },\n\t\t\"tDepth\": { value: null },\n\n\t\t\"maxblur\": { value: 1.0 },\n\n\t\t\"showFocus\": { value: 0 },\n\t\t\"manualdof\": { value: 0 },\n\t\t\"vignetting\": { value: 0 },\n\t\t\"depthblur\": { value: 0 },\n\n\t\t\"threshold\": { value: 0.5 },\n\t\t\"gain\": { value: 2.0 },\n\t\t\"bias\": { value: 0.5 },\n\t\t\"fringe\": { value: 0.7 },\n\n\t\t\"znear\": { value: 0.1 },\n\t\t\"zfar\": { value: 100 },\n\n\t\t\"noise\": { value: 1 },\n\t\t\"dithering\": { value: 0.0001 },\n\t\t\"pentagon\": { value: 0 },\n\n\t\t\"shaderFocus\": { value: 1 },\n\t\t\"focusCoords\": { value: new THREE.Vector2() }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"#include <packing>\", \"varying vec2 vUv;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"uniform float textureWidth;\", \"uniform float textureHeight;\", \"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\", \"uniform float focalLength; //focal length in mm\", \"uniform float fstop; //f-stop value\", \"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\", \"/*\", \"make sure that these two values are the same for your camera, otherwise distances will be wrong.\", \"*/\", \"uniform float znear; // camera clipping start\", \"uniform float zfar; // camera clipping end\", \"//------------------------------------------\", \"//user variables\", \"const int samples = SAMPLES; //samples on the first ring\", \"const int rings = RINGS; //ring count\", \"const int maxringsamples = rings * samples;\", \"uniform bool manualdof; // manual dof calculation\", \"float ndofstart = 1.0; // near dof blur start\", \"float ndofdist = 2.0; // near dof blur falloff distance\", \"float fdofstart = 1.0; // far dof blur start\", \"float fdofdist = 3.0; // far dof blur falloff distance\", \"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\", \"uniform bool vignetting; // use optical lens vignetting\", \"float vignout = 1.3; // vignetting outer border\", \"float vignin = 0.0; // vignetting inner border\", \"float vignfade = 22.0; // f-stops till vignete fades\", \"uniform bool shaderFocus;\", \"// disable if you use external focalDepth value\", \"uniform vec2 focusCoords;\", \"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\", \"// if center of screen use vec2(0.5, 0.5);\", \"uniform float maxblur;\", \"//clamp value of max blur (0.0 = no blur, 1.0 default)\", \"uniform float threshold; // highlight threshold;\", \"uniform float gain; // highlight gain;\", \"uniform float bias; // bokeh edge bias\", \"uniform float fringe; // bokeh chromatic aberration / fringing\", \"uniform bool noise; //use noise instead of pattern for sample dithering\", \"uniform float dithering;\", \"uniform bool depthblur; // blur the depth buffer\", \"float dbsize = 1.25; // depth blur size\", \"/*\", \"next part is experimental\", \"not looking good with small sample and ring count\", \"looks okay starting from samples = 4, rings = 4\", \"*/\", \"uniform bool pentagon; //use pentagon as bokeh shape?\", \"float feather = 0.4; //pentagon shape feather\", \"//------------------------------------------\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float penta(vec2 coords) {\", \"//pentagonal shape\", \"float scale = float(rings) - 1.3;\", \"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\", \"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\", \"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\", \"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\", \"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\", \"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\", \"vec4  one = vec4( 1.0 );\", \"vec4 P = vec4((coords),vec2(scale, scale));\", \"vec4 dist = vec4(0.0);\", \"float inorout = -4.0;\", \"dist.x = dot( P, HS0 );\", \"dist.y = dot( P, HS1 );\", \"dist.z = dot( P, HS2 );\", \"dist.w = dot( P, HS3 );\", \"dist = smoothstep( -feather, feather, dist );\", \"inorout += dot( dist, one );\", \"dist.x = dot( P, HS4 );\", \"dist.y = HS5.w - abs( P.z );\", \"dist = smoothstep( -feather, feather, dist );\", \"inorout += dist.x;\", \"return clamp( inorout, 0.0, 1.0 );\", \"}\", \"float bdepth(vec2 coords) {\", \"// Depth buffer blur\", \"float d = 0.0;\", \"float kernel[9];\", \"vec2 offset[9];\", \"vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\", \"offset[0] = vec2(-wh.x,-wh.y);\", \"offset[1] = vec2( 0.0, -wh.y);\", \"offset[2] = vec2( wh.x -wh.y);\", \"offset[3] = vec2(-wh.x,  0.0);\", \"offset[4] = vec2( 0.0,   0.0);\", \"offset[5] = vec2( wh.x,  0.0);\", \"offset[6] = vec2(-wh.x, wh.y);\", \"offset[7] = vec2( 0.0,  wh.y);\", \"offset[8] = vec2( wh.x, wh.y);\", \"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\", \"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\", \"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\", \"for( int i=0; i<9; i++ ) {\", \"float tmp = getDepth( coords + offset[ i ] );\", \"d += tmp * kernel[i];\", \"}\", \"return d;\", \"}\", \"vec3 color(vec2 coords,float blur) {\", \"//processing the sample\", \"vec3 col = vec3(0.0);\", \"vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\", \"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\", \"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\", \"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\", \"vec3 lumcoeff = vec3(0.299,0.587,0.114);\", \"float lum = dot(col.rgb, lumcoeff);\", \"float thresh = max((lum-threshold)*gain, 0.0);\", \"return col+mix(vec3(0.0),col,thresh*blur);\", \"}\", \"vec3 debugFocus(vec3 col, float blur, float depth) {\", \"float edge = 0.002*depth; //distance based edge smoothing\", \"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\", \"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\", \"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\", \"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\", \"return col;\", \"}\", \"float linearize(float depth) {\", \"return -zfar * znear / (depth * (zfar - znear) - zfar);\", \"}\", \"float vignette() {\", \"float dist = distance(vUv.xy, vec2(0.5,0.5));\", \"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\", \"return clamp(dist,0.0,1.0);\", \"}\", \"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\", \"float rings2 = float(rings);\", \"float step = PI*2.0 / float(ringsamples);\", \"float pw = cos(j*step)*i;\", \"float ph = sin(j*step)*i;\", \"float p = 1.0;\", \"if (pentagon) {\", \"p = penta(vec2(pw,ph));\", \"}\", \"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\", \"return 1.0 * mix(1.0, i /rings2, bias) * p;\", \"}\", \"void main() {\", \"//scene depth calculation\", \"float depth = linearize( getDepth( vUv.xy ) );\", \"// Blur depth?\", \"if (depthblur) {\", \"depth = linearize(bdepth(vUv.xy));\", \"}\", \"//focal plane calculation\", \"float fDepth = focalDepth;\", \"if (shaderFocus) {\", \"fDepth = linearize( getDepth( focusCoords ) );\", \"}\", \"// dof blur factor calculation\", \"float blur = 0.0;\", \"if (manualdof) {\", \"float a = depth-fDepth; // Focal plane\", \"float b = (a-fdofstart)/fdofdist; // Far DoF\", \"float c = (-a-ndofstart)/ndofdist; // Near Dof\", \"blur = (a>0.0) ? b : c;\", \"} else {\", \"float f = focalLength; // focal length in mm\", \"float d = fDepth*1000.0; // focal plane in mm\", \"float o = depth*1000.0; // depth in mm\", \"float a = (o*f)/(o-f);\", \"float b = (d*f)/(d-f);\", \"float c = (d-f)/(d*fstop*CoC);\", \"blur = abs(a-b)*c;\", \"}\", \"blur = clamp(blur,0.0,1.0);\", \"// calculation of pattern for dithering\", \"vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\", \"// getting blur x and y step factor\", \"float w = (1.0/textureWidth)*blur*maxblur+noise.x;\", \"float h = (1.0/textureHeight)*blur*maxblur+noise.y;\", \"// calculation of final color\", \"vec3 col = vec3(0.0);\", \"if(blur < 0.05) {\", \"//some optimization thingy\", \"col = texture2D(tColor, vUv.xy).rgb;\", \"} else {\", \"col = texture2D(tColor, vUv.xy).rgb;\", \"float s = 1.0;\", \"int ringsamples;\", \"for (int i = 1; i <= rings; i++) {\", \"/*unboxstart*/\", \"ringsamples = i * samples;\", \"for (int j = 0 ; j < maxringsamples ; j++) {\", \"if (j >= ringsamples) break;\", \"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\", \"}\", \"/*unboxend*/\", \"}\", \"col /= s; //divide by sample count\", \"}\", \"if (showFocus) {\", \"col = debugFocus(col, blur, depth);\", \"}\", \"if (vignetting) {\", \"col *= vignette();\", \"}\", \"gl_FragColor.rgb = col;\", \"gl_FragColor.a = 1.0;\", \"} \"].join(\"\\n\")\n\n};\n\nexports.default = BokehShader2;\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author tapio / http://tapio.github.com/\n *\n * Brightness and contrast adjustment\n * https://github.com/evanw/glfx.js\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nvar BrightnessContrastShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"brightness\": { value: 0 },\n\t\t\"contrast\": { value: 0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float brightness;\", \"uniform float contrast;\", \"varying vec2 vUv;\", \"void main() {\", \"gl_FragColor = texture2D( tDiffuse, vUv );\", \"gl_FragColor.rgb += brightness;\", \"if (contrast > 0.0) {\", \"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\", \"} else {\", \"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BrightnessContrastShader;\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Color correction\n */\n\nvar ColorCorrectionShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"powRGB\": { value: new THREE.Vector3(2, 2, 2) },\n\t\t\"mulRGB\": { value: new THREE.Vector3(1, 1, 1) },\n\t\t\"addRGB\": { value: new THREE.Vector3(0, 0, 0) }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 powRGB;\", \"uniform vec3 mulRGB;\", \"uniform vec3 addRGB;\", \"varying vec2 vUv;\", \"void main() {\", \"gl_FragColor = texture2D( tDiffuse, vUv );\", \"gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ColorCorrectionShader;\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Colorify shader\n */\n\nvar ColorifyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"color\": { value: new THREE.Color(0xffffff) }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform vec3 color;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"gl_FragColor = vec4( v * color, texel.w );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ColorifyShader;\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader using mipmaps\n * - from Matt Handley @applmak\n * - requires power-of-2 sized render target with enabled mipmaps\n */\n\nvar DOFMipMapShader = {\n\n\tuniforms: {\n\n\t\t\"tColor\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"focus\": { value: 1.0 },\n\t\t\"maxblur\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float focus;\", \"uniform float maxblur;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 depth = texture2D( tDepth, vUv );\", \"float factor = depth.x - focus;\", \"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\", \"gl_FragColor = col;\", \"gl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = DOFMipMapShader;\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Focus shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nvar FocusShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"screenWidth\": { value: 1024 },\n\t\t\"screenHeight\": { value: 1024 },\n\t\t\"sampleDistance\": { value: 0.94 },\n\t\t\"waveFactor\": { value: 0.00125 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float screenWidth;\", \"uniform float screenHeight;\", \"uniform float sampleDistance;\", \"uniform float waveFactor;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 color, org, tmp, add;\", \"float sample_dist, f;\", \"vec2 vin;\", \"vec2 uv = vUv;\", \"add = color = org = texture2D( tDiffuse, uv );\", \"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\", \"sample_dist = dot( vin, vin ) * 2.0;\", \"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\", \"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\", \"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\", \"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\", \"}\"].join(\"\\n\")\n};\n\nexports.default = FocusShader;\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n *\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nvar FreiChenShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"aspect\": { value: new THREE.Vector2(512, 512) }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform vec2 aspect;\", \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\", \"mat3 G[9];\",\n\n\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\", \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\", \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\", \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\", \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\", \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\", \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\", \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\", \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\", \"void main(void)\", \"{\", \"G[0] = g0,\", \"G[1] = g1,\", \"G[2] = g2,\", \"G[3] = g3,\", \"G[4] = g4,\", \"G[5] = g5,\", \"G[6] = g6,\", \"G[7] = g7,\", \"G[8] = g8;\", \"mat3 I;\", \"float cnv[9];\", \"vec3 sample;\",\n\n\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\"for (float i=0.0; i<3.0; i++) {\", \"for (float j=0.0; j<3.0; j++) {\", \"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\", \"I[int(i)][int(j)] = length(sample);\", \"}\", \"}\",\n\n\t/* calculate the convolution values for all the masks */\n\t\"for (int i=0; i<9; i++) {\", \"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\", \"cnv[i] = dp3 * dp3;\", \"}\", \"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\", \"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\", \"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\", \"}\"].join(\"\\n\")\n};\n\nexports.default = FreiChenShader;\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Based on Nvidia Cg tutorial\n */\n\nvar FresnelShader = {\n\n\tuniforms: {\n\n\t\t\"mRefractionRatio\": { value: 1.02 },\n\t\t\"mFresnelBias\": { value: 0.1 },\n\t\t\"mFresnelPower\": { value: 2.0 },\n\t\t\"mFresnelScale\": { value: 1.0 },\n\t\t\"tCube\": { value: null }\n\n\t},\n\n\tvertexShader: [\"uniform float mRefractionRatio;\", \"uniform float mFresnelBias;\", \"uniform float mFresnelScale;\", \"uniform float mFresnelPower;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\", \"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\", \"vec3 I = worldPosition.xyz - cameraPosition;\", \"vReflect = reflect( I, worldNormal );\", \"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\", \"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\", \"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\", \"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\", \"gl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform samplerCube tCube;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\", \"vec4 refractedColor = vec4( 1.0 );\", \"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\", \"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\", \"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\", \"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = FresnelShader;\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author davidedc / http://www.sketchpatch.net/\n *\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nvar FXAAShader = {\n\n  uniforms: {\n\n    \"tDiffuse\": { value: null },\n    \"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n  },\n\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n  fragmentShader: [\"precision highp float;\", \"\", \"uniform sampler2D tDiffuse;\", \"\", \"uniform vec2 resolution;\", \"\", \"varying vec2 vUv;\", \"\", \"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\", \"\", \"//----------------------------------------------------------------------------------\", \"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\", \"// SDK Version: v3.00\", \"// Email:       gameworks@nvidia.com\", \"// Site:        http://developer.nvidia.com/\", \"//\", \"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\", \"//\", \"// Redistribution and use in source and binary forms, with or without\", \"// modification, are permitted provided that the following conditions\", \"// are met:\", \"//  * Redistributions of source code must retain the above copyright\", \"//    notice, this list of conditions and the following disclaimer.\", \"//  * Redistributions in binary form must reproduce the above copyright\", \"//    notice, this list of conditions and the following disclaimer in the\", \"//    documentation and/or other materials provided with the distribution.\", \"//  * Neither the name of NVIDIA CORPORATION nor the names of its\", \"//    contributors may be used to endorse or promote products derived\", \"//    from this software without specific prior written permission.\", \"//\", \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\", \"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\", \"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\", \"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\", \"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\", \"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\", \"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\", \"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\", \"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\", \"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\", \"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\", \"//\", \"//----------------------------------------------------------------------------------\", \"\", \"#define FXAA_PC 1\", \"#define FXAA_GLSL_100 1\", \"#define FXAA_QUALITY_PRESET 12\", \"\", \"#define FXAA_GREEN_AS_LUMA 1\", \"\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_PC_CONSOLE\", \"    //\", \"    // The console algorithm for PC is included\", \"    // for developers targeting really low spec machines.\", \"    // Likely better to just run FXAA_PC, and use a really low preset.\", \"    //\", \"    #define FXAA_PC_CONSOLE 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_120\", \"    #define FXAA_GLSL_120 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_130\", \"    #define FXAA_GLSL_130 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_3\", \"    #define FXAA_HLSL_3 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_4\", \"    #define FXAA_HLSL_4 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_5\", \"    #define FXAA_HLSL_5 0\", \"#endif\", \"/*==========================================================================*/\", \"#ifndef FXAA_GREEN_AS_LUMA\", \"    //\", \"    // For those using non-linear color,\", \"    // and either not able to get luma in alpha, or not wanting to,\", \"    // this enables FXAA to run using green as a proxy for luma.\", \"    // So with this enabled, no need to pack luma in alpha.\", \"    //\", \"    // This will turn off AA on anything which lacks some amount of green.\", \"    // Pure red and blue or combination of only R and B, will get no AA.\", \"    //\", \"    // Might want to lower the settings for both,\", \"    //    fxaaConsoleEdgeThresholdMin\", \"    //    fxaaQualityEdgeThresholdMin\", \"    // In order to insure AA does not get turned off on colors\", \"    // which contain a minor amount of green.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_GREEN_AS_LUMA 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_EARLY_EXIT\", \"    //\", \"    // Controls algorithm's early exit path.\", \"    // On PS3 turning this ON adds 2 cycles to the shader.\", \"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\", \"    // Turning this off on console will result in a more blurry image.\", \"    // So this defaults to on.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_EARLY_EXIT 1\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_DISCARD\", \"    //\", \"    // Only valid for PC OpenGL currently.\", \"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\", \"    //\", \"    // 1 = Use discard on pixels which don't need AA.\", \"    //     For APIs which enable concurrent TEX+ROP from same surface.\", \"    // 0 = Return unchanged color on pixels which don't need AA.\", \"    //\", \"    #define FXAA_DISCARD 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_FAST_PIXEL_OFFSET\", \"    //\", \"    // Used for GLSL 120 only.\", \"    //\", \"    // 1 = GL API supports fast pixel offsets\", \"    // 0 = do not use fast pixel offsets\", \"    //\", \"    #ifdef GL_EXT_gpu_shader4\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifndef FXAA_FAST_PIXEL_OFFSET\", \"        #define FXAA_FAST_PIXEL_OFFSET 0\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GATHER4_ALPHA\", \"    //\", \"    // 1 = API supports gather4 on alpha channel.\", \"    // 0 = API does not support gather4 on alpha channel.\", \"    //\", \"    #if (FXAA_HLSL_5 == 1)\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifndef FXAA_GATHER4_ALPHA\", \"        #define FXAA_GATHER4_ALPHA 0\", \"    #endif\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                        FXAA QUALITY - TUNING KNOBS\", \"------------------------------------------------------------------------------\", \"NOTE the other tuning knobs are now in the shader function inputs!\", \"============================================================================*/\", \"#ifndef FXAA_QUALITY_PRESET\", \"    //\", \"    // Choose the quality preset.\", \"    // This needs to be compiled into the shader as it effects code.\", \"    // Best option to include multiple presets is to\", \"    // in each shader define the preset, then include this file.\", \"    //\", \"    // OPTIONS\", \"    // -----------------------------------------------------------------------\", \"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\", \"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\", \"    // 39       - no dither, very expensive\", \"    //\", \"    // NOTES\", \"    // -----------------------------------------------------------------------\", \"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\", \"    // 13 = about same speed as FXAA 3.9 and better than 12\", \"    // 23 = closest to FXAA 3.9 visually and performance wise\", \"    //  _ = the lowest digit is directly related to performance\", \"    // _  = the highest digit is directly related to style\", \"    //\", \"    #define FXAA_QUALITY_PRESET 12\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"\", \"                           FXAA QUALITY - PRESETS\", \"\", \"============================================================================*/\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - MEDIUM DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 10)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 3.0\", \"    #define FXAA_QUALITY_P2 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 11)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 3.0\", \"    #define FXAA_QUALITY_P3 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 12)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 4.0\", \"    #define FXAA_QUALITY_P4 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 13)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 4.0\", \"    #define FXAA_QUALITY_P5 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 14)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 4.0\", \"    #define FXAA_QUALITY_P6 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 15)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 12.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - LOW DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 20)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 2.0\", \"    #define FXAA_QUALITY_P2 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 21)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 22)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 23)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 24)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 3.0\", \"    #define FXAA_QUALITY_P6 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 25)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 26)\", \"    #define FXAA_QUALITY_PS 9\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 4.0\", \"    #define FXAA_QUALITY_P8 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 27)\", \"    #define FXAA_QUALITY_PS 10\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 4.0\", \"    #define FXAA_QUALITY_P9 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 28)\", \"    #define FXAA_QUALITY_PS 11\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 4.0\", \"    #define FXAA_QUALITY_P10 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 29)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - EXTREME QUALITY\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 39)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.0\", \"    #define FXAA_QUALITY_P2 1.0\", \"    #define FXAA_QUALITY_P3 1.0\", \"    #define FXAA_QUALITY_P4 1.0\", \"    #define FXAA_QUALITY_P5 1.5\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                                API PORTING\", \"\", \"============================================================================*/\", \"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard discard\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 vec2\", \"    #define FxaaFloat3 vec3\", \"    #define FxaaFloat4 vec4\", \"    #define FxaaHalf float\", \"    #define FxaaHalf2 vec2\", \"    #define FxaaHalf3 vec3\", \"    #define FxaaHalf4 vec4\", \"    #define FxaaInt2 ivec2\", \"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\", \"    #define FxaaTex sampler2D\", \"#else\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard clip(-1)\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 float2\", \"    #define FxaaFloat3 float3\", \"    #define FxaaFloat4 float4\", \"    #define FxaaHalf half\", \"    #define FxaaHalf2 half2\", \"    #define FxaaHalf3 half3\", \"    #define FxaaHalf4 half4\", \"    #define FxaaSat(x) saturate(x)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_100 == 1)\", \"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\", \"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_120 == 1)\", \"    // Requires,\", \"    //  #version 120\", \"    // And at least,\", \"    //  #extension GL_EXT_gpu_shader4 : enable\", \"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\", \"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\", \"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\", \"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\", \"    #else\", \"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\", \"    #endif\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_130 == 1)\", \"    // Requires \\\"#version 130\\\" or better\", \"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_3 == 1)\", \"    #define FxaaInt2 float2\", \"    #define FxaaTex sampler2D\", \"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\", \"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_4 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_5 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\", \"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\", \"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\", \"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\", \"============================================================================*/\", \"#if (FXAA_GREEN_AS_LUMA == 0)\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\", \"#else\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\", \"#endif\", \"\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                             FXAA3 QUALITY - PC\", \"\", \"============================================================================*/\", \"#if (FXAA_PC == 1)\", \"/*--------------------------------------------------------------------------*/\", \"FxaaFloat4 FxaaPixelShader(\", \"    //\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy} = center of pixel\", \"    FxaaFloat2 pos,\", \"    //\", \"    // Used only for FXAA Console, and not used on the 360 version.\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy_} = upper left of pixel\", \"    // {_zw} = lower right of pixel\", \"    FxaaFloat4 fxaaConsolePosPos,\", \"    //\", \"    // Input color texture.\", \"    // {rgb_} = color in linear or perceptual color space\", \"    // if (FXAA_GREEN_AS_LUMA == 0)\", \"    //     {__a} = luma in perceptual color space (not linear)\", \"    FxaaTex tex,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 2nd sampler.\", \"    // This sampler needs to have an exponent bias of -1.\", \"    FxaaTex fxaaConsole360TexExpBiasNegOne,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 3nd sampler.\", \"    // This sampler needs to have an exponent bias of -2.\", \"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This must be from a constant/uniform.\", \"    // {x_} = 1.0/screenWidthInPixels\", \"    // {_y} = 1.0/screenHeightInPixels\", \"    FxaaFloat2 fxaaQualityRcpFrame,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This must be from a constant/uniform.\", \"    // This effects sub-pixel AA quality and inversely sharpness.\", \"    //   Where N ranges between,\", \"    //     N = 0.50 (default)\", \"    //     N = 0.33 (sharper)\", \"    // {x__} = -N/screenWidthInPixels\", \"    // {_y_} = -N/screenHeightInPixels\", \"    // {_z_} =  N/screenWidthInPixels\", \"    // {__w} =  N/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Not used on 360, but used on PS3 and PC.\", \"    // This must be from a constant/uniform.\", \"    // {x__} = -2.0/screenWidthInPixels\", \"    // {_y_} = -2.0/screenHeightInPixels\", \"    // {_z_} =  2.0/screenWidthInPixels\", \"    // {__w} =  2.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\", \"    // This must be from a constant/uniform.\", \"    // {x__} =  8.0/screenWidthInPixels\", \"    // {_y_} =  8.0/screenHeightInPixels\", \"    // {_z_} = -4.0/screenWidthInPixels\", \"    // {__w} = -4.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_SUBPIX define.\", \"    // It is here now to allow easier tuning.\", \"    // Choose the amount of sub-pixel aliasing removal.\", \"    // This can effect sharpness.\", \"    //   1.00 - upper limit (softer)\", \"    //   0.75 - default amount of filtering\", \"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\", \"    //   0.25 - almost off\", \"    //   0.00 - completely off\", \"    FxaaFloat fxaaQualitySubpix,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // The minimum amount of local contrast required to apply algorithm.\", \"    //   0.333 - too little (faster)\", \"    //   0.250 - low quality\", \"    //   0.166 - default\", \"    //   0.125 - high quality\", \"    //   0.063 - overkill (slower)\", \"    FxaaFloat fxaaQualityEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\", \"    //   0.0625 - high quality (faster)\", \"    //   0.0312 - visible limit (slower)\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaQualityEdgeThresholdMin,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only three safe values here: 2 and 4 and 8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // For all other platforms can be a non-power of two.\", \"    //   8.0 is sharper (default!!!)\", \"    //   4.0 is softer\", \"    //   2.0 is really soft (good only for vector graphics inputs)\", \"    FxaaFloat fxaaConsoleEdgeSharpness,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only two safe values here: 1/4 and 1/8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // Other platforms can use other values.\", \"    //   0.125 leaves less aliasing, but is softer (default!!!)\", \"    //   0.25 leaves more aliasing, and is sharper\", \"    FxaaFloat fxaaConsoleEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // This only applies when FXAA_EARLY_EXIT is 1.\", \"    // This does not apply to PS3,\", \"    // PS3 was simplified to avoid more shader instructions.\", \"    //   0.06 - faster but more aliasing in darks\", \"    //   0.05 - default\", \"    //   0.04 - slower and less aliasing in darks\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaConsoleEdgeThresholdMin,\", \"    //\", \"    // Extra constants for 360 FXAA Console only.\", \"    // Use zeros or anything else for other platforms.\", \"    // These must be in physical constant registers and NOT immedates.\", \"    // Immedates will result in compiler un-optimizing.\", \"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\", \"    FxaaFloat4 fxaaConsole360ConstDir\", \") {\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posM;\", \"    posM.x = pos.x;\", \"    posM.y = pos.y;\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        #if (FXAA_DISCARD == 0)\", \"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"            #if (FXAA_GREEN_AS_LUMA == 0)\", \"                #define lumaM rgbyM.w\", \"            #else\", \"                #define lumaM rgbyM.y\", \"            #endif\", \"        #endif\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\", \"        #else\", \"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\", \"        #endif\", \"        #if (FXAA_DISCARD == 1)\", \"            #define lumaM luma4A.w\", \"        #endif\", \"        #define lumaE luma4A.z\", \"        #define lumaS luma4A.x\", \"        #define lumaSE luma4A.y\", \"        #define lumaNW luma4B.w\", \"        #define lumaN luma4B.z\", \"        #define lumaW luma4B.x\", \"    #else\", \"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            #define lumaM rgbyM.w\", \"        #else\", \"            #define lumaM rgbyM.y\", \"        #endif\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat maxSM = max(lumaS, lumaM);\", \"    FxaaFloat minSM = min(lumaS, lumaM);\", \"    FxaaFloat maxESM = max(lumaE, maxSM);\", \"    FxaaFloat minESM = min(lumaE, minSM);\", \"    FxaaFloat maxWN = max(lumaN, lumaW);\", \"    FxaaFloat minWN = min(lumaN, lumaW);\", \"    FxaaFloat rangeMax = max(maxWN, maxESM);\", \"    FxaaFloat rangeMin = min(minWN, minESM);\", \"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\", \"    FxaaFloat range = rangeMax - rangeMin;\", \"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\", \"    FxaaBool earlyExit = range < rangeMaxClamped;\", \"/*--------------------------------------------------------------------------*/\", \"    if(earlyExit)\", \"        #if (FXAA_DISCARD == 1)\", \"            FxaaDiscard;\", \"        #else\", \"            return rgbyM;\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_GATHER4_ALPHA == 0)\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #else\", \"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\", \"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNS = lumaN + lumaS;\", \"    FxaaFloat lumaWE = lumaW + lumaE;\", \"    FxaaFloat subpixRcpRange = 1.0/range;\", \"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\", \"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\", \"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNESE = lumaNE + lumaSE;\", \"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\", \"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\", \"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\", \"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\", \"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\", \"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\", \"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\", \"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\", \"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\", \"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\", \"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\", \"    FxaaBool horzSpan = edgeHorz >= edgeVert;\", \"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\", \"/*--------------------------------------------------------------------------*/\", \"    if(!horzSpan) lumaN = lumaW;\", \"    if(!horzSpan) lumaS = lumaE;\", \"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\", \"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat gradientN = lumaN - lumaM;\", \"    FxaaFloat gradientS = lumaS - lumaM;\", \"    FxaaFloat lumaNN = lumaN + lumaM;\", \"    FxaaFloat lumaSS = lumaS + lumaM;\", \"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\", \"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\", \"    if(pairN) lengthSign = -lengthSign;\", \"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posB;\", \"    posB.x = posM.x;\", \"    posB.y = posM.y;\", \"    FxaaFloat2 offNP;\", \"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\", \"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\", \"    if(!horzSpan) posB.x += lengthSign * 0.5;\", \"    if( horzSpan) posB.y += lengthSign * 0.5;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posN;\", \"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\", \"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat2 posP;\", \"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\", \"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\", \"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\", \"    FxaaFloat subpixE = subpixC * subpixC;\", \"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\", \"/*--------------------------------------------------------------------------*/\", \"    if(!pairN) lumaNN = lumaSS;\", \"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\", \"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\", \"    FxaaFloat subpixF = subpixD * subpixE;\", \"    FxaaBool lumaMLTZero = lumaMM < 0.0;\", \"/*--------------------------------------------------------------------------*/\", \"    lumaEndN -= lumaNN * 0.5;\", \"    lumaEndP -= lumaNN * 0.5;\", \"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\", \"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\", \"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\", \"    FxaaBool doneNP = (!doneN) || (!doneP);\", \"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\", \"/*--------------------------------------------------------------------------*/\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 3)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 4)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 5)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 6)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\", \"/*--------------------------------------------------------------------------*/\", \"                        #if (FXAA_QUALITY_PS > 7)\", \"                        if(doneNP) {\", \"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                            doneN = abs(lumaEndN) >= gradientScaled;\", \"                            doneP = abs(lumaEndP) >= gradientScaled;\", \"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\", \"                            doneNP = (!doneN) || (!doneP);\", \"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_QUALITY_PS > 8)\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 9)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 10)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 11)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 12)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                        }\", \"                        #endif\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat dstN = posM.x - posN.x;\", \"    FxaaFloat dstP = posP.x - posM.x;\", \"    if(!horzSpan) dstN = posM.y - posN.y;\", \"    if(!horzSpan) dstP = posP.y - posM.y;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLength = (dstP + dstN);\", \"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLengthRcp = 1.0/spanLength;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool directionN = dstN < dstP;\", \"    FxaaFloat dst = min(dstN, dstP);\", \"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\", \"    FxaaFloat subpixG = subpixF * subpixF;\", \"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\", \"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\", \"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\", \"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\", \"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\", \"    #if (FXAA_DISCARD == 1)\", \"        return FxaaTexTop(tex, posM);\", \"    #else\", \"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\", \"    #endif\", \"}\", \"/*==========================================================================*/\", \"#endif\", \"\", \"void main() {\", \"  gl_FragColor = FxaaPixelShader(\", \"    vUv,\", \"    vec4(0.0),\", \"    tDiffuse,\", \"    tDiffuse,\", \"    tDiffuse,\", \"    resolution,\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    0.75,\", \"    0.166,\", \"    0.0833,\", \"    0.0,\", \"    0.0,\", \"    0.0,\", \"    vec4(0.0)\", \"  );\", \"\", \"  // TODO avoid querying texture twice for same texel\", \"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = FXAAShader;\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * Gamma Correction Shader\n * http://en.wikipedia.org/wiki/gamma_correction\n */\n\nvar GammaCorrectionShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\", \"gl_FragColor = LinearToGamma( tex, float( GAMMA_FACTOR ) );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = GammaCorrectionShader;\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nvar HorizontalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"h\": { value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float h;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HorizontalBlurShader;\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nvar HorizontalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"h\": { value: 1.0 / 512.0 },\n\t\t\"r\": { value: 0.35 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float h;\", \"uniform float r;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"float hh = h * abs( r - vUv.y );\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HorizontalTiltShiftShader;\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author tapio / http://tapio.github.com/\n *\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nvar HueSaturationShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"hue\": { value: 0 },\n\t\t\"saturation\": { value: 0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float hue;\", \"uniform float saturation;\", \"varying vec2 vUv;\", \"void main() {\", \"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t// hue\n\t\"float angle = hue * 3.14159265;\", \"float s = sin(angle), c = cos(angle);\", \"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\", \"float len = length(gl_FragColor.rgb);\", \"gl_FragColor.rgb = vec3(\", \"dot(gl_FragColor.rgb, weights.xyz),\", \"dot(gl_FragColor.rgb, weights.zxy),\", \"dot(gl_FragColor.rgb, weights.yzx)\", \");\",\n\n\t// saturation\n\t\"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\", \"if (saturation > 0.0) {\", \"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\", \"} else {\", \"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HueSaturationShader;\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * Kaleidoscope Shader\n * Radial reflection around center point\n * Ported from: http://pixelshaders.com/editor/\n * by Toby Schachman / http://tobyschachman.com/\n *\n * sides: number of reflections\n * angle: initial angle in radians\n */\n\nvar KaleidoShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"sides\": { value: 6.0 },\n\t\t\"angle\": { value: 0.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float sides;\", \"uniform float angle;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 p = vUv - 0.5;\", \"float r = length(p);\", \"float a = atan(p.y, p.x) + angle;\", \"float tau = 2. * 3.1416 ;\", \"a = mod(a, tau/sides);\", \"a = abs(a - tau/sides/2.) ;\", \"p = r * vec2(cos(a), sin(a));\", \"vec4 color = texture2D(tDiffuse, p + 0.5);\", \"gl_FragColor = color;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = KaleidoShader;\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\n\nvar MirrorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"side\": { value: 1 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform int side;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 p = vUv;\", \"if (side == 0){\", \"if (p.x > 0.5) p.x = 1.0 - p.x;\", \"}else if (side == 1){\", \"if (p.x < 0.5) p.x = 1.0 - p.x;\", \"}else if (side == 2){\", \"if (p.y < 0.5) p.y = 1.0 - p.y;\", \"}else if (side == 3){\", \"if (p.y > 0.5) p.y = 1.0 - p.y;\", \"} \", \"vec4 color = texture2D(tDiffuse, p);\", \"gl_FragColor = color;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = MirrorShader;\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Normal map shader\n * - compute normals from heightmap\n */\n\nvar NormalMapShader = {\n\n\tuniforms: {\n\n\t\t\"heightMap\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(512, 512) },\n\t\t\"scale\": { value: new THREE.Vector2(1, 1) },\n\t\t\"height\": { value: 0.05 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float height;\", \"uniform vec2 resolution;\", \"uniform sampler2D heightMap;\", \"varying vec2 vUv;\", \"void main() {\", \"float val = texture2D( heightMap, vUv ).x;\", \"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\", \"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\", \"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = NormalMapShader;\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// TODO to ES6\n\n// Author: Aleksandr Albert\n// Website: www.routter.co.tt\n\n// Description: A deep water ocean shader set\n// based on an implementation of a Tessendorf Waves\n// originally presented by David Li ( www.david.li/waves )\n\n// The general method is to apply shaders to simulation Framebuffers\n// and then sample these framebuffers when rendering the ocean mesh\n\n// The set uses 7 shaders:\n\n// -- Simulation shaders\n// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n\n// -- Rendering Shader\n// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n\n\nTHREE.ShaderLib['ocean_sim_vertex'] = {\n\tvertexShader: ['varying vec2 vUV;', 'void main (void) {', 'vUV = position.xy * 0.5 + 0.5;', 'gl_Position = vec4(position, 1.0 );', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_subtransform'] = {\n\tuniforms: {\n\t\t\"u_input\": { value: null },\n\t\t\"u_transformSize\": { value: 512.0 },\n\t\t\"u_subtransformSize\": { value: 250.0 }\n\t},\n\tfragmentShader: [\n\t//GPU FFT using a Stockham formulation\n\n\t'precision highp float;', '#include <common>', 'uniform sampler2D u_input;', 'uniform float u_transformSize;', 'uniform float u_subtransformSize;', 'varying vec2 vUV;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'void main (void) {', '#ifdef HORIZONTAL', 'float index = vUV.x * u_transformSize - 0.5;', '#else', 'float index = vUV.y * u_transformSize - 0.5;', '#endif', 'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',\n\n\t//transform two complex sequences simultaneously\n\t'#ifdef HORIZONTAL', 'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', '#else', 'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;', '#endif', 'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);', 'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));', 'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);', 'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);', 'gl_FragColor = vec4(outputA, outputB);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_initial_spectrum'] = {\n\tuniforms: {\n\t\t\"u_wind\": { value: new THREE.Vector2(10.0, 10.0) },\n\t\t\"u_resolution\": { value: 512.0 },\n\t\t\"u_size\": { value: 250.0 }\n\t},\n\tfragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'const float CM = 0.23;', 'uniform vec2 u_wind;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + pow2(k / KM)));', '}', 'float tanh (float x) {', 'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;', 'float k = length(K);', 'float l_wind = length(u_wind);', 'float Omega = 0.84;', 'float kp = G * pow2(Omega / l_wind);', 'float c = omega(k) / k;', 'float cp = omega(kp) / kp;', 'float Lpm = exp(-1.25 * pow2(kp / k));', 'float gamma = 1.7;', 'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));', 'float Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));', 'float Jp = pow(gamma, Gamma);', 'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));', 'float alphap = 0.006 * sqrt(Omega);', 'float Bl = 0.5 * alphap * cp / c * Fp;', 'float z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);', 'float uStar = 0.41 * l_wind / log(10.0 / z0);', 'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));', 'float Fm = exp(-0.25 * pow2(k / KM - 1.0));', 'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;', 'float a0 = log(2.0) / 4.0;', 'float am = 0.13 * uStar / CM;', 'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));', 'float cosPhi = dot(normalize(u_wind), normalize(K));', 'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));', 'float dk = 2.0 * PI / u_size;', 'float h = sqrt(S / 2.0) * dk;', 'if (K.x == 0.0 && K.y == 0.0) {', 'h = 0.0;', //no DC term\n\t'}', 'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_phase'] = {\n\tuniforms: {\n\t\t\"u_phases\": { value: null },\n\t\t\"u_deltaTime\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_size\": { value: null }\n\t},\n\tfragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform sampler2D u_phases;', 'uniform float u_deltaTime;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'float deltaTime = 1.0 / 60.0;', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'float deltaPhase = omega(length(waveVector)) * u_deltaTime;', 'phase = mod(phase + deltaPhase, 2.0 * PI);', 'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_spectrum'] = {\n\tuniforms: {\n\t\t\"u_size\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_choppiness\": { value: null },\n\t\t\"u_phases\": { value: null },\n\t\t\"u_initialSpectrum\": { value: null }\n\t},\n\tfragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform float u_size;', 'uniform float u_resolution;', 'uniform float u_choppiness;', 'uniform sampler2D u_phases;', 'uniform sampler2D u_initialSpectrum;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'vec2 multiplyByI (vec2 z) {', 'return vec2(-z[1], z[0]);', '}', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'vec2 phaseVector = vec2(cos(phase), sin(phase));', 'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;', 'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;', 'h0Star.y *= -1.0;', 'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));', 'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;', 'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',\n\n\t//no DC term\n\t'if (waveVector.x == 0.0 && waveVector.y == 0.0) {', 'h = vec2(0.0);', 'hX = vec2(0.0);', 'hZ = vec2(0.0);', '}', 'gl_FragColor = vec4(hX + multiplyByI(h), hZ);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_normals'] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_size\": { value: null }\n\t},\n\tfragmentShader: ['precision highp float;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform float u_resolution;', 'uniform float u_size;', 'void main (void) {', 'float texel = 1.0 / u_resolution;', 'float texelSize = u_size / u_resolution;', 'vec3 center = texture2D(u_displacementMap, vUV).rgb;', 'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;', 'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;', 'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;', 'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;', 'vec3 topRight = cross(right, top);', 'vec3 topLeft = cross(top, left);', 'vec3 bottomLeft = cross(left, bottom);', 'vec3 bottomRight = cross(bottom, right);', 'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_main'] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { value: null },\n\t\t\"u_normalMap\": { value: null },\n\t\t\"u_geometrySize\": { value: null },\n\t\t\"u_size\": { value: null },\n\t\t\"u_projectionMatrix\": { value: null },\n\t\t\"u_viewMatrix\": { value: null },\n\t\t\"u_cameraPosition\": { value: null },\n\t\t\"u_skyColor\": { value: null },\n\t\t\"u_oceanColor\": { value: null },\n\t\t\"u_sunDirection\": { value: null },\n\t\t\"u_exposure\": { value: null }\n\t},\n\tvertexShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform mat4 u_projectionMatrix;', 'uniform mat4 u_viewMatrix;', 'uniform float u_size;', 'uniform float u_geometrySize;', 'uniform sampler2D u_displacementMap;', 'void main (void) {', 'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);', 'vPos = newPos;', 'vUV = uv;', 'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);', '}'].join('\\n'),\n\tfragmentShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform sampler2D u_normalMap;', 'uniform vec3 u_cameraPosition;', 'uniform vec3 u_oceanColor;', 'uniform vec3 u_skyColor;', 'uniform vec3 u_sunDirection;', 'uniform float u_exposure;', 'vec3 hdr (vec3 color, float exposure) {', 'return 1.0 - exp(-color * exposure);', '}', 'void main (void) {', 'vec3 normal = texture2D(u_normalMap, vUV).rgb;', 'vec3 view = normalize(u_cameraPosition - vPos);', 'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);', 'vec3 sky = fresnel * u_skyColor;', 'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);', 'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;', 'vec3 color = sky + water;', 'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);', '}'].join('\\n')\n};\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n\nvar ParallaxShader = {\n\t// Ordered from fastest to best quality.\n\tmodes: {\n\t\tnone: 'NO_PARALLAX',\n\t\tbasic: 'USE_BASIC_PARALLAX',\n\t\tsteep: 'USE_STEEP_PARALLAX',\n\t\tocclusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM\n\t\trelief: 'USE_RELIEF_PARALLAX'\n\t},\n\n\tuniforms: {\n\t\t\"bumpMap\": { value: null },\n\t\t\"map\": { value: null },\n\t\t\"parallaxScale\": { value: null },\n\t\t\"parallaxMinLayers\": { value: null },\n\t\t\"parallaxMaxLayers\": { value: null }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"void main() {\", \"vUv = uv;\", \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"vViewPosition = -mvPosition.xyz;\", \"vNormal = normalize( normalMatrix * normal );\", \"gl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D bumpMap;\", \"uniform sampler2D map;\", \"uniform float parallaxScale;\", \"uniform float parallaxMinLayers;\", \"uniform float parallaxMaxLayers;\", \"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"#ifdef USE_BASIC_PARALLAX\", \"vec2 parallaxMap( in vec3 V ) {\", \"float initialHeight = texture2D( bumpMap, vUv ).r;\",\n\n\t// No Offset Limitting: messy, floating output at grazing angles.\n\t//\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n\n\t// Offset Limiting\n\t\"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\", \"return vUv - texCoordOffset;\", \"}\", \"#else\", \"vec2 parallaxMap( in vec3 V ) {\",\n\n\t// Determine number of layers from angle between V and N\n\t\"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\", \"float layerHeight = 1.0 / numLayers;\", \"float currentLayerHeight = 0.0;\",\n\t// Shift of texture coordinates for each iteration\n\t\"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;\", \"vec2 currentTextureCoords = vUv;\", \"float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\n\t// while ( heightFromTexture > currentLayerHeight )\n\t// Infinite loops are not well supported. Do a \"large\" finite\n\t// loop, but not too large, as it slows down some compilers.\n\t\"for ( int i = 0; i < 30; i += 1 ) {\", \"if ( heightFromTexture <= currentLayerHeight ) {\", \"break;\", \"}\", \"currentLayerHeight += layerHeight;\",\n\t// Shift texture coordinates along vector V\n\t\"currentTextureCoords -= dtex;\", \"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", \"}\", \"#ifdef USE_STEEP_PARALLAX\", \"return currentTextureCoords;\", \"#elif defined( USE_RELIEF_PARALLAX )\", \"vec2 deltaTexCoord = dtex / 2.0;\", \"float deltaHeight = layerHeight / 2.0;\",\n\n\t// Return to the mid point of previous layer\n\t\"currentTextureCoords += deltaTexCoord;\", \"currentLayerHeight -= deltaHeight;\",\n\n\t// Binary search to increase precision of Steep Parallax Mapping\n\t\"const int numSearches = 5;\", \"for ( int i = 0; i < numSearches; i += 1 ) {\", \"deltaTexCoord /= 2.0;\", \"deltaHeight /= 2.0;\", \"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t// Shift along or against vector V\n\t\"if( heightFromTexture > currentLayerHeight ) {\", // Below the surface\n\n\t\"currentTextureCoords -= deltaTexCoord;\", \"currentLayerHeight += deltaHeight;\", \"} else {\", // above the surface\n\n\t\"currentTextureCoords += deltaTexCoord;\", \"currentLayerHeight -= deltaHeight;\", \"}\", \"}\", \"return currentTextureCoords;\", \"#elif defined( USE_OCLUSION_PARALLAX )\", \"vec2 prevTCoords = currentTextureCoords + dtex;\",\n\n\t// Heights for linear interpolation\n\t\"float nextH = heightFromTexture - currentLayerHeight;\", \"float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\",\n\n\t// Proportions for linear interpolation\n\t\"float weight = nextH / ( nextH - prevH );\",\n\n\t// Interpolation of texture coordinates\n\t\"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\", \"#else\", // NO_PARALLAX\n\n\t\"return vUv;\", \"#endif\", \"}\", \"#endif\", \"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\", \"vec2 texDx = dFdx( vUv );\", \"vec2 texDy = dFdy( vUv );\", \"vec3 vSigmaX = dFdx( surfPosition );\", \"vec3 vSigmaY = dFdy( surfPosition );\", \"vec3 vR1 = cross( vSigmaY, surfNormal );\", \"vec3 vR2 = cross( surfNormal, vSigmaX );\", \"float fDet = dot( vSigmaX, vR1 );\", \"vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\", \"vec3 vProjVtex;\", \"vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\", \"vProjVtex.z = dot( surfNormal, viewPosition );\", \"return parallaxMap( vProjVtex );\", \"}\", \"void main() {\", \"vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\", \"gl_FragColor = texture2D( map, mapUv );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ParallaxShader;\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author wongbryan / http://wongbryan.github.io\n *\n * Pixelation shader\n */\n\nvar PixelShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: null },\n\t\t\"pixelSize\": { value: 1. }\n\n\t},\n\n\tvertexShader: [\"varying highp vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float pixelSize;\", \"uniform vec2 resolution;\", \"varying highp vec2 vUv;\", \"void main(){\", \"vec2 dxy = pixelSize / resolution;\", \"vec2 coord = dxy * floor( vUv / dxy );\", \"gl_FragColor = texture2D(tDiffuse, coord);\", \"}\"].join(\"\\n\")\n};\n\nexports.default = PixelShader;\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nvar RGBShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"amount\": { value: 0.005 },\n\t\t\"angle\": { value: 0.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float amount;\", \"uniform float angle;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 offset = amount * vec2( cos(angle), sin(angle));\", \"vec4 cr = texture2D(tDiffuse, vUv + offset);\", \"vec4 cga = texture2D(tDiffuse, vUv);\", \"vec4 cb = texture2D(tDiffuse, vUv - offset);\", \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = RGBShiftShader;\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Sepia tone shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nvar SepiaShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"amount\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float amount;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 color = texture2D( tDiffuse, vUv );\", \"vec3 c = color.rgb;\", \"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\", \"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\", \"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\", \"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = SepiaShader;\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nvar SobelOperatorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\",\n\n\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\"const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\", // x direction kernel\n\t\"const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\", // y direction kernel\n\n\t// fetch the 3x3 neighbourhood of a fragment\n\n\t// first column\n\n\t\"float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\", \"float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\", \"float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\",\n\n\t// second column\n\n\t\"float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\", \"float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\", \"float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\",\n\n\t// third column\n\n\t\"float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\", \"float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\", \"float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\",\n\n\t// gradient value in x direction\n\n\t\"float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \", \"Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \", \"Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \",\n\n\t// gradient value in y direction\n\n\t\"float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \", \"Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \", \"Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \",\n\n\t// magnitute of the total gradient\n\n\t\"float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\", \"gl_FragColor = vec4( vec3( G ), 1 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = SobelOperatorShader;\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author flimshaw / http://charliehoey.com\n *\n * Technicolor Shader\n * Simulates the look of the two-strip technicolor process popular in early 20th century films.\n * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\n * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\n */\n\nvar TechnicolorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\", \"vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\", \"gl_FragColor = newTex;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = TechnicolorShader;\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nvar TriangleBlurShader = {\n\n\tuniforms: {\n\n\t\t\"texture\": { value: null },\n\t\t\"delta\": { value: new THREE.Vector2(1, 1) }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"#define ITERATIONS 10.0\", \"uniform sampler2D texture;\", \"uniform vec2 delta;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 color = vec4( 0.0 );\", \"float total = 0.0;\",\n\n\t// randomize the lookup values to hide the fixed number of samples\n\n\t\"float offset = rand( vUv );\", \"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\", \"float percent = ( t + offset - 0.5 ) / ITERATIONS;\", \"float weight = 1.0 - abs( percent );\", \"color += texture2D( texture, vUv + delta * percent ) * weight;\", \"total += weight;\", \"}\", \"gl_FragColor = color / total;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = TriangleBlurShader;\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nvar VerticalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"v\": { value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float v;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = VerticalBlurShader;\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nvar VerticalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"v\": { value: 1.0 / 512.0 },\n\t\t\"r\": { value: 0.35 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float v;\", \"uniform float r;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"float vv = v * abs( r - vUv.y );\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = VerticalTiltShiftShader;\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Vignette shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nvar VignetteShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"offset\": { value: 1.0 },\n\t\t\"darkness\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float offset;\", \"uniform float darkness;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\",\n\n\t// Eskil's vignette\n\n\t\"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\", \"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\",\n\n\t/*\n // alternative version from glfx.js\n // this one makes more \"dusty\" look (as opposed to \"burned\")\n \t\"vec4 color = texture2D( tDiffuse, vUv );\",\n \"float dist = distance( vUv, vec2( 0.5 ) );\",\n \"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\n \"gl_FragColor = color;\",\n */\n\n\t\"}\"].join(\"\\n\")\n\n};\n\nexports.default = VignetteShader;\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n */\n\nvar WaterRefractionShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'time': {\n\t\t\ttype: 'f',\n\t\t\tvalue: 0\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDudv': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\ttype: 'm4',\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: ['uniform mat4 textureMatrix;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'void main() {', '\tvUv = uv;', '\tvUvRefraction = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\tfragmentShader: ['uniform vec3 color;', 'uniform float time;', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDudv;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );', '}', 'void main() {', ' float waveStrength = 0.1;', ' float waveSpeed = 0.03;',\n\n\t// simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)\n\n\t'\tvec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;', '\tdistortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );', '\tvec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;',\n\n\t// new uv coords\n\n\t' vec4 uv = vec4( vUvRefraction );', ' uv.xy += distortion;', '\tvec4 base = texture2DProj( tDiffuse, uv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\nexports.default = WaterRefractionShader;\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Volume = undefined;\n\nvar _Volume = __webpack_require__(10);\n\nvar _Volume2 = _interopRequireDefault(_Volume);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Volume = _Volume2.default;\n\n/***/ })\n/******/ ])));\n\n//# sourceURL=webpack:///./node_modules/threejs-ext/dist/index.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/uri-js/dist/es5/uri.all.js":
/*!*************************************************!*\
  !*** ./node_modules/uri-js/dist/es5/uri.all.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\t true ? factory(exports) :\n\tundefined;\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\") {\n        uriTokens.push(\":\");\n        uriTokens.push(components.port.toString(10));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        //normalize the default port\n        if (components.port === (String(components.scheme).toLowerCase() !== \"https\" ? 80 : 443) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$2 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$3 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$4 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n\n\n//# sourceURL=webpack:///./node_modules/uri-js/dist/es5/uri.all.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack:///./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/module.js?");

/***/ }),

/***/ "./node_modules/webworkify-webpack/index.js":
/*!**************************************************!*\
  !*** ./node_modules/webworkify-webpack/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function webpackBootstrapFunc (modules) {\n/******/  // The module cache\n/******/  var installedModules = {};\n\n/******/  // The require function\n/******/  function __webpack_require__(moduleId) {\n\n/******/    // Check if module is in cache\n/******/    if(installedModules[moduleId])\n/******/      return installedModules[moduleId].exports;\n\n/******/    // Create a new module (and put it into the cache)\n/******/    var module = installedModules[moduleId] = {\n/******/      i: moduleId,\n/******/      l: false,\n/******/      exports: {}\n/******/    };\n\n/******/    // Execute the module function\n/******/    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/    // Flag the module as loaded\n/******/    module.l = true;\n\n/******/    // Return the exports of the module\n/******/    return module.exports;\n/******/  }\n\n/******/  // expose the modules object (__webpack_modules__)\n/******/  __webpack_require__.m = modules;\n\n/******/  // expose the module cache\n/******/  __webpack_require__.c = installedModules;\n\n/******/  // identity function for calling harmony imports with the correct context\n/******/  __webpack_require__.i = function(value) { return value; };\n\n/******/  // define getter function for harmony exports\n/******/  __webpack_require__.d = function(exports, name, getter) {\n/******/    if(!__webpack_require__.o(exports, name)) {\n/******/      Object.defineProperty(exports, name, {\n/******/        configurable: false,\n/******/        enumerable: true,\n/******/        get: getter\n/******/      });\n/******/    }\n/******/  };\n\n/******/  // define __esModule on exports\n/******/  __webpack_require__.r = function(exports) {\n/******/    Object.defineProperty(exports, '__esModule', { value: true });\n/******/  };\n\n/******/  // getDefaultExport function for compatibility with non-harmony modules\n/******/  __webpack_require__.n = function(module) {\n/******/    var getter = module && module.__esModule ?\n/******/      function getDefault() { return module['default']; } :\n/******/      function getModuleExports() { return module; };\n/******/    __webpack_require__.d(getter, 'a', getter);\n/******/    return getter;\n/******/  };\n\n/******/  // Object.prototype.hasOwnProperty.call\n/******/  __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n/******/  // __webpack_public_path__\n/******/  __webpack_require__.p = \"/\";\n\n/******/  // on error function for async loading\n/******/  __webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n  var f = __webpack_require__(__webpack_require__.s = ENTRY_MODULE)\n  return f.default || f // try to call default if defined to also support babel esmodule exports\n}\n\nvar moduleNameReqExp = '[\\\\.|\\\\-|\\\\+|\\\\w|\\/|@]+'\nvar dependencyRegExp = '\\\\(\\\\s*(\\/\\\\*.*?\\\\*\\/)?\\\\s*.*?(' + moduleNameReqExp + ').*?\\\\)' // additional chars when output.pathinfo is true\n\n// http://stackoverflow.com/a/2593661/130442\nfunction quoteRegExp (str) {\n  return (str + '').replace(/[.?*+^$[\\]\\\\(){}|-]/g, '\\\\$&')\n}\n\nfunction isNumeric(n) {\n  return !isNaN(1 * n); // 1 * n converts integers, integers as string (\"123\"), 1e3 and \"1e3\" to integers and strings to NaN\n}\n\nfunction getModuleDependencies (sources, module, queueName) {\n  var retval = {}\n  retval[queueName] = []\n\n  var fnString = module.toString()\n  var wrapperSignature = fnString.match(/^function\\s?\\w*\\(\\w+,\\s*\\w+,\\s*(\\w+)\\)/)\n  if (!wrapperSignature) return retval\n  var webpackRequireName = wrapperSignature[1]\n\n  // main bundle deps\n  var re = new RegExp('(\\\\\\\\n|\\\\W)' + quoteRegExp(webpackRequireName) + dependencyRegExp, 'g')\n  var match\n  while ((match = re.exec(fnString))) {\n    if (match[3] === 'dll-reference') continue\n    retval[queueName].push(match[3])\n  }\n\n  // dll deps\n  re = new RegExp('\\\\(' + quoteRegExp(webpackRequireName) + '\\\\(\"(dll-reference\\\\s(' + moduleNameReqExp + '))\"\\\\)\\\\)' + dependencyRegExp, 'g')\n  while ((match = re.exec(fnString))) {\n    if (!sources[match[2]]) {\n      retval[queueName].push(match[1])\n      sources[match[2]] = __webpack_require__(match[1]).m\n    }\n    retval[match[2]] = retval[match[2]] || []\n    retval[match[2]].push(match[4])\n  }\n\n  // convert 1e3 back to 1000 - this can be important after uglify-js converted 1000 to 1e3\n  var keys = Object.keys(retval);\n  for (var i = 0; i < keys.length; i++) {\n    for (var j = 0; j < retval[keys[i]].length; j++) {\n      if (isNumeric(retval[keys[i]][j])) {\n        retval[keys[i]][j] = 1 * retval[keys[i]][j];\n      }\n    }\n  }\n\n  return retval\n}\n\nfunction hasValuesInQueues (queues) {\n  var keys = Object.keys(queues)\n  return keys.reduce(function (hasValues, key) {\n    return hasValues || queues[key].length > 0\n  }, false)\n}\n\nfunction getRequiredModules (sources, moduleId) {\n  var modulesQueue = {\n    main: [moduleId]\n  }\n  var requiredModules = {\n    main: []\n  }\n  var seenModules = {\n    main: {}\n  }\n\n  while (hasValuesInQueues(modulesQueue)) {\n    var queues = Object.keys(modulesQueue)\n    for (var i = 0; i < queues.length; i++) {\n      var queueName = queues[i]\n      var queue = modulesQueue[queueName]\n      var moduleToCheck = queue.pop()\n      seenModules[queueName] = seenModules[queueName] || {}\n      if (seenModules[queueName][moduleToCheck] || !sources[queueName][moduleToCheck]) continue\n      seenModules[queueName][moduleToCheck] = true\n      requiredModules[queueName] = requiredModules[queueName] || []\n      requiredModules[queueName].push(moduleToCheck)\n      var newModules = getModuleDependencies(sources, sources[queueName][moduleToCheck], queueName)\n      var newModulesKeys = Object.keys(newModules)\n      for (var j = 0; j < newModulesKeys.length; j++) {\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]] || []\n        modulesQueue[newModulesKeys[j]] = modulesQueue[newModulesKeys[j]].concat(newModules[newModulesKeys[j]])\n      }\n    }\n  }\n\n  return requiredModules\n}\n\nmodule.exports = function (moduleId, options) {\n  options = options || {}\n  var sources = {\n    main: __webpack_require__.m\n  }\n\n  var requiredModules = options.all ? { main: Object.keys(sources.main) } : getRequiredModules(sources, moduleId)\n\n  var src = ''\n\n  Object.keys(requiredModules).filter(function (m) { return m !== 'main' }).forEach(function (module) {\n    var entryModule = 0\n    while (requiredModules[module][entryModule]) {\n      entryModule++\n    }\n    requiredModules[module].push(entryModule)\n    sources[module][entryModule] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })'\n    src = src + 'var ' + module + ' = (' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(entryModule)) + ')({' + requiredModules[module].map(function (id) { return '' + JSON.stringify(id) + ': ' + sources[module][id].toString() }).join(',') + '});\\n'\n  })\n\n  src = src + 'new ((' + webpackBootstrapFunc.toString().replace('ENTRY_MODULE', JSON.stringify(moduleId)) + ')({' + requiredModules.main.map(function (id) { return '' + JSON.stringify(id) + ': ' + sources.main[id].toString() }).join(',') + '}))(self);'\n\n  var blob = new window.Blob([src], { type: 'text/javascript' })\n  if (options.bare) { return blob }\n\n  var URL = window.URL || window.webkitURL || window.mozURL || window.msURL\n\n  var workerUrl = URL.createObjectURL(blob)\n  var worker = new window.Worker(workerUrl)\n  worker.objectURL = workerUrl\n\n  return worker\n}\n\n\n//# sourceURL=webpack:///./node_modules/webworkify-webpack/index.js?");

/***/ }),

/***/ "./src/functions.js":
/*!**************************!*\
  !*** ./src/functions.js ***!
  \**************************/
/*! exports provided: DEFAULT_ROOT, loadTextureAsBase64, loadBlockState, loadTextureMeta, loadJsonFromPath, loadJsonFromPath_, scaleUv, trimCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_ROOT\", function() { return DEFAULT_ROOT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadTextureAsBase64\", function() { return loadTextureAsBase64; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBlockState\", function() { return loadBlockState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadTextureMeta\", function() { return loadTextureMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJsonFromPath\", function() { return loadJsonFromPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJsonFromPath_\", function() { return loadJsonFromPath_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleUv\", function() { return scaleUv; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trimCanvas\", function() { return trimCanvas; });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nconst debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"minerender\");\r\n\r\n/**\r\n * Default asset root\r\n * @type {string}\r\n */\r\nconst DEFAULT_ROOT = \"https://assets.mcasset.cloud/1.13\";\r\n/**\r\n * Texture cache\r\n * @type {Object.<string,string>}\r\n */\r\nconst textureCache = {};\r\n/**\r\n * Texture callbacks\r\n * @type {Object.<string,function[]>}\r\n */\r\nconst textureCallbacks = {};\r\n\r\n/**\r\n * Model cache\r\n * @type {Object.<string,string>}\r\n */\r\nconst modelCache = {};\r\n/**\r\n * Model callbacks\r\n * @type {Object.<string,function[]>}\r\n */\r\nconst modelCallbacks = {};\r\n\r\n\r\n/**\r\n * Loads a Mincraft texture an returns it as Base64\r\n *\r\n * @param {string} root Asset root, see {@link DEFAULT_ROOT}\r\n * @param {string} namespace Namespace, usually 'minecraft'\r\n * @param {string} dir Directory of the texture\r\n * @param {string} name Name of the texture\r\n * @returns {Promise<string>}\r\n */\r\nfunction loadTextureAsBase64(root, namespace, dir, name) {\r\n    if (name.startsWith(\"minecraft:\")) {\r\n        name = name.substring(10);\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n        loadTexture(root, namespace, dir, name, resolve, reject);\r\n    });\r\n};\r\n\r\n/**\r\n * Load a texture as base64 - shouldn't be used directly\r\n * @see loadTextureAsBase64\r\n * @ignore\r\n */\r\nfunction loadTexture(root, namespace, dir, name, resolve, reject, forceLoad) {\r\n    if (name.startsWith(\"minecraft:\")) {\r\n        name = name.substring(10);\r\n    }\r\n\r\n    let path = \"/assets/\" + namespace + \"/textures\" + dir + name + \".png\";\r\n\r\n    if (textureCache.hasOwnProperty(path)) {\r\n        if (textureCache[path] === \"__invalid\") {\r\n            reject();\r\n            return;\r\n        }\r\n        resolve(textureCache[path]);\r\n        return;\r\n    }\r\n\r\n    if (!textureCallbacks.hasOwnProperty(path) || textureCallbacks[path].length === 0 || forceLoad) {\r\n        // https://gist.github.com/oliyh/db3d1a582aefe6d8fee9 / https://stackoverflow.com/questions/20035615/using-raw-image-data-from-ajax-request-for-data-uri\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open('GET', root + path, true);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.onloadend = function () {\r\n            if (xhr.status === 200) {\r\n                let arr = new Uint8Array(xhr.response || xhr.responseText);\r\n                let raw = String.fromCharCode.apply(null, arr);\r\n                let b64 = btoa(raw);\r\n                let dataURL = \"data:image/png;base64,\" + b64;\r\n\r\n                textureCache[path] = dataURL;\r\n\r\n                if (textureCallbacks.hasOwnProperty(path)) {\r\n                    while (textureCallbacks[path].length > 0) {\r\n                        let cb = textureCallbacks[path].shift(0);\r\n                        cb[0](dataURL);\r\n                    }\r\n                }\r\n            } else {\r\n                if (DEFAULT_ROOT === root) {\r\n                    textureCache[path] = \"__invalid\";\r\n\r\n                    if (textureCallbacks.hasOwnProperty(path)) {\r\n                        while (textureCallbacks[path].length > 0) {\r\n                            let cb = textureCallbacks[path].shift(0);\r\n                            cb[1]();\r\n                        }\r\n                    }\r\n                } else {\r\n                    loadTexture(DEFAULT_ROOT, namespace, dir, name, resolve, reject, true)\r\n                }\r\n            }\r\n        };\r\n        xhr.send();\r\n\r\n        // init array\r\n        if (!textureCallbacks.hasOwnProperty(path))\r\n            textureCallbacks[path] = [];\r\n    }\r\n\r\n    // add the promise callback\r\n    textureCallbacks[path].push([resolve, reject]);\r\n}\r\n\r\n\r\n/**\r\n * Loads a blockstate file and returns the contained JSON\r\n * @param {string} state Name of the blockstate\r\n * @param {string} assetRoot Asset root, see {@link DEFAULT_ROOT}\r\n * @returns {Promise<object>}\r\n */\r\nfunction loadBlockState(state, assetRoot) {\r\n    if (state.startsWith(\"minecraft:\")) {\r\n        state = state.substring(10);\r\n    }\r\n    return loadJsonFromPath(assetRoot, \"/assets/minecraft/blockstates/\" + state + \".json\")\r\n}\r\n\r\nfunction loadTextureMeta(texture, assetRoot) {\r\n    if (texture.startsWith(\"minecraft:\")) {\r\n        texture = texture.substring(10);\r\n    }\r\n    return loadJsonFromPath(assetRoot, \"/assets/minecraft/textures/block/\" + texture + \".png.mcmeta\")\r\n}\r\n\r\n/**\r\n * Loads a model file and returns the contained JSON\r\n * @param {string} root Asset root, see {@link DEFAULT_ROOT}\r\n * @param {string} path Path to the model file\r\n * @returns {Promise<object>}\r\n */\r\nfunction loadJsonFromPath(root, path) {\r\n    return new Promise((resolve, reject) => {\r\n        loadJsonFromPath_(root, path, resolve, reject);\r\n    })\r\n}\r\n\r\n/**\r\n * Load a model - shouldn't used directly\r\n * @see loadJsonFromPath\r\n * @ignore\r\n */\r\nfunction loadJsonFromPath_(root, path, resolve, reject, forceLoad) {\r\n    if (modelCache.hasOwnProperty(path)) {\r\n        if (modelCache[path] === \"__invalid\") {\r\n            reject();\r\n            return;\r\n        }\r\n        resolve(Object.assign({}, modelCache[path]));\r\n        return;\r\n    }\r\n\r\n    if (!modelCallbacks.hasOwnProperty(path) || modelCallbacks[path].length === 0 || forceLoad) {\r\n        debug(root + path)\r\n        fetch(root + path, {\r\n            mode: \"cors\",\r\n            redirect: \"follow\"\r\n        })\r\n            .then(response => response.json())\r\n            .then(data => {\r\n                debug(\"json data:\", data);\r\n                modelCache[path] = data;\r\n\r\n                if (modelCallbacks.hasOwnProperty(path)) {\r\n                    while (modelCallbacks[path].length > 0) {\r\n                        let dataCopy = Object.assign({}, data);\r\n                        let cb = modelCallbacks[path].shift(0);\r\n                        cb[0](dataCopy);\r\n                    }\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                console.warn(err);\r\n                if (DEFAULT_ROOT === root) {\r\n                    modelCache[path] = \"__invalid\";\r\n\r\n                    if (modelCallbacks.hasOwnProperty(path)) {\r\n                        while (modelCallbacks[path].length > 0) {\r\n                            let cb = modelCallbacks[path].shift(0);\r\n                            cb[1]();\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Try again with default root\r\n                    loadJsonFromPath_(DEFAULT_ROOT, path, resolve, reject, true);\r\n                }\r\n            });\r\n\r\n        if (!modelCallbacks.hasOwnProperty(path))\r\n            modelCallbacks[path] = [];\r\n    }\r\n\r\n    modelCallbacks[path].push([resolve, reject]);\r\n}\r\n\r\n/**\r\n * Scales UV values\r\n * @param {number} uv UV value\r\n * @param {number} size\r\n * @param {number} [scale=16]\r\n * @returns {number}\r\n */\r\nfunction scaleUv(uv, size, scale) {\r\n    if (uv === 0) return 0;\r\n    return size / (scale || 16) * uv;\r\n}\r\n\r\n\r\n// https://gist.github.com/remy/784508\r\nfunction trimCanvas(c) {\r\n    let ctx = c.getContext('2d'),\r\n        copy = document.createElement('canvas').getContext('2d'),\r\n        pixels = ctx.getImageData(0, 0, c.width, c.height),\r\n        l = pixels.data.length,\r\n        i,\r\n        bound = {\r\n            top: null,\r\n            left: null,\r\n            right: null,\r\n            bottom: null\r\n        },\r\n        x, y;\r\n\r\n    for (i = 0; i < l; i += 4) {\r\n        if (pixels.data[i + 3] !== 0) {\r\n            x = (i / 4) % c.width;\r\n            y = ~~((i / 4) / c.width);\r\n\r\n            if (bound.top === null) {\r\n                bound.top = y;\r\n            }\r\n\r\n            if (bound.left === null) {\r\n                bound.left = x;\r\n            } else if (x < bound.left) {\r\n                bound.left = x;\r\n            }\r\n\r\n            if (bound.right === null) {\r\n                bound.right = x;\r\n            } else if (bound.right < x) {\r\n                bound.right = x;\r\n            }\r\n\r\n            if (bound.bottom === null) {\r\n                bound.bottom = y;\r\n            } else if (bound.bottom < y) {\r\n                bound.bottom = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    let trimHeight = bound.bottom - bound.top,\r\n        trimWidth = bound.right - bound.left,\r\n        trimmed = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);\r\n\r\n    copy.canvas.width = trimWidth;\r\n    copy.canvas.height = trimHeight;\r\n    copy.putImageData(trimmed, 0, 0);\r\n\r\n    // open new window with trimmed image:\r\n    return copy.canvas;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/functions.js?");

/***/ }),

/***/ "./src/lib/OrbitControls.js":
/*!**********************************!*\
  !*** ./src/lib/OrbitControls.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return OrbitControls; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\r\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\r\n\r\nfunction OrbitControls( object, domElement ) {\r\n\r\n    this.object = object;\r\n\r\n    this.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the object orbits around\r\n    this.target = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n    // How far you can dolly in and out ( PerspectiveCamera only )\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // How far you can zoom in and out ( OrthographicCamera only )\r\n    this.minZoom = 0;\r\n    this.maxZoom = Infinity;\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // How far you can orbit horizontally, upper and lower limits.\r\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n    this.minAzimuthAngle = - Infinity; // radians\r\n    this.maxAzimuthAngle = Infinity; // radians\r\n\r\n    // Set to true to enable damping (inertia)\r\n    // If damping is enabled, you must call controls.update() in your animation loop\r\n    this.enableDamping = false;\r\n    this.dampingFactor = 0.25;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n    // Set to false to disable zooming\r\n    this.enableZoom = true;\r\n    this.zoomSpeed = 1.0;\r\n\r\n    // Set to false to disable rotating\r\n    this.enableRotate = true;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to false to disable panning\r\n    this.enablePan = true;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // Set to false to disable use of the keys\r\n    this.enableKeys = true;\r\n\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    // Mouse buttons\r\n    this.mouseButtons = { ORBIT: three__WEBPACK_IMPORTED_MODULE_0__[\"MOUSE\"].LEFT, ZOOM: three__WEBPACK_IMPORTED_MODULE_0__[\"MOUSE\"].MIDDLE, PAN: three__WEBPACK_IMPORTED_MODULE_0__[\"MOUSE\"].RIGHT };\r\n\r\n    // for reset\r\n    this.target0 = this.target.clone();\r\n    this.position0 = this.object.position.clone();\r\n    this.zoom0 = this.object.zoom;\r\n\r\n    //\r\n    // public methods\r\n    //\r\n\r\n    this.getPolarAngle = function () {\r\n\r\n        return spherical.phi;\r\n\r\n    };\r\n\r\n    this.getAzimuthalAngle = function () {\r\n\r\n        return spherical.theta;\r\n\r\n    };\r\n\r\n    this.saveState = function () {\r\n\r\n        scope.target0.copy( scope.target );\r\n        scope.position0.copy( scope.object.position );\r\n        scope.zoom0 = scope.object.zoom;\r\n\r\n    };\r\n\r\n    this.reset = function () {\r\n\r\n        scope.target.copy( scope.target0 );\r\n        scope.object.position.copy( scope.position0 );\r\n        scope.object.zoom = scope.zoom0;\r\n\r\n        scope.object.updateProjectionMatrix();\r\n        scope.dispatchEvent( changeEvent );\r\n\r\n        scope.update();\r\n\r\n        state = STATE.NONE;\r\n\r\n    };\r\n\r\n    // this method is exposed, but perhaps it would be better if we can make it private...\r\n    this.update = function () {\r\n\r\n        var offset = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        // so camera.up is the orbit axis\r\n        var quat = new three__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"]().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]( 0, 1, 0 ) );\r\n        var quatInverse = quat.clone().inverse();\r\n\r\n        var lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n        var lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"]();\r\n\r\n        return function update() {\r\n\r\n            var position = scope.object.position;\r\n\r\n            offset.copy( position ).sub( scope.target );\r\n\r\n            // rotate offset to \"y-axis-is-up\" space\r\n            offset.applyQuaternion( quat );\r\n\r\n            // angle from z-axis around y-axis\r\n            spherical.setFromVector3( offset );\r\n\r\n            if ( scope.autoRotate && state === STATE.NONE ) {\r\n\r\n                rotateLeft( getAutoRotationAngle() );\r\n\r\n            }\r\n\r\n            spherical.theta += sphericalDelta.theta;\r\n            spherical.phi += sphericalDelta.phi;\r\n\r\n            // restrict theta to be between desired limits\r\n            spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\r\n\r\n            // restrict phi to be between desired limits\r\n            spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\r\n\r\n            spherical.makeSafe();\r\n\r\n\r\n            spherical.radius *= scale;\r\n\r\n            // restrict radius to be between desired limits\r\n            spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\r\n\r\n            // move target to panned location\r\n            scope.target.add( panOffset );\r\n\r\n            offset.setFromSpherical( spherical );\r\n\r\n            // rotate offset back to \"camera-up-vector-is-up\" space\r\n            offset.applyQuaternion( quatInverse );\r\n\r\n            position.copy( scope.target ).add( offset );\r\n\r\n            scope.object.lookAt( scope.target );\r\n\r\n            if ( scope.enableDamping === true ) {\r\n\r\n                sphericalDelta.theta *= ( 1 - scope.dampingFactor );\r\n                sphericalDelta.phi *= ( 1 - scope.dampingFactor );\r\n\r\n            } else {\r\n\r\n                sphericalDelta.set( 0, 0, 0 );\r\n\r\n            }\r\n\r\n            scale = 1;\r\n            panOffset.set( 0, 0, 0 );\r\n\r\n            // update condition is:\r\n            // min(camera displacement, camera rotation in radians)^2 > EPS\r\n            // using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n            if ( zoomChanged ||\r\n                lastPosition.distanceToSquared( scope.object.position ) > EPS ||\r\n                8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\r\n\r\n                scope.dispatchEvent( changeEvent );\r\n\r\n                lastPosition.copy( scope.object.position );\r\n                lastQuaternion.copy( scope.object.quaternion );\r\n                zoomChanged = false;\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            return false;\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    this.dispose = function () {\r\n\r\n        scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\r\n        scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n        scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\r\n\r\n        scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\r\n        scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\r\n        scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\r\n\r\n        document.removeEventListener( 'mousemove', onMouseMove, false );\r\n        document.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        window.removeEventListener( 'keydown', onKeyDown, false );\r\n\r\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n\r\n    };\r\n\r\n    //\r\n    // internals\r\n    //\r\n\r\n    var scope = this;\r\n\r\n    var changeEvent = { type: 'change' };\r\n    var startEvent = { type: 'start' };\r\n    var endEvent = { type: 'end' };\r\n\r\n    var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\r\n\r\n    var state = STATE.NONE;\r\n\r\n    var EPS = 0.000001;\r\n\r\n    // current position in spherical coordinates\r\n    var spherical = new three__WEBPACK_IMPORTED_MODULE_0__[\"Spherical\"]();\r\n    var sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Spherical\"]();\r\n\r\n    var scale = 1;\r\n    var panOffset = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n    var zoomChanged = false;\r\n\r\n    var rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n\r\n    var panStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var panEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var panDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n\r\n    var dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n\r\n    function getAutoRotationAngle() {\r\n\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n    }\r\n\r\n    function getZoomScale() {\r\n\r\n        return Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n    }\r\n\r\n    function rotateLeft( angle ) {\r\n\r\n        sphericalDelta.theta -= angle;\r\n\r\n    }\r\n\r\n    function rotateUp( angle ) {\r\n\r\n        sphericalDelta.phi -= angle;\r\n\r\n    }\r\n\r\n    var panLeft = function () {\r\n\r\n        var v = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        return function panLeft( distance, objectMatrix ) {\r\n\r\n            v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n            v.multiplyScalar( - distance );\r\n\r\n            panOffset.add( v );\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    var panUp = function () {\r\n\r\n        var v = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        return function panUp( distance, objectMatrix ) {\r\n\r\n            v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\r\n            v.multiplyScalar( distance );\r\n\r\n            panOffset.add( v );\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    // deltaX and deltaY are in pixels; right and down are positive\r\n    var pan = function () {\r\n\r\n        var offset = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        return function pan( deltaX, deltaY ) {\r\n\r\n            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n            if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"] ) {\r\n\r\n                // perspective\r\n                var position = scope.object.position;\r\n                offset.copy( position ).sub( scope.target );\r\n                var targetDistance = offset.length();\r\n\r\n                // half of the fov is center to top of screen\r\n                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n                // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n                panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\r\n                panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\r\n\r\n            } else if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"] ) {\r\n\r\n                // orthographic\r\n                panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\r\n                panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\r\n\r\n            } else {\r\n\r\n                // camera neither orthographic nor perspective\r\n                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n                scope.enablePan = false;\r\n\r\n            }\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    function dollyIn( dollyScale ) {\r\n\r\n        if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"] ) {\r\n\r\n            scale /= dollyScale;\r\n\r\n        } else if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"] ) {\r\n\r\n            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n\r\n        } else {\r\n\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n            scope.enableZoom = false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function dollyOut( dollyScale ) {\r\n\r\n        if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"] ) {\r\n\r\n            scale *= dollyScale;\r\n\r\n        } else if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"] ) {\r\n\r\n            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n\r\n        } else {\r\n\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n            scope.enableZoom = false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //\r\n    // event callbacks - update the object state\r\n    //\r\n\r\n    function handleMouseDownRotate( event ) {\r\n\r\n        //console.log( 'handleMouseDownRotate' );\r\n\r\n        rotateStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseDownDolly( event ) {\r\n\r\n        //console.log( 'handleMouseDownDolly' );\r\n\r\n        dollyStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseDownPan( event ) {\r\n\r\n        //console.log( 'handleMouseDownPan' );\r\n\r\n        panStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseMoveRotate( event ) {\r\n\r\n        //console.log( 'handleMouseMoveRotate' );\r\n\r\n        rotateEnd.set( event.clientX, event.clientY );\r\n        rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        // rotating across whole screen goes 360 degrees around\r\n        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n        rotateStart.copy( rotateEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseMoveDolly( event ) {\r\n\r\n        //console.log( 'handleMouseMoveDolly' );\r\n\r\n        dollyEnd.set( event.clientX, event.clientY );\r\n\r\n        dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n        if ( dollyDelta.y > 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        } else if ( dollyDelta.y < 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        }\r\n\r\n        dollyStart.copy( dollyEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseMovePan( event ) {\r\n\r\n        //console.log( 'handleMouseMovePan' );\r\n\r\n        panEnd.set( event.clientX, event.clientY );\r\n\r\n        panDelta.subVectors( panEnd, panStart );\r\n\r\n        pan( panDelta.x, panDelta.y );\r\n\r\n        panStart.copy( panEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseUp( event ) {\r\n\r\n        // console.log( 'handleMouseUp' );\r\n\r\n    }\r\n\r\n    function handleMouseWheel( event ) {\r\n\r\n        // console.log( 'handleMouseWheel' );\r\n\r\n        if ( event.deltaY < 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        } else if ( event.deltaY > 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        }\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleKeyDown( event ) {\r\n\r\n        //console.log( 'handleKeyDown' );\r\n\r\n        switch ( event.keyCode ) {\r\n\r\n            case scope.keys.UP:\r\n                pan( 0, scope.keyPanSpeed );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.BOTTOM:\r\n                pan( 0, - scope.keyPanSpeed );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.LEFT:\r\n                pan( scope.keyPanSpeed, 0 );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.RIGHT:\r\n                pan( - scope.keyPanSpeed, 0 );\r\n                scope.update();\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function handleTouchStartRotate( event ) {\r\n\r\n        //console.log( 'handleTouchStartRotate' );\r\n\r\n        rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n    }\r\n\r\n    function handleTouchStartDolly( event ) {\r\n\r\n        //console.log( 'handleTouchStartDolly' );\r\n\r\n        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        dollyStart.set( 0, distance );\r\n\r\n    }\r\n\r\n    function handleTouchStartPan( event ) {\r\n\r\n        //console.log( 'handleTouchStartPan' );\r\n\r\n        panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n    }\r\n\r\n    function handleTouchMoveRotate( event ) {\r\n\r\n        //console.log( 'handleTouchMoveRotate' );\r\n\r\n        rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n        rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        // rotating across whole screen goes 360 degrees around\r\n        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n        rotateStart.copy( rotateEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchMoveDolly( event ) {\r\n\r\n        //console.log( 'handleTouchMoveDolly' );\r\n\r\n        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        dollyEnd.set( 0, distance );\r\n\r\n        dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n        if ( dollyDelta.y > 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        } else if ( dollyDelta.y < 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        }\r\n\r\n        dollyStart.copy( dollyEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchMovePan( event ) {\r\n\r\n        //console.log( 'handleTouchMovePan' );\r\n\r\n        panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n        panDelta.subVectors( panEnd, panStart );\r\n\r\n        pan( panDelta.x, panDelta.y );\r\n\r\n        panStart.copy( panEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchEnd( event ) {\r\n\r\n        //console.log( 'handleTouchEnd' );\r\n\r\n    }\r\n\r\n    //\r\n    // event handlers - FSM: listen for events and reset state\r\n    //\r\n\r\n    function onMouseDown( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        switch ( event.button ) {\r\n\r\n            case scope.mouseButtons.ORBIT:\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleMouseDownRotate( event );\r\n\r\n                state = STATE.ROTATE;\r\n\r\n                break;\r\n\r\n            case scope.mouseButtons.ZOOM:\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleMouseDownDolly( event );\r\n\r\n                state = STATE.DOLLY;\r\n\r\n                break;\r\n\r\n            case scope.mouseButtons.PAN:\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleMouseDownPan( event );\r\n\r\n                state = STATE.PAN;\r\n\r\n                break;\r\n\r\n        }\r\n\r\n        if ( state !== STATE.NONE ) {\r\n\r\n            document.addEventListener( 'mousemove', onMouseMove, false );\r\n            document.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n            scope.dispatchEvent( startEvent );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onMouseMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        switch ( state ) {\r\n\r\n            case STATE.ROTATE:\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleMouseMoveRotate( event );\r\n\r\n                break;\r\n\r\n            case STATE.DOLLY:\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleMouseMoveDolly( event );\r\n\r\n                break;\r\n\r\n            case STATE.PAN:\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleMouseMovePan( event );\r\n\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onMouseUp( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        handleMouseUp( event );\r\n\r\n        document.removeEventListener( 'mousemove', onMouseMove, false );\r\n        document.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        scope.dispatchEvent( endEvent );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onMouseWheel( event ) {\r\n\r\n        if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        handleMouseWheel( event );\r\n\r\n        scope.dispatchEvent( startEvent ); // not sure why these are here...\r\n        scope.dispatchEvent( endEvent );\r\n\r\n    }\r\n\r\n    function onKeyDown( event ) {\r\n\r\n        if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\r\n\r\n        handleKeyDown( event );\r\n\r\n    }\r\n\r\n    function onTouchStart( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1:\t// one-fingered touch: rotate\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleTouchStartRotate( event );\r\n\r\n                state = STATE.TOUCH_ROTATE;\r\n\r\n                break;\r\n\r\n            case 2:\t// two-fingered touch: dolly\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleTouchStartDolly( event );\r\n\r\n                state = STATE.TOUCH_DOLLY;\r\n\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleTouchStartPan( event );\r\n\r\n                state = STATE.TOUCH_PAN;\r\n\r\n                break;\r\n\r\n            default:\r\n\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n        if ( state !== STATE.NONE ) {\r\n\r\n            scope.dispatchEvent( startEvent );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onTouchMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1: // one-fingered touch: rotate\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n                if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\r\n\r\n                handleTouchMoveRotate( event );\r\n\r\n                break;\r\n\r\n            case 2: // two-fingered touch: dolly\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n                if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\r\n\r\n                handleTouchMoveDolly( event );\r\n\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n\r\n                if ( scope.enablePan === false ) return;\r\n                if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\r\n\r\n                handleTouchMovePan( event );\r\n\r\n                break;\r\n\r\n            default:\r\n\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onTouchEnd( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        handleTouchEnd( event );\r\n\r\n        scope.dispatchEvent( endEvent );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onContextMenu( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n    }\r\n\r\n    //\r\n\r\n    scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\r\n\r\n    scope.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n    scope.domElement.addEventListener( 'wheel', onMouseWheel, false );\r\n\r\n    scope.domElement.addEventListener( 'touchstart', onTouchStart, false );\r\n    scope.domElement.addEventListener( 'touchend', onTouchEnd, false );\r\n    scope.domElement.addEventListener( 'touchmove', onTouchMove, false );\r\n\r\n    window.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n    // force an update at start\r\n\r\n    this.update();\r\n\r\n};\r\n\r\nOrbitControls.prototype = Object.create( three__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"].prototype );\r\nOrbitControls.prototype.constructor = OrbitControls;\r\n\r\nObject.defineProperties( OrbitControls.prototype, {\r\n\r\n    center: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .center has been renamed to .target' );\r\n            return this.target;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    // backward compatibility\r\n\r\n    noZoom: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n            return ! this.enableZoom;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n            this.enableZoom = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noRotate: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n            return ! this.enableRotate;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n            this.enableRotate = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noPan: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n            return ! this.enablePan;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n            this.enablePan = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noKeys: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n            return ! this.enableKeys;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n            this.enableKeys = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    staticMoving: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n            return ! this.enableDamping;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n            this.enableDamping = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    dynamicDampingFactor: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n            return this.dampingFactor;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n            this.dampingFactor = value;\r\n\r\n        }\r\n\r\n    }\r\n\r\n} );\n\n//# sourceURL=webpack:///./src/lib/OrbitControls.js?");

/***/ }),

/***/ "./src/model/ModelWorker.js":
/*!**********************************!*\
  !*** ./src/model/ModelWorker.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return worker; });\n/* harmony import */ var _modelFunctions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modelFunctions */ \"./src/model/modelFunctions.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\nconst debug = debug__WEBPACK_IMPORTED_MODULE_1__(\"minerender\");\r\n\r\nfunction worker(self) {\r\n    debug(\"New Worker!\")\r\n    self.addEventListener(\"message\", event => {\r\n        let msg = event.data;\r\n\r\n        if (msg.func === \"parseModel\") {\r\n            Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_0__[\"parseModel\"])(msg.model, msg.modelOptions, [], msg.assetRoot).then((parsedModelList) => {\r\n                self.postMessage({msg: \"done\",parsedModelList:parsedModelList})\r\n                close();\r\n            })\r\n        } else if (msg.func === \"loadAndMergeModel\") {\r\n            Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_0__[\"loadAndMergeModel\"])(msg.model, msg.assetRoot).then((mergedModel) => {\r\n                self.postMessage({msg: \"done\",mergedModel:mergedModel});\r\n                close();\r\n            })\r\n        } else if (msg.func === \"loadTextures\") {\r\n            Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_0__[\"loadTextures\"])(msg.textures, msg.assetRoot).then((textures) => {\r\n                self.postMessage({msg: \"done\",textures:textures});\r\n                close();\r\n            })\r\n        } else {\r\n            console.warn(\"Unknown function '\" + msg.func + \"' for ModelWorker\");\r\n            console.warn(msg);\r\n            close();\r\n        }\r\n    })\r\n};\r\n\n\n//# sourceURL=webpack:///./src/model/ModelWorker.js?");

/***/ }),

/***/ "./src/model/index.js":
/*!****************************!*\
  !*** ./src/model/index.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! deepmerge */ \"./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _renderBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderBase */ \"./src/renderBase.js\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../functions */ \"./src/functions.js\");\n/* harmony import */ var _modelConverter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modelConverter */ \"./src/model/modelConverter.js\");\n/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! md5 */ \"./node_modules/md5/md5.js\");\n/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(md5__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _modelFunctions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modelFunctions */ \"./src/model/modelFunctions.js\");\n/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! webworkify-webpack */ \"./node_modules/webworkify-webpack/index.js\");\n/* harmony import */ var webworkify_webpack__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(webworkify_webpack__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _skin__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../skin */ \"./src/skin/index.js\");\n/* harmony import */ var onscreen_lib_methods_off__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! onscreen/lib/methods/off */ \"./node_modules/onscreen/lib/methods/off.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_11__);\n\r\n\r\n__webpack_require__(/*! three-instanced-mesh */ \"./node_modules/three-instanced-mesh/index.js\")(three__WEBPACK_IMPORTED_MODULE_0__);\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst debug = debug__WEBPACK_IMPORTED_MODULE_11__(\"minerender\");\r\n\r\nconst ModelWorker = /*require.resolve*/(/*! ./ModelWorker.js */ \"./src/model/ModelWorker.js\");\r\n\r\n\r\nString.prototype.replaceAll = function (search, replacement) {\r\n    let target = this;\r\n    return target.replace(new RegExp(search, 'g'), replacement);\r\n};\r\n\r\nconst colors = [\r\n    0xFF0000,\r\n    0x00FFFF,\r\n    0x0000FF,\r\n    0x000080,\r\n    0xFF00FF,\r\n    0x800080,\r\n    0x808000,\r\n    0x00FF00,\r\n    0x008000,\r\n    0xFFFF00,\r\n    0x800000,\r\n    0x008080,\r\n];\r\n\r\nconst FACE_ORDER = [\"east\", \"west\", \"up\", \"down\", \"south\", \"north\"];\r\nconst TINTS = [\"lightgreen\"];\r\n\r\nconst mergedModelCache = {};\r\nconst loadedTextureCache = {};\r\nconst modelInstances = {};\r\n\r\nconst textureCache = {};\r\nconst canvasCache = {};\r\nconst materialCache = {};\r\nconst geometryCache = {};\r\nconst instanceCache = {};\r\n\r\nconst animatedTextures = [];\r\n\r\n/**\r\n * @see defaultOptions\r\n * @property {string} type alternative way to specify the model type (block/item)\r\n * @property {boolean} [centerCubes=false] center the cube's rotation point\r\n * @property {string} [assetRoot=DEFAULT_ROOT] root to get asset files from\r\n */\r\nlet defOptions = {\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 35,\r\n        y: 25,\r\n        z: 20,\r\n        target: [0, 0, 0]\r\n    },\r\n    type: \"block\",\r\n    centerCubes: false,\r\n    assetRoot: _functions__WEBPACK_IMPORTED_MODULE_4__[\"DEFAULT_ROOT\"],\r\n    useWebWorkers: false\r\n};\r\n\r\n/**\r\n * A renderer for Minecraft models, i.e. blocks & items\r\n */\r\nclass ModelRender extends _renderBase__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {string} [options.assetRoot=DEFAULT_ROOT] root to get asset files from\r\n     *\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, element) {\r\n        super(options, defOptions, element);\r\n\r\n        this.renderType = \"ModelRender\";\r\n\r\n        this.models = [];\r\n        this.instancePositionMap = {};\r\n        this.attached = false;\r\n    }\r\n\r\n    /**\r\n     * Does the actual rendering\r\n     * @param {(string[]|Object[])} models Array of models to render - Either strings in the format <block|item>/<model name> or objects\r\n     * @param {string} [models[].type=block] either 'block' or 'item'\r\n     * @param {string} models[].model if 'type' is given, just the block/item name otherwise '<block|item>/<model name>'\r\n     * @param {number[]} [models[].offset] [x,y,z] array of the offset\r\n     * @param {number[]} [models[].rotation] [x,y,z] array of the rotation\r\n     * @param {string} [models[].blockstate] name of a blockstate to be used to determine the models (only for blocks)\r\n     * @param {string} [models[].variant=normal] if 'blockstate' is given, the block variant to use\r\n     * @param {function} [cb] Callback when rendering finished\r\n     */\r\n    render(models, cb) {\r\n        let modelRender = this;\r\n\r\n        if (!modelRender.attached && !modelRender._scene) {// Don't init scene if attached, since we already have an available scene\r\n            super.initScene(function () {\r\n                // Animate textures\r\n                for (let i = 0; i < animatedTextures.length; i++) {\r\n                    animatedTextures[i]();\r\n                }\r\n\r\n                modelRender.element.dispatchEvent(new CustomEvent(\"modelRender\", {detail: {models: modelRender.models}}));\r\n            });\r\n        } else {\r\n            console.log(\"[ModelRender] is attached - skipping scene init\");\r\n        }\r\n\r\n        let parsedModelList = [];\r\n\r\n        parseModels(modelRender, models, parsedModelList)\r\n            .then(() => loadAndMergeModels(modelRender, parsedModelList))\r\n            .then(() => loadModelTextures(modelRender, parsedModelList))\r\n            .then(() => doModelRender(modelRender, parsedModelList))\r\n            .then((renderedModels) => {\r\n                console.timeEnd(\"doModelRender\");\r\n                debug(renderedModels)\r\n                if (typeof cb === \"function\") cb();\r\n            })\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\nfunction parseModels(modelRender, models, parsedModelList) {\r\n    console.time(\"parseModels\");\r\n    console.log(\"Parsing Models...\");\r\n    let parsePromises = [];\r\n    for (let i = 0; i < models.length; i++) {\r\n        let model = models[i];\r\n\r\n        // parsePromises.push(parseModel(model, model, parsedModelList, modelRender.options.assetRoot))\r\n        parsePromises.push(new Promise(resolve => {\r\n            if (modelRender.options.useWebWorkers) {\r\n                let w = webworkify_webpack__WEBPACK_IMPORTED_MODULE_8___default()(ModelWorker);\r\n                w.addEventListener('message', event => {\r\n                    parsedModelList.push(...event.data.parsedModelList);\r\n                    resolve();\r\n                });\r\n                w.postMessage({\r\n                    func: \"parseModel\",\r\n                    model: model,\r\n                    modelOptions: model,\r\n                    parsedModelList: parsedModelList,\r\n                    assetRoot: modelRender.options.assetRoot\r\n                })\r\n            } else {\r\n                Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"parseModel\"])(model, model, parsedModelList, modelRender.options.assetRoot).then(() => {\r\n                    resolve();\r\n                })\r\n            }\r\n        }))\r\n\r\n    }\r\n\r\n    return Promise.all(parsePromises);\r\n}\r\n\r\n\r\nfunction loadAndMergeModels(modelRender, parsedModelList) {\r\n    console.timeEnd(\"parseModels\");\r\n    console.time(\"loadAndMergeModels\");\r\n\r\n    let jsonPromises = [];\r\n\r\n    console.log(\"Loading Model JSON data & merging...\");\r\n    let uniqueModels = {};\r\n    for (let i = 0; i < parsedModelList.length; i++) {\r\n        let cacheKey = Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])(parsedModelList[i]);\r\n        modelInstances[cacheKey] = (modelInstances[cacheKey] || 0) + 1;\r\n        uniqueModels[cacheKey] = parsedModelList[i];\r\n    }\r\n    let uniqueModelList = Object.values(uniqueModels);\r\n    debug(uniqueModelList.length + \" unique models\");\r\n    for (let i = 0; i < uniqueModelList.length; i++) {\r\n        jsonPromises.push(new Promise(resolve => {\r\n            let model = uniqueModelList[i];\r\n            let cacheKey = Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])(model);\r\n            debug(\"loadAndMerge \" + cacheKey);\r\n\r\n\r\n            if (mergedModelCache.hasOwnProperty(cacheKey)) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if (modelRender.options.useWebWorkers) {\r\n                let w = webworkify_webpack__WEBPACK_IMPORTED_MODULE_8___default()(ModelWorker);\r\n                w.addEventListener('message', event => {\r\n                    mergedModelCache[cacheKey] = event.data.mergedModel;\r\n                    resolve();\r\n                });\r\n                w.postMessage({\r\n                    func: \"loadAndMergeModel\",\r\n                    model: model,\r\n                    assetRoot: modelRender.options.assetRoot\r\n                });\r\n            } else {\r\n                Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"loadAndMergeModel\"])(model, modelRender.options.assetRoot).then((mergedModel) => {\r\n                    mergedModelCache[cacheKey] = mergedModel;\r\n                    resolve();\r\n                })\r\n            }\r\n        }))\r\n    }\r\n\r\n    return Promise.all(jsonPromises);\r\n}\r\n\r\nfunction loadModelTextures(modelRender, parsedModelList) {\r\n    console.timeEnd(\"loadAndMergeModels\");\r\n    console.time(\"loadModelTextures\");\r\n\r\n    let texturePromises = [];\r\n\r\n    console.log(\"Loading Textures...\");\r\n    let uniqueModels = {};\r\n    for (let i = 0; i < parsedModelList.length; i++) {\r\n        uniqueModels[Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])(parsedModelList[i])] = parsedModelList[i];\r\n    }\r\n    let uniqueModelList = Object.values(uniqueModels);\r\n    debug(uniqueModelList.length + \" unique models\");\r\n    for (let i = 0; i < uniqueModelList.length; i++) {\r\n        texturePromises.push(new Promise(resolve => {\r\n            let model = uniqueModelList[i];\r\n            let cacheKey = Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])(model);\r\n            debug(\"loadTexture \" + cacheKey);\r\n            let mergedModel = mergedModelCache[cacheKey];\r\n\r\n            if (loadedTextureCache.hasOwnProperty(cacheKey)) {\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if (!mergedModel) {\r\n                console.warn(\"Missing merged model\");\r\n                console.warn(model.name);\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if (!mergedModel.textures) {\r\n                console.warn(\"The model doesn't have any textures!\");\r\n                console.warn(\"Please make sure you're using the proper file.\");\r\n                console.warn(model.name);\r\n                resolve();\r\n                return;\r\n            }\r\n\r\n            if (modelRender.options.useWebWorkers) {\r\n                let w = webworkify_webpack__WEBPACK_IMPORTED_MODULE_8___default()(ModelWorker);\r\n                w.addEventListener('message', event => {\r\n                    loadedTextureCache[cacheKey] = event.data.textures;\r\n                    resolve();\r\n                });\r\n                w.postMessage({\r\n                    func: \"loadTextures\",\r\n                    textures: mergedModel.textures,\r\n                    assetRoot: modelRender.options.assetRoot\r\n                });\r\n            } else {\r\n                Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"loadTextures\"])(mergedModel.textures, modelRender.options.assetRoot).then((textures) => {\r\n                    loadedTextureCache[cacheKey] = textures;\r\n                    resolve();\r\n                })\r\n            }\r\n        }))\r\n    }\r\n\r\n\r\n    return Promise.all(texturePromises);\r\n}\r\n\r\nfunction doModelRender(modelRender, parsedModelList) {\r\n    console.timeEnd(\"loadModelTextures\");\r\n    console.time(\"doModelRender\");\r\n\r\n    console.log(\"Rendering Models...\");\r\n\r\n    let renderPromises = [];\r\n\r\n    for (let i = 0; i < parsedModelList.length; i++) {\r\n        renderPromises.push(new Promise(resolve => {\r\n            let model = parsedModelList[i];\r\n\r\n            let mergedModel = mergedModelCache[Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])(model)];\r\n            let textures = loadedTextureCache[Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])(model)];\r\n\r\n            let offset = model.offset || [0, 0, 0];\r\n            let rotation = model.rotation || [0, 0, 0];\r\n            let scale = model.scale || [1, 1, 1];\r\n\r\n            if (model.options.hasOwnProperty(\"display\")) {\r\n                if (mergedModel.hasOwnProperty(\"display\")) {\r\n                    if (mergedModel.display.hasOwnProperty(model.options.display)) {\r\n                        let displayData = mergedModel.display[model.options.display];\r\n\r\n                        if (displayData.hasOwnProperty(\"translation\")) {\r\n                            offset = [offset[0] + displayData.translation[0], offset[1] + displayData.translation[1], offset[2] + displayData.translation[2]];\r\n                        }\r\n                        if (displayData.hasOwnProperty(\"rotation\")) {\r\n                            rotation = [rotation[0] + displayData.rotation[0], rotation[1] + displayData.rotation[1], rotation[2] + displayData.rotation[2]];\r\n                        }\r\n                        if (displayData.hasOwnProperty(\"scale\")) {\r\n                            scale = [displayData.scale[0], displayData.scale[1], displayData.scale[2]];\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n\r\n            renderModel(modelRender, mergedModel, textures, mergedModel.textures, model.type, model.name, model.variant, offset, rotation, scale).then((renderedModel) => {\r\n\r\n                if (renderedModel.firstInstance) {\r\n                    let container = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n                    container.add(renderedModel.mesh);\r\n\r\n                    modelRender.models.push(container);\r\n                    modelRender.addToScene(container);\r\n                }\r\n\r\n                resolve(renderedModel);\r\n            })\r\n        }))\r\n    }\r\n\r\n    return Promise.all(renderPromises);\r\n}\r\n\r\n\r\nlet renderModel = function (modelRender, model, textures, textureNames, type, name, variant, offset, rotation, scale) {\r\n    return new Promise((resolve) => {\r\n        if (model.hasOwnProperty(\"elements\")) {// block OR item with block parent\r\n            let modelKey = Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])({type: type, name: name, variant: variant});\r\n            let instanceCount = modelInstances[modelKey];\r\n\r\n            let applyModelTransforms = function (mesh, instanceIndex) {\r\n                mesh.userData.modelType = type;\r\n                mesh.userData.modelName = name;\r\n\r\n                let _v3o = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n                let _v3s = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n                let _q = new three__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"]();\r\n\r\n                let instanceInfo = {\r\n                    key: modelKey,\r\n                    index: instanceIndex,\r\n                    offset: offset,\r\n                    scale: scale,\r\n                    rotation: rotation\r\n                };\r\n\r\n                if (rotation) {\r\n                    mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new three__WEBPACK_IMPORTED_MODULE_0__[\"Euler\"](Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(rotation[0]), Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(Math.abs(rotation[0]) > 0 ? rotation[1] : -rotation[1]), Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(rotation[2]))));\r\n                }\r\n                if (offset) {\r\n                    mesh.setPositionAt(instanceIndex, _v3o.set(offset[0], offset[1], offset[2]));\r\n                    modelRender.instancePositionMap[offset[0] + \"_\" + offset[1] + \"_\" + offset[2]] = instanceInfo;\r\n                }\r\n                if (scale) {\r\n                    mesh.setScaleAt(instanceIndex, _v3s.set(scale[0], scale[1], scale[2]));\r\n                }\r\n\r\n                mesh.needsUpdate();\r\n\r\n                // mesh.position = _v3o;\r\n                // Object.defineProperty(mesh.position,\"x\",{\r\n                //     get:function () {\r\n                //         return this._x||0;\r\n                //     },\r\n                //     set:function (x) {\r\n                //         this._x=x;\r\n                //         mesh.setPositionAt(instanceIndex, _v3o.set(x, this.y, this.z));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.position,\"y\",{\r\n                //     get:function () {\r\n                //         return this._y||0;\r\n                //     },\r\n                //     set:function (y) {\r\n                //         this._y=y;\r\n                //         mesh.setPositionAt(instanceIndex, _v3o.set(this.x, y, this.z));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.position,\"z\",{\r\n                //     get:function () {\r\n                //         return this._z||0;\r\n                //     },\r\n                //     set:function (z) {\r\n                //         this._z=z;\r\n                //         mesh.setPositionAt(instanceIndex, _v3o.set(this.x, this.y, z));\r\n                //     }\r\n                // })\r\n                //\r\n                // mesh.rotation = new THREE.Euler(toRadians(rotation[0]), toRadians(Math.abs(rotation[0]) > 0 ? rotation[1] : -rotation[1]), toRadians(rotation[2]));\r\n                // Object.defineProperty(mesh.rotation,\"x\",{\r\n                //     get:function () {\r\n                //         return this._x||0;\r\n                //     },\r\n                //     set:function (x) {\r\n                //         this._x=x;\r\n                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(x), toRadians(this.y), toRadians(this.z))));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.rotation,\"y\",{\r\n                //     get:function () {\r\n                //         return this._y||0;\r\n                //     },\r\n                //     set:function (y) {\r\n                //         this._y=y;\r\n                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(this.x), toRadians(y), toRadians(this.z))));\r\n                //     }\r\n                // });\r\n                // Object.defineProperty(mesh.rotation,\"z\",{\r\n                //     get:function () {\r\n                //         return this._z||0;\r\n                //     },\r\n                //     set:function (z) {\r\n                //         this._z=z;\r\n                //         mesh.setQuaternionAt(instanceIndex, _q.setFromEuler(new THREE.Euler(toRadians(this.x), toRadians(this.y), toRadians(z))));\r\n                //     }\r\n                // });\r\n                //\r\n                // mesh.scale = _v3s;\r\n\r\n                resolve({\r\n                    mesh: mesh,\r\n                    firstInstance: instanceIndex === 0\r\n                });\r\n            };\r\n\r\n            let finalizeCubeModel = function (geometry, materials) {\r\n                geometry.translate(-8, -8, -8);\r\n\r\n\r\n                let cachedInstance;\r\n\r\n                if (!instanceCache.hasOwnProperty(modelKey)) {\r\n                    debug(\"Caching new model instance \" + modelKey + \" (with \" + instanceCount + \" instances)\");\r\n                    let newInstance = new three__WEBPACK_IMPORTED_MODULE_0__[\"InstancedMesh\"](\r\n                        geometry,\r\n                        materials,\r\n                        instanceCount,\r\n                        false,\r\n                        false,\r\n                        false);\r\n                    cachedInstance = {\r\n                        instance: newInstance,\r\n                        index: 0\r\n                    };\r\n                    instanceCache[modelKey] = cachedInstance;\r\n                    let _v3o = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n                    let _v3s = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](1, 1, 1);\r\n                    let _q = new three__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"]();\r\n\r\n                    for (let i = 0; i < instanceCount; i++) {\r\n\r\n                        newInstance.setQuaternionAt(i, _q);\r\n                        newInstance.setPositionAt(i, _v3o);\r\n                        newInstance.setScaleAt(i, _v3s);\r\n\r\n                    }\r\n                } else {\r\n                    debug(\"Using cached instance (\" + modelKey + \")\");\r\n                    cachedInstance = instanceCache[modelKey];\r\n\r\n                }\r\n\r\n                applyModelTransforms(cachedInstance.instance, cachedInstance.index++);\r\n            };\r\n\r\n            if (instanceCache.hasOwnProperty(modelKey)) {\r\n                debug(\"Using cached model instance (\" + modelKey + \")\");\r\n                let cachedInstance = instanceCache[modelKey];\r\n                applyModelTransforms(cachedInstance.instance, cachedInstance.index++);\r\n                return;\r\n            }\r\n\r\n            // Render the elements\r\n            let promises = [];\r\n            for (let i = 0; i < model.elements.length; i++) {\r\n                let element = model.elements[i];\r\n\r\n                // // From net.minecraft.client.renderer.block.model.BlockPart.java#47 - https://yeleha.co/2JcqSr4\r\n                let fallbackFaces = {\r\n                    down: {\r\n                        uv: [element.from[0], 16 - element.to[2], element.to[0], 16 - element.from[2]],\r\n                        texture: \"#down\"\r\n                    },\r\n                    up: {\r\n                        uv: [element.from[0], element.from[2], element.to[0], element.to[2]],\r\n                        texture: \"#up\"\r\n                    },\r\n                    north: {\r\n                        uv: [16 - element.to[0], 16 - element.to[1], 16 - element.from[0], 16 - element.from[1]],\r\n                        texture: \"#north\"\r\n                    },\r\n                    south: {\r\n                        uv: [element.from[0], 16 - element.to[1], element.to[0], 16 - element.from[1]],\r\n                        texture: \"#south\"\r\n                    },\r\n                    west: {\r\n                        uv: [element.from[2], 16 - element.to[1], element.to[2], 16 - element.from[2]],\r\n                        texture: \"#west\"\r\n                    },\r\n                    east: {\r\n                        uv: [16 - element.to[2], 16 - element.to[1], 16 - element.from[2], 16 - element.from[1]],\r\n                        texture: \"#east\"\r\n                    }\r\n                };\r\n\r\n                promises.push(new Promise((resolve) => {\r\n                    let baseName = name.replaceAll(\" \", \"_\").replaceAll(\"-\", \"_\").toLowerCase() + \"_\" + (element.__comment ? element.__comment.replaceAll(\" \", \"_\").replaceAll(\"-\", \"_\").toLowerCase() + \"_\" : \"\");\r\n                    createCube(element.to[0] - element.from[0], element.to[1] - element.from[1], element.to[2] - element.from[2],\r\n                        baseName + Date.now(),\r\n                        element.faces, fallbackFaces, textures, textureNames, modelRender.options.assetRoot, baseName)\r\n                        .then((cube) => {\r\n                            cube.applyMatrix(new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]().makeTranslation((element.to[0] - element.from[0]) / 2, (element.to[1] - element.from[1]) / 2, (element.to[2] - element.from[2]) / 2));\r\n                            cube.applyMatrix(new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]().makeTranslation(element.from[0], element.from[1], element.from[2]));\r\n\r\n                            if (element.rotation) {\r\n                                rotateAboutPoint(cube,\r\n                                    new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](element.rotation.origin[0], element.rotation.origin[1], element.rotation.origin[2]),\r\n                                    new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](element.rotation.axis === \"x\" ? 1 : 0, element.rotation.axis === \"y\" ? 1 : 0, element.rotation.axis === \"z\" ? 1 : 0),\r\n                                    Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(element.rotation.angle));\r\n                            }\r\n\r\n                            resolve(cube);\r\n                        })\r\n                }));\r\n\r\n\r\n            }\r\n\r\n            Promise.all(promises).then((cubes) => {\r\n                let mergedCubes = Object(_renderBase__WEBPACK_IMPORTED_MODULE_3__[\"mergeCubeMeshes\"])(cubes, true);\r\n                mergedCubes.sourceSize = cubes.length;\r\n                finalizeCubeModel(mergedCubes.geometry, mergedCubes.materials, cubes.length);\r\n                for (let i = 0; i < cubes.length; i++) {\r\n                    Object(_renderBase__WEBPACK_IMPORTED_MODULE_3__[\"deepDisposeMesh\"])(cubes[i], true);\r\n                }\r\n            })\r\n        } else {// 2d item\r\n            createPlane(name + \"_\" + Date.now(), textures).then((plane) => {\r\n                if (offset) {\r\n                    plane.applyMatrix(new three__WEBPACK_IMPORTED_MODULE_0__[\"Matrix4\"]().makeTranslation(offset[0], offset[1], offset[2]))\r\n                }\r\n                if (rotation) {\r\n                    plane.rotation.set(Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(rotation[0]), Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(Math.abs(rotation[0]) > 0 ? rotation[1] : -rotation[1]), Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(rotation[2]));\r\n                }\r\n                if (scale) {\r\n                    plane.scale.set(scale[0], scale[1], scale[2]);\r\n                }\r\n\r\n                resolve({\r\n                    mesh: plane,\r\n                    firstInstance: true\r\n                });\r\n            })\r\n        }\r\n    })\r\n};\r\n\r\nfunction setVisibilityOfInstance(meshKey, visibleScale, instanceIndex, visible) {\r\n    let instance = instanceCache[meshKey];\r\n    if (instance && instance.instance) {\r\n        let mesh = instance.instance;\r\n        let newScale;\r\n        if (visible) {\r\n            if (visibleScale) {\r\n                newScale = visibleScale;\r\n            } else {\r\n                newScale = [1, 1, 1];\r\n            }\r\n        } else {\r\n            newScale = [0, 0, 0];\r\n        }\r\n        let _v3s = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n        mesh.setScaleAt(instanceIndex, _v3s.set(newScale[0], newScale[1], newScale[2]));\r\n        return mesh;\r\n    }\r\n}\r\n\r\nfunction setVisibilityAtMulti(positions, visible) {\r\n    let updatedMeshes = {};\r\n    for (let pos of positions) {\r\n        let info = this.instancePositionMap[pos[0] + \"_\" + pos[1] + \"_\" + pos[2]];\r\n        if (info) {\r\n            let mesh = setVisibilityOfInstance(info.key, info.scale, info.index, visible);\r\n            if (mesh) {\r\n                updatedMeshes[info.key] = mesh;\r\n            }\r\n        }\r\n    }\r\n    for (let mesh of Object.values(updatedMeshes)) {\r\n        mesh.needsUpdate();\r\n    }\r\n}\r\n\r\nfunction setVisibilityAt(x, y, z, visible) {\r\n    setVisibilityAtMulti([[x, y, z]], visible);\r\n}\r\n\r\nModelRender.prototype.setVisibilityAtMulti = setVisibilityAtMulti;\r\nModelRender.prototype.setVisibilityAt = setVisibilityAt;\r\n\r\nfunction setVisibilityOfType(type, name, variant, visible) {\r\n    let instance = instanceCache[Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"modelCacheKey\"])({type: type, name: name, variant: variant})];\r\n    if (instance && instance.instance) {\r\n        let mesh = instance.instance;\r\n        mesh.visible = visible;\r\n    }\r\n}\r\n\r\nModelRender.prototype.setVisibilityOfType = setVisibilityOfType;\r\n\r\nlet createDot = function (c) {\r\n    let dotGeometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"]();\r\n    dotGeometry.vertices.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]());\r\n    let dotMaterial = new three__WEBPACK_IMPORTED_MODULE_0__[\"PointsMaterial\"]({size: 5, sizeAttenuation: false, color: c});\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Points\"](dotGeometry, dotMaterial);\r\n};\r\n\r\nlet createPlane = function (name, textures) {\r\n    return new Promise((resolve) => {\r\n\r\n        let materialLoaded = function (material, width, height) {\r\n            let geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"PlaneGeometry\"](width, height);\r\n            let plane = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\r\n            plane.name = name;\r\n            plane.receiveShadow = true;\r\n\r\n            resolve(plane);\r\n        };\r\n\r\n        if (textures) {\r\n            let w = 0, h = 0;\r\n            let promises = [];\r\n            for (let t in textures) {\r\n                if (textures.hasOwnProperty(t)) {\r\n                    promises.push(new Promise((resolve) => {\r\n                        let img = new Image();\r\n                        img.onload = function () {\r\n                            if (img.width > w) w = img.width;\r\n                            if (img.height > h) h = img.height;\r\n                            resolve(img);\r\n                        };\r\n                        img.src = textures[t];\r\n                    }))\r\n                }\r\n            }\r\n            Promise.all(promises).then((images) => {\r\n                let canvas = document.createElement(\"canvas\");\r\n                canvas.width = w;\r\n                canvas.height = h;\r\n                let context = canvas.getContext(\"2d\");\r\n\r\n                for (let i = 0; i < images.length; i++) {\r\n                    let img = images[i];\r\n                    context.drawImage(img, 0, 0);\r\n                }\r\n\r\n                let data = canvas.toDataURL(\"image/png\");\r\n                let hash = md5__WEBPACK_IMPORTED_MODULE_6__(data);\r\n\r\n                if (materialCache.hasOwnProperty(hash)) {// Use material from cache\r\n                    debug(\"Using cached Material (\" + hash + \")\");\r\n                    materialLoaded(materialCache[hash], w, h);\r\n                    return;\r\n                }\r\n\r\n                let textureLoaded = function (texture) {\r\n                    let material = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\r\n                        map: texture,\r\n                        transparent: true,\r\n                        side: three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"],\r\n                        alphaTest: 0.5,\r\n                        name: name\r\n                    });\r\n\r\n                    // Add material to cache\r\n                    debug(\"Caching Material \" + hash);\r\n                    materialCache[hash] = material;\r\n\r\n                    materialLoaded(material, w, h);\r\n                };\r\n\r\n                if (textureCache.hasOwnProperty(hash)) {// Use texture to cache\r\n                    debug(\"Using cached Texture (\" + hash + \")\");\r\n                    textureLoaded(textureCache[hash]);\r\n                    return;\r\n                }\r\n\r\n                debug(\"Pre-Caching Texture \" + hash);\r\n                textureCache[hash] = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"]().load(data, function (texture) {\r\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                    texture.anisotropy = 0;\r\n                    texture.needsUpdate = true;\r\n\r\n                    debug(\"Caching Texture \" + hash);\r\n                    // Add texture to cache\r\n                    textureCache[hash] = texture;\r\n\r\n                    textureLoaded(texture);\r\n                });\r\n            });\r\n        }\r\n\r\n    })\r\n};\r\n\r\n\r\n/// From https://github.com/InventivetalentDev/SkinRender/blob/master/js/render/skin.js#L353\r\nlet createCube = function (width, height, depth, name, faces, fallbackFaces, textures, textureNames, assetRoot, baseName) {\r\n    return new Promise((resolve) => {\r\n        let geometryKey = width + \"_\" + height + \"_\" + depth;\r\n        let geometry;\r\n        if (geometryCache.hasOwnProperty(geometryKey)) {\r\n            debug(\"Using cached Geometry (\" + geometryKey + \")\");\r\n            geometry = geometryCache[geometryKey];\r\n        } else {\r\n            geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](width, height, depth);\r\n            debug(\"Caching Geometry \" + geometryKey);\r\n            geometryCache[geometryKey] = geometry;\r\n        }\r\n\r\n        let materialsLoaded = function (materials) {\r\n            let cube = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, materials);\r\n            cube.name = name;\r\n            cube.receiveShadow = true;\r\n\r\n            resolve(cube);\r\n        };\r\n        if (textures) {\r\n            let promises = [];\r\n            for (let i = 0; i < 6; i++) {\r\n                promises.push(new Promise((resolve) => {\r\n                    let f = FACE_ORDER[i];\r\n                    if (!faces.hasOwnProperty(f)) {\r\n                        // console.warn(\"Missing face: \" + f + \" in model \" + name);\r\n                        resolve(null);\r\n                        return;\r\n                    }\r\n                    let face = faces[f];\r\n                    let textureRef = face.texture.substr(1);\r\n                    if (!textures.hasOwnProperty(textureRef) || !textures[textureRef]) {\r\n                        console.warn(\"Missing texture '\" + textureRef + \"' for face \" + f + \" in model \" + name);\r\n                        resolve(null);\r\n                        return;\r\n                    }\r\n\r\n                    let canvasKey = textureRef + \"_\" + f + \"_\" + baseName;\r\n\r\n                    let processImgToCanvasData = (img) => {\r\n                        let uv = face.uv;\r\n                        if (!uv) {\r\n                            // console.warn(\"Missing UV mapping for face \" + f + \" in model \" + name + \". Using defaults\");\r\n                            uv = fallbackFaces[f].uv;\r\n                        }\r\n\r\n                        // Scale the uv values to match the image width, so we can support resource packs with higher-resolution textures\r\n                        uv = [\r\n                            Object(_functions__WEBPACK_IMPORTED_MODULE_4__[\"scaleUv\"])(uv[0], img.width),\r\n                            Object(_functions__WEBPACK_IMPORTED_MODULE_4__[\"scaleUv\"])(uv[1], img.height),\r\n                            Object(_functions__WEBPACK_IMPORTED_MODULE_4__[\"scaleUv\"])(uv[2], img.width),\r\n                            Object(_functions__WEBPACK_IMPORTED_MODULE_4__[\"scaleUv\"])(uv[3], img.height)\r\n                        ];\r\n\r\n\r\n                        let canvas = document.createElement(\"canvas\");\r\n                        canvas.width = Math.abs(uv[2] - uv[0]);\r\n                        canvas.height = Math.abs(uv[3] - uv[1]);\r\n\r\n                        let context = canvas.getContext(\"2d\");\r\n                        context.drawImage(img, Math.min(uv[0], uv[2]), Math.min(uv[1], uv[3]), canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);\r\n\r\n                        let tintColor;\r\n                        if (face.hasOwnProperty(\"tintindex\")) {\r\n                            tintColor = TINTS[face.tintindex];\r\n                        } else if (baseName.startsWith(\"water_\")) {\r\n                            tintColor = \"blue\";\r\n                        }\r\n\r\n                        if (tintColor) {\r\n                            context.fillStyle = tintColor;\r\n                            context.globalCompositeOperation = 'multiply';\r\n                            context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n                            context.globalAlpha = 1;\r\n                            context.globalCompositeOperation = 'destination-in';\r\n                            context.drawImage(img, Math.min(uv[0], uv[2]), Math.min(uv[1], uv[3]), canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);\r\n\r\n                            // context.globalAlpha = 0.5;\r\n                            // context.beginPath();\r\n                            // context.fillStyle = \"green\";\r\n                            // context.rect(0, 0, uv[2] - uv[0], uv[3] - uv[1]);\r\n                            // context.fill();\r\n                            // context.globalAlpha = 1.0;\r\n                        }\r\n\r\n                        let canvasData = context.getImageData(0, 0, canvas.width, canvas.height).data;\r\n                        let hasTransparency = false;\r\n                        for (let i = 3; i < (canvas.width * canvas.height); i += 4) {\r\n                            if (canvasData[i] < 255) {\r\n                                hasTransparency = true;\r\n                                break;\r\n                            }\r\n                        }\r\n\r\n                        let dataUrl = canvas.toDataURL(\"image/png\");\r\n                        let dataHash = md5__WEBPACK_IMPORTED_MODULE_6__(dataUrl);\r\n\r\n                        let d = {\r\n                            canvas: canvas,\r\n                            data: canvasData,\r\n                            dataUrl: dataUrl,\r\n                            dataUrlHash: dataHash,\r\n                            hasTransparency: hasTransparency,\r\n                            width: canvas.width,\r\n                            height: canvas.height\r\n                        };\r\n                        debug(\"Caching new canvas (\" + canvasKey + \"/\" + dataHash + \")\")\r\n                        canvasCache[canvasKey] = d;\r\n                        return d;\r\n                    };\r\n\r\n                    let loadTextureFromCanvas = (canvas) => {\r\n\r\n\r\n                        let loadTextureDefault = function (canvas) {\r\n                            let data = canvas.dataUrl;\r\n                            let hash = canvas.dataUrlHash;\r\n                            let hasTransparency = canvas.hasTransparency;\r\n\r\n                            if (materialCache.hasOwnProperty(hash)) {// Use material from cache\r\n                                debug(\"Using cached Material (\" + hash + \", without meta)\");\r\n                                resolve(materialCache[hash]);\r\n                                return;\r\n                            }\r\n\r\n                            let n = textureNames[textureRef];\r\n                            if (n.startsWith(\"#\")) {\r\n                                n = textureNames[name.substr(1)];\r\n                            }\r\n                            debug(\"Pre-Caching Material \" + hash + \", without meta\");\r\n                            materialCache[hash] = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\r\n                                map: null,\r\n                                transparent: hasTransparency,\r\n                                side: hasTransparency ? three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"] : three__WEBPACK_IMPORTED_MODULE_0__[\"FrontSide\"],\r\n                                alphaTest: 0.5,\r\n                                name: f + \"_\" + textureRef + \"_\" + n\r\n                            });\r\n\r\n                            let textureLoaded = function (texture) {\r\n                                // Add material to cache\r\n                                debug(\"Finalizing Cached Material \" + hash + \", without meta\");\r\n                                materialCache[hash].map = texture;\r\n                                materialCache[hash].needsUpdate = true;\r\n\r\n                                resolve(materialCache[hash]);\r\n                            };\r\n\r\n                            if (textureCache.hasOwnProperty(hash)) {// Use texture from cache\r\n                                debug(\"Using cached Texture (\" + hash + \")\");\r\n                                textureLoaded(textureCache[hash]);\r\n                                return;\r\n                            }\r\n\r\n                            debug(\"Pre-Caching Texture \" + hash);\r\n                            textureCache[hash] = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"]().load(data, function (texture) {\r\n                                texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                                texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                                texture.anisotropy = 0;\r\n                                texture.needsUpdate = true;\r\n\r\n                                if (face.hasOwnProperty(\"rotation\")) {\r\n                                    texture.center.x = .5;\r\n                                    texture.center.y = .5;\r\n                                    texture.rotation = Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"toRadians\"])(face.rotation);\r\n                                }\r\n\r\n                                debug(\"Caching Texture \" + hash);\r\n                                // Add texture to cache\r\n                                textureCache[hash] = texture;\r\n\r\n                                textureLoaded(texture);\r\n                            });\r\n                        };\r\n\r\n                        let loadTextureWithMeta = function (canvas, meta) {\r\n                            let hash = canvas.dataUrlHash;\r\n                            let hasTransparency = canvas.hasTransparency;\r\n\r\n                            if (materialCache.hasOwnProperty(hash)) {// Use material from cache\r\n                                debug(\"Using cached Material (\" + hash + \", with meta)\");\r\n                                resolve(materialCache[hash]);\r\n                                return;\r\n                            }\r\n\r\n                            debug(\"Pre-Caching Material \" + hash + \", with meta\");\r\n                            materialCache[hash] = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\r\n                                map: null,\r\n                                transparent: hasTransparency,\r\n                                side: hasTransparency ? three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"] : three__WEBPACK_IMPORTED_MODULE_0__[\"FrontSide\"],\r\n                                alphaTest: 0.5\r\n                            });\r\n\r\n                            let frametime = 1;\r\n                            if (meta.hasOwnProperty(\"animation\")) {\r\n                                if (meta.animation.hasOwnProperty(\"frametime\")) {\r\n                                    frametime = meta.animation.frametime;\r\n                                }\r\n                            }\r\n\r\n                            let parts = Math.floor(canvas.height / canvas.width);\r\n\r\n                            console.log(\"Generating animated texture...\");\r\n\r\n                            let promises1 = [];\r\n                            for (let i = 0; i < parts; i++) {\r\n                                promises1.push(new Promise((resolve) => {\r\n                                    let canvas1 = document.createElement(\"canvas\");\r\n                                    canvas1.width = canvas.width;\r\n                                    canvas1.height = canvas.width;\r\n                                    let context1 = canvas1.getContext(\"2d\");\r\n                                    context1.drawImage(canvas.canvas, 0, i * canvas.width, canvas.width, canvas.width, 0, 0, canvas.width, canvas.width);\r\n\r\n                                    let data = canvas1.toDataURL(\"image/png\");\r\n                                    let hash = md5__WEBPACK_IMPORTED_MODULE_6__(data);\r\n\r\n                                    if (textureCache.hasOwnProperty(hash)) {// Use texture to cache\r\n                                        debug(\"Using cached Texture (\" + hash + \")\");\r\n                                        resolve(textureCache[hash]);\r\n                                        return;\r\n                                    }\r\n\r\n                                    debug(\"Pre-Caching Texture \" + hash);\r\n                                    textureCache[hash] = new three__WEBPACK_IMPORTED_MODULE_0__[\"TextureLoader\"]().load(data, function (texture) {\r\n                                        texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                                        texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                                        texture.anisotropy = 0;\r\n                                        texture.needsUpdate = true;\r\n\r\n                                        debug(\"Caching Texture \" + hash + \", without meta\");\r\n                                        // add texture to cache\r\n                                        textureCache[hash] = texture;\r\n\r\n                                        resolve(texture);\r\n                                    });\r\n                                }));\r\n                            }\r\n\r\n                            Promise.all(promises1).then((textures) => {\r\n\r\n                                let frameCounter = 0;\r\n                                let textureIndex = 0;\r\n                                animatedTextures.push(() => {// called on render\r\n                                    if (frameCounter >= frametime) {\r\n                                        frameCounter = 0;\r\n\r\n                                        // Set new texture\r\n                                        materialCache[hash].map = textures[textureIndex];\r\n\r\n                                        textureIndex++;\r\n                                    }\r\n                                    if (textureIndex >= textures.length) {\r\n                                        textureIndex = 0;\r\n                                    }\r\n                                    frameCounter += 0.1;// game ticks TODO: figure out the proper value for this\r\n                                })\r\n\r\n                                // Add material to cache\r\n                                debug(\"Finalizing Cached Material \" + hash + \", with meta\");\r\n                                materialCache[hash].map = textures[0];\r\n                                materialCache[hash].needsUpdate = true;\r\n\r\n                                resolve(materialCache[hash]);\r\n                            });\r\n                        };\r\n\r\n                        if ((canvas.height > canvas.width) && (canvas.height % canvas.width === 0)) {// Taking a guess that this is an animated texture\r\n                            let name = textureNames[textureRef];\r\n                            if (name.startsWith(\"#\")) {\r\n                                name = textureNames[name.substring(1)];\r\n                            }\r\n                            if (name.indexOf(\"/\") !== -1) {\r\n                                name = name.substring(name.indexOf(\"/\") + 1);\r\n                            }\r\n                            Object(_functions__WEBPACK_IMPORTED_MODULE_4__[\"loadTextureMeta\"])(name, assetRoot).then((meta) => {\r\n                                loadTextureWithMeta(canvas, meta);\r\n                            }).catch(() => {// Guessed wrong :shrug:\r\n                                loadTextureDefault(canvas);\r\n                            })\r\n                        } else {\r\n                            loadTextureDefault(canvas);\r\n                        }\r\n                    };\r\n\r\n\r\n                    if (canvasCache.hasOwnProperty(canvasKey)) {\r\n                        let cachedCanvas = canvasCache[canvasKey];\r\n\r\n                        if (cachedCanvas.hasOwnProperty(\"img\")) {\r\n                            debug(\"Waiting for canvas image that's already loading (\" + canvasKey + \")\")\r\n                            let img = cachedCanvas.img;\r\n                            img.waitingForCanvas.push(function (canvas) {\r\n                                loadTextureFromCanvas(canvas);\r\n                            });\r\n                        } else {\r\n                            debug(\"Using cached canvas (\" + canvasKey + \")\")\r\n                            loadTextureFromCanvas(canvasCache[canvasKey]);\r\n                        }\r\n                    } else {\r\n                        let img = new Image();\r\n                        img.onerror = function (err) {\r\n                            console.warn(err);\r\n                            resolve(null);\r\n                        };\r\n                        img.waitingForCanvas = [];\r\n                        img.onload = function () {\r\n                            let canvasData = processImgToCanvasData(img);\r\n                            loadTextureFromCanvas(canvasData);\r\n\r\n                            for (let c = 0; c < img.waitingForCanvas.length; c++) {\r\n                                img.waitingForCanvas[c](canvasData);\r\n                            }\r\n                        };\r\n                        debug(\"Pre-caching canvas (\" + canvasKey + \")\");\r\n                        canvasCache[canvasKey] = {\r\n                            img: img\r\n                        };\r\n                        img.src = textures[textureRef];\r\n                    }\r\n                }));\r\n            }\r\n            Promise.all(promises).then(materials => materialsLoaded(materials))\r\n        } else {\r\n            let materials = [];\r\n            for (let i = 0; i < 6; i++) {\r\n                materials.push(new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\r\n                    color: colors[i + 2],\r\n                    wireframe: true\r\n                }))\r\n            }\r\n            materialsLoaded(materials);\r\n        }\r\n\r\n        // if (textures) {\r\n        //     applyCubeTextureToGeometry(geometry, texture, uv, width, height, depth);\r\n        // }\r\n\r\n\r\n    })\r\n};\r\n\r\n/// https://stackoverflow.com/questions/42812861/three-js-pivot-point/42866733#42866733\r\n// obj - your object (THREE.Object3D or derived)\r\n// point - the point of rotation (THREE.Vector3)\r\n// axis - the axis of rotation (normalized THREE.Vector3)\r\n// theta - radian value of rotation\r\nfunction rotateAboutPoint(obj, point, axis, theta) {\r\n    obj.position.sub(point); // remove the offset\r\n    obj.position.applyAxisAngle(axis, theta); // rotate the POSITION\r\n    obj.position.add(point); // re-add the offset\r\n\r\n    obj.rotateOnAxis(axis, theta); // rotate the OBJECT\r\n}\r\n\r\nModelRender.cache = {\r\n    loadedTextures: loadedTextureCache,\r\n    mergedModels: mergedModelCache,\r\n    instanceCount: modelInstances,\r\n\r\n    texture: textureCache,\r\n    canvas: canvasCache,\r\n    material: materialCache,\r\n    geometry: geometryCache,\r\n    instances: instanceCache,\r\n\r\n    animated: animatedTextures,\r\n\r\n\r\n    resetInstances: function () {\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(modelInstances);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(instanceCache);\r\n    },\r\n    clearAll: function () {\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(loadedTextureCache);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(mergedModelCache);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(modelInstances);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(textureCache);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(canvasCache);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(materialCache);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(geometryCache);\r\n        Object(_modelFunctions__WEBPACK_IMPORTED_MODULE_7__[\"deleteObjectProperties\"])(instanceCache);\r\n        animatedTextures.splice(0, animatedTextures.length);\r\n    }\r\n};\r\nModelRender.ModelConverter = _modelConverter__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\r\n\r\nif (typeof window !== \"undefined\") {\r\n    window.ModelRender = ModelRender;\r\n    window.ModelConverter = _modelConverter__WEBPACK_IMPORTED_MODULE_5__[\"default\"];\r\n}\r\nif (typeof global !== \"undefined\")\r\n    global.ModelRender = ModelRender;\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ModelRender);\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/model/index.js?");

/***/ }),

/***/ "./src/model/modelConverter.js":
/*!*************************************!*\
  !*** ./src/model/modelConverter.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"./node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prismarine_nbt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prismarine-nbt */ \"./node_modules/prismarine-nbt/nbt.js\");\n/* harmony import */ var prismarine_nbt__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prismarine_nbt__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _skin_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../skin/index */ \"./src/skin/index.js\");\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../functions */ \"./src/functions.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Helper to convert multi-block structures to models used by {@link ModelRender}\r\n * @constructor\r\n */\r\nfunction ModelConverter() {\r\n}\r\n\r\n/**\r\n * Converts a {@link https://minecraft.gamepedia.com/Structure_block_file_format|Minecraft structure file} to models\r\n * @param {object} structure structure file info\r\n * @param {string} structure.url URL to a structure file\r\n * @param {(Blob|File)} structure.file uploaded file\r\n * @param {(Uint8Array|ArrayBuffer)} structure.raw Raw NBT data\r\n * @param cb\r\n */\r\nModelConverter.prototype.structureToModels = function (structure, cb) {\r\n    loadNBT(structure).then((rawNbt) => {\r\n        prismarine_nbt__WEBPACK_IMPORTED_MODULE_1__[\"parse\"](rawNbt, (err, data) => {\r\n            if (err) {\r\n                console.warn(\"Error while parsing NBT data\");\r\n                console.warn(err);\r\n                return;\r\n            }\r\n\r\n            if (true) {\r\n                console.log(\"NBT Data:\")\r\n                console.log(data);\r\n            }\r\n\r\n            parseStructureData(data).then((data) => {\r\n                cb(data);\r\n            })\r\n        })\r\n    })\r\n};\r\n\r\n\r\n/**\r\n * Converts a Minecraft schematic file to models\r\n * @param {object} schematic structure file info\r\n * @param {string} schematic.url URL to a structure file\r\n * @param {(Blob|File)} schematic.file uploaded file\r\n * @param {(Uint8Array|ArrayBuffer)} schematic.raw Raw NBT data\r\n * @param cb\r\n */\r\nModelConverter.prototype.schematicToModels = function (schematic, cb) {\r\n    loadNBT(schematic).then(rawNbt => {\r\n        prismarine_nbt__WEBPACK_IMPORTED_MODULE_1__[\"parse\"](rawNbt, (err, data) => {\r\n            if (err) {\r\n                console.warn(\"Error while parsing NBT data\");\r\n                console.warn(err);\r\n                return;\r\n            }\r\n\r\n            if (true) {\r\n                console.log(\"NBT Data:\")\r\n                console.log(data);\r\n            }\r\n\r\n            let xhr = new XMLHttpRequest();\r\n            xhr.open('GET', \"https://minerender.org/res/idsToNames.json\", true);\r\n            xhr.onloadend = function () {\r\n                if (xhr.status === 200) {\r\n                    console.log(xhr.response || xhr.responseText);\r\n\r\n                    let idsToNames = JSON.parse(xhr.response || xhr.responseText);\r\n                    parseSchematicData(data, idsToNames).then(data => cb(data));\r\n                }\r\n            };\r\n            xhr.send();\r\n\r\n        })\r\n    })\r\n};\r\n\r\n\r\nfunction loadNBT(source) {\r\n    return new Promise((resolve, reject) => {\r\n        if (source.file) {\r\n            let reader = new FileReader();\r\n            reader.onload = function () {\r\n                let arrayBuffer = this.result;\r\n                let array = new Uint8Array(arrayBuffer);\r\n\r\n                resolve(array);\r\n            }\r\n            reader.readAsArrayBuffer(source.file);\r\n        } else if (source.url) {\r\n            let xhr = new XMLHttpRequest();\r\n            xhr.open('GET', source.url, true);\r\n            xhr.responseType = 'arraybuffer';\r\n            xhr.onloadend = function () {\r\n                if (xhr.status === 200) {\r\n                    let array = new Uint8Array(xhr.response || xhr.responseText);\r\n\r\n                    resolve(array);\r\n                }\r\n            };\r\n            xhr.send();\r\n        } else if (source.raw) {\r\n            if (source.raw instanceof Uint8Array) {\r\n                resolve(source.raw)\r\n            } else {\r\n                resolve(new Uint8Array(source.raw));\r\n            }\r\n        } else {\r\n            reject();\r\n        }\r\n    })\r\n}\r\n\r\nModelConverter.loadNBT = loadNBT;\r\n\r\nfunction parseStructureData(data, paletteIndex) {\r\n    return new Promise((resolve, reject) => {\r\n        if (data.type === \"compound\") {\r\n            if (data.value.hasOwnProperty(\"blocks\") && (data.value.hasOwnProperty(\"palette\") || data.value.hasOwnProperty(\"palettes\"))) {\r\n                let originalPalette;\r\n                if (data.value.hasOwnProperty(\"palette\")) {\r\n                    originalPalette = data.value[\"palette\"].value.value;\r\n                } else {\r\n                    if (typeof paletteIndex === \"undefined\") paletteIndex = 0;\r\n                    if (paletteIndex >= data.value[\"palettes\"].value.value.length || !data.value[\"palettes\"].value.value[paletteIndex]) {\r\n                        console.warn(\"Specified palette index (\" + paletteIndex + \") is outside of available palettes (\" + data.value[\"palettes\"].value.value.length + \")\")\r\n                        return;\r\n                    }\r\n                    originalPalette = data.value[\"palettes\"].value.value[paletteIndex].value;\r\n                }\r\n\r\n\r\n                // Simplify palette\r\n                let palette = [];\r\n                for (let i = 0; i < originalPalette.length; i++) {\r\n                    palette.push(originalPalette[i]);\r\n                }\r\n\r\n                let arr = [];\r\n\r\n                // Iterate blocks\r\n                let blocks = data.value.blocks.value.value;\r\n                for (let i = 0; i < blocks.length; i++) {\r\n                    let blockType = palette[blocks[i].state.value].Name.value;\r\n                    if (blockType === \"minecraft:air\") {\r\n                        // No need to add air\r\n                        continue;\r\n                    }\r\n                    let shortBlockType = blockType.substr(\"minecraft:\".length);\r\n\r\n                    let pos = blocks[i].pos.value.value;\r\n\r\n                    let multipartConditions = {};\r\n\r\n                    let variantString = \"\";\r\n                    if (palette[blocks[i].state.value].hasOwnProperty(\"Properties\")) {\r\n                        let strs = [];\r\n                        for (let p in palette[blocks[i].state.value].Properties.value) {\r\n                            if (palette[blocks[i].state.value].Properties.value.hasOwnProperty(p)) {\r\n                                let prop = palette[blocks[i].state.value].Properties.value[p];\r\n\r\n                                strs.push(p + \"=\" + prop.value);\r\n\r\n                                multipartConditions[p] = prop.value;\r\n                            }\r\n                        }\r\n\r\n                        // Make sure the variants are sorted properly, or it won't match the game files\r\n                        strs.sort();\r\n\r\n                        for (let i = 0; i < strs.length; i++) {\r\n                            variantString += \",\" + strs[i];\r\n                        }\r\n\r\n                        variantString = variantString.substr(1);\r\n                    }\r\n\r\n                    if (specialVariants.hasOwnProperty(shortBlockType)) {\r\n                        shortBlockType = specialVariants[shortBlockType](palette[blocks[i].state.value].Properties.value);\r\n                        variantString = \"\";\r\n                    }\r\n\r\n                    let block = {\r\n                        blockstate: shortBlockType,\r\n                        variant: variantString,\r\n                        multipart: multipartConditions,\r\n                        offset: [pos[0] * 16, pos[1] * 16, pos[2] * 16]\r\n                    };\r\n                    arr.push(block)\r\n                }\r\n\r\n                resolve(arr);\r\n            } else {\r\n                console.warn(\"Invalid NBT - Missing blocks/palette(s)\");\r\n                reject();\r\n            }\r\n        } else {\r\n            console.warn(\"Invalid NBT - Root tag should be compound\");\r\n            reject();\r\n        }\r\n    })\r\n}\r\n\r\nModelConverter.parseStructureData = parseStructureData;\r\n\r\nfunction parseSchematicData(data, idToNameMap) {\r\n    return new Promise((resolve, reject) => {\r\n        let width = data.value.Width.value;\r\n        let height = data.value.Height.value;\r\n        let length = data.value.Length.value;\r\n\r\n        let infoAt = function (x, y, z) {\r\n            let index = (y * length + z) * width + x;\r\n            let id = (data.value.Blocks.value[index] || 0) & 0xff;\r\n            if (data.value.AddBlocks && ((index >> 1) < data.value.AddBlocks.value.length)) { // in AddBlocks\r\n                if ((index & 1) === 0) {\r\n                    id = ((data.value.AddBlocks.value[index >> 1] & 0x0f) << 8) + id;\r\n                } else {\r\n                    id = ((data.value.AddBlocks.value[index >> 1] & 0xf0) << 4) + id;\r\n                }\r\n            }\r\n            let d = (data.value.Data.value[index] || 0);\r\n            return {\r\n                id: id,\r\n                data: d\r\n            }\r\n        };\r\n\r\n        let convertLegacy = function (id, data) {\r\n            let mapped = idToNameMap.blocks[id + \":\" + data];\r\n            if (!mapped) {\r\n                // try to bypass data\r\n                mapped = idToNameMap.blocks[id + \":\" + 0];\r\n            }\r\n            if (!mapped) {\r\n                console.warn(\"Missing legacy mapping for \" + id + \":\" + data);\r\n                return \"minecraft:air\";\r\n            }\r\n            return mapped;\r\n        };\r\n\r\n        let arr = [];\r\n\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                for (let z = 0; z < length; z++) {\r\n                    let info = infoAt(x, y, z);\r\n                    if (info.id === 0 && info.data === 0) continue;\r\n                    let convertedInfo = convertLegacy(info.id, info.data);\r\n\r\n                    let infoSplit = convertedInfo.replace(\"minecraft:\", \"\").replace(\"]\", \"\").split(\"[\");\r\n                    let shortName = infoSplit[0];\r\n                    let variantString = infoSplit[1] || \"\";\r\n\r\n                    if (shortName === \"air\") continue;\r\n\r\n                    if (variantString !== \"\") {\r\n                        variantString = variantString.split(\",\").sort().join(\",\");\r\n                    }\r\n\r\n                    arr.push({\r\n                        blockstate: shortName,\r\n                        variant: variantString,\r\n                        offset: [x * 16, y * 16, z * 16]\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        resolve(arr);\r\n    })\r\n}\r\n\r\nModelConverter.parseSchematicData = parseSchematicData;\r\n\r\nlet specialVariants = {\r\n    \"stained_glass\": function (properties) {\r\n        return properties.color.value + \"_stained_glass\";\r\n    },\r\n    \"planks\": function (properties) {\r\n        return properties.variant.value + \"_planks\";\r\n    }\r\n};\r\n\r\n\r\nModelConverter.prototype.constructor = ModelConverter;\r\n\r\nwindow.ModelConverter = ModelConverter;\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (ModelConverter);\r\n\n\n//# sourceURL=webpack:///./src/model/modelConverter.js?");

/***/ }),

/***/ "./src/model/modelFunctions.js":
/*!*************************************!*\
  !*** ./src/model/modelFunctions.js ***!
  \*************************************/
/*! exports provided: parseModel, loadAndMergeModel, modelCacheKey, findMatchingVariant, variantStringToObject, parseModelType, loadModel, loadTextures, mergeParents, toRadians, deleteObjectProperties */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseModel\", function() { return parseModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadAndMergeModel\", function() { return loadAndMergeModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modelCacheKey\", function() { return modelCacheKey; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"findMatchingVariant\", function() { return findMatchingVariant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"variantStringToObject\", function() { return variantStringToObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseModelType\", function() { return parseModelType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadModel\", function() { return loadModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadTextures\", function() { return loadTextures; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeParents\", function() { return mergeParents; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRadians\", function() { return toRadians; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deleteObjectProperties\", function() { return deleteObjectProperties; });\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../functions */ \"./src/functions.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"./node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_2__);\n\r\n\r\n\r\n\r\n\r\nconst debug = debug__WEBPACK_IMPORTED_MODULE_2__(\"minerender\");\r\n\r\nfunction parseModel(model, modelOptions, parsedModelList, assetRoot) {\r\n    return new Promise(resolve => {\r\n        let type = \"block\";\r\n        let offset;\r\n        let rotation;\r\n        let scale;\r\n\r\n        if (typeof model === \"string\") {\r\n            let parsed = parseModelType(model);\r\n            model = parsed.model;\r\n            type = parsed.type;\r\n\r\n            parsedModelList.push({\r\n                name: model,\r\n                type: type,\r\n                options: modelOptions\r\n            });\r\n            resolve(parsedModelList);\r\n        } else if (typeof model === \"object\") {\r\n            if (model.hasOwnProperty(\"offset\")) {\r\n                offset = model[\"offset\"];\r\n            }\r\n            if (model.hasOwnProperty(\"rotation\")) {\r\n                rotation = model[\"rotation\"];\r\n            }\r\n            if (model.hasOwnProperty(\"scale\")) {\r\n                scale = model[\"scale\"];\r\n            }\r\n\r\n            if (model.hasOwnProperty(\"model\")) {\r\n                if (model.hasOwnProperty(\"type\")) {\r\n                    type = model[\"type\"];\r\n                    model = model[\"model\"];\r\n                } else {\r\n                    let parsed = parseModelType(model[\"model\"]);\r\n                    model = parsed.model;\r\n                    type = parsed.type;\r\n                }\r\n\r\n                parsedModelList.push({\r\n                    name: model,\r\n                    type: type,\r\n                    offset: offset,\r\n                    rotation: rotation,\r\n                    scale: scale,\r\n                    options: modelOptions\r\n                });\r\n                resolve(parsedModelList);\r\n            } else if (model.hasOwnProperty(\"blockstate\")) {\r\n                type = \"block\";\r\n\r\n                Object(_functions__WEBPACK_IMPORTED_MODULE_0__[\"loadBlockState\"])(model.blockstate, assetRoot).then((blockstate) => {\r\n                    if (blockstate.hasOwnProperty(\"variants\")) {\r\n\r\n                        if (model.hasOwnProperty(\"variant\")) {\r\n                            let variantKey = findMatchingVariant(blockstate.variants, model.variant);\r\n                            if (variantKey === null) {\r\n                                console.warn(`Missing variant key for ${model.blockstate}: \"${model.variant}\"`);\r\n                                console.warn(blockstate.variants);\r\n                                resolve(null);\r\n                                return;\r\n                            }\r\n                            let variant = blockstate.variants[variantKey];\r\n                            if (!variant) {\r\n                                console.warn(`Missing variant for ${model.blockstate}: \"${model.variant}\"`);\r\n                                variant = blockstate.variants[Object.keys(blockstate.variants)[0]];\r\n                            }\r\n\r\n                            let variants = [];\r\n                            if (!Array.isArray(variant)) {\r\n                                variants = [variant];\r\n                            } else {\r\n                                variants = variant;\r\n                            }\r\n\r\n                            rotation = [0, 0, 0];\r\n\r\n                            let v = variants[Math.floor(Math.random() * variants.length)];\r\n                            if (variant.hasOwnProperty(\"x\")) {\r\n                                rotation[0] = v.x;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"y\")) {\r\n                                rotation[1] = v.y;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                rotation[2] = v.z;\r\n                            }\r\n                            let parsed = parseModelType(v.model);\r\n                            parsedModelList.push({\r\n                                name: parsed.model,\r\n                                type: \"block\",\r\n                                variant: model.variant,\r\n                                offset: offset,\r\n                                rotation: rotation,\r\n                                scale: scale,\r\n                                options: modelOptions\r\n                            });\r\n                            resolve(parsedModelList);\r\n                        } else {\r\n                            let variant;\r\n                            if (blockstate.variants.hasOwnProperty(\"normal\")) {\r\n                                variant = blockstate.variants.normal;\r\n                            } else if (blockstate.variants.hasOwnProperty(\"\")) {\r\n                                variant = blockstate.variants[\"\"];\r\n                            } else {\r\n                                variant = blockstate.variants[Object.keys(blockstate.variants)[0]]\r\n                            }\r\n\r\n                            let variants = [];\r\n                            if (!Array.isArray(variant)) {\r\n                                variants = [variant];\r\n                            } else {\r\n                                variants = variant;\r\n                            }\r\n\r\n                            rotation = [0, 0, 0];\r\n\r\n                            let v = variants[Math.floor(Math.random() * variants.length)];\r\n                            if (variant.hasOwnProperty(\"x\")) {\r\n                                rotation[0] = v.x;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"y\")) {\r\n                                rotation[1] = v.y;\r\n                            }\r\n                            if (variant.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                rotation[2] = v.z;\r\n                            }\r\n                            let parsed = parseModelType(v.model);\r\n                            parsedModelList.push({\r\n                                name: parsed.model,\r\n                                type: \"block\",\r\n                                variant: model.variant,\r\n                                offset: offset,\r\n                                rotation: rotation,\r\n                                scale: scale,\r\n                                options: modelOptions\r\n                            })\r\n                            resolve(parsedModelList);\r\n                        }\r\n                    } else if (blockstate.hasOwnProperty(\"multipart\")) {\r\n                        for (let j = 0; j < blockstate.multipart.length; j++) {\r\n                            let cond = blockstate.multipart[j];\r\n                            let apply = cond.apply;\r\n                            let when = cond.when;\r\n\r\n                            rotation = [0, 0, 0];\r\n\r\n                            if (!when) {\r\n                                if (apply.hasOwnProperty(\"x\")) {\r\n                                    rotation[0] = apply.x;\r\n                                }\r\n                                if (apply.hasOwnProperty(\"y\")) {\r\n                                    rotation[1] = apply.y;\r\n                                }\r\n                                if (apply.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                    rotation[2] = apply.z;\r\n                                }\r\n                                let parsed = parseModelType(apply.model);\r\n                                parsedModelList.push({\r\n                                    name: parsed.model,\r\n                                    type: \"block\",\r\n                                    offset: offset,\r\n                                    rotation: rotation,\r\n                                    scale: scale,\r\n                                    options: modelOptions\r\n                                });\r\n                            } else if (model.hasOwnProperty(\"multipart\")) {\r\n                                let multipartConditions = model.multipart;\r\n\r\n                                let applies = false;\r\n                                if (when.hasOwnProperty(\"OR\")) {\r\n                                    for (let k = 0; k < when.OR.length; k++) {\r\n                                        if (applies) break;\r\n                                        for (let c in when.OR[k]) {\r\n                                            if (applies) break;\r\n                                            if (when.OR[k].hasOwnProperty(c)) {\r\n                                                let expected = when.OR[k][c];\r\n                                                let expectedArray = expected.split(\"|\");\r\n\r\n                                                let given = multipartConditions[c];\r\n                                                for (let k = 0; k < expectedArray.length; k++) {\r\n                                                    if (expectedArray[k] === given) {\r\n                                                        applies = true;\r\n                                                        break;\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    for (let c in when) {// this SHOULD be a single case, but iterating makes it a bit easier\r\n                                        if (applies) break;\r\n                                        if (when.hasOwnProperty(c)) {\r\n                                            let expected = String(when[c]);\r\n                                            let expectedArray = expected.split(\"|\");\r\n\r\n                                            let given = multipartConditions[c];\r\n                                            for (let k = 0; k < expectedArray.length; k++) {\r\n                                                if (expectedArray[k] === given) {\r\n                                                    applies = true;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (applies) {\r\n                                    if (apply.hasOwnProperty(\"x\")) {\r\n                                        rotation[0] = apply.x;\r\n                                    }\r\n                                    if (apply.hasOwnProperty(\"y\")) {\r\n                                        rotation[1] = apply.y;\r\n                                    }\r\n                                    if (apply.hasOwnProperty(\"z\")) {// Not actually used by MC, but why not?\r\n                                        rotation[2] = apply.z;\r\n                                    }\r\n                                    let parsed = parseModelType(apply.model);\r\n                                    parsedModelList.push({\r\n                                        name: parsed.model,\r\n                                        type: \"block\",\r\n                                        offset: offset,\r\n                                        rotation: rotation,\r\n                                        scale: scale,\r\n                                        options: modelOptions\r\n                                    })\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        resolve(parsedModelList);\r\n                    }\r\n                }).catch(() => {\r\n                    resolve(parsedModelList);\r\n                })\r\n            }\r\n\r\n        }\r\n    })\r\n}\r\n\r\nfunction loadAndMergeModel(model, assetRoot) {\r\n    return loadModel(model.name, model.type, assetRoot)\r\n        .then(modelData => mergeParents(modelData, model.name, assetRoot))\r\n        .then(merged => {\r\n            debug(model.name + \" merged:\");\r\n            debug(merged);\r\n            if (!merged.hasOwnProperty(\"elements\")) {\r\n                if (model.name === \"lava\" || model.name === \"water\") {\r\n                    merged.elements = [\r\n                        {\r\n                            \"from\": [0, 0, 0],\r\n                            \"to\": [16, 16, 16],\r\n                            \"faces\": {\r\n                                \"down\": {\"texture\": \"#particle\", \"cullface\": \"down\"},\r\n                                \"up\": {\"texture\": \"#particle\", \"cullface\": \"up\"},\r\n                                \"north\": {\"texture\": \"#particle\", \"cullface\": \"north\"},\r\n                                \"south\": {\"texture\": \"#particle\", \"cullface\": \"south\"},\r\n                                \"west\": {\"texture\": \"#particle\", \"cullface\": \"west\"},\r\n                                \"east\": {\"texture\": \"#particle\", \"cullface\": \"east\"}\r\n                            }\r\n                        }\r\n                    ]\r\n                }\r\n            }\r\n            return merged;\r\n        })\r\n}\r\n\r\n\r\n// Utils\r\n\r\nfunction modelCacheKey(model) {\r\n    return model.type + \"__\" + model.name /*+ \"[\" + (model.variant || \"default\") + \"]\"*/;\r\n}\r\n\r\nfunction findMatchingVariant(variants, selector) {\r\n    if (!Array.isArray(variants)) variants = Object.keys(variants);\r\n\r\n    if (!selector || selector === \"\" || selector.length === 0) return \"\";\r\n    let selectorObj = variantStringToObject(selector);\r\n    for (let i = 0; i < variants.length; i++) {\r\n        let variantObj = variantStringToObject(variants[i]);\r\n\r\n        let matches = true;\r\n        for (let k in selectorObj) {\r\n            if (selectorObj.hasOwnProperty(k)) {\r\n                if (variantObj.hasOwnProperty(k)) {\r\n                    if (selectorObj[k] !== variantObj[k]) {\r\n                        matches = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (matches) return variants[i];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nfunction variantStringToObject(str) {\r\n    let split = str.split(\",\");\r\n    let obj = {};\r\n    for (let i = 0; i < split.length; i++) {\r\n        let spl = split[i];\r\n        let split1 = spl.split(\"=\");\r\n        obj[split1[0]] = split1[1];\r\n    }\r\n    return obj;\r\n}\r\n\r\nfunction parseModelType(string) {\r\n    if (string.startsWith(\"minecraft:\")) {\r\n        string = string.substring(\"minecraft:\".length);\r\n    }\r\n    if (string.startsWith(\"block/\")) {\r\n        // if (type === \"item\") {\r\n        //     throw new Error(\"Tried to mix block/item models\");\r\n        // }\r\n        return {\r\n            type: \"block\",\r\n            model: string.substring(\"block/\".length)\r\n        };\r\n    } else if (string.startsWith(\"item/\")) {\r\n        // if (type === \"block\") {\r\n        //     throw new Error(\"Tried to mix item/block models\");\r\n        // }\r\n        return {\r\n            type: \"item\",\r\n            model: string.substring(\"item/\".length)\r\n        };\r\n    }\r\n    return {\r\n        type: \"block\",\r\n        model: \"string\"\r\n    }\r\n}\r\n\r\nfunction loadModel(model, type/* block OR item */, assetRoot) {\r\n    return new Promise((resolve, reject) => {\r\n        if (typeof model === \"string\") {\r\n            if (model.startsWith(\"minecraft:\")) {\r\n                model = model.substring(\"minecraft:\".length);\r\n            }\r\n            if (model.startsWith(\"{\") && model.endsWith(\"}\")) {// JSON string\r\n                resolve(JSON.parse(model));\r\n            } else if (model.startsWith(\"http\")) {// URL\r\n                fetch(model, {\r\n                    mode: \"cors\",\r\n                    redirect: \"follow\"\r\n                })\r\n                    .then(response => response.json())\r\n                    .then(data => {\r\n                        console.log(\"model data:\", data);\r\n                        resolve(data);\r\n                    })\r\n                    .catch(err => {\r\n                        console.warn(\"Failed to load model data from \" + model);\r\n                        console.warn(err);\r\n                        resolve({});\r\n                    });\r\n            } else {// model name -> use local data\r\n                Object(_functions__WEBPACK_IMPORTED_MODULE_0__[\"loadJsonFromPath\"])(assetRoot, \"/assets/minecraft/models/\" + (type || \"block\") + \"/\" + model + \".json\").then((data) => {\r\n                    resolve(data);\r\n                }).catch(err => {\r\n                    console.warn(\"Failed to load model data for \" + model);\r\n                    console.warn(err);\r\n                    resolve({});\r\n                });\r\n            }\r\n        } else if (typeof model === \"object\") {// JSON object\r\n            resolve(model);\r\n        } else {\r\n            console.warn(\"Invalid model\");\r\n            reject();\r\n        }\r\n    });\r\n};\r\n\r\nfunction loadTextures(textureNames, assetRoot) {\r\n    return new Promise((resolve) => {\r\n        let promises = [];\r\n        let filteredNames = [];\r\n\r\n        let names = Object.keys(textureNames);\r\n        for (let i = 0; i < names.length; i++) {\r\n            let name = names[i];\r\n            let texture = textureNames[name];\r\n            if (texture.startsWith(\"#\")) {// reference to another texture, no need to load\r\n                continue;\r\n            }\r\n            filteredNames.push(name);\r\n            promises.push(Object(_functions__WEBPACK_IMPORTED_MODULE_0__[\"loadTextureAsBase64\"])(assetRoot, \"minecraft\", \"/\", texture).catch(err => {\r\n                console.warn(\"Failed to load texture \" + texture);\r\n                console.warn(err);\r\n                return undefined;\r\n            }));\r\n        }\r\n        Promise.all(promises).then((textures) => {\r\n            let mappedTextures = {};\r\n            for (let i = 0; i < textures.length; i++) {\r\n                if (!textures[i]) continue;\r\n                mappedTextures[filteredNames[i]] = textures[i];\r\n            }\r\n\r\n            // Fill in the referenced textures\r\n            for (let i = 0; i < names.length; i++) {\r\n                let name = names[i];\r\n                if (!mappedTextures.hasOwnProperty(name) && textureNames.hasOwnProperty(name)) {\r\n                    let ref = textureNames[name].substr(1);\r\n                    mappedTextures[name] = mappedTextures[ref];\r\n                }\r\n            }\r\n\r\n            resolve(mappedTextures);\r\n        });\r\n    })\r\n};\r\n\r\n\r\nfunction mergeParents(model, modelName, assetRoot) {\r\n    return new Promise((resolve, reject) => {\r\n        mergeParents_(model, modelName, [], [], assetRoot, resolve, reject);\r\n    });\r\n};\r\nlet mergeParents_ = function (model, name, stack, hierarchy, assetRoot, resolve, reject) {\r\n    stack.push(model);\r\n\r\n    if (!model.hasOwnProperty(\"parent\") || model[\"parent\"] === \"builtin/generated\" || model[\"parent\"] === \"builtin/entity\") {// already at the highest parent OR we reach the builtin parent which seems to be the hardcoded stuff that's not in the json files\r\n        let merged = {};\r\n        for (let i = stack.length - 1; i >= 0; i--) {\r\n            merged = deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(merged, stack[i]);\r\n        }\r\n\r\n        hierarchy.unshift(name);\r\n        merged.hierarchy = hierarchy;\r\n        resolve(merged);\r\n        return;\r\n    }\r\n\r\n    let parent = model[\"parent\"];\r\n    delete model[\"parent\"];// remove the child's parent so it will be replaced by the parent's parent\r\n    hierarchy.push(parent);\r\n\r\n    if (parent.startsWith(\"minecraft:\")) {\r\n        parent = parent.substring(\"minecraft:\".length);\r\n    }\r\n    Object(_functions__WEBPACK_IMPORTED_MODULE_0__[\"loadJsonFromPath\"])(assetRoot, \"/assets/minecraft/models/\" + parent + \".json\").then((parentData) => {\r\n        let mergedModel = Object.assign({}, model, parentData);\r\n        mergeParents_(mergedModel, name, stack, hierarchy, assetRoot, resolve, reject);\r\n    }).catch(reason => {\r\n        console.warn(\"Failed to load parent model \" + parent);\r\n        reject(reason);\r\n    });\r\n\r\n};\r\n\r\nfunction toRadians(angle) {\r\n    return angle * (Math.PI / 180);\r\n}\r\n\r\nfunction deleteObjectProperties(obj) {\r\n    Object.keys(obj).forEach(function (key) {\r\n        delete obj[key];\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./src/model/modelFunctions.js?");

/***/ }),

/***/ "./src/renderBase.js":
/*!***************************!*\
  !*** ./src/renderBase.js ***!
  \***************************/
/*! exports provided: defaultOptions, default, deepDisposeMesh, mergeMeshes__, mergeCubeMeshes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultOptions\", function() { return defaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deepDisposeMesh\", function() { return deepDisposeMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeMeshes__\", function() { return mergeMeshes__; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeCubeMeshes\", function() { return mergeCubeMeshes; });\n/* harmony import */ var _lib_OrbitControls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/OrbitControls */ \"./src/lib/OrbitControls.js\");\n/* harmony import */ var threejs_ext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! threejs-ext */ \"./node_modules/threejs-ext/dist/index.js\");\n/* harmony import */ var threejs_ext__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(threejs_ext__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @johh/three-effectcomposer */ \"./node_modules/@johh/three-effectcomposer/dist/index.js\");\n/* harmony import */ var _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var onscreen__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! onscreen */ \"./node_modules/onscreen/dist/on-screen.umd.js\");\n/* harmony import */ var onscreen__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(onscreen__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var stats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stats.js */ \"./node_modules/stats.js/build/stats.min.js\");\n/* harmony import */ var stats_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(stats_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./functions */ \"./src/functions.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @property {boolean} showAxes                 Debugging - Show the scene's axes\r\n * @property {boolean} showOutlines             Debugging - Show bounding boxes\r\n * @property {boolean} showGrid                 Debugging - Show coordinate grid\r\n *\r\n * @property {object} controls                  Controls settings\r\n * @property {boolean} [controls.enabled=true]  Toggle controls\r\n * @property {boolean} [controls.zoom=true]     Toggle zoom\r\n * @property {boolean} [controls.rotate=true]   Toggle rotation\r\n * @property {boolean} [controls.pan=true]      Toggle panning\r\n *\r\n * @property {object} camera                    Camera settings\r\n * @property {string} [camera.type=perspective] Camera type\r\n * @property {number} camera.x                  Camera X-position\r\n * @property {number} camera.y                  Camera Y-Position\r\n * @property {number} camera.z                  Camera Z-Position\r\n * @property {number[]} camera.target           [x,y,z] array where the camera should look\r\n *\r\n * @property {number} frameRateLimit            Limit render calls to fps\r\n * @property {boolean} enableStats              Toggle stats.js info\r\n * @property {boolean} pauseHidden              Pause render elements which are not on screen\r\n */\r\nconst defaultOptions = {\r\n    showAxes: false,\r\n    showGrid: false,\r\n    autoResize: false,\r\n    controls: {\r\n        enabled: true,\r\n        zoom: true,\r\n        rotate: true,\r\n        pan: true,\r\n        keys: true\r\n    },\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 20,\r\n        y: 35,\r\n        z: 20,\r\n        target: [0, 0, 0]\r\n    },\r\n    canvas: {\r\n        width: undefined,\r\n        height: undefined\r\n    },\r\n    frameRateLimit: -1,\r\n    enableStats: false,\r\n    pauseHidden: true,\r\n    forceContext: false,\r\n    sendStats: true\r\n};\r\n\r\n/**\r\n * Base class for all Renders\r\n */\r\nclass Render {\r\n\r\n    /**\r\n     * @param {object} options The options for this renderer, see {@link defaultOptions}\r\n     * @param {object} defOptions Additional default options, provided by the individual renders\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, defOptions, element) {\r\n        /**\r\n         * DOM Element to attach the renderer to\r\n         * @type {HTMLElement}\r\n         */\r\n        this.element = element || document.body;\r\n        /**\r\n         * Combined options\r\n         * @type {{} & defaultOptions & defOptions & options}\r\n         */\r\n        this.options = Object.assign({}, defaultOptions, defOptions, options);\r\n\r\n        this.renderType = \"_Base_\";\r\n    }\r\n\r\n    /**\r\n     * @param {boolean} [trim=false] whether to trim transparent pixels\r\n     * @param {string} [mime=image/png] mime type of the image\r\n     * @returns {string} The content of the renderer's canvas as a Base64 encoded image\r\n     */\r\n    toImage(trim, mime) {\r\n        if (!mime) mime = \"image/png\";\r\n        if (this._renderer) {\r\n            if (!trim) {\r\n                return this._renderer.domElement.toDataURL(mime);\r\n            } else {\r\n                // Clone the canvas onto a 2d context, so we can trim it properly\r\n                let newCanvas = document.createElement('canvas');\r\n                let context = newCanvas.getContext('2d');\r\n\r\n                newCanvas.width = this._renderer.domElement.width;\r\n                newCanvas.height = this._renderer.domElement.height;\r\n\r\n                context.drawImage(this._renderer.domElement, 0, 0);\r\n\r\n                let trimmed = Object(_functions__WEBPACK_IMPORTED_MODULE_7__[\"trimCanvas\"])(newCanvas);\r\n                return trimmed.toDataURL(mime);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Export the current scene content in the .obj format (only geometries, no textures)\r\n     * @returns {string} the .obj file content\r\n     */\r\n    toObj() {\r\n        if (this._scene) {\r\n            let exporter = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"OBJExporter\"]();\r\n            return exporter.parse(this._scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Export the current scene content in the .gltf format (geometries + textures)\r\n     * @returns {Promise<any>} a promise which resolves with the .gltf file content\r\n     */\r\n    toGLTF(exportOptions) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this._scene) {\r\n                let exporter = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"GLTFExporter\"]();\r\n                exporter.parse(this._scene, (gltf) => {\r\n                    resolve(gltf);\r\n                }, exportOptions)\r\n            } else {\r\n                reject();\r\n            }\r\n        })\r\n    }\r\n\r\n    toPLY(exportOptions) {\r\n        if (this._scene) {\r\n            let exporter = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"PLYExporter\"]();\r\n            return exporter.parse(this._scene, exportOptions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the scene\r\n     * @param renderCb\r\n     * @param doNotAnimate\r\n     * @protected\r\n     */\r\n    initScene(renderCb, doNotAnimate) {\r\n        let renderObj = this;\r\n\r\n        console.log(\" \");\r\n        console.log('%c       ', 'font-size: 100px; background: url(https://minerender.org/img/minerender.svg) no-repeat;');\r\n        console.log(\"MineRender/\" + (renderObj.renderType || renderObj.constructor.name) + \"/\" + \"1.4.13\");\r\n        console.log(( false ? undefined : \"DEVELOPMENT\") + \" build\");\r\n        console.log(\"Built @ \" + \"2025-05-19T09:36:04.653Z\");\r\n        console.log(\" \");\r\n\r\n        if (renderObj.options.sendStats) {\r\n            // Send stats\r\n\r\n            let iframe = false;\r\n            try {\r\n                iframe = window.self !== window.top;\r\n            } catch (e) {\r\n                return true;\r\n            }\r\n            let hostname;\r\n            try{\r\n                hostname = new URL(iframe ? document.referrer : window.location).hostname;\r\n            }catch (e) {\r\n                console.warn(\"Failed to get hostname\");\r\n            }\r\n\r\n            jquery__WEBPACK_IMPORTED_MODULE_5__[\"post\"]({\r\n                url: \"https://minerender.org/stats.php\",\r\n                data: {\r\n                    action: \"init\",\r\n                    type: renderObj.renderType,\r\n                    host: hostname,\r\n                    source: (iframe ? \"iframe\" : \"javascript\")\r\n                }\r\n            });\r\n        }\r\n\r\n        // Scene INIT\r\n        let scene = new three__WEBPACK_IMPORTED_MODULE_3__[\"Scene\"]();\r\n        renderObj._scene = scene;\r\n        let camera;\r\n        if (renderObj.options.camera.type === \"orthographic\") {\r\n            camera = new three__WEBPACK_IMPORTED_MODULE_3__[\"OrthographicCamera\"]((renderObj.options.canvas.width || window.innerWidth) / -2, (renderObj.options.canvas.width || window.innerWidth) / 2, (renderObj.options.canvas.height || window.innerHeight) / 2, (renderObj.options.canvas.height || window.innerHeight) / -2, 1, 1000);\r\n        } else {\r\n            camera = new three__WEBPACK_IMPORTED_MODULE_3__[\"PerspectiveCamera\"](75, (renderObj.options.canvas.width || window.innerWidth) / (renderObj.options.canvas.height || window.innerHeight), 5, 1000);\r\n        }\r\n        renderObj._camera = camera;\r\n\r\n        if (renderObj.options.camera.zoom) {\r\n            camera.zoom = renderObj.options.camera.zoom;\r\n        }\r\n\r\n        let renderer = new three__WEBPACK_IMPORTED_MODULE_3__[\"WebGLRenderer\"]({alpha: true, antialias: true, preserveDrawingBuffer: true});\r\n        renderObj._renderer = renderer;\r\n        renderer.setSize((renderObj.options.canvas.width || window.innerWidth), (renderObj.options.canvas.height || window.innerHeight));\r\n        renderer.setClearColor(0x000000, 0);\r\n        renderer.setPixelRatio(window.devicePixelRatio);\r\n        renderer.shadowMap.enabled = true;\r\n        renderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_3__[\"PCFSoftShadowMap\"];\r\n        renderObj.element.appendChild(renderObj._canvas = renderer.domElement);\r\n\r\n        let composer = new _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2___default.a(renderer);\r\n        composer.setSize((renderObj.options.canvas.width || window.innerWidth), (renderObj.options.canvas.height || window.innerHeight));\r\n        renderObj._composer = composer;\r\n        let ssaaRenderPass = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"SSAARenderPass\"](scene, camera);\r\n        ssaaRenderPass.unbiased = true;\r\n        composer.addPass(ssaaRenderPass);\r\n        // let renderPass = new RenderPass(scene, camera);\r\n        // renderPass.enabled = false;\r\n        // composer.addPass(renderPass);\r\n        let copyPass = new _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__[\"ShaderPass\"](_johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__[\"CopyShader\"]);\r\n        copyPass.renderToScreen = true;\r\n        composer.addPass(copyPass);\r\n\r\n        if (renderObj.options.autoResize) {\r\n            renderObj._resizeListener = function () {\r\n                let width = (renderObj.element && renderObj.element !== document.body) ? renderObj.element.offsetWidth : window.innerWidth;\r\n                let height = (renderObj.element && renderObj.element !== document.body) ? renderObj.element.offsetHeight : window.innerHeight;\r\n\r\n                renderObj._resize(width, height);\r\n            };\r\n            window.addEventListener(\"resize\", renderObj._resizeListener);\r\n        }\r\n        renderObj._resize = function (width, height) {\r\n            if (renderObj.options.camera.type === \"orthographic\") {\r\n                camera.left = width / -2;\r\n                camera.right = width / 2;\r\n                camera.top = height / 2;\r\n                camera.bottom = height / -2;\r\n            } else {\r\n                camera.aspect = width / height;\r\n            }\r\n            camera.updateProjectionMatrix();\r\n\r\n            renderer.setSize(width, height);\r\n            composer.setSize(width, height);\r\n        };\r\n\r\n        // Helpers\r\n        if (renderObj.options.showAxes) {\r\n            scene.add(new three__WEBPACK_IMPORTED_MODULE_3__[\"AxesHelper\"](50));\r\n        }\r\n        if (renderObj.options.showGrid) {\r\n            scene.add(new three__WEBPACK_IMPORTED_MODULE_3__[\"GridHelper\"](100, 100));\r\n        }\r\n\r\n        let light = new three__WEBPACK_IMPORTED_MODULE_3__[\"AmbientLight\"](0xFFFFFF); // soft white light\r\n        scene.add(light);\r\n\r\n        // Init controls\r\n        let controls = new _lib_OrbitControls__WEBPACK_IMPORTED_MODULE_0__[\"default\"](camera, renderer.domElement);\r\n        renderObj._controls = controls;\r\n        controls.enableZoom = renderObj.options.controls.zoom;\r\n        controls.enableRotate = renderObj.options.controls.rotate;\r\n        controls.enablePan = renderObj.options.controls.pan;\r\n        controls.enableKeys = renderObj.options.controls.keys;\r\n        controls.target.set(renderObj.options.camera.target[0], renderObj.options.camera.target[1], renderObj.options.camera.target[2]);\r\n\r\n        // Set camera location & target\r\n        camera.position.x = renderObj.options.camera.x;\r\n        camera.position.y = renderObj.options.camera.y;\r\n        camera.position.z = renderObj.options.camera.z;\r\n        camera.lookAt(new three__WEBPACK_IMPORTED_MODULE_3__[\"Vector3\"](renderObj.options.camera.target[0], renderObj.options.camera.target[1], renderObj.options.camera.target[2]));\r\n\r\n        if (renderObj.options.enableStats) {\r\n            renderObj._stats = new stats_js__WEBPACK_IMPORTED_MODULE_6___default.a();\r\n            renderObj._stats.showPanel(0);\r\n            document.body.appendChild(renderObj._stats.dom);\r\n        }\r\n\r\n        let limitFps = false;\r\n        if (renderObj.options.frameRateLimit > 0) {\r\n            // based on https://stackoverflow.com/a/51942991/6257838\r\n            limitFps = true;\r\n            renderObj._clock = new three__WEBPACK_IMPORTED_MODULE_3__[\"Clock\"]();\r\n            renderObj._animDelta = 0;\r\n            renderObj._animInterval = 1.0 / renderObj.options.frameRateLimit;\r\n        }\r\n\r\n\r\n        // Do the render!\r\n        let animate = function () {\r\n            renderObj._animId = requestAnimationFrame(animate);\r\n\r\n            if (renderObj.options.enableStats) {\r\n                renderObj._stats.begin();\r\n            }\r\n\r\n            if (renderObj.options.pauseHidden && ((typeof document.visibilityState !== \"undefined\" && document.visibilityState !== \"visible\") || !renderObj.onScreen)) return;\r\n\r\n            if (limitFps) {\r\n                renderObj._animDelta += renderObj._clock.getDelta();\r\n                if (renderObj._animDelta <= renderObj._animInterval) return;\r\n            }\r\n\r\n            if (typeof renderCb === \"function\") {\r\n                renderCb();\r\n            }\r\n\r\n            composer.render();\r\n\r\n            if (limitFps) {\r\n                renderObj._animDelta = renderObj._animDelta % renderObj._animInterval;\r\n            }\r\n\r\n            if (renderObj.options.enableStats) {\r\n                renderObj._stats.end();\r\n            }\r\n\r\n        };\r\n        renderObj._animate = animate;\r\n\r\n        if (!doNotAnimate) {\r\n            animate();\r\n        }\r\n\r\n        renderObj.onScreen = true;// default to true, in case the checking is disabled\r\n        let id = \"minerender-canvas-\" + renderObj._scene.uuid + \"-\" + Date.now();\r\n        renderObj._canvas.id = id;\r\n        if (renderObj.options.pauseHidden) {\r\n            renderObj.onScreen = false;// set to false if the check is enabled\r\n            let os = new onscreen__WEBPACK_IMPORTED_MODULE_4___default.a();\r\n            renderObj._onScreenObserver = os;\r\n\r\n            os.on(\"enter\", \"#\" + id, (element, event) => {\r\n                renderObj.onScreen = true;\r\n                if (renderObj.options.forceContext) {\r\n                    renderObj._renderer.forceContextRestore();\r\n                }\r\n            })\r\n            os.on(\"leave\", \"#\" + id, (element, event) => {\r\n                renderObj.onScreen = false;\r\n                if (renderObj.options.forceContext) {\r\n                    renderObj._renderer.forceContextLoss();\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds an object to the scene & sets userData.renderType to this renderer's type\r\n     * @param toAdd object to add\r\n     */\r\n    addToScene(toAdd) {\r\n        let renderObj = this;\r\n        if (renderObj._scene && toAdd) {\r\n            toAdd.userData.renderType = renderObj.renderType;\r\n            renderObj._scene.add(toAdd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the scene\r\n     * @param onlySelfType whether to remove only objects whose type is equal to this renderer's type (useful for combined render)\r\n     * @param filterFn Filter function to check which children of the scene to remove\r\n     */\r\n    clearScene(onlySelfType, filterFn) {\r\n        if (onlySelfType || filterFn) {\r\n            for (let i = this._scene.children.length - 1; i >= 0; i--) {\r\n                let child = this._scene.children[i];\r\n                if (filterFn) {\r\n                    let shouldKeep = filterFn(child);\r\n                    if (shouldKeep) {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (onlySelfType) {\r\n                    if (child.userData.renderType !== this.renderType) {\r\n                        continue;\r\n                    }\r\n                }\r\n                deepDisposeMesh(child, true);\r\n                this._scene.remove(child);\r\n            }\r\n        } else {\r\n            while (this._scene.children.length > 0) {\r\n                this._scene.remove(this._scene.children[0]);\r\n            }\r\n        }\r\n    };\r\n\r\n    dispose() {\r\n        cancelAnimationFrame(this._animId);\r\n        if (this._onScreenObserver) {\r\n            this._onScreenObserver.destroy();\r\n        }\r\n\r\n        this.clearScene();\r\n\r\n        this._canvas.remove();\r\n        let el = this.element;\r\n        while (el.firstChild) {\r\n            el.removeChild(el.firstChild);\r\n        }\r\n\r\n        if (this.options.autoResize) {\r\n            window.removeEventListener(\"resize\", this._resizeListener);\r\n        }\r\n\r\n        if (this._renderer) {\r\n            this._renderer.forceContextLoss();\r\n            this._renderer.dispose();\r\n            this._renderer.context = undefined;\r\n            this._renderer.domElement = undefined;\r\n        }\r\n    };\r\n\r\n}\r\n\r\n// https://stackoverflow.com/questions/27217388/use-multiple-materials-for-merged-geometries-in-three-js/44485364#44485364\r\nfunction deepDisposeMesh(obj, removeChildren) {\r\n    if (!obj) return;\r\n    if (obj.geometry && obj.geometry.dispose) obj.geometry.dispose();\r\n    if (obj.material && obj.material.dispose) obj.material.dispose();\r\n    if (obj.texture && obj.texture.dispose) obj.texture.dispose();\r\n    if (obj.children) {\r\n        let children = obj.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            deepDisposeMesh(children[i], removeChildren);\r\n        }\r\n\r\n        if (removeChildren) {\r\n            for (let i = obj.children.length - 1; i >= 0; i--) {\r\n                obj.remove(children[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction mergeMeshes__(meshes, toBufferGeometry) {\r\n    let finalGeometry,\r\n        materials = [],\r\n        mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_3__[\"Geometry\"](),\r\n        mergedMesh;\r\n\r\n    meshes.forEach(function (mesh, index) {\r\n        mesh.updateMatrix();\r\n        mesh.geometry.faces.forEach(function (face) {\r\n            face.materialIndex = 0;\r\n        });\r\n        mergedGeometry.merge(mesh.geometry, mesh.matrix, index);\r\n        materials.push(mesh.material);\r\n    });\r\n\r\n    mergedGeometry.groupsNeedUpdate = true;\r\n\r\n    if (toBufferGeometry) {\r\n        finalGeometry = new three__WEBPACK_IMPORTED_MODULE_3__[\"BufferGeometry\"]().fromGeometry(mergedGeometry);\r\n    } else {\r\n        finalGeometry = mergedGeometry;\r\n    }\r\n\r\n    mergedMesh = new three__WEBPACK_IMPORTED_MODULE_3__[\"Mesh\"](finalGeometry, materials);\r\n    mergedMesh.geometry.computeFaceNormals();\r\n    mergedMesh.geometry.computeVertexNormals();\r\n\r\n    return mergedMesh;\r\n\r\n}\r\n\r\nfunction mergeCubeMeshes(cubes, toBuffer) {\r\n    cubes = cubes.filter(c => !!c);\r\n\r\n    let mergedCubes = new three__WEBPACK_IMPORTED_MODULE_3__[\"Geometry\"]();\r\n    let mergedMaterials = [];\r\n    for (let i = 0; i < cubes.length; i++) {\r\n        let offset = i * Math.max(cubes[i].material.length, 1);\r\n        mergedCubes.merge(cubes[i].geometry, cubes[i].matrix, offset);\r\n        for (let j = 0; j < cubes[i].material.length; j++) {\r\n            mergedMaterials.push(cubes[i].material[j]);\r\n        }\r\n        // for (let j = 0; j < cubes[i].geometry.faces.length; j++) {\r\n        //     cubes[i].geometry.faces[j].materialIndex=offset-1+j;\r\n        // }\r\n\r\n        deepDisposeMesh(cubes[i], true);\r\n    }\r\n    mergedCubes.mergeVertices();\r\n    return {\r\n        geometry: toBuffer ? new three__WEBPACK_IMPORTED_MODULE_3__[\"BufferGeometry\"]().fromGeometry(mergedCubes) : mergedCubes,\r\n        materials: mergedMaterials\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./src/renderBase.js?");

/***/ }),

/***/ "./src/skin/index.js":
/*!***************************!*\
  !*** ./src/skin/index.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _texturePositions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texturePositions */ \"./src/skin/texturePositions.js\");\n/* harmony import */ var _renderBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderBase */ \"./src/renderBase.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @see defaultOptions\r\n */\r\nlet defOptions = {\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 20,\r\n        y: 35,\r\n        z: 20,\r\n        target: [0, 18, 0]\r\n    },\r\n    makeNonTransparentOpaque: true\r\n};\r\n\r\n/**\r\n * A renderer for Minecraft player models/skins\r\n */\r\nclass SkinRender extends _renderBase__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, element) {\r\n        super(options, defOptions, element);\r\n\r\n        this.renderType = \"SkinRender\";\r\n        this._animId = -1;\r\n\r\n        // bind this renderer to the element\r\n        this.element.skinRender = this;\r\n        this.attached = false;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Does the actual rendering\r\n     *\r\n     * @param {(string|Object)} texture The texture to render - May be a string with the playername/URL/Base64 or an Object\r\n     * @param {string} texture.url URL to the texture image\r\n     * @param {string} texture.data Base64 encoded image data of the texture\r\n     * @param {string} texture.username Player username\r\n     * @param {string} texture.uuid Player UUID\r\n     * @param {number} texture.mineskin ID of a MineSkin.org skin\r\n     * @param {boolean} [texture.slim=false] Whether the provided texture uses the slim skin format\r\n     *\r\n     * @param {string} [texture.cape=latest] Cape to render using capes.dev - Either a direct link to the cape data (api.capes.dev/get/...) OR a specific cape type\r\n     * @param {string} [texture.capeUser] Specify this to use a different user for the cape texture than the skin\r\n     * @param {string} [texture.capeUrl] URL to a cape texture\r\n     * @param {string} [texture.capeData] Base64 encoded image data of the cape texture\r\n     * @param {string} [texture.mineskin] deprecated; ID of a MineSkin.org skin with a cape\r\n     * @param {boolean} [texture.optifine=false] deprecated; Whether the provided cape texture is an optifine cape\r\n     *\r\n     * @param {function} [cb] Callback when rendering finished\r\n     */\r\n    render(texture, cb) {\r\n        let skinRender = this;\r\n\r\n        let renderStarted = false;\r\n\r\n        let imagesLoaded = (skinTexture, capeTexture) => {\r\n            renderStarted = true;\r\n            skinTexture.needsUpdate = true;\r\n            if (capeTexture) capeTexture.needsUpdate = true;\r\n\r\n            let textureVersion = -1;\r\n            if (skinTexture.image.height === 32) {\r\n                textureVersion = 0;\r\n            } else if (skinTexture.image.height === 64) {\r\n                textureVersion = 1;\r\n            } else {\r\n                console.error(\"Couldn't detect texture version. Invalid dimensions: \" + skinTexture.image.width + \"x\" + skinTexture.image.height)\r\n            }\r\n            console.log(\"Skin Texture Version: \" + textureVersion)\r\n\r\n            // To keep the pixelated texture\r\n            skinTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n            skinTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n            skinTexture.anisotropy = 0;\r\n            if (capeTexture) {\r\n                capeTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                capeTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                capeTexture.anisotropy = 0;\r\n                capeTexture.format = three__WEBPACK_IMPORTED_MODULE_0__[\"RGBFormat\"]; // no transparency\r\n            }\r\n\r\n            if (!skinRender.attached && !skinRender._scene) {// Don't init scene if attached, since we already have an available scene\r\n                super.initScene(function () {\r\n                    skinRender.element.dispatchEvent(new CustomEvent(\"skinRender\", {detail: {playerModel: skinRender.playerModel}}));\r\n                });\r\n            } else {\r\n                console.log(\"[SkinRender] is attached - skipping scene init\");\r\n            }\r\n\r\n            console.log(\"Slim: \" + slim)\r\n            let playerModel = createPlayerModel(skinTexture, capeTexture, textureVersion, slim, texture._capeType ? texture._capeType : texture.optifine ? \"optifine\" : \"minecraft\");\r\n            skinRender.addToScene(playerModel);\r\n            // console.log(playerModel);\r\n            skinRender.playerModel = playerModel;\r\n\r\n            if (typeof cb === \"function\") cb();\r\n        }\r\n\r\n        skinRender._skinImage = new Image();\r\n        skinRender._skinImage.crossOrigin = \"anonymous\";\r\n        skinRender._capeImage = new Image();\r\n        skinRender._capeImage.crossOrigin = \"anonymous\";\r\n        let hasCape = texture.cape !== undefined || texture.capeUser !== undefined || texture.capeUrl !== undefined || texture.capeData !== undefined || texture.mineskin !== undefined;\r\n        let slim = false;\r\n        let skinLoaded = false;\r\n        let capeLoaded = false;\r\n\r\n        let skinTexture = new three__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"]();\r\n        let capeTexture = new three__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"]();\r\n        skinTexture.image = skinRender._skinImage;\r\n        skinRender._skinImage.onload = function () {\r\n            if (!skinRender._skinImage) return;\r\n\r\n            skinLoaded = true;\r\n            console.log(\"Skin Image Loaded\");\r\n\r\n            if (texture.slim === undefined) {\r\n                if (skinRender._skinImage.height !== 32) {\r\n\r\n                    let detectCanvas = document.createElement(\"canvas\");\r\n                    let detectCtx = detectCanvas.getContext(\"2d\");\r\n                    // detectCanvas.style.display = \"none\";\r\n                    detectCanvas.width = skinRender._skinImage.width;\r\n                    detectCanvas.height = skinRender._skinImage.height;\r\n                    detectCtx.drawImage(skinRender._skinImage, 0, 0);\r\n\r\n                    console.log(\"Slim Detection:\")\r\n\r\n                    // Check the 2 columns that should be transparent on slim skins\r\n                    let px1 = detectCtx.getImageData(46, 52, 1, 12).data;\r\n                    let px2 = detectCtx.getImageData(54, 20, 1, 12).data;\r\n                    let allTransparent = true;\r\n                    for (let i = 3; i < 12 * 4; i += 4) {\r\n                        if (px1[i] === 255) {\r\n                            allTransparent = false;\r\n                            break;\r\n                        }\r\n                        if (px2[i] === 255) {\r\n                            allTransparent = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    console.log(allTransparent)\r\n\r\n                    if (allTransparent) slim = true;\r\n                }\r\n            }\r\n\r\n            if (skinRender.options.makeNonTransparentOpaque && skinRender._skinImage.height !== 32) {\r\n                let sourceCanvas = document.createElement(\"canvas\");\r\n                let sourceContext = sourceCanvas.getContext(\"2d\");\r\n                sourceCanvas.width = skinRender._skinImage.width;\r\n                sourceCanvas.height = skinRender._skinImage.height;\r\n                // draw skin texture\r\n                sourceContext.drawImage(skinRender._skinImage, 0, 0);\r\n\r\n                // remove partial transparency\r\n                let opaqueCanvas = document.createElement(\"canvas\");\r\n                let opaqueContext = opaqueCanvas.getContext(\"2d\");\r\n                opaqueCanvas.width = skinRender._skinImage.width;\r\n                opaqueCanvas.height = skinRender._skinImage.height;\r\n\r\n                let imageData = sourceContext.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);\r\n                let pixels = imageData.data;\r\n\r\n                function removeTransparency(x, y) {\r\n                    if (x > 0 && y > 0 && x < 32 && y < 32) return true; // top left, face + right leg + half of body\r\n                    if (x > 32 && y > 16 && x < 32 + 32 && y < 16 + 16) return true;// mid right, other body half + right arm\r\n                    if (x > 16 && y > 48 && x < 16 + 32 && y < 48 + 16) return true;// bottom mid, left leg + left arm\r\n                    return false;\r\n                }\r\n\r\n                // check every pixel for transparency\r\n                for (let i = 0; i < pixels.length; i += 4) {\r\n                    let a = pixels[i + 3];\r\n                    let x = (i / 4) % sourceCanvas.width;\r\n                    let y = Math.floor((i / 4) / sourceCanvas.width);\r\n                    if (a > 178 || removeTransparency(x, y)) { // alpha over threshold OR area not supposed to have transparency at all\r\n                        pixels[i + 3] = 255; // max the alpha\r\n                    }\r\n                }\r\n\r\n                // update destination canvas\r\n                opaqueContext.putImageData(imageData, 0, 0);\r\n\r\n                console.log(opaqueCanvas.toDataURL())\r\n\r\n                skinTexture = new three__WEBPACK_IMPORTED_MODULE_0__[\"CanvasTexture\"](opaqueCanvas);\r\n            }\r\n\r\n            if (skinLoaded && (capeLoaded || !hasCape)) {\r\n                if (!renderStarted) imagesLoaded(skinTexture, capeTexture);\r\n            }\r\n        };\r\n        skinRender._skinImage.onerror = function (e) {\r\n            console.warn(\"Skin Image Error\")\r\n            console.warn(e)\r\n        }\r\n        console.log(\"Has Cape: \" + hasCape)\r\n        if (hasCape) {\r\n            capeTexture.image = skinRender._capeImage;\r\n            skinRender._capeImage.onload = function () {\r\n                if (!skinRender._capeImage) return;\r\n\r\n                capeLoaded = true;\r\n                console.log(\"Cape Image Loaded\");\r\n\r\n                if (capeLoaded && skinLoaded) {\r\n                    if (!renderStarted) imagesLoaded(skinTexture, capeTexture);\r\n                }\r\n            }\r\n            skinRender._capeImage.onerror = function (e) {\r\n                console.warn(\"Cape Image Error\")\r\n                console.warn(e);\r\n\r\n                // Continue anyway, just without the cape\r\n                capeLoaded = true;\r\n                if (skinLoaded) {\r\n                    if (!renderStarted) imagesLoaded(skinTexture);\r\n                }\r\n            }\r\n        } else {\r\n            capeTexture = null;\r\n            skinRender._capeImage = null;\r\n        }\r\n\r\n        if (typeof texture === \"string\") {\r\n            // console.log(texture)\r\n            if (texture.indexOf(\"http\") === 0) {// URL\r\n                skinRender._skinImage.src = texture\r\n            } else if (texture.length <= 16) {// Probably a Minecraft username\r\n                getJSON(\"https://minerender.org/nameToUuid.php?name=\" + texture, function (err, data) {\r\n                    if (err) return console.log(err);\r\n                    console.log(data);\r\n                    skinRender._skinImage.src = \"https://crafatar.com/skins/\" + (data.id ? data.id : texture);\r\n                });\r\n            } else if (texture.length <= 36) {// Probably player UUID\r\n                image.src = \"https://crafatar.com/skins/\" + texture + \"?overlay\";\r\n            } else {// taking a guess that it's a Base64 image\r\n                skinRender._skinImage.src = texture;\r\n            }\r\n        } else if (typeof texture === \"object\") {\r\n            if (texture.url) {\r\n                skinRender._skinImage.src = texture.url;\r\n            } else if (texture.data) {\r\n                skinRender._skinImage.src = texture.data;\r\n            } else if (texture.username) {\r\n                getJSON(\"https://minerender.org/nameToUuid.php?name=\" + texture.username, function (err, data) {\r\n                    if (err) return console.log(err);\r\n                    skinRender._skinImage.src = \"https://crafatar.com/skins/\" + (data.id ? data.id : texture.username) + \"?overlay\";\r\n                });\r\n            } else if (texture.uuid) {\r\n                skinRender._skinImage.src = \"https://crafatar.com/skins/\" + texture.uuid + \"?overlay\";\r\n            } else if (texture.mineskin) {\r\n                skinRender._skinImage.src = \"https://api.mineskin.org/render/texture/\" + texture.mineskin;\r\n            }\r\n            if (texture.cape) {\r\n                if (texture.cape.length > 36) { // Likely either a cape ID or URL\r\n                    let capeDataUrl = texture.cape.startsWith(\"http\") ? texture.cape : \"https://api.capes.dev/get/\" + texture.cape;\r\n                    getJSON(capeDataUrl, function (err, data) {\r\n                        if (err) {\r\n                            console.log(\"failed to get capes.dev\")\r\n                            skinRender._capeImage.onload(); // avoid getting stuck\r\n                            return console.log(err);\r\n                        }\r\n                        if (data.exists) {\r\n                            texture._capeType = data.type;\r\n                            skinRender._capeImage.src = data.imageUrls.base.full;\r\n                        } else {\r\n                            skinRender._capeImage.onload(); // avoid getting stuck\r\n                        }\r\n                    })\r\n                } else { // Type\r\n                    let capeLoadUrl = \"https://api.capes.dev/load/\";\r\n                    if (texture.capeUser) {// Try to find a player to use\r\n                        capeLoadUrl += texture.capeUser;\r\n                    } else if (texture.username) {\r\n                        capeLoadUrl += texture.username;\r\n                    } else if (texture.uuid) {\r\n                        capeLoadUrl += texture.uuid;\r\n                    } else {\r\n                        console.warn(\"Couldn't find a user to get a cape from\");\r\n                    }\r\n                    capeLoadUrl += \"/\" + texture.cape; // append type\r\n\r\n                    getJSON(capeLoadUrl, function (err, data) {\r\n                        if (err) {\r\n                            console.log(\"failed to get capes.dev\")\r\n                            skinRender._capeImage.onload(); // avoid getting stuck\r\n                            return console.log(err);\r\n                        }\r\n                        // Should be a single object of the requested type\r\n                        if (data.exists) {\r\n                            texture._capeType = data.type;\r\n                            skinRender._capeImage.src = data.imageUrls.base.full;\r\n                        } else {\r\n                            skinRender._capeImage.onload(); // avoid getting stuck\r\n                        }\r\n                    })\r\n                }\r\n            } else if (texture.capeUrl) {\r\n                skinRender._capeImage.src = texture.capeUrl;\r\n            } else if (texture.capeData) {\r\n                skinRender._capeImage.src = texture.capeData;\r\n            } else if (texture.mineskin) {\r\n                skinRender._capeImage.src = \"https://api.mineskin.org/render/texture/\" + texture.mineskin + \"/cape\";\r\n            }\r\n\r\n            slim = texture.slim;\r\n        } else {\r\n            throw new Error(\"Invalid texture value\")\r\n        }\r\n    };\r\n\r\n\r\n    resize(width, height) {\r\n        return this._resize(width, height);\r\n    };\r\n\r\n    reset() {\r\n        this._skinImage = null;\r\n        this._capeImage = null;\r\n\r\n        if (this._animId) {\r\n            cancelAnimationFrame(this._animId);\r\n        }\r\n        if (this._canvas) {\r\n            this._canvas.remove();\r\n        }\r\n    };\r\n\r\n    getPlayerModel() {\r\n        return this.playerModel;\r\n    };\r\n\r\n\r\n    getModelByName(name) {\r\n        return this._scene.getObjectByName(name, true);\r\n    };\r\n\r\n    toggleSkinPart(name, visible) {\r\n        this._scene.getObjectByName(name, true).visible = visible;\r\n    };\r\n\r\n\r\n}\r\n\r\nfunction createCube(texture, width, height, depth, textures, slim, name, transparent) {\r\n    let textureWidth = texture.image.width;\r\n    let textureHeight = texture.image.height;\r\n\r\n    let geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](width, height, depth);\r\n    let material = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\r\n        /*color: 0x00ff00,*/map: texture, transparent: transparent || false, alphaTest: 0.1, side: transparent ? three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"] : three__WEBPACK_IMPORTED_MODULE_0__[\"FrontSide\"]//TODO: double sided not working properly\r\n    });\r\n\r\n    geometry.computeBoundingBox();\r\n\r\n    geometry.faceVertexUvs[0] = [];\r\n\r\n    let faceNames = [\"right\", \"left\", \"top\", \"bottom\", \"front\", \"back\"];\r\n    let faceUvs = [];\r\n    for (let i = 0; i < faceNames.length; i++) {\r\n        let face = textures[faceNames[i]];\r\n        if (faceNames[i] === \"back\") {\r\n            //     console.log(face)\r\n            // console.log(\"X: \" + (slim && face.sx ? face.sx : face.x))\r\n            // console.log(\"W: \" + (slim && face.sw ? face.sw : face.w))\r\n        }\r\n        let w = textureWidth;\r\n        let h = textureHeight;\r\n        let tx1 = ((slim && face.sx ? face.sx : face.x) / w);\r\n        let ty1 = (face.y / h);\r\n        let tx2 = (((slim && face.sx ? face.sx : face.x) + (slim && face.sw ? face.sw : face.w)) / w);\r\n        let ty2 = ((face.y + face.h) / h);\r\n\r\n        faceUvs[i] = [\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx1, ty2),\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx1, ty1),\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx2, ty1),\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx2, ty2)\r\n        ];\r\n        // console.log(faceUvs[i])\r\n\r\n        let flipX = face.flipX;\r\n        let flipY = face.flipY;\r\n\r\n        let temp;\r\n        if (flipY) {\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[2];\r\n            faceUvs[i][1] = temp[3];\r\n            faceUvs[i][2] = temp[0];\r\n            faceUvs[i][3] = temp[1]\r\n        }\r\n        if (flipX) {//flip x\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[3];\r\n            faceUvs[i][1] = temp[2];\r\n            faceUvs[i][2] = temp[1];\r\n            faceUvs[i][3] = temp[0]\r\n        }\r\n    }\r\n\r\n    let j = 0;\r\n    for (let i = 0; i < faceUvs.length; i++) {\r\n        geometry.faceVertexUvs[0][j] = [faceUvs[i][0], faceUvs[i][1], faceUvs[i][3]];\r\n        geometry.faceVertexUvs[0][j + 1] = [faceUvs[i][1], faceUvs[i][2], faceUvs[i][3]];\r\n        j += 2;\r\n    }\r\n    geometry.uvsNeedUpdate = true;\r\n\r\n    let cube = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\r\n    cube.name = name;\r\n    // cube.position.set(x, y, z);\r\n    cube.castShadow = true;\r\n    cube.receiveShadow = false;\r\n\r\n    return cube;\r\n};\r\n\r\n\r\nfunction createPlayerModel(skinTexture, capeTexture, v, slim, capeType) {\r\n    console.log(\"capeType: \" + capeType);\r\n\r\n    let headGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    headGroup.name = \"headGroup\";\r\n    headGroup.position.x = 0;\r\n    headGroup.position.y = 28;\r\n    headGroup.position.z = 0;\r\n    headGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    let head = createCube(skinTexture,\r\n        8, 8, 8,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].head[v],\r\n        slim,\r\n        \"head\"\r\n    );\r\n    head.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    headGroup.add(head);\r\n    let hat = createCube(skinTexture,\r\n        8.504, 8.504, 8.504,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hat[v],\r\n        slim,\r\n        \"hat\",\r\n        true\r\n    );\r\n    hat.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    headGroup.add(hat);\r\n\r\n    let bodyGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    bodyGroup.name = \"bodyGroup\";\r\n    bodyGroup.position.x = 0;\r\n    bodyGroup.position.y = 18;\r\n    bodyGroup.position.z = 0;\r\n    let body = createCube(skinTexture,\r\n        8, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].body[v],\r\n        slim,\r\n        \"body\"\r\n    );\r\n    bodyGroup.add(body);\r\n    if (v >= 1) {\r\n        let jacket = createCube(skinTexture,\r\n            8.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].jacket,\r\n            slim,\r\n            \"jacket\",\r\n            true\r\n        );\r\n        bodyGroup.add(jacket);\r\n    }\r\n\r\n    let leftArmGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    leftArmGroup.name = \"leftArmGroup\";\r\n    leftArmGroup.position.x = slim ? -5.5 : -6;\r\n    leftArmGroup.position.y = 18;\r\n    leftArmGroup.position.z = 0;\r\n    leftArmGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let leftArm = createCube(skinTexture,\r\n        slim ? 3 : 4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftArm[v],\r\n        slim,\r\n        \"leftArm\"\r\n    );\r\n    leftArm.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    leftArmGroup.add(leftArm);\r\n    if (v >= 1) {\r\n        let leftSleeve = createCube(skinTexture,\r\n            slim ? 3.504 : 4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftSleeve,\r\n            slim,\r\n            \"leftSleeve\",\r\n            true\r\n        );\r\n        leftSleeve.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        leftArmGroup.add(leftSleeve);\r\n    }\r\n\r\n    let rightArmGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    rightArmGroup.name = \"rightArmGroup\";\r\n    rightArmGroup.position.x = slim ? 5.5 : 6;\r\n    rightArmGroup.position.y = 18;\r\n    rightArmGroup.position.z = 0;\r\n    rightArmGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let rightArm = createCube(skinTexture,\r\n        slim ? 3 : 4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightArm[v],\r\n        slim,\r\n        \"rightArm\"\r\n    );\r\n    rightArm.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    rightArmGroup.add(rightArm);\r\n    if (v >= 1) {\r\n        let rightSleeve = createCube(skinTexture,\r\n            slim ? 3.504 : 4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightSleeve,\r\n            slim,\r\n            \"rightSleeve\",\r\n            true\r\n        );\r\n        rightSleeve.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        rightArmGroup.add(rightSleeve);\r\n    }\r\n\r\n    let leftLegGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    leftLegGroup.name = \"leftLegGroup\";\r\n    leftLegGroup.position.x = -2;\r\n    leftLegGroup.position.y = 6;\r\n    leftLegGroup.position.z = 0;\r\n    leftLegGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let leftLeg = createCube(skinTexture,\r\n        4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftLeg[v],\r\n        slim,\r\n        \"leftLeg\"\r\n    );\r\n    leftLeg.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    leftLegGroup.add(leftLeg);\r\n    if (v >= 1) {\r\n        let leftTrousers = createCube(skinTexture,\r\n            4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftTrousers,\r\n            slim,\r\n            \"leftTrousers\",\r\n            true\r\n        );\r\n        leftTrousers.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        leftLegGroup.add(leftTrousers);\r\n    }\r\n\r\n    let rightLegGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    rightLegGroup.name = \"rightLegGroup\";\r\n    rightLegGroup.position.x = 2;\r\n    rightLegGroup.position.y = 6;\r\n    rightLegGroup.position.z = 0;\r\n    rightLegGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let rightLeg = createCube(skinTexture,\r\n        4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightLeg[v],\r\n        slim,\r\n        \"rightLeg\"\r\n    );\r\n    rightLeg.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    rightLegGroup.add(rightLeg);\r\n    if (v >= 1) {\r\n        let rightTrousers = createCube(skinTexture,\r\n            4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightTrousers,\r\n            slim,\r\n            \"rightTrousers\",\r\n            true\r\n        );\r\n        rightTrousers.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        rightLegGroup.add(rightTrousers);\r\n    }\r\n\r\n    let playerGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    playerGroup.add(headGroup);\r\n    playerGroup.add(bodyGroup);\r\n    playerGroup.add(leftArmGroup);\r\n    playerGroup.add(rightArmGroup);\r\n    playerGroup.add(leftLegGroup);\r\n    playerGroup.add(rightLegGroup);\r\n\r\n    if (capeTexture) {\r\n        console.log(_texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\r\n        let capeTextureCoordinates = _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].capeRelative;\r\n        if (capeType === \"optifine\") {\r\n            capeTextureCoordinates = _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].capeOptifineRelative;\r\n        }\r\n        if (capeType === \"labymod\") {\r\n            capeTextureCoordinates = _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].capeLabymodRelative;\r\n        }\r\n        capeTextureCoordinates = JSON.parse(JSON.stringify(capeTextureCoordinates)); // bad clone to keep the below scaling from affecting everything\r\n\r\n        console.log(capeTextureCoordinates);\r\n\r\n        // Multiply coordinates by image dimensions\r\n        for (let cord in capeTextureCoordinates) {\r\n            capeTextureCoordinates[cord].x *= capeTexture.image.width;\r\n            capeTextureCoordinates[cord].w *= capeTexture.image.width;\r\n            capeTextureCoordinates[cord].y *= capeTexture.image.height;\r\n            capeTextureCoordinates[cord].h *= capeTexture.image.height;\r\n        }\r\n\r\n        console.log(capeTextureCoordinates);\r\n\r\n        let capeGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n        capeGroup.name = \"capeGroup\";\r\n        capeGroup.position.x = 0;\r\n        capeGroup.position.y = 16;\r\n        capeGroup.position.z = -2.5;\r\n        capeGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 8);\r\n        capeGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1), 0.5);\r\n        let cape = createCube(capeTexture,\r\n            10, 16, 1,\r\n            capeTextureCoordinates,\r\n            false,\r\n            \"cape\");\r\n        cape.rotation.x = toRadians(10); // slight backward angle\r\n        cape.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -8);\r\n        cape.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1), -0.5);\r\n        cape.rotation.y = toRadians(180); // flip front&back to be correct\r\n        capeGroup.add(cape)\r\n\r\n        playerGroup.add(capeGroup);\r\n    }\r\n\r\n    return playerGroup;\r\n};\r\n\r\n// From https://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/\r\nfunction buildAxes(length) {\r\n    let axes = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](length, 0, 0), 0xFF0000, false)); // +X\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](-length, 0, 0), 0xFF0000, true)); // -X\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, length, 0), 0x00FF00, false)); // +Y\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, -length, 0), 0x00FF00, true)); // -Y\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, length), 0x0000FF, false)); // +Z\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, -length), 0x0000FF, true)); // -Z\r\n\r\n    return axes;\r\n\r\n};\r\n\r\nfunction buildAxis(src, dst, colorHex, dashed) {\r\n    let geom = new three__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"](),\r\n        mat;\r\n\r\n    if (dashed) {\r\n        mat = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineDashedMaterial\"]({linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3});\r\n    } else {\r\n        mat = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineBasicMaterial\"]({linewidth: 3, color: colorHex});\r\n    }\r\n\r\n    geom.vertices.push(src.clone());\r\n    geom.vertices.push(dst.clone());\r\n    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines\r\n\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Line\"](geom, mat, three__WEBPACK_IMPORTED_MODULE_0__[\"LinePieces\"]);\r\n};\r\n\r\nfunction toRadians(angle) {\r\n    return angle * (Math.PI / 180);\r\n}\r\n\r\nfunction getJSON(url, callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'json';\r\n    xhr.onload = function () {\r\n        let status = xhr.status;\r\n        let r = xhr.response || xhr.responseText;\r\n        if (typeof r === \"string\") {\r\n            r = JSON.parse(r);\r\n        }\r\n        if (status === 200) {\r\n            callback(null, r);\r\n        } else {\r\n            callback(xhr.statusText, r);\r\n        }\r\n    };\r\n    xhr.send();\r\n}\r\n\r\nif (typeof window !== \"undefined\")\r\n    window.SkinRender = SkinRender;\r\nif (typeof global !== \"undefined\")\r\n    global.SkinRender = SkinRender;\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SkinRender);\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/skin/index.js?");

/***/ }),

/***/ "./src/skin/texturePositions.js":
/*!**************************************!*\
  !*** ./src/skin/texturePositions.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * Texture positions for Minecraft's player model\r\n */\r\nconst texturePositions =  {\r\n    head: [\r\n        {// 64x32\r\n            left: {\r\n                x: 0,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 8,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 16,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 24,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 8,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            bottom: {\r\n                x: 16,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 0,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 8,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 16,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 24,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 8,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            bottom: {\r\n                x: 16,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        }\r\n    ],\r\n    body: [\r\n        {// 64x32\r\n            left: {\r\n                x: 16,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 0,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            right: {\r\n                x: 28,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            back: {\r\n                x: 32,\r\n                y: 0,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 12,\r\n                w: 8,\r\n                h: 4\r\n            },\r\n            bottom: {\r\n                x: 28,\r\n                y: 12,\r\n                w: 8,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 16,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 32,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            right: {\r\n                x: 28,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 32,\r\n                y: 32,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 44,\r\n                w: 8,\r\n                h: 4\r\n            },\r\n            bottom: {\r\n                x: 28,\r\n                y: 44,\r\n                w: 8,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    rightArm: [\r\n        {// 64x32 - same as rightArm\r\n            left: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 32,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 36,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 39,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 43,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 36,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 40,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                sx: 39,\r\n                sw: 3,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    leftArm: [\r\n        {// 64x32 - same as leftArm\r\n            left: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 40,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 47,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 51,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                sx: 47,\r\n                sw: 3,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    rightLeg: [\r\n        {// 64x32 - same as rightLeg\r\n            left: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 16,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 24,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 28,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 24,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    leftLeg: [\r\n        {// 64x32 - same as leftLeg\r\n            left: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 0,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n\r\n    hat: [\r\n        { // 64x32\r\n            left: {\r\n                x: 32,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            front: {\r\n                x: 40,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            back: {\r\n                x: 56,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 40,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        },\r\n        { // 64x64\r\n            left: {\r\n                x: 32,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            front: {\r\n                x: 40,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            back: {\r\n                x: 56,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 40,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    jacket: {\r\n        left: {\r\n            x: 16,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 20,\r\n            y: 16,\r\n            w: 8,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 28,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 32,\r\n            y: 16,\r\n            w: 8,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 20,\r\n            y: 28,\r\n            w: 8,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 28,\r\n            y: 28,\r\n            w: 8,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    rightSleeve: {\r\n        left: {\r\n            x: 48,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 52,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sw: 3\r\n        },\r\n        right: {\r\n            x: 56,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 55\r\n        },\r\n        back: {\r\n            x: 60,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 59,\r\n            sw: 3\r\n        },\r\n        top: {\r\n            x: 52,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            sw: 3\r\n        },\r\n        bottom: {\r\n            x: 56,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            sx: 55,\r\n            sw: 3,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    leftSleeve: {\r\n        left: {\r\n            x: 40,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 44,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sw: 3\r\n        },\r\n        right: {\r\n            x: 48,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 47\r\n        },\r\n        back: {\r\n            x: 52,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 51,\r\n            sw: 3\r\n        },\r\n        top: {\r\n            x: 44,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            sw: 3\r\n        },\r\n        bottom: {\r\n            x: 48,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            sx: 47,\r\n            sw: 3,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    rightTrousers: {\r\n        left: {\r\n            x: 0,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 4,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 8,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 4,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 8,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    leftTrousers: {\r\n        left: {\r\n            x: 0,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 4,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 8,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 4,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 8,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n\r\n    cape: {\r\n        right: {\r\n            x: 0,\r\n            y: 5,\r\n            w: 1,\r\n            h: 16\r\n        },\r\n        front: {\r\n            x: 1,\r\n            y: 5,\r\n            w: 10,\r\n            h: 16\r\n        },\r\n        left: {\r\n            x: 11,\r\n            y: 5,\r\n            w: 1,\r\n            h: 16\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 5,\r\n            w: 10,\r\n            h: 16\r\n        },\r\n        top: {\r\n            x: 1,\r\n            y: 21,\r\n            w: 10,\r\n            h: 1\r\n        },\r\n        bottom: {\r\n            x: 11,\r\n            y: 21,\r\n            w: 10,\r\n            h: 1\r\n        }\r\n    },\r\n    capeRelative: { // Cape coordinates relative to image dimensions, starting bottom-left\r\n        right: {\r\n            x: 0,\r\n            y: 15/32,\r\n            w: 1/64,\r\n            h: 16/32\r\n        },\r\n        front: {\r\n            x: 1/64,\r\n            y: 15/32,\r\n            w: 10/64,\r\n            h: 16/32\r\n        },\r\n        left: {\r\n            x: 11/64,\r\n            y: 15/32,\r\n            w: 1/64,\r\n            h: 16/32\r\n        },\r\n        back: {\r\n            x: 12/64,\r\n            y: 15/32,\r\n            w: 10/64,\r\n            h: 16/32\r\n        },\r\n        top: {\r\n            x: 1/64,\r\n            y: 31/32,\r\n            w: 10/64,\r\n            h: 1/32\r\n        },\r\n        bottom: {\r\n            x: 11/64,\r\n            y: 31/32,\r\n            w: 10/64,\r\n            h: 1/32\r\n        }\r\n    },\r\n    capeOptifineRelative: {\r\n        right: {\r\n            x: 0,\r\n            y: 10/44,\r\n            w: 2/92,\r\n            h: 32/44\r\n        },\r\n        front: {\r\n            x: 2/92,\r\n            y: 10/44,\r\n            w: 20/92,\r\n            h: 32/44\r\n        },\r\n        left: {\r\n            x: 22/92,\r\n            y: 10/44,\r\n            w: 2/92,\r\n            h: 32/44\r\n        },\r\n        back: {\r\n            x: 24/92,\r\n            y: 10/44,\r\n            w: 20/92,\r\n            h: 32/44\r\n        },\r\n        top: {\r\n            x: 2/92,\r\n            y: 42/44,\r\n            w: 20/92,\r\n            h: 2/44\r\n        },\r\n        bottom: {\r\n            x: 22/92,\r\n            y: 42/44,\r\n            w: 20/92,\r\n            h: 2/44\r\n        }\r\n    },\r\n    capeOptifine: {\r\n        right: {\r\n            x: 0,\r\n            y: 10,\r\n            w: 2,\r\n            h: 32\r\n        },\r\n        front: {\r\n            x: 2,\r\n            y: 10,\r\n            w: 20,\r\n            h: 32\r\n        },\r\n        left: {\r\n            x: 22,\r\n            y: 10,\r\n            w: 2,\r\n            h: 32\r\n        },\r\n        back: {\r\n            x: 24,\r\n            y: 10,\r\n            w: 20,\r\n            h: 32\r\n        },\r\n        top: {\r\n            x: 2,\r\n            y: 42,\r\n            w: 20,\r\n            h: 2\r\n        },\r\n        bottom: {\r\n            x: 22,\r\n            y: 42,\r\n            w: 20,\r\n            h: 2\r\n        }\r\n    },\r\n    capeLabymodRelative: {\r\n        right: {\r\n            x: 0,\r\n            y: 0,\r\n            w: 1/22,\r\n            h: 16/17\r\n        },\r\n        front: {\r\n            x: 1/22,\r\n            y: 0,\r\n            w: 10/22,\r\n            h: 16/17\r\n        },\r\n        left: {\r\n            x: 11/22,\r\n            y: 0,\r\n            w: 1/22,\r\n            h: 16/17\r\n        },\r\n        back: {\r\n            x: 12/22,\r\n            y: 0,\r\n            w: 10/22,\r\n            h: 16/17\r\n        },\r\n        top: {\r\n            x: 1/22,\r\n            y: 16/17,\r\n            w: 10/22,\r\n            h: 1/17\r\n        },\r\n        bottom: {\r\n            x: 11/22,\r\n            y: 16/17,\r\n            w: 10/22,\r\n            h: 1/17\r\n        }\r\n    },\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (texturePositions);\r\n\n\n//# sourceURL=webpack:///./src/skin/texturePositions.js?");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 2:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ 3:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack:///util_(ignored)?");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = jQuery;\n\n//# sourceURL=webpack:///external_%22jQuery%22?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = THREE;\n\n//# sourceURL=webpack:///external_%22THREE%22?");

/***/ })

/******/ });