/*!
 * MineRender 1.4.11
 * (c) 2018, Haylee Sch√§fer (inventivetalent) / MIT License
 * https://minerender.org
 * Build #1613813330530 / Sat Feb 20 2021 10:28:50 GMT+0100 (GMT+01:00)
 */
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/skin/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@johh/three-effectcomposer/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _CopyShader = __webpack_require__(/*! ./lib/CopyShader */ \"./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js\");\n\nObject.defineProperty(exports, 'CopyShader', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_CopyShader).default;\n  }\n});\n\nvar _Pass = __webpack_require__(/*! ./lib/Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nObject.defineProperty(exports, 'Pass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_Pass).default;\n  }\n});\n\nvar _ShaderPass = __webpack_require__(/*! ./lib/ShaderPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js\");\n\nObject.defineProperty(exports, 'ShaderPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_ShaderPass).default;\n  }\n});\n\nvar _RenderingPass = __webpack_require__(/*! ./lib/RenderingPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js\");\n\nObject.defineProperty(exports, 'RenderingPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_RenderingPass).default;\n  }\n});\n\nvar _TexturePass = __webpack_require__(/*! ./lib/TexturePass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js\");\n\nObject.defineProperty(exports, 'TexturePass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_TexturePass).default;\n  }\n});\n\nvar _RenderPass = __webpack_require__(/*! ./lib/RenderPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js\");\n\nObject.defineProperty(exports, 'RenderPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_RenderPass).default;\n  }\n});\n\nvar _MaskPass = __webpack_require__(/*! ./lib/MaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js\");\n\nObject.defineProperty(exports, 'MaskPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_MaskPass).default;\n  }\n});\n\nvar _ClearMaskPass = __webpack_require__(/*! ./lib/ClearMaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js\");\n\nObject.defineProperty(exports, 'ClearMaskPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_ClearMaskPass).default;\n  }\n});\n\nvar _ClearPass = __webpack_require__(/*! ./lib/ClearPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js\");\n\nObject.defineProperty(exports, 'ClearPass', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_ClearPass).default;\n  }\n});\n\nvar _EffectComposer = __webpack_require__(/*! ./lib/EffectComposer */ \"./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js\");\n\nObject.defineProperty(exports, 'default', {\n  enumerable: true,\n  get: function get() {\n    return _interopRequireDefault(_EffectComposer).default;\n  }\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/index.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ClearMaskPass = function (_Pass) {\n\t_inherits(ClearMaskPass, _Pass);\n\n\tfunction ClearMaskPass() {\n\t\t_classCallCheck(this, ClearMaskPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (ClearMaskPass.__proto__ || Object.getPrototypeOf(ClearMaskPass)).call(this));\n\n\t\t_this.needsSwap = false;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(ClearMaskPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer) {\n\n\t\t\trenderer.state.buffers.stencil.setTest(false);\n\t\t}\n\t}]);\n\n\treturn ClearMaskPass;\n}(_Pass3.default);\n\nexports.default = ClearMaskPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ClearPass = function (_Pass) {\n\t_inherits(ClearPass, _Pass);\n\n\tfunction ClearPass(clearColor, clearAlpha) {\n\t\t_classCallCheck(this, ClearPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (ClearPass.__proto__ || Object.getPrototypeOf(ClearPass)).call(this));\n\n\t\t_this.needsSwap = false;\n\n\t\t_this.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n\t\t_this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(ClearPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer) {\n\n\t\t\tvar oldClearColor = void 0;\n\t\t\tvar oldClearAlpha = void 0;\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\t\t\trenderer.clear();\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn ClearPass;\n}(_Pass3.default);\n\nexports.default = ClearPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/ClearPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js":
/*!************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = {\n\tuniforms: {\n\n\t\ttDiffuse: { value: null },\n\t\topacity: { value: 1.0 }\n\n\t},\n\n\tvertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\tfragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '\tvec4 texel = texture2D( tDiffuse, vUv );', '\tgl_FragColor = opacity * texel;', '}'].join('\\n')\n};\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _ShaderPass = __webpack_require__(/*! ./ShaderPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js\");\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nvar _CopyShader = __webpack_require__(/*! ./CopyShader */ \"./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js\");\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _MaskPass = __webpack_require__(/*! ./MaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js\");\n\nvar _MaskPass2 = _interopRequireDefault(_MaskPass);\n\nvar _ClearMaskPass = __webpack_require__(/*! ./ClearMaskPass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/ClearMaskPass.js\");\n\nvar _ClearMaskPass2 = _interopRequireDefault(_ClearMaskPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EffectComposer = function () {\n\tfunction EffectComposer(renderer, _renderTarget) {\n\t\t_classCallCheck(this, EffectComposer);\n\n\t\tvar renderTarget = _renderTarget;\n\n\t\tthis.renderer = renderer;\n\n\t\tif (renderTarget === undefined) {\n\n\t\t\tvar parameters = {\n\t\t\t\tminFilter: THREE.LinearFilter,\n\t\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\t\tformat: THREE.RGBAFormat,\n\t\t\t\tstencilBuffer: false\n\t\t\t};\n\n\t\t\tvar size = renderer.getSize(new THREE.Vector2());\n\t\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);\n\n\t\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\t\t} else {\n\n\t\t\tthis._pixelRatio = 1;\n\t\t\tthis._width = renderTarget.width;\n\t\t\tthis._height = renderTarget.height;\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\t\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tthis.renderToScreen = true;\n\n\t\tthis.passes = [];\n\n\t\tthis.copyPass = new _ShaderPass2.default(_CopyShader2.default);\n\n\t\tthis.clock = new THREE.Clock();\n\t}\n\n\t_createClass(EffectComposer, [{\n\t\tkey: 'swapBuffers',\n\t\tvalue: function swapBuffers() {\n\n\t\t\tvar tmp = this.readBuffer;\n\t\t\tthis.readBuffer = this.writeBuffer;\n\t\t\tthis.writeBuffer = tmp;\n\t\t}\n\t}, {\n\t\tkey: 'addPass',\n\t\tvalue: function addPass(pass) {\n\n\t\t\tthis.passes.push(pass);\n\n\t\t\tvar size = this.renderer.getDrawingBufferSize(new THREE.Vector2());\n\t\t\tpass.setSize(size.width, size.height);\n\t\t}\n\t}, {\n\t\tkey: 'insertPass',\n\t\tvalue: function insertPass(pass, index) {\n\n\t\t\tthis.passes.splice(index, 0, pass);\n\t\t}\n\t}, {\n\t\tkey: 'isLastEnabledPass',\n\t\tvalue: function isLastEnabledPass(passIndex) {\n\n\t\t\tfor (var i = passIndex + 1; i < this.passes.length; i += 1) {\n\n\t\t\t\tif (this.passes[i].enabled) {\n\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render() {\n\t\t\tvar deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.clock.getDelta();\n\n\n\t\t\t// deltaTime value is in seconds\n\n\t\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\t\tvar maskActive = false;\n\n\t\t\tvar pass = void 0;\n\t\t\tvar i = void 0;\n\t\t\tvar il = this.passes.length;\n\n\t\t\tfor (i = 0; i < il; i += 1) {\n\n\t\t\t\tpass = this.passes[i];\n\n\t\t\t\tif (pass.enabled !== false) {\n\n\t\t\t\t\tpass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n\t\t\t\t\tpass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n\n\t\t\t\t\tif (pass.needsSwap) {\n\n\t\t\t\t\t\tif (maskActive) {\n\t\t\t\t\t\t\tvar context = this.renderer.context;\n\n\n\t\t\t\t\t\t\tcontext.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n\n\t\t\t\t\t\t\tthis.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);\n\n\t\t\t\t\t\t\tcontext.stencilFunc(context.EQUAL, 1, 0xffffffff);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.swapBuffers();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (pass instanceof _MaskPass2.default) {\n\n\t\t\t\t\tmaskActive = true;\n\t\t\t\t} else if (pass instanceof _ClearMaskPass2.default) {\n\n\t\t\t\t\tmaskActive = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.renderer.setRenderTarget(currentRenderTarget);\n\t\t}\n\t}, {\n\t\tkey: 'reset',\n\t\tvalue: function reset(_renderTarget) {\n\n\t\t\tvar renderTarget = _renderTarget;\n\n\t\t\tif (renderTarget === undefined) {\n\n\t\t\t\tvar size = this.renderer.getSize(new THREE.Vector2());\n\t\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\t\tthis._width = size.width;\n\t\t\t\tthis._height = size.height;\n\n\t\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\t\trenderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);\n\t\t\t}\n\n\t\t\tthis.renderTarget1.dispose();\n\t\t\tthis.renderTarget2.dispose();\n\t\t\tthis.renderTarget1 = renderTarget;\n\t\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\t\tthis.writeBuffer = this.renderTarget1;\n\t\t\tthis.readBuffer = this.renderTarget2;\n\t\t}\n\t}, {\n\t\tkey: 'setSize',\n\t\tvalue: function setSize(width, height) {\n\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\n\t\t\tvar effectiveWidth = this._width * this._pixelRatio;\n\t\t\tvar effectiveHeight = this._height * this._pixelRatio;\n\n\t\t\tthis.renderTarget1.setSize(effectiveWidth, effectiveHeight);\n\t\t\tthis.renderTarget2.setSize(effectiveWidth, effectiveHeight);\n\n\t\t\tfor (var i = 0; i < this.passes.length; i += 1) {\n\n\t\t\t\tthis.passes[i].setSize(effectiveWidth, effectiveHeight);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'setPixelRatio',\n\t\tvalue: function setPixelRatio(pixelRatio) {\n\n\t\t\tthis._pixelRatio = pixelRatio;\n\n\t\t\tthis.setSize(this._width, this._height);\n\t\t}\n\t}]);\n\n\treturn EffectComposer;\n}();\n\nexports.default = EffectComposer;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/EffectComposer.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar MaskPass = function (_Pass) {\n\t_inherits(MaskPass, _Pass);\n\n\tfunction MaskPass(scene, camera) {\n\t\t_classCallCheck(this, MaskPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (MaskPass.__proto__ || Object.getPrototypeOf(MaskPass)).call(this));\n\n\t\t_this.scene = scene;\n\t\t_this.camera = camera;\n\n\t\t_this.clear = true;\n\t\t_this.needsSwap = false;\n\n\t\t_this.inverse = false;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(MaskPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer) {\n\t\t\tvar context = renderer.context,\n\t\t\t    state = renderer.state;\n\n\t\t\t// don't update color or depth\n\n\t\t\tstate.buffers.color.setMask(false);\n\t\t\tstate.buffers.depth.setMask(false);\n\n\t\t\t// lock buffers\n\n\t\t\tstate.buffers.color.setLocked(true);\n\t\t\tstate.buffers.depth.setLocked(true);\n\n\t\t\t// set up stencil\n\n\t\t\tvar writeValue = void 0;\n\t\t\tvar clearValue = void 0;\n\n\t\t\tif (this.inverse) {\n\n\t\t\t\twriteValue = 0;\n\t\t\t\tclearValue = 1;\n\t\t\t} else {\n\n\t\t\t\twriteValue = 1;\n\t\t\t\tclearValue = 0;\n\t\t\t}\n\n\t\t\tstate.buffers.stencil.setTest(true);\n\t\t\tstate.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n\t\t\tstate.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n\t\t\tstate.buffers.stencil.setClear(clearValue);\n\n\t\t\t// draw into the stencil buffer\n\n\t\t\trenderer.setRenderTarget(readBuffer);\n\t\t\tif (this.clear) renderer.clear();\n\t\t\trenderer.render(this.scene, this.camera);\n\n\t\t\trenderer.setRenderTarget(writeBuffer);\n\t\t\tif (this.clear) renderer.clear();\n\t\t\trenderer.render(this.scene, this.camera);\n\n\t\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\t\tstate.buffers.color.setLocked(false);\n\t\t\tstate.buffers.depth.setLocked(false);\n\n\t\t\t// only render where stencil is set to 1\n\n\t\t\tstate.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n\t\t\tstate.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n\t\t}\n\t}]);\n\n\treturn MaskPass;\n}(_Pass3.default);\n\nexports.default = MaskPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/MaskPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js":
/*!******************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* eslint-disable no-underscore-dangle */\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar camera = new _three.OrthographicCamera(-1, 1, 1, -1, 0, 1);\nvar geometry = new _three.PlaneBufferGeometry(2, 2);\n\nvar _FullScreenQuad = function () {\n\tfunction _FullScreenQuad(material) {\n\t\t_classCallCheck(this, _FullScreenQuad);\n\n\t\tthis._mesh = new _three.Mesh(geometry, material);\n\t}\n\n\t_createClass(_FullScreenQuad, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer) {\n\n\t\t\trenderer.render(this._mesh, camera);\n\t\t}\n\t}, {\n\t\tkey: 'material',\n\t\tget: function get() {\n\n\t\t\treturn this._mesh.material;\n\t\t},\n\t\tset: function set(value) {\n\n\t\t\tthis._mesh.material = value;\n\t\t}\n\t}]);\n\n\treturn _FullScreenQuad;\n}();\n\nvar Pass = function () {\n\tfunction Pass() {\n\t\t_classCallCheck(this, Pass);\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\t\tthis.clear = false;\n\t\tthis.renderToScreen = false;\n\t}\n\n\t_createClass(Pass, [{\n\t\tkey: 'setSize',\n\t\tvalue: function setSize(width, height) {}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t\tconsole.error('THREE.Pass: .render() must be implemented in derived pass.');\n\t\t}\n\t}]);\n\n\treturn Pass;\n}();\n\nPass.FullScreenQuad = _FullScreenQuad;\nexports.default = Pass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js":
/*!************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RenderPass = function (_Pass) {\n\t_inherits(RenderPass, _Pass);\n\n\tfunction RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {\n\t\t_classCallCheck(this, RenderPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (RenderPass.__proto__ || Object.getPrototypeOf(RenderPass)).call(this));\n\n\t\t_this.scene = scene;\n\t\t_this.camera = camera;\n\n\t\t_this.overrideMaterial = overrideMaterial;\n\n\t\t_this.clearColor = clearColor;\n\t\t_this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\t\t_this.clear = true;\n\t\t_this.clearDepth = false;\n\t\t_this.needsSwap = false;\n\n\t\treturn _this;\n\t}\n\n\t_createClass(RenderPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(_renderer, writeBuffer, readBuffer) {\n\n\t\t\tvar renderer = _renderer;\n\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t\tvar oldClearColor = void 0;\n\t\t\tvar oldClearAlpha = void 0;\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\t}\n\n\t\t\tif (this.clearDepth) {\n\n\t\t\t\trenderer.clearDepth();\n\t\t\t}\n\n\t\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif (this.clear) {\n\n\t\t\t\trenderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t}\n\t\t\trenderer.render(this.scene, this.camera);\n\n\t\t\tif (this.clearColor) {\n\n\t\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t\t}\n\n\t\t\tthis.scene.overrideMaterial = null;\n\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\t}]);\n\n\treturn RenderPass;\n}(_Pass3.default);\n\nexports.default = RenderPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/RenderPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar RenderingPass = function (_Pass) {\n\t_inherits(RenderingPass, _Pass);\n\n\tfunction RenderingPass() {\n\t\t_classCallCheck(this, RenderingPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (RenderingPass.__proto__ || Object.getPrototypeOf(RenderingPass)).call(this));\n\n\t\t_this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\t\t_this.scene = new THREE.Scene();\n\t\t_this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\t\t_this.quad.frustumCulled = false;\n\t\t_this.scene.add(_this.quad);\n\n\t\treturn _this;\n\t}\n\n\treturn RenderingPass;\n}(_Pass3.default);\n\nexports.default = RenderingPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/RenderingPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js":
/*!************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ShaderPass = function (_Pass) {\n\t_inherits(ShaderPass, _Pass);\n\n\tfunction ShaderPass(shader, textureID) {\n\t\t_classCallCheck(this, ShaderPass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (ShaderPass.__proto__ || Object.getPrototypeOf(ShaderPass)).call(this));\n\n\t\t_this.textureID = textureID !== undefined ? textureID : 'tDiffuse';\n\n\t\tif (shader instanceof THREE.ShaderMaterial) {\n\n\t\t\t_this.uniforms = shader.uniforms;\n\n\t\t\t_this.material = shader;\n\t\t} else if (shader) {\n\n\t\t\t_this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t\t_this.material = new THREE.ShaderMaterial({\n\n\t\t\t\tdefines: Object.assign({}, shader.defines),\n\t\t\t\tuniforms: _this.uniforms,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t});\n\t\t}\n\n\t\t_this.fsQuad = new _Pass3.default.FullScreenQuad(_this.material);\n\n\t\treturn _this;\n\t}\n\n\t_createClass(ShaderPass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(renderer, writeBuffer, readBuffer) {\n\n\t\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t\t}\n\n\t\t\tthis.fsQuad.material = this.material;\n\n\t\t\tif (this.renderToScreen) {\n\n\t\t\t\trenderer.setRenderTarget(null);\n\t\t\t\tthis.fsQuad.render(renderer);\n\t\t\t} else {\n\n\t\t\t\trenderer.setRenderTarget(writeBuffer);\n\t\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\t\tif (this.clear) {\n\n\t\t\t\t\trenderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t\t}\n\t\t\t\tthis.fsQuad.render(renderer);\n\t\t\t}\n\t\t}\n\t}]);\n\n\treturn ShaderPass;\n}(_Pass3.default);\n\nexports.default = ShaderPass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/ShaderPass.js?");

/***/ }),

/***/ "./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _three = __webpack_require__(/*! three */ \"three\");\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass2 = __webpack_require__(/*! ./Pass */ \"./node_modules/@johh/three-effectcomposer/dist/lib/Pass.js\");\n\nvar _Pass3 = _interopRequireDefault(_Pass2);\n\nvar _CopyShader = __webpack_require__(/*! ./CopyShader */ \"./node_modules/@johh/three-effectcomposer/dist/lib/CopyShader.js\");\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TexturePass = function (_Pass) {\n\t_inherits(TexturePass, _Pass);\n\n\tfunction TexturePass(map, opacity) {\n\t\t_classCallCheck(this, TexturePass);\n\n\t\tvar _this = _possibleConstructorReturn(this, (TexturePass.__proto__ || Object.getPrototypeOf(TexturePass)).call(this));\n\n\t\tvar shader = _CopyShader2.default;\n\n\t\t_this.map = map;\n\t\t_this.opacity = opacity !== undefined ? opacity : 1.0;\n\n\t\t_this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t_this.material = new THREE.ShaderMaterial({\n\n\t\t\tuniforms: _this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\n\t\t});\n\n\t\t_this.needsSwap = false;\n\n\t\t_this.fsQuad = new _Pass3.default.FullScreenQuad(null);\n\n\t\treturn _this;\n\t}\n\n\t_createClass(TexturePass, [{\n\t\tkey: 'render',\n\t\tvalue: function render(_renderer, writeBuffer, readBuffer) {\n\n\t\t\tvar renderer = _renderer;\n\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\trenderer.autoClear = false;\n\n\t\t\tthis.fsQuad.material = this.material;\n\n\t\t\tthis.uniforms.opacity.value = this.opacity;\n\t\t\tthis.uniforms.tDiffuse.value = this.map;\n\t\t\tthis.material.transparent = this.opacity < 1.0;\n\n\t\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\t\t\tif (this.clear) renderer.clear();\n\t\t\tthis.fsQuad.render(renderer);\n\n\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\t}]);\n\n\treturn TexturePass;\n}(_Pass3.default);\n\nexports.default = TexturePass;\n\n//# sourceURL=webpack:///./node_modules/@johh/three-effectcomposer/dist/lib/TexturePass.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/process/browser.js */ \"./node_modules/node-libs-browser/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack:///./node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n//# sourceURL=webpack:///./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/process/browser.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/process/browser.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/node-libs-browser/node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/onscreen/dist/on-screen.umd.js":
/*!*****************************************************!*\
  !*** ./node_modules/onscreen/dist/on-screen.umd.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  /**\n   * Attaches the scroll event handler\n   *\n   * @return {void}\n   */\n  function attach() {\n      var container = this.options.container;\n\n      if (container instanceof HTMLElement) {\n          var style = window.getComputedStyle(container);\n\n          if (style.position === 'static') {\n              container.style.position = 'relative';\n          }\n      }\n\n      container.addEventListener('scroll', this._scroll, { passive: true });\n      window.addEventListener('resize', this._scroll, { passive: true });\n      this._scroll();\n      this.attached = true;\n  }\n\n  /**\n   * Checks an element's position in respect to the viewport\n   * and determines wether it's inside the viewport.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the viewport.\n   */\n  function inViewport(el) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { tolerance: 0 };\n\n      if (!el) {\n          throw new Error('You should specify the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n\n      var elRect = el.getBoundingClientRect();\n\n      return (\n          // Check bottom boundary\n          elRect.bottom - options.tolerance > 0 &&\n\n          // Check right boundary\n          elRect.right - options.tolerance > 0 &&\n\n          // Check left boundary\n          elRect.left + options.tolerance < (window.innerWidth || document.documentElement.clientWidth) &&\n\n          // Check top boundary\n          elRect.top + options.tolerance < (window.innerHeight || document.documentElement.clientHeight)\n      );\n  }\n\n  /**\n   * Checks an element's position in respect to a HTMLElement\n   * and determines wether it's within its boundaries.\n   *\n   * @param {node} element The DOM node you want to check\n   * @return {boolean} A boolean value that indicates wether is on or off the container.\n   */\n  function inContainer(el) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { tolerance: 0, container: '' };\n\n      if (!el) {\n          throw new Error('You should specify the element you want to test');\n      }\n\n      if (typeof el === 'string') {\n          el = document.querySelector(el);\n      }\n      if (typeof options === 'string') {\n          options = {\n              tolerance: 0,\n              container: document.querySelector(options)\n          };\n      }\n      if (typeof options.container === 'string') {\n          options.container = document.querySelector(options.container);\n      }\n      if (options instanceof HTMLElement) {\n          options = {\n              tolerance: 0,\n              container: options\n          };\n      }\n      if (!options.container) {\n          throw new Error('You should specify a container element');\n      }\n\n      var containerRect = options.container.getBoundingClientRect();\n\n      return (\n          // // Check bottom boundary\n          el.offsetTop + el.clientHeight - options.tolerance > options.container.scrollTop &&\n\n          // Check right boundary\n          el.offsetLeft + el.clientWidth - options.tolerance > options.container.scrollLeft &&\n\n          // Check left boundary\n          el.offsetLeft + options.tolerance < containerRect.width + options.container.scrollLeft &&\n\n          // // Check top boundary\n          el.offsetTop + options.tolerance < containerRect.height + options.container.scrollTop\n      );\n  }\n\n  // TODO: Refactor this so it can be easily tested\n  /* istanbul ignore next */\n  function eventHandler() {\n      var trackedElements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { tolerance: 0 };\n\n      var selectors = Object.keys(trackedElements);\n      var testVisibility = void 0;\n\n      if (!selectors.length) return;\n\n      if (options.container === window) {\n          testVisibility = inViewport;\n      } else {\n          testVisibility = inContainer;\n      }\n\n      selectors.forEach(function (selector) {\n          trackedElements[selector].nodes.forEach(function (item) {\n              if (testVisibility(item.node, options)) {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = true;\n              } else {\n                  item.wasVisible = item.isVisible;\n                  item.isVisible = false;\n              }\n              if (item.isVisible === true && item.wasVisible === false) {\n                  if (!trackedElements[selector].enter) return;\n\n                  Object.keys(trackedElements[selector].enter).forEach(function (callback) {\n                      if (typeof trackedElements[selector].enter[callback] === 'function') {\n                          trackedElements[selector].enter[callback](item.node, 'enter');\n                      }\n                  });\n              }\n              if (item.isVisible === false && item.wasVisible === true) {\n                  if (!trackedElements[selector].leave) return;\n\n                  Object.keys(trackedElements[selector].leave).forEach(function (callback) {\n                      if (typeof trackedElements[selector].leave[callback] === 'function') {\n                          trackedElements[selector].leave[callback](item.node, 'leave');\n                      }\n                  });\n              }\n          });\n      });\n  }\n\n  /**\n   * Debounces the scroll event to avoid performance issues\n   *\n   * @return {void}\n   */\n  function debouncedScroll() {\n      var _this = this;\n\n      var timeout = void 0;\n\n      return function () {\n          clearTimeout(timeout);\n\n          timeout = setTimeout(function () {\n              eventHandler(_this.trackedElements, _this.options);\n          }, _this.options.debounce);\n      };\n  }\n\n  /**\n   * Removes the scroll event handler\n   *\n   * @return {void}\n   */\n  function destroy() {\n    this.options.container.removeEventListener('scroll', this._scroll);\n    window.removeEventListener('resize', this._scroll);\n    this.attached = false;\n  }\n\n  /**\n   * Stops tracking elements matching a CSS selector. If a selector has no\n   * callbacks it gets removed.\n   *\n   * @param {string} event The event you want to stop tracking (enter or leave)\n   * @param {string} selector The CSS selector you want to stop tracking\n   * @return {void}\n   */\n  function off(event, selector, handler) {\n      var enterCallbacks = Object.keys(this.trackedElements[selector].enter || {});\n      var leaveCallbacks = Object.keys(this.trackedElements[selector].leave || {});\n\n      if ({}.hasOwnProperty.call(this.trackedElements, selector)) {\n          if (handler) {\n              if (this.trackedElements[selector][event]) {\n                  var callbackName = typeof handler === 'function' ? handler.name : handler;\n                  delete this.trackedElements[selector][event][callbackName];\n              }\n          } else {\n              delete this.trackedElements[selector][event];\n          }\n      }\n\n      if (!enterCallbacks.length && !leaveCallbacks.length) {\n          delete this.trackedElements[selector];\n      }\n  }\n\n  /**\n   * Starts tracking elements matching a CSS selector\n   *\n   * @param {string} event The event you want to track (enter or leave)\n   * @param {string} selector The element you want to track\n   * @param {function} callback The callback function to handle the event\n   * @return {void}\n   */\n  function on(event, selector, callback) {\n      var allowed = ['enter', 'leave'];\n\n      if (!event) throw new Error('No event given. Choose either enter or leave');\n      if (!selector) throw new Error('No selector to track');\n      if (allowed.indexOf(event) < 0) throw new Error(event + ' event is not supported');\n\n      if (!{}.hasOwnProperty.call(this.trackedElements, selector)) {\n          this.trackedElements[selector] = {};\n      }\n\n      this.trackedElements[selector].nodes = [];\n\n      for (var i = 0, elems = document.querySelectorAll(selector); i < elems.length; i++) {\n          var item = {\n              isVisible: false,\n              wasVisible: false,\n              node: elems[i]\n          };\n\n          this.trackedElements[selector].nodes.push(item);\n      }\n\n      if (typeof callback === 'function') {\n          if (!this.trackedElements[selector][event]) {\n              this.trackedElements[selector][event] = {};\n          }\n\n          this.trackedElements[selector][event][callback.name || 'anonymous'] = callback;\n      }\n  }\n\n  /**\n   * Observes DOM mutations and runs a callback function when\n   * detecting one.\n   *\n   * @param {node} obj The DOM node you want to observe\n   * @param {function} callback The callback function you want to call\n   * @return {void}\n   */\n  function observeDOM(obj, callback) {\n      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n\n      /* istanbul ignore else */\n      if (MutationObserver) {\n          var obs = new MutationObserver(callback);\n\n          obs.observe(obj, {\n              childList: true,\n              subtree: true\n          });\n      } else {\n          obj.addEventListener('DOMNodeInserted', callback, false);\n          obj.addEventListener('DOMNodeRemoved', callback, false);\n      }\n  }\n\n  /**\n   * Detects wether DOM nodes enter or leave the viewport\n   *\n   * @constructor\n   * @param {object} options The configuration object\n   */\n  function OnScreen() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { tolerance: 0, debounce: 100, container: window };\n\n      this.options = {};\n      this.trackedElements = {};\n\n      Object.defineProperties(this.options, {\n          container: {\n              configurable: false,\n              enumerable: false,\n              get: function get() {\n                  var container = void 0;\n\n                  if (typeof options.container === 'string') {\n                      container = document.querySelector(options.container);\n                  } else if (options.container instanceof HTMLElement) {\n                      container = options.container;\n                  }\n\n                  return container || window;\n              },\n              set: function set(value) {\n                  options.container = value;\n              }\n          },\n          debounce: {\n              get: function get() {\n                  return parseInt(options.debounce, 10) || 100;\n              },\n              set: function set(value) {\n                  options.debounce = value;\n              }\n          },\n          tolerance: {\n              get: function get() {\n                  return parseInt(options.tolerance, 10) || 0;\n              },\n              set: function set(value) {\n                  options.tolerance = value;\n              }\n          }\n      });\n\n      Object.defineProperty(this, '_scroll', {\n          enumerable: false,\n          configurable: false,\n          writable: false,\n          value: this._debouncedScroll.call(this)\n      });\n\n      observeDOM(document.querySelector('body'), function () {\n          Object.keys(_this.trackedElements).forEach(function (element) {\n              _this.on('enter', element);\n              _this.on('leave', element);\n          });\n      });\n\n      this.attach();\n  }\n\n  Object.defineProperties(OnScreen.prototype, {\n      _debouncedScroll: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: debouncedScroll\n      },\n      attach: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: attach\n      },\n      destroy: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: destroy\n      },\n      off: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: off\n      },\n      on: {\n          configurable: false,\n          writable: false,\n          enumerable: false,\n          value: on\n      }\n  });\n\n  OnScreen.check = inViewport;\n\n  return OnScreen;\n\n}));\n//# sourceMappingURL=on-screen.umd.js.map\n\n\n//# sourceURL=webpack:///./node_modules/onscreen/dist/on-screen.umd.js?");

/***/ }),

/***/ "./node_modules/stats.js/build/stats.min.js":
/*!**************************************************!*\
  !*** ./node_modules/stats.js/build/stats.min.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// stats.js - http://github.com/mrdoob/stats.js\n(function(f,e){ true?module.exports=e():undefined})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?\"block\":\"none\";l=a}var l=0,c=document.createElement(\"div\");c.style.cssText=\"position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000\";c.addEventListener(\"click\",function(a){a.preventDefault();\nu(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel(\"FPS\",\"#0ff\",\"#002\")),h=e(new f.Panel(\"MS\",\"#0f0\",\"#020\"));if(self.performance&&self.performance.memory)var t=e(new f.Panel(\"MB\",\"#f08\",\"#201\"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/\n1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement(\"canvas\");q.width=r;q.height=h;q.style.cssText=\"width:80px;height:48px\";var b=q.getContext(\"2d\");b.font=\"bold \"+9*a+\"px Helvetica,Arial,sans-serif\";b.textBaseline=\"top\";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);\nb.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+\" \"+e+\" (\"+g(c)+\"-\"+g(k)+\")\",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});\n\n\n//# sourceURL=webpack:///./node_modules/stats.js/build/stats.min.js?");

/***/ }),

/***/ "./node_modules/threejs-ext/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/threejs-ext/dist/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * The three.js expansion library v0.92.0\n * Collected by Jusfoun Visualization Department\n * Contact: \n *   vis@jusfoun.com\n *   http://vis.jusfoun.com\n *   http://jusfoun-vis.github.io\n * \n * Copyright (c) 2018, Jusfoun Big Data Group Inc.\n * All rights reserved.\n * \n * LICENSE\n * http://www.jusfoun.com/software/LICENSE.txt\n * \n * The three.js LICENSE\n * http://threejs.org/license\n */\n(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 27);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __webpack_require__(/*! three */ \"three\");\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n */\nvar Pass = function Pass() {\n\n  // if set to true, the pass is processed by the composer\n  this.enabled = true;\n\n  // if set to true, the pass indicates to swap read and write buffer after rendering\n  this.needsSwap = true;\n\n  // if set to true, the pass clears its buffer before rendering\n  this.clear = false;\n\n  // if set to true, the result of the pass is rendered to screen\n  this.renderToScreen = false;\n};\n\nObject.assign(Pass.prototype, {\n\n  setSize: function setSize(width, height) {},\n\n  render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n    console.error('THREE.Pass: .render() must be implemented in derived pass.');\n  }\n\n});\n\nexports.default = Pass;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Full-screen textured quad shader\n */\n\nvar CopyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = opacity * texel;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = CopyShader;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar ShaderPass = function ShaderPass(shader, textureID) {\n\n\t_Pass2.default.call(this);\n\n\tthis.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\n\tif (shader instanceof THREE.ShaderMaterial) {\n\n\t\tthis.uniforms = shader.uniforms;\n\n\t\tthis.material = shader;\n\t} else if (shader) {\n\n\t\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\tthis.material = new THREE.ShaderMaterial({\n\n\t\t\tdefines: Object.assign({}, shader.defines),\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t});\n\t}\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nShaderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: ShaderPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t}\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n\n});\n\nexports.default = ShaderPass;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\n/**\r\n * @author Takahiro / https://github.com/takahirox\r\n *\r\n * Simple CharsetEncoder.\r\n */\r\n\r\nfunction CharsetEncoder() {\r\n}\r\n\r\n/*\r\n * Converts from Shift_JIS Uint8Array data to Unicode strings.\r\n */\r\nCharsetEncoder.prototype.s2u = function(uint8Array) {\r\n  var t = this.s2uTable;\r\n  var str = '';\r\n  var p = 0;\r\n\r\n  while(p < uint8Array.length) {\r\n    var key = uint8Array[p++];\r\n\r\n    if(! ((key >= 0x00 && key <= 0x7e) ||\r\n          (key >= 0xa1 && key <= 0xdf)) &&\r\n       p < uint8Array.length) {\r\n      key = (key << 8) | uint8Array[p++];\r\n    }\r\n\r\n    if(t[key] === undefined) {\r\n      throw 'unknown char code ' + key + '.';\r\n    }\r\n\r\n    str += String.fromCharCode(t[key]);\r\n  }\r\n\r\n  return str;\r\n};\r\n\r\nCharsetEncoder.prototype.s2uTable = {\r\n0:0,\r\n1:1,\r\n2:2,\r\n3:3,\r\n4:4,\r\n5:5,\r\n6:6,\r\n7:7,\r\n8:8,\r\n9:9,\r\n10:10,\r\n11:11,\r\n12:12,\r\n13:13,\r\n14:14,\r\n15:15,\r\n16:16,\r\n17:17,\r\n18:18,\r\n19:19,\r\n20:20,\r\n21:21,\r\n22:22,\r\n23:23,\r\n24:24,\r\n25:25,\r\n26:26,\r\n27:27,\r\n28:28,\r\n29:29,\r\n30:30,\r\n31:31,\r\n32:32,\r\n33:33,\r\n34:34,\r\n35:35,\r\n36:36,\r\n37:37,\r\n38:38,\r\n39:39,\r\n40:40,\r\n41:41,\r\n42:42,\r\n43:43,\r\n44:44,\r\n45:45,\r\n46:46,\r\n47:47,\r\n48:48,\r\n49:49,\r\n50:50,\r\n51:51,\r\n52:52,\r\n53:53,\r\n54:54,\r\n55:55,\r\n56:56,\r\n57:57,\r\n58:58,\r\n59:59,\r\n60:60,\r\n61:61,\r\n62:62,\r\n63:63,\r\n64:64,\r\n65:65,\r\n66:66,\r\n67:67,\r\n68:68,\r\n69:69,\r\n70:70,\r\n71:71,\r\n72:72,\r\n73:73,\r\n74:74,\r\n75:75,\r\n76:76,\r\n77:77,\r\n78:78,\r\n79:79,\r\n80:80,\r\n81:81,\r\n82:82,\r\n83:83,\r\n84:84,\r\n85:85,\r\n86:86,\r\n87:87,\r\n88:88,\r\n89:89,\r\n90:90,\r\n91:91,\r\n92:92,\r\n93:93,\r\n94:94,\r\n95:95,\r\n96:96,\r\n97:97,\r\n98:98,\r\n99:99,\r\n100:100,\r\n101:101,\r\n102:102,\r\n103:103,\r\n104:104,\r\n105:105,\r\n106:106,\r\n107:107,\r\n108:108,\r\n109:109,\r\n110:110,\r\n111:111,\r\n112:112,\r\n113:113,\r\n114:114,\r\n115:115,\r\n116:116,\r\n117:117,\r\n118:118,\r\n119:119,\r\n120:120,\r\n121:121,\r\n122:122,\r\n123:123,\r\n124:124,\r\n125:125,\r\n126:126,\r\n161:65377,\r\n162:65378,\r\n163:65379,\r\n164:65380,\r\n165:65381,\r\n166:65382,\r\n167:65383,\r\n168:65384,\r\n169:65385,\r\n170:65386,\r\n171:65387,\r\n172:65388,\r\n173:65389,\r\n174:65390,\r\n175:65391,\r\n176:65392,\r\n177:65393,\r\n178:65394,\r\n179:65395,\r\n180:65396,\r\n181:65397,\r\n182:65398,\r\n183:65399,\r\n184:65400,\r\n185:65401,\r\n186:65402,\r\n187:65403,\r\n188:65404,\r\n189:65405,\r\n190:65406,\r\n191:65407,\r\n192:65408,\r\n193:65409,\r\n194:65410,\r\n195:65411,\r\n196:65412,\r\n197:65413,\r\n198:65414,\r\n199:65415,\r\n200:65416,\r\n201:65417,\r\n202:65418,\r\n203:65419,\r\n204:65420,\r\n205:65421,\r\n206:65422,\r\n207:65423,\r\n208:65424,\r\n209:65425,\r\n210:65426,\r\n211:65427,\r\n212:65428,\r\n213:65429,\r\n214:65430,\r\n215:65431,\r\n216:65432,\r\n217:65433,\r\n218:65434,\r\n219:65435,\r\n220:65436,\r\n221:65437,\r\n222:65438,\r\n223:65439,\r\n33088:12288,\r\n33089:12289,\r\n33090:12290,\r\n33091:65292,\r\n33092:65294,\r\n33093:12539,\r\n33094:65306,\r\n33095:65307,\r\n33096:65311,\r\n33097:65281,\r\n33098:12443,\r\n33099:12444,\r\n33100:180,\r\n33101:65344,\r\n33102:168,\r\n33103:65342,\r\n33104:65507,\r\n33105:65343,\r\n33106:12541,\r\n33107:12542,\r\n33108:12445,\r\n33109:12446,\r\n33110:12291,\r\n33111:20189,\r\n33112:12293,\r\n33113:12294,\r\n33114:12295,\r\n33115:12540,\r\n33116:8213,\r\n33117:8208,\r\n33118:65295,\r\n33119:65340,\r\n33120:65374,\r\n33121:8741,\r\n33122:65372,\r\n33123:8230,\r\n33124:8229,\r\n33125:8216,\r\n33126:8217,\r\n33127:8220,\r\n33128:8221,\r\n33129:65288,\r\n33130:65289,\r\n33131:12308,\r\n33132:12309,\r\n33133:65339,\r\n33134:65341,\r\n33135:65371,\r\n33136:65373,\r\n33137:12296,\r\n33138:12297,\r\n33139:12298,\r\n33140:12299,\r\n33141:12300,\r\n33142:12301,\r\n33143:12302,\r\n33144:12303,\r\n33145:12304,\r\n33146:12305,\r\n33147:65291,\r\n33148:65293,\r\n33149:177,\r\n33150:215,\r\n33152:247,\r\n33153:65309,\r\n33154:8800,\r\n33155:65308,\r\n33156:65310,\r\n33157:8806,\r\n33158:8807,\r\n33159:8734,\r\n33160:8756,\r\n33161:9794,\r\n33162:9792,\r\n33163:176,\r\n33164:8242,\r\n33165:8243,\r\n33166:8451,\r\n33167:65509,\r\n33168:65284,\r\n33169:65504,\r\n33170:65505,\r\n33171:65285,\r\n33172:65283,\r\n33173:65286,\r\n33174:65290,\r\n33175:65312,\r\n33176:167,\r\n33177:9734,\r\n33178:9733,\r\n33179:9675,\r\n33180:9679,\r\n33181:9678,\r\n33182:9671,\r\n33183:9670,\r\n33184:9633,\r\n33185:9632,\r\n33186:9651,\r\n33187:9650,\r\n33188:9661,\r\n33189:9660,\r\n33190:8251,\r\n33191:12306,\r\n33192:8594,\r\n33193:8592,\r\n33194:8593,\r\n33195:8595,\r\n33196:12307,\r\n33208:8712,\r\n33209:8715,\r\n33210:8838,\r\n33211:8839,\r\n33212:8834,\r\n33213:8835,\r\n33214:8746,\r\n33215:8745,\r\n33224:8743,\r\n33225:8744,\r\n33226:65506,\r\n33227:8658,\r\n33228:8660,\r\n33229:8704,\r\n33230:8707,\r\n33242:8736,\r\n33243:8869,\r\n33244:8978,\r\n33245:8706,\r\n33246:8711,\r\n33247:8801,\r\n33248:8786,\r\n33249:8810,\r\n33250:8811,\r\n33251:8730,\r\n33252:8765,\r\n33253:8733,\r\n33254:8757,\r\n33255:8747,\r\n33256:8748,\r\n33264:8491,\r\n33265:8240,\r\n33266:9839,\r\n33267:9837,\r\n33268:9834,\r\n33269:8224,\r\n33270:8225,\r\n33271:182,\r\n33276:9711,\r\n33359:65296,\r\n33360:65297,\r\n33361:65298,\r\n33362:65299,\r\n33363:65300,\r\n33364:65301,\r\n33365:65302,\r\n33366:65303,\r\n33367:65304,\r\n33368:65305,\r\n33376:65313,\r\n33377:65314,\r\n33378:65315,\r\n33379:65316,\r\n33380:65317,\r\n33381:65318,\r\n33382:65319,\r\n33383:65320,\r\n33384:65321,\r\n33385:65322,\r\n33386:65323,\r\n33387:65324,\r\n33388:65325,\r\n33389:65326,\r\n33390:65327,\r\n33391:65328,\r\n33392:65329,\r\n33393:65330,\r\n33394:65331,\r\n33395:65332,\r\n33396:65333,\r\n33397:65334,\r\n33398:65335,\r\n33399:65336,\r\n33400:65337,\r\n33401:65338,\r\n33409:65345,\r\n33410:65346,\r\n33411:65347,\r\n33412:65348,\r\n33413:65349,\r\n33414:65350,\r\n33415:65351,\r\n33416:65352,\r\n33417:65353,\r\n33418:65354,\r\n33419:65355,\r\n33420:65356,\r\n33421:65357,\r\n33422:65358,\r\n33423:65359,\r\n33424:65360,\r\n33425:65361,\r\n33426:65362,\r\n33427:65363,\r\n33428:65364,\r\n33429:65365,\r\n33430:65366,\r\n33431:65367,\r\n33432:65368,\r\n33433:65369,\r\n33434:65370,\r\n33439:12353,\r\n33440:12354,\r\n33441:12355,\r\n33442:12356,\r\n33443:12357,\r\n33444:12358,\r\n33445:12359,\r\n33446:12360,\r\n33447:12361,\r\n33448:12362,\r\n33449:12363,\r\n33450:12364,\r\n33451:12365,\r\n33452:12366,\r\n33453:12367,\r\n33454:12368,\r\n33455:12369,\r\n33456:12370,\r\n33457:12371,\r\n33458:12372,\r\n33459:12373,\r\n33460:12374,\r\n33461:12375,\r\n33462:12376,\r\n33463:12377,\r\n33464:12378,\r\n33465:12379,\r\n33466:12380,\r\n33467:12381,\r\n33468:12382,\r\n33469:12383,\r\n33470:12384,\r\n33471:12385,\r\n33472:12386,\r\n33473:12387,\r\n33474:12388,\r\n33475:12389,\r\n33476:12390,\r\n33477:12391,\r\n33478:12392,\r\n33479:12393,\r\n33480:12394,\r\n33481:12395,\r\n33482:12396,\r\n33483:12397,\r\n33484:12398,\r\n33485:12399,\r\n33486:12400,\r\n33487:12401,\r\n33488:12402,\r\n33489:12403,\r\n33490:12404,\r\n33491:12405,\r\n33492:12406,\r\n33493:12407,\r\n33494:12408,\r\n33495:12409,\r\n33496:12410,\r\n33497:12411,\r\n33498:12412,\r\n33499:12413,\r\n33500:12414,\r\n33501:12415,\r\n33502:12416,\r\n33503:12417,\r\n33504:12418,\r\n33505:12419,\r\n33506:12420,\r\n33507:12421,\r\n33508:12422,\r\n33509:12423,\r\n33510:12424,\r\n33511:12425,\r\n33512:12426,\r\n33513:12427,\r\n33514:12428,\r\n33515:12429,\r\n33516:12430,\r\n33517:12431,\r\n33518:12432,\r\n33519:12433,\r\n33520:12434,\r\n33521:12435,\r\n33600:12449,\r\n33601:12450,\r\n33602:12451,\r\n33603:12452,\r\n33604:12453,\r\n33605:12454,\r\n33606:12455,\r\n33607:12456,\r\n33608:12457,\r\n33609:12458,\r\n33610:12459,\r\n33611:12460,\r\n33612:12461,\r\n33613:12462,\r\n33614:12463,\r\n33615:12464,\r\n33616:12465,\r\n33617:12466,\r\n33618:12467,\r\n33619:12468,\r\n33620:12469,\r\n33621:12470,\r\n33622:12471,\r\n33623:12472,\r\n33624:12473,\r\n33625:12474,\r\n33626:12475,\r\n33627:12476,\r\n33628:12477,\r\n33629:12478,\r\n33630:12479,\r\n33631:12480,\r\n33632:12481,\r\n33633:12482,\r\n33634:12483,\r\n33635:12484,\r\n33636:12485,\r\n33637:12486,\r\n33638:12487,\r\n33639:12488,\r\n33640:12489,\r\n33641:12490,\r\n33642:12491,\r\n33643:12492,\r\n33644:12493,\r\n33645:12494,\r\n33646:12495,\r\n33647:12496,\r\n33648:12497,\r\n33649:12498,\r\n33650:12499,\r\n33651:12500,\r\n33652:12501,\r\n33653:12502,\r\n33654:12503,\r\n33655:12504,\r\n33656:12505,\r\n33657:12506,\r\n33658:12507,\r\n33659:12508,\r\n33660:12509,\r\n33661:12510,\r\n33662:12511,\r\n33664:12512,\r\n33665:12513,\r\n33666:12514,\r\n33667:12515,\r\n33668:12516,\r\n33669:12517,\r\n33670:12518,\r\n33671:12519,\r\n33672:12520,\r\n33673:12521,\r\n33674:12522,\r\n33675:12523,\r\n33676:12524,\r\n33677:12525,\r\n33678:12526,\r\n33679:12527,\r\n33680:12528,\r\n33681:12529,\r\n33682:12530,\r\n33683:12531,\r\n33684:12532,\r\n33685:12533,\r\n33686:12534,\r\n33695:913,\r\n33696:914,\r\n33697:915,\r\n33698:916,\r\n33699:917,\r\n33700:918,\r\n33701:919,\r\n33702:920,\r\n33703:921,\r\n33704:922,\r\n33705:923,\r\n33706:924,\r\n33707:925,\r\n33708:926,\r\n33709:927,\r\n33710:928,\r\n33711:929,\r\n33712:931,\r\n33713:932,\r\n33714:933,\r\n33715:934,\r\n33716:935,\r\n33717:936,\r\n33718:937,\r\n33727:945,\r\n33728:946,\r\n33729:947,\r\n33730:948,\r\n33731:949,\r\n33732:950,\r\n33733:951,\r\n33734:952,\r\n33735:953,\r\n33736:954,\r\n33737:955,\r\n33738:956,\r\n33739:957,\r\n33740:958,\r\n33741:959,\r\n33742:960,\r\n33743:961,\r\n33744:963,\r\n33745:964,\r\n33746:965,\r\n33747:966,\r\n33748:967,\r\n33749:968,\r\n33750:969,\r\n33856:1040,\r\n33857:1041,\r\n33858:1042,\r\n33859:1043,\r\n33860:1044,\r\n33861:1045,\r\n33862:1025,\r\n33863:1046,\r\n33864:1047,\r\n33865:1048,\r\n33866:1049,\r\n33867:1050,\r\n33868:1051,\r\n33869:1052,\r\n33870:1053,\r\n33871:1054,\r\n33872:1055,\r\n33873:1056,\r\n33874:1057,\r\n33875:1058,\r\n33876:1059,\r\n33877:1060,\r\n33878:1061,\r\n33879:1062,\r\n33880:1063,\r\n33881:1064,\r\n33882:1065,\r\n33883:1066,\r\n33884:1067,\r\n33885:1068,\r\n33886:1069,\r\n33887:1070,\r\n33888:1071,\r\n33904:1072,\r\n33905:1073,\r\n33906:1074,\r\n33907:1075,\r\n33908:1076,\r\n33909:1077,\r\n33910:1105,\r\n33911:1078,\r\n33912:1079,\r\n33913:1080,\r\n33914:1081,\r\n33915:1082,\r\n33916:1083,\r\n33917:1084,\r\n33918:1085,\r\n33920:1086,\r\n33921:1087,\r\n33922:1088,\r\n33923:1089,\r\n33924:1090,\r\n33925:1091,\r\n33926:1092,\r\n33927:1093,\r\n33928:1094,\r\n33929:1095,\r\n33930:1096,\r\n33931:1097,\r\n33932:1098,\r\n33933:1099,\r\n33934:1100,\r\n33935:1101,\r\n33936:1102,\r\n33937:1103,\r\n33951:9472,\r\n33952:9474,\r\n33953:9484,\r\n33954:9488,\r\n33955:9496,\r\n33956:9492,\r\n33957:9500,\r\n33958:9516,\r\n33959:9508,\r\n33960:9524,\r\n33961:9532,\r\n33962:9473,\r\n33963:9475,\r\n33964:9487,\r\n33965:9491,\r\n33966:9499,\r\n33967:9495,\r\n33968:9507,\r\n33969:9523,\r\n33970:9515,\r\n33971:9531,\r\n33972:9547,\r\n33973:9504,\r\n33974:9519,\r\n33975:9512,\r\n33976:9527,\r\n33977:9535,\r\n33978:9501,\r\n33979:9520,\r\n33980:9509,\r\n33981:9528,\r\n33982:9538,\r\n34624:9312,\r\n34625:9313,\r\n34626:9314,\r\n34627:9315,\r\n34628:9316,\r\n34629:9317,\r\n34630:9318,\r\n34631:9319,\r\n34632:9320,\r\n34633:9321,\r\n34634:9322,\r\n34635:9323,\r\n34636:9324,\r\n34637:9325,\r\n34638:9326,\r\n34639:9327,\r\n34640:9328,\r\n34641:9329,\r\n34642:9330,\r\n34643:9331,\r\n34644:8544,\r\n34645:8545,\r\n34646:8546,\r\n34647:8547,\r\n34648:8548,\r\n34649:8549,\r\n34650:8550,\r\n34651:8551,\r\n34652:8552,\r\n34653:8553,\r\n34655:13129,\r\n34656:13076,\r\n34657:13090,\r\n34658:13133,\r\n34659:13080,\r\n34660:13095,\r\n34661:13059,\r\n34662:13110,\r\n34663:13137,\r\n34664:13143,\r\n34665:13069,\r\n34666:13094,\r\n34667:13091,\r\n34668:13099,\r\n34669:13130,\r\n34670:13115,\r\n34671:13212,\r\n34672:13213,\r\n34673:13214,\r\n34674:13198,\r\n34675:13199,\r\n34676:13252,\r\n34677:13217,\r\n34686:13179,\r\n34688:12317,\r\n34689:12319,\r\n34690:8470,\r\n34691:13261,\r\n34692:8481,\r\n34693:12964,\r\n34694:12965,\r\n34695:12966,\r\n34696:12967,\r\n34697:12968,\r\n34698:12849,\r\n34699:12850,\r\n34700:12857,\r\n34701:13182,\r\n34702:13181,\r\n34703:13180,\r\n34704:8786,\r\n34705:8801,\r\n34706:8747,\r\n34707:8750,\r\n34708:8721,\r\n34709:8730,\r\n34710:8869,\r\n34711:8736,\r\n34712:8735,\r\n34713:8895,\r\n34714:8757,\r\n34715:8745,\r\n34716:8746,\r\n34975:20124,\r\n34976:21782,\r\n34977:23043,\r\n34978:38463,\r\n34979:21696,\r\n34980:24859,\r\n34981:25384,\r\n34982:23030,\r\n34983:36898,\r\n34984:33909,\r\n34985:33564,\r\n34986:31312,\r\n34987:24746,\r\n34988:25569,\r\n34989:28197,\r\n34990:26093,\r\n34991:33894,\r\n34992:33446,\r\n34993:39925,\r\n34994:26771,\r\n34995:22311,\r\n34996:26017,\r\n34997:25201,\r\n34998:23451,\r\n34999:22992,\r\n35000:34427,\r\n35001:39156,\r\n35002:32098,\r\n35003:32190,\r\n35004:39822,\r\n35005:25110,\r\n35006:31903,\r\n35007:34999,\r\n35008:23433,\r\n35009:24245,\r\n35010:25353,\r\n35011:26263,\r\n35012:26696,\r\n35013:38343,\r\n35014:38797,\r\n35015:26447,\r\n35016:20197,\r\n35017:20234,\r\n35018:20301,\r\n35019:20381,\r\n35020:20553,\r\n35021:22258,\r\n35022:22839,\r\n35023:22996,\r\n35024:23041,\r\n35025:23561,\r\n35026:24799,\r\n35027:24847,\r\n35028:24944,\r\n35029:26131,\r\n35030:26885,\r\n35031:28858,\r\n35032:30031,\r\n35033:30064,\r\n35034:31227,\r\n35035:32173,\r\n35036:32239,\r\n35037:32963,\r\n35038:33806,\r\n35039:34915,\r\n35040:35586,\r\n35041:36949,\r\n35042:36986,\r\n35043:21307,\r\n35044:20117,\r\n35045:20133,\r\n35046:22495,\r\n35047:32946,\r\n35048:37057,\r\n35049:30959,\r\n35050:19968,\r\n35051:22769,\r\n35052:28322,\r\n35053:36920,\r\n35054:31282,\r\n35055:33576,\r\n35056:33419,\r\n35057:39983,\r\n35058:20801,\r\n35059:21360,\r\n35060:21693,\r\n35061:21729,\r\n35062:22240,\r\n35063:23035,\r\n35064:24341,\r\n35065:39154,\r\n35066:28139,\r\n35067:32996,\r\n35068:34093,\r\n35136:38498,\r\n35137:38512,\r\n35138:38560,\r\n35139:38907,\r\n35140:21515,\r\n35141:21491,\r\n35142:23431,\r\n35143:28879,\r\n35144:32701,\r\n35145:36802,\r\n35146:38632,\r\n35147:21359,\r\n35148:40284,\r\n35149:31418,\r\n35150:19985,\r\n35151:30867,\r\n35152:33276,\r\n35153:28198,\r\n35154:22040,\r\n35155:21764,\r\n35156:27421,\r\n35157:34074,\r\n35158:39995,\r\n35159:23013,\r\n35160:21417,\r\n35161:28006,\r\n35162:29916,\r\n35163:38287,\r\n35164:22082,\r\n35165:20113,\r\n35166:36939,\r\n35167:38642,\r\n35168:33615,\r\n35169:39180,\r\n35170:21473,\r\n35171:21942,\r\n35172:23344,\r\n35173:24433,\r\n35174:26144,\r\n35175:26355,\r\n35176:26628,\r\n35177:27704,\r\n35178:27891,\r\n35179:27945,\r\n35180:29787,\r\n35181:30408,\r\n35182:31310,\r\n35183:38964,\r\n35184:33521,\r\n35185:34907,\r\n35186:35424,\r\n35187:37613,\r\n35188:28082,\r\n35189:30123,\r\n35190:30410,\r\n35191:39365,\r\n35192:24742,\r\n35193:35585,\r\n35194:36234,\r\n35195:38322,\r\n35196:27022,\r\n35197:21421,\r\n35198:20870,\r\n35200:22290,\r\n35201:22576,\r\n35202:22852,\r\n35203:23476,\r\n35204:24310,\r\n35205:24616,\r\n35206:25513,\r\n35207:25588,\r\n35208:27839,\r\n35209:28436,\r\n35210:28814,\r\n35211:28948,\r\n35212:29017,\r\n35213:29141,\r\n35214:29503,\r\n35215:32257,\r\n35216:33398,\r\n35217:33489,\r\n35218:34199,\r\n35219:36960,\r\n35220:37467,\r\n35221:40219,\r\n35222:22633,\r\n35223:26044,\r\n35224:27738,\r\n35225:29989,\r\n35226:20985,\r\n35227:22830,\r\n35228:22885,\r\n35229:24448,\r\n35230:24540,\r\n35231:25276,\r\n35232:26106,\r\n35233:27178,\r\n35234:27431,\r\n35235:27572,\r\n35236:29579,\r\n35237:32705,\r\n35238:35158,\r\n35239:40236,\r\n35240:40206,\r\n35241:40644,\r\n35242:23713,\r\n35243:27798,\r\n35244:33659,\r\n35245:20740,\r\n35246:23627,\r\n35247:25014,\r\n35248:33222,\r\n35249:26742,\r\n35250:29281,\r\n35251:20057,\r\n35252:20474,\r\n35253:21368,\r\n35254:24681,\r\n35255:28201,\r\n35256:31311,\r\n35257:38899,\r\n35258:19979,\r\n35259:21270,\r\n35260:20206,\r\n35261:20309,\r\n35262:20285,\r\n35263:20385,\r\n35264:20339,\r\n35265:21152,\r\n35266:21487,\r\n35267:22025,\r\n35268:22799,\r\n35269:23233,\r\n35270:23478,\r\n35271:23521,\r\n35272:31185,\r\n35273:26247,\r\n35274:26524,\r\n35275:26550,\r\n35276:27468,\r\n35277:27827,\r\n35278:28779,\r\n35279:29634,\r\n35280:31117,\r\n35281:31166,\r\n35282:31292,\r\n35283:31623,\r\n35284:33457,\r\n35285:33499,\r\n35286:33540,\r\n35287:33655,\r\n35288:33775,\r\n35289:33747,\r\n35290:34662,\r\n35291:35506,\r\n35292:22057,\r\n35293:36008,\r\n35294:36838,\r\n35295:36942,\r\n35296:38686,\r\n35297:34442,\r\n35298:20420,\r\n35299:23784,\r\n35300:25105,\r\n35301:29273,\r\n35302:30011,\r\n35303:33253,\r\n35304:33469,\r\n35305:34558,\r\n35306:36032,\r\n35307:38597,\r\n35308:39187,\r\n35309:39381,\r\n35310:20171,\r\n35311:20250,\r\n35312:35299,\r\n35313:22238,\r\n35314:22602,\r\n35315:22730,\r\n35316:24315,\r\n35317:24555,\r\n35318:24618,\r\n35319:24724,\r\n35320:24674,\r\n35321:25040,\r\n35322:25106,\r\n35323:25296,\r\n35324:25913,\r\n35392:39745,\r\n35393:26214,\r\n35394:26800,\r\n35395:28023,\r\n35396:28784,\r\n35397:30028,\r\n35398:30342,\r\n35399:32117,\r\n35400:33445,\r\n35401:34809,\r\n35402:38283,\r\n35403:38542,\r\n35404:35997,\r\n35405:20977,\r\n35406:21182,\r\n35407:22806,\r\n35408:21683,\r\n35409:23475,\r\n35410:23830,\r\n35411:24936,\r\n35412:27010,\r\n35413:28079,\r\n35414:30861,\r\n35415:33995,\r\n35416:34903,\r\n35417:35442,\r\n35418:37799,\r\n35419:39608,\r\n35420:28012,\r\n35421:39336,\r\n35422:34521,\r\n35423:22435,\r\n35424:26623,\r\n35425:34510,\r\n35426:37390,\r\n35427:21123,\r\n35428:22151,\r\n35429:21508,\r\n35430:24275,\r\n35431:25313,\r\n35432:25785,\r\n35433:26684,\r\n35434:26680,\r\n35435:27579,\r\n35436:29554,\r\n35437:30906,\r\n35438:31339,\r\n35439:35226,\r\n35440:35282,\r\n35441:36203,\r\n35442:36611,\r\n35443:37101,\r\n35444:38307,\r\n35445:38548,\r\n35446:38761,\r\n35447:23398,\r\n35448:23731,\r\n35449:27005,\r\n35450:38989,\r\n35451:38990,\r\n35452:25499,\r\n35453:31520,\r\n35454:27179,\r\n35456:27263,\r\n35457:26806,\r\n35458:39949,\r\n35459:28511,\r\n35460:21106,\r\n35461:21917,\r\n35462:24688,\r\n35463:25324,\r\n35464:27963,\r\n35465:28167,\r\n35466:28369,\r\n35467:33883,\r\n35468:35088,\r\n35469:36676,\r\n35470:19988,\r\n35471:39993,\r\n35472:21494,\r\n35473:26907,\r\n35474:27194,\r\n35475:38788,\r\n35476:26666,\r\n35477:20828,\r\n35478:31427,\r\n35479:33970,\r\n35480:37340,\r\n35481:37772,\r\n35482:22107,\r\n35483:40232,\r\n35484:26658,\r\n35485:33541,\r\n35486:33841,\r\n35487:31909,\r\n35488:21000,\r\n35489:33477,\r\n35490:29926,\r\n35491:20094,\r\n35492:20355,\r\n35493:20896,\r\n35494:23506,\r\n35495:21002,\r\n35496:21208,\r\n35497:21223,\r\n35498:24059,\r\n35499:21914,\r\n35500:22570,\r\n35501:23014,\r\n35502:23436,\r\n35503:23448,\r\n35504:23515,\r\n35505:24178,\r\n35506:24185,\r\n35507:24739,\r\n35508:24863,\r\n35509:24931,\r\n35510:25022,\r\n35511:25563,\r\n35512:25954,\r\n35513:26577,\r\n35514:26707,\r\n35515:26874,\r\n35516:27454,\r\n35517:27475,\r\n35518:27735,\r\n35519:28450,\r\n35520:28567,\r\n35521:28485,\r\n35522:29872,\r\n35523:29976,\r\n35524:30435,\r\n35525:30475,\r\n35526:31487,\r\n35527:31649,\r\n35528:31777,\r\n35529:32233,\r\n35530:32566,\r\n35531:32752,\r\n35532:32925,\r\n35533:33382,\r\n35534:33694,\r\n35535:35251,\r\n35536:35532,\r\n35537:36011,\r\n35538:36996,\r\n35539:37969,\r\n35540:38291,\r\n35541:38289,\r\n35542:38306,\r\n35543:38501,\r\n35544:38867,\r\n35545:39208,\r\n35546:33304,\r\n35547:20024,\r\n35548:21547,\r\n35549:23736,\r\n35550:24012,\r\n35551:29609,\r\n35552:30284,\r\n35553:30524,\r\n35554:23721,\r\n35555:32747,\r\n35556:36107,\r\n35557:38593,\r\n35558:38929,\r\n35559:38996,\r\n35560:39000,\r\n35561:20225,\r\n35562:20238,\r\n35563:21361,\r\n35564:21916,\r\n35565:22120,\r\n35566:22522,\r\n35567:22855,\r\n35568:23305,\r\n35569:23492,\r\n35570:23696,\r\n35571:24076,\r\n35572:24190,\r\n35573:24524,\r\n35574:25582,\r\n35575:26426,\r\n35576:26071,\r\n35577:26082,\r\n35578:26399,\r\n35579:26827,\r\n35580:26820,\r\n35648:27231,\r\n35649:24112,\r\n35650:27589,\r\n35651:27671,\r\n35652:27773,\r\n35653:30079,\r\n35654:31048,\r\n35655:23395,\r\n35656:31232,\r\n35657:32000,\r\n35658:24509,\r\n35659:35215,\r\n35660:35352,\r\n35661:36020,\r\n35662:36215,\r\n35663:36556,\r\n35664:36637,\r\n35665:39138,\r\n35666:39438,\r\n35667:39740,\r\n35668:20096,\r\n35669:20605,\r\n35670:20736,\r\n35671:22931,\r\n35672:23452,\r\n35673:25135,\r\n35674:25216,\r\n35675:25836,\r\n35676:27450,\r\n35677:29344,\r\n35678:30097,\r\n35679:31047,\r\n35680:32681,\r\n35681:34811,\r\n35682:35516,\r\n35683:35696,\r\n35684:25516,\r\n35685:33738,\r\n35686:38816,\r\n35687:21513,\r\n35688:21507,\r\n35689:21931,\r\n35690:26708,\r\n35691:27224,\r\n35692:35440,\r\n35693:30759,\r\n35694:26485,\r\n35695:40653,\r\n35696:21364,\r\n35697:23458,\r\n35698:33050,\r\n35699:34384,\r\n35700:36870,\r\n35701:19992,\r\n35702:20037,\r\n35703:20167,\r\n35704:20241,\r\n35705:21450,\r\n35706:21560,\r\n35707:23470,\r\n35708:24339,\r\n35709:24613,\r\n35710:25937,\r\n35712:26429,\r\n35713:27714,\r\n35714:27762,\r\n35715:27875,\r\n35716:28792,\r\n35717:29699,\r\n35718:31350,\r\n35719:31406,\r\n35720:31496,\r\n35721:32026,\r\n35722:31998,\r\n35723:32102,\r\n35724:26087,\r\n35725:29275,\r\n35726:21435,\r\n35727:23621,\r\n35728:24040,\r\n35729:25298,\r\n35730:25312,\r\n35731:25369,\r\n35732:28192,\r\n35733:34394,\r\n35734:35377,\r\n35735:36317,\r\n35736:37624,\r\n35737:28417,\r\n35738:31142,\r\n35739:39770,\r\n35740:20136,\r\n35741:20139,\r\n35742:20140,\r\n35743:20379,\r\n35744:20384,\r\n35745:20689,\r\n35746:20807,\r\n35747:31478,\r\n35748:20849,\r\n35749:20982,\r\n35750:21332,\r\n35751:21281,\r\n35752:21375,\r\n35753:21483,\r\n35754:21932,\r\n35755:22659,\r\n35756:23777,\r\n35757:24375,\r\n35758:24394,\r\n35759:24623,\r\n35760:24656,\r\n35761:24685,\r\n35762:25375,\r\n35763:25945,\r\n35764:27211,\r\n35765:27841,\r\n35766:29378,\r\n35767:29421,\r\n35768:30703,\r\n35769:33016,\r\n35770:33029,\r\n35771:33288,\r\n35772:34126,\r\n35773:37111,\r\n35774:37857,\r\n35775:38911,\r\n35776:39255,\r\n35777:39514,\r\n35778:20208,\r\n35779:20957,\r\n35780:23597,\r\n35781:26241,\r\n35782:26989,\r\n35783:23616,\r\n35784:26354,\r\n35785:26997,\r\n35786:29577,\r\n35787:26704,\r\n35788:31873,\r\n35789:20677,\r\n35790:21220,\r\n35791:22343,\r\n35792:24062,\r\n35793:37670,\r\n35794:26020,\r\n35795:27427,\r\n35796:27453,\r\n35797:29748,\r\n35798:31105,\r\n35799:31165,\r\n35800:31563,\r\n35801:32202,\r\n35802:33465,\r\n35803:33740,\r\n35804:34943,\r\n35805:35167,\r\n35806:35641,\r\n35807:36817,\r\n35808:37329,\r\n35809:21535,\r\n35810:37504,\r\n35811:20061,\r\n35812:20534,\r\n35813:21477,\r\n35814:21306,\r\n35815:29399,\r\n35816:29590,\r\n35817:30697,\r\n35818:33510,\r\n35819:36527,\r\n35820:39366,\r\n35821:39368,\r\n35822:39378,\r\n35823:20855,\r\n35824:24858,\r\n35825:34398,\r\n35826:21936,\r\n35827:31354,\r\n35828:20598,\r\n35829:23507,\r\n35830:36935,\r\n35831:38533,\r\n35832:20018,\r\n35833:27355,\r\n35834:37351,\r\n35835:23633,\r\n35836:23624,\r\n35904:25496,\r\n35905:31391,\r\n35906:27795,\r\n35907:38772,\r\n35908:36705,\r\n35909:31402,\r\n35910:29066,\r\n35911:38536,\r\n35912:31874,\r\n35913:26647,\r\n35914:32368,\r\n35915:26705,\r\n35916:37740,\r\n35917:21234,\r\n35918:21531,\r\n35919:34219,\r\n35920:35347,\r\n35921:32676,\r\n35922:36557,\r\n35923:37089,\r\n35924:21350,\r\n35925:34952,\r\n35926:31041,\r\n35927:20418,\r\n35928:20670,\r\n35929:21009,\r\n35930:20804,\r\n35931:21843,\r\n35932:22317,\r\n35933:29674,\r\n35934:22411,\r\n35935:22865,\r\n35936:24418,\r\n35937:24452,\r\n35938:24693,\r\n35939:24950,\r\n35940:24935,\r\n35941:25001,\r\n35942:25522,\r\n35943:25658,\r\n35944:25964,\r\n35945:26223,\r\n35946:26690,\r\n35947:28179,\r\n35948:30054,\r\n35949:31293,\r\n35950:31995,\r\n35951:32076,\r\n35952:32153,\r\n35953:32331,\r\n35954:32619,\r\n35955:33550,\r\n35956:33610,\r\n35957:34509,\r\n35958:35336,\r\n35959:35427,\r\n35960:35686,\r\n35961:36605,\r\n35962:38938,\r\n35963:40335,\r\n35964:33464,\r\n35965:36814,\r\n35966:39912,\r\n35968:21127,\r\n35969:25119,\r\n35970:25731,\r\n35971:28608,\r\n35972:38553,\r\n35973:26689,\r\n35974:20625,\r\n35975:27424,\r\n35976:27770,\r\n35977:28500,\r\n35978:31348,\r\n35979:32080,\r\n35980:34880,\r\n35981:35363,\r\n35982:26376,\r\n35983:20214,\r\n35984:20537,\r\n35985:20518,\r\n35986:20581,\r\n35987:20860,\r\n35988:21048,\r\n35989:21091,\r\n35990:21927,\r\n35991:22287,\r\n35992:22533,\r\n35993:23244,\r\n35994:24314,\r\n35995:25010,\r\n35996:25080,\r\n35997:25331,\r\n35998:25458,\r\n35999:26908,\r\n36000:27177,\r\n36001:29309,\r\n36002:29356,\r\n36003:29486,\r\n36004:30740,\r\n36005:30831,\r\n36006:32121,\r\n36007:30476,\r\n36008:32937,\r\n36009:35211,\r\n36010:35609,\r\n36011:36066,\r\n36012:36562,\r\n36013:36963,\r\n36014:37749,\r\n36015:38522,\r\n36016:38997,\r\n36017:39443,\r\n36018:40568,\r\n36019:20803,\r\n36020:21407,\r\n36021:21427,\r\n36022:24187,\r\n36023:24358,\r\n36024:28187,\r\n36025:28304,\r\n36026:29572,\r\n36027:29694,\r\n36028:32067,\r\n36029:33335,\r\n36030:35328,\r\n36031:35578,\r\n36032:38480,\r\n36033:20046,\r\n36034:20491,\r\n36035:21476,\r\n36036:21628,\r\n36037:22266,\r\n36038:22993,\r\n36039:23396,\r\n36040:24049,\r\n36041:24235,\r\n36042:24359,\r\n36043:25144,\r\n36044:25925,\r\n36045:26543,\r\n36046:28246,\r\n36047:29392,\r\n36048:31946,\r\n36049:34996,\r\n36050:32929,\r\n36051:32993,\r\n36052:33776,\r\n36053:34382,\r\n36054:35463,\r\n36055:36328,\r\n36056:37431,\r\n36057:38599,\r\n36058:39015,\r\n36059:40723,\r\n36060:20116,\r\n36061:20114,\r\n36062:20237,\r\n36063:21320,\r\n36064:21577,\r\n36065:21566,\r\n36066:23087,\r\n36067:24460,\r\n36068:24481,\r\n36069:24735,\r\n36070:26791,\r\n36071:27278,\r\n36072:29786,\r\n36073:30849,\r\n36074:35486,\r\n36075:35492,\r\n36076:35703,\r\n36077:37264,\r\n36078:20062,\r\n36079:39881,\r\n36080:20132,\r\n36081:20348,\r\n36082:20399,\r\n36083:20505,\r\n36084:20502,\r\n36085:20809,\r\n36086:20844,\r\n36087:21151,\r\n36088:21177,\r\n36089:21246,\r\n36090:21402,\r\n36091:21475,\r\n36092:21521,\r\n36160:21518,\r\n36161:21897,\r\n36162:22353,\r\n36163:22434,\r\n36164:22909,\r\n36165:23380,\r\n36166:23389,\r\n36167:23439,\r\n36168:24037,\r\n36169:24039,\r\n36170:24055,\r\n36171:24184,\r\n36172:24195,\r\n36173:24218,\r\n36174:24247,\r\n36175:24344,\r\n36176:24658,\r\n36177:24908,\r\n36178:25239,\r\n36179:25304,\r\n36180:25511,\r\n36181:25915,\r\n36182:26114,\r\n36183:26179,\r\n36184:26356,\r\n36185:26477,\r\n36186:26657,\r\n36187:26775,\r\n36188:27083,\r\n36189:27743,\r\n36190:27946,\r\n36191:28009,\r\n36192:28207,\r\n36193:28317,\r\n36194:30002,\r\n36195:30343,\r\n36196:30828,\r\n36197:31295,\r\n36198:31968,\r\n36199:32005,\r\n36200:32024,\r\n36201:32094,\r\n36202:32177,\r\n36203:32789,\r\n36204:32771,\r\n36205:32943,\r\n36206:32945,\r\n36207:33108,\r\n36208:33167,\r\n36209:33322,\r\n36210:33618,\r\n36211:34892,\r\n36212:34913,\r\n36213:35611,\r\n36214:36002,\r\n36215:36092,\r\n36216:37066,\r\n36217:37237,\r\n36218:37489,\r\n36219:30783,\r\n36220:37628,\r\n36221:38308,\r\n36222:38477,\r\n36224:38917,\r\n36225:39321,\r\n36226:39640,\r\n36227:40251,\r\n36228:21083,\r\n36229:21163,\r\n36230:21495,\r\n36231:21512,\r\n36232:22741,\r\n36233:25335,\r\n36234:28640,\r\n36235:35946,\r\n36236:36703,\r\n36237:40633,\r\n36238:20811,\r\n36239:21051,\r\n36240:21578,\r\n36241:22269,\r\n36242:31296,\r\n36243:37239,\r\n36244:40288,\r\n36245:40658,\r\n36246:29508,\r\n36247:28425,\r\n36248:33136,\r\n36249:29969,\r\n36250:24573,\r\n36251:24794,\r\n36252:39592,\r\n36253:29403,\r\n36254:36796,\r\n36255:27492,\r\n36256:38915,\r\n36257:20170,\r\n36258:22256,\r\n36259:22372,\r\n36260:22718,\r\n36261:23130,\r\n36262:24680,\r\n36263:25031,\r\n36264:26127,\r\n36265:26118,\r\n36266:26681,\r\n36267:26801,\r\n36268:28151,\r\n36269:30165,\r\n36270:32058,\r\n36271:33390,\r\n36272:39746,\r\n36273:20123,\r\n36274:20304,\r\n36275:21449,\r\n36276:21766,\r\n36277:23919,\r\n36278:24038,\r\n36279:24046,\r\n36280:26619,\r\n36281:27801,\r\n36282:29811,\r\n36283:30722,\r\n36284:35408,\r\n36285:37782,\r\n36286:35039,\r\n36287:22352,\r\n36288:24231,\r\n36289:25387,\r\n36290:20661,\r\n36291:20652,\r\n36292:20877,\r\n36293:26368,\r\n36294:21705,\r\n36295:22622,\r\n36296:22971,\r\n36297:23472,\r\n36298:24425,\r\n36299:25165,\r\n36300:25505,\r\n36301:26685,\r\n36302:27507,\r\n36303:28168,\r\n36304:28797,\r\n36305:37319,\r\n36306:29312,\r\n36307:30741,\r\n36308:30758,\r\n36309:31085,\r\n36310:25998,\r\n36311:32048,\r\n36312:33756,\r\n36313:35009,\r\n36314:36617,\r\n36315:38555,\r\n36316:21092,\r\n36317:22312,\r\n36318:26448,\r\n36319:32618,\r\n36320:36001,\r\n36321:20916,\r\n36322:22338,\r\n36323:38442,\r\n36324:22586,\r\n36325:27018,\r\n36326:32948,\r\n36327:21682,\r\n36328:23822,\r\n36329:22524,\r\n36330:30869,\r\n36331:40442,\r\n36332:20316,\r\n36333:21066,\r\n36334:21643,\r\n36335:25662,\r\n36336:26152,\r\n36337:26388,\r\n36338:26613,\r\n36339:31364,\r\n36340:31574,\r\n36341:32034,\r\n36342:37679,\r\n36343:26716,\r\n36344:39853,\r\n36345:31545,\r\n36346:21273,\r\n36347:20874,\r\n36348:21047,\r\n36416:23519,\r\n36417:25334,\r\n36418:25774,\r\n36419:25830,\r\n36420:26413,\r\n36421:27578,\r\n36422:34217,\r\n36423:38609,\r\n36424:30352,\r\n36425:39894,\r\n36426:25420,\r\n36427:37638,\r\n36428:39851,\r\n36429:30399,\r\n36430:26194,\r\n36431:19977,\r\n36432:20632,\r\n36433:21442,\r\n36434:23665,\r\n36435:24808,\r\n36436:25746,\r\n36437:25955,\r\n36438:26719,\r\n36439:29158,\r\n36440:29642,\r\n36441:29987,\r\n36442:31639,\r\n36443:32386,\r\n36444:34453,\r\n36445:35715,\r\n36446:36059,\r\n36447:37240,\r\n36448:39184,\r\n36449:26028,\r\n36450:26283,\r\n36451:27531,\r\n36452:20181,\r\n36453:20180,\r\n36454:20282,\r\n36455:20351,\r\n36456:21050,\r\n36457:21496,\r\n36458:21490,\r\n36459:21987,\r\n36460:22235,\r\n36461:22763,\r\n36462:22987,\r\n36463:22985,\r\n36464:23039,\r\n36465:23376,\r\n36466:23629,\r\n36467:24066,\r\n36468:24107,\r\n36469:24535,\r\n36470:24605,\r\n36471:25351,\r\n36472:25903,\r\n36473:23388,\r\n36474:26031,\r\n36475:26045,\r\n36476:26088,\r\n36477:26525,\r\n36478:27490,\r\n36480:27515,\r\n36481:27663,\r\n36482:29509,\r\n36483:31049,\r\n36484:31169,\r\n36485:31992,\r\n36486:32025,\r\n36487:32043,\r\n36488:32930,\r\n36489:33026,\r\n36490:33267,\r\n36491:35222,\r\n36492:35422,\r\n36493:35433,\r\n36494:35430,\r\n36495:35468,\r\n36496:35566,\r\n36497:36039,\r\n36498:36060,\r\n36499:38604,\r\n36500:39164,\r\n36501:27503,\r\n36502:20107,\r\n36503:20284,\r\n36504:20365,\r\n36505:20816,\r\n36506:23383,\r\n36507:23546,\r\n36508:24904,\r\n36509:25345,\r\n36510:26178,\r\n36511:27425,\r\n36512:28363,\r\n36513:27835,\r\n36514:29246,\r\n36515:29885,\r\n36516:30164,\r\n36517:30913,\r\n36518:31034,\r\n36519:32780,\r\n36520:32819,\r\n36521:33258,\r\n36522:33940,\r\n36523:36766,\r\n36524:27728,\r\n36525:40575,\r\n36526:24335,\r\n36527:35672,\r\n36528:40235,\r\n36529:31482,\r\n36530:36600,\r\n36531:23437,\r\n36532:38635,\r\n36533:19971,\r\n36534:21489,\r\n36535:22519,\r\n36536:22833,\r\n36537:23241,\r\n36538:23460,\r\n36539:24713,\r\n36540:28287,\r\n36541:28422,\r\n36542:30142,\r\n36543:36074,\r\n36544:23455,\r\n36545:34048,\r\n36546:31712,\r\n36547:20594,\r\n36548:26612,\r\n36549:33437,\r\n36550:23649,\r\n36551:34122,\r\n36552:32286,\r\n36553:33294,\r\n36554:20889,\r\n36555:23556,\r\n36556:25448,\r\n36557:36198,\r\n36558:26012,\r\n36559:29038,\r\n36560:31038,\r\n36561:32023,\r\n36562:32773,\r\n36563:35613,\r\n36564:36554,\r\n36565:36974,\r\n36566:34503,\r\n36567:37034,\r\n36568:20511,\r\n36569:21242,\r\n36570:23610,\r\n36571:26451,\r\n36572:28796,\r\n36573:29237,\r\n36574:37196,\r\n36575:37320,\r\n36576:37675,\r\n36577:33509,\r\n36578:23490,\r\n36579:24369,\r\n36580:24825,\r\n36581:20027,\r\n36582:21462,\r\n36583:23432,\r\n36584:25163,\r\n36585:26417,\r\n36586:27530,\r\n36587:29417,\r\n36588:29664,\r\n36589:31278,\r\n36590:33131,\r\n36591:36259,\r\n36592:37202,\r\n36593:39318,\r\n36594:20754,\r\n36595:21463,\r\n36596:21610,\r\n36597:23551,\r\n36598:25480,\r\n36599:27193,\r\n36600:32172,\r\n36601:38656,\r\n36602:22234,\r\n36603:21454,\r\n36604:21608,\r\n36672:23447,\r\n36673:23601,\r\n36674:24030,\r\n36675:20462,\r\n36676:24833,\r\n36677:25342,\r\n36678:27954,\r\n36679:31168,\r\n36680:31179,\r\n36681:32066,\r\n36682:32333,\r\n36683:32722,\r\n36684:33261,\r\n36685:33311,\r\n36686:33936,\r\n36687:34886,\r\n36688:35186,\r\n36689:35728,\r\n36690:36468,\r\n36691:36655,\r\n36692:36913,\r\n36693:37195,\r\n36694:37228,\r\n36695:38598,\r\n36696:37276,\r\n36697:20160,\r\n36698:20303,\r\n36699:20805,\r\n36700:21313,\r\n36701:24467,\r\n36702:25102,\r\n36703:26580,\r\n36704:27713,\r\n36705:28171,\r\n36706:29539,\r\n36707:32294,\r\n36708:37325,\r\n36709:37507,\r\n36710:21460,\r\n36711:22809,\r\n36712:23487,\r\n36713:28113,\r\n36714:31069,\r\n36715:32302,\r\n36716:31899,\r\n36717:22654,\r\n36718:29087,\r\n36719:20986,\r\n36720:34899,\r\n36721:36848,\r\n36722:20426,\r\n36723:23803,\r\n36724:26149,\r\n36725:30636,\r\n36726:31459,\r\n36727:33308,\r\n36728:39423,\r\n36729:20934,\r\n36730:24490,\r\n36731:26092,\r\n36732:26991,\r\n36733:27529,\r\n36734:28147,\r\n36736:28310,\r\n36737:28516,\r\n36738:30462,\r\n36739:32020,\r\n36740:24033,\r\n36741:36981,\r\n36742:37255,\r\n36743:38918,\r\n36744:20966,\r\n36745:21021,\r\n36746:25152,\r\n36747:26257,\r\n36748:26329,\r\n36749:28186,\r\n36750:24246,\r\n36751:32210,\r\n36752:32626,\r\n36753:26360,\r\n36754:34223,\r\n36755:34295,\r\n36756:35576,\r\n36757:21161,\r\n36758:21465,\r\n36759:22899,\r\n36760:24207,\r\n36761:24464,\r\n36762:24661,\r\n36763:37604,\r\n36764:38500,\r\n36765:20663,\r\n36766:20767,\r\n36767:21213,\r\n36768:21280,\r\n36769:21319,\r\n36770:21484,\r\n36771:21736,\r\n36772:21830,\r\n36773:21809,\r\n36774:22039,\r\n36775:22888,\r\n36776:22974,\r\n36777:23100,\r\n36778:23477,\r\n36779:23558,\r\n36780:23567,\r\n36781:23569,\r\n36782:23578,\r\n36783:24196,\r\n36784:24202,\r\n36785:24288,\r\n36786:24432,\r\n36787:25215,\r\n36788:25220,\r\n36789:25307,\r\n36790:25484,\r\n36791:25463,\r\n36792:26119,\r\n36793:26124,\r\n36794:26157,\r\n36795:26230,\r\n36796:26494,\r\n36797:26786,\r\n36798:27167,\r\n36799:27189,\r\n36800:27836,\r\n36801:28040,\r\n36802:28169,\r\n36803:28248,\r\n36804:28988,\r\n36805:28966,\r\n36806:29031,\r\n36807:30151,\r\n36808:30465,\r\n36809:30813,\r\n36810:30977,\r\n36811:31077,\r\n36812:31216,\r\n36813:31456,\r\n36814:31505,\r\n36815:31911,\r\n36816:32057,\r\n36817:32918,\r\n36818:33750,\r\n36819:33931,\r\n36820:34121,\r\n36821:34909,\r\n36822:35059,\r\n36823:35359,\r\n36824:35388,\r\n36825:35412,\r\n36826:35443,\r\n36827:35937,\r\n36828:36062,\r\n36829:37284,\r\n36830:37478,\r\n36831:37758,\r\n36832:37912,\r\n36833:38556,\r\n36834:38808,\r\n36835:19978,\r\n36836:19976,\r\n36837:19998,\r\n36838:20055,\r\n36839:20887,\r\n36840:21104,\r\n36841:22478,\r\n36842:22580,\r\n36843:22732,\r\n36844:23330,\r\n36845:24120,\r\n36846:24773,\r\n36847:25854,\r\n36848:26465,\r\n36849:26454,\r\n36850:27972,\r\n36851:29366,\r\n36852:30067,\r\n36853:31331,\r\n36854:33976,\r\n36855:35698,\r\n36856:37304,\r\n36857:37664,\r\n36858:22065,\r\n36859:22516,\r\n36860:39166,\r\n36928:25325,\r\n36929:26893,\r\n36930:27542,\r\n36931:29165,\r\n36932:32340,\r\n36933:32887,\r\n36934:33394,\r\n36935:35302,\r\n36936:39135,\r\n36937:34645,\r\n36938:36785,\r\n36939:23611,\r\n36940:20280,\r\n36941:20449,\r\n36942:20405,\r\n36943:21767,\r\n36944:23072,\r\n36945:23517,\r\n36946:23529,\r\n36947:24515,\r\n36948:24910,\r\n36949:25391,\r\n36950:26032,\r\n36951:26187,\r\n36952:26862,\r\n36953:27035,\r\n36954:28024,\r\n36955:28145,\r\n36956:30003,\r\n36957:30137,\r\n36958:30495,\r\n36959:31070,\r\n36960:31206,\r\n36961:32051,\r\n36962:33251,\r\n36963:33455,\r\n36964:34218,\r\n36965:35242,\r\n36966:35386,\r\n36967:36523,\r\n36968:36763,\r\n36969:36914,\r\n36970:37341,\r\n36971:38663,\r\n36972:20154,\r\n36973:20161,\r\n36974:20995,\r\n36975:22645,\r\n36976:22764,\r\n36977:23563,\r\n36978:29978,\r\n36979:23613,\r\n36980:33102,\r\n36981:35338,\r\n36982:36805,\r\n36983:38499,\r\n36984:38765,\r\n36985:31525,\r\n36986:35535,\r\n36987:38920,\r\n36988:37218,\r\n36989:22259,\r\n36990:21416,\r\n36992:36887,\r\n36993:21561,\r\n36994:22402,\r\n36995:24101,\r\n36996:25512,\r\n36997:27700,\r\n36998:28810,\r\n36999:30561,\r\n37000:31883,\r\n37001:32736,\r\n37002:34928,\r\n37003:36930,\r\n37004:37204,\r\n37005:37648,\r\n37006:37656,\r\n37007:38543,\r\n37008:29790,\r\n37009:39620,\r\n37010:23815,\r\n37011:23913,\r\n37012:25968,\r\n37013:26530,\r\n37014:36264,\r\n37015:38619,\r\n37016:25454,\r\n37017:26441,\r\n37018:26905,\r\n37019:33733,\r\n37020:38935,\r\n37021:38592,\r\n37022:35070,\r\n37023:28548,\r\n37024:25722,\r\n37025:23544,\r\n37026:19990,\r\n37027:28716,\r\n37028:30045,\r\n37029:26159,\r\n37030:20932,\r\n37031:21046,\r\n37032:21218,\r\n37033:22995,\r\n37034:24449,\r\n37035:24615,\r\n37036:25104,\r\n37037:25919,\r\n37038:25972,\r\n37039:26143,\r\n37040:26228,\r\n37041:26866,\r\n37042:26646,\r\n37043:27491,\r\n37044:28165,\r\n37045:29298,\r\n37046:29983,\r\n37047:30427,\r\n37048:31934,\r\n37049:32854,\r\n37050:22768,\r\n37051:35069,\r\n37052:35199,\r\n37053:35488,\r\n37054:35475,\r\n37055:35531,\r\n37056:36893,\r\n37057:37266,\r\n37058:38738,\r\n37059:38745,\r\n37060:25993,\r\n37061:31246,\r\n37062:33030,\r\n37063:38587,\r\n37064:24109,\r\n37065:24796,\r\n37066:25114,\r\n37067:26021,\r\n37068:26132,\r\n37069:26512,\r\n37070:30707,\r\n37071:31309,\r\n37072:31821,\r\n37073:32318,\r\n37074:33034,\r\n37075:36012,\r\n37076:36196,\r\n37077:36321,\r\n37078:36447,\r\n37079:30889,\r\n37080:20999,\r\n37081:25305,\r\n37082:25509,\r\n37083:25666,\r\n37084:25240,\r\n37085:35373,\r\n37086:31363,\r\n37087:31680,\r\n37088:35500,\r\n37089:38634,\r\n37090:32118,\r\n37091:33292,\r\n37092:34633,\r\n37093:20185,\r\n37094:20808,\r\n37095:21315,\r\n37096:21344,\r\n37097:23459,\r\n37098:23554,\r\n37099:23574,\r\n37100:24029,\r\n37101:25126,\r\n37102:25159,\r\n37103:25776,\r\n37104:26643,\r\n37105:26676,\r\n37106:27849,\r\n37107:27973,\r\n37108:27927,\r\n37109:26579,\r\n37110:28508,\r\n37111:29006,\r\n37112:29053,\r\n37113:26059,\r\n37114:31359,\r\n37115:31661,\r\n37116:32218,\r\n37184:32330,\r\n37185:32680,\r\n37186:33146,\r\n37187:33307,\r\n37188:33337,\r\n37189:34214,\r\n37190:35438,\r\n37191:36046,\r\n37192:36341,\r\n37193:36984,\r\n37194:36983,\r\n37195:37549,\r\n37196:37521,\r\n37197:38275,\r\n37198:39854,\r\n37199:21069,\r\n37200:21892,\r\n37201:28472,\r\n37202:28982,\r\n37203:20840,\r\n37204:31109,\r\n37205:32341,\r\n37206:33203,\r\n37207:31950,\r\n37208:22092,\r\n37209:22609,\r\n37210:23720,\r\n37211:25514,\r\n37212:26366,\r\n37213:26365,\r\n37214:26970,\r\n37215:29401,\r\n37216:30095,\r\n37217:30094,\r\n37218:30990,\r\n37219:31062,\r\n37220:31199,\r\n37221:31895,\r\n37222:32032,\r\n37223:32068,\r\n37224:34311,\r\n37225:35380,\r\n37226:38459,\r\n37227:36961,\r\n37228:40736,\r\n37229:20711,\r\n37230:21109,\r\n37231:21452,\r\n37232:21474,\r\n37233:20489,\r\n37234:21930,\r\n37235:22766,\r\n37236:22863,\r\n37237:29245,\r\n37238:23435,\r\n37239:23652,\r\n37240:21277,\r\n37241:24803,\r\n37242:24819,\r\n37243:25436,\r\n37244:25475,\r\n37245:25407,\r\n37246:25531,\r\n37248:25805,\r\n37249:26089,\r\n37250:26361,\r\n37251:24035,\r\n37252:27085,\r\n37253:27133,\r\n37254:28437,\r\n37255:29157,\r\n37256:20105,\r\n37257:30185,\r\n37258:30456,\r\n37259:31379,\r\n37260:31967,\r\n37261:32207,\r\n37262:32156,\r\n37263:32865,\r\n37264:33609,\r\n37265:33624,\r\n37266:33900,\r\n37267:33980,\r\n37268:34299,\r\n37269:35013,\r\n37270:36208,\r\n37271:36865,\r\n37272:36973,\r\n37273:37783,\r\n37274:38684,\r\n37275:39442,\r\n37276:20687,\r\n37277:22679,\r\n37278:24974,\r\n37279:33235,\r\n37280:34101,\r\n37281:36104,\r\n37282:36896,\r\n37283:20419,\r\n37284:20596,\r\n37285:21063,\r\n37286:21363,\r\n37287:24687,\r\n37288:25417,\r\n37289:26463,\r\n37290:28204,\r\n37291:36275,\r\n37292:36895,\r\n37293:20439,\r\n37294:23646,\r\n37295:36042,\r\n37296:26063,\r\n37297:32154,\r\n37298:21330,\r\n37299:34966,\r\n37300:20854,\r\n37301:25539,\r\n37302:23384,\r\n37303:23403,\r\n37304:23562,\r\n37305:25613,\r\n37306:26449,\r\n37307:36956,\r\n37308:20182,\r\n37309:22810,\r\n37310:22826,\r\n37311:27760,\r\n37312:35409,\r\n37313:21822,\r\n37314:22549,\r\n37315:22949,\r\n37316:24816,\r\n37317:25171,\r\n37318:26561,\r\n37319:33333,\r\n37320:26965,\r\n37321:38464,\r\n37322:39364,\r\n37323:39464,\r\n37324:20307,\r\n37325:22534,\r\n37326:23550,\r\n37327:32784,\r\n37328:23729,\r\n37329:24111,\r\n37330:24453,\r\n37331:24608,\r\n37332:24907,\r\n37333:25140,\r\n37334:26367,\r\n37335:27888,\r\n37336:28382,\r\n37337:32974,\r\n37338:33151,\r\n37339:33492,\r\n37340:34955,\r\n37341:36024,\r\n37342:36864,\r\n37343:36910,\r\n37344:38538,\r\n37345:40667,\r\n37346:39899,\r\n37347:20195,\r\n37348:21488,\r\n37349:22823,\r\n37350:31532,\r\n37351:37261,\r\n37352:38988,\r\n37353:40441,\r\n37354:28381,\r\n37355:28711,\r\n37356:21331,\r\n37357:21828,\r\n37358:23429,\r\n37359:25176,\r\n37360:25246,\r\n37361:25299,\r\n37362:27810,\r\n37363:28655,\r\n37364:29730,\r\n37365:35351,\r\n37366:37944,\r\n37367:28609,\r\n37368:35582,\r\n37369:33592,\r\n37370:20967,\r\n37371:34552,\r\n37372:21482,\r\n37440:21481,\r\n37441:20294,\r\n37442:36948,\r\n37443:36784,\r\n37444:22890,\r\n37445:33073,\r\n37446:24061,\r\n37447:31466,\r\n37448:36799,\r\n37449:26842,\r\n37450:35895,\r\n37451:29432,\r\n37452:40008,\r\n37453:27197,\r\n37454:35504,\r\n37455:20025,\r\n37456:21336,\r\n37457:22022,\r\n37458:22374,\r\n37459:25285,\r\n37460:25506,\r\n37461:26086,\r\n37462:27470,\r\n37463:28129,\r\n37464:28251,\r\n37465:28845,\r\n37466:30701,\r\n37467:31471,\r\n37468:31658,\r\n37469:32187,\r\n37470:32829,\r\n37471:32966,\r\n37472:34507,\r\n37473:35477,\r\n37474:37723,\r\n37475:22243,\r\n37476:22727,\r\n37477:24382,\r\n37478:26029,\r\n37479:26262,\r\n37480:27264,\r\n37481:27573,\r\n37482:30007,\r\n37483:35527,\r\n37484:20516,\r\n37485:30693,\r\n37486:22320,\r\n37487:24347,\r\n37488:24677,\r\n37489:26234,\r\n37490:27744,\r\n37491:30196,\r\n37492:31258,\r\n37493:32622,\r\n37494:33268,\r\n37495:34584,\r\n37496:36933,\r\n37497:39347,\r\n37498:31689,\r\n37499:30044,\r\n37500:31481,\r\n37501:31569,\r\n37502:33988,\r\n37504:36880,\r\n37505:31209,\r\n37506:31378,\r\n37507:33590,\r\n37508:23265,\r\n37509:30528,\r\n37510:20013,\r\n37511:20210,\r\n37512:23449,\r\n37513:24544,\r\n37514:25277,\r\n37515:26172,\r\n37516:26609,\r\n37517:27880,\r\n37518:34411,\r\n37519:34935,\r\n37520:35387,\r\n37521:37198,\r\n37522:37619,\r\n37523:39376,\r\n37524:27159,\r\n37525:28710,\r\n37526:29482,\r\n37527:33511,\r\n37528:33879,\r\n37529:36015,\r\n37530:19969,\r\n37531:20806,\r\n37532:20939,\r\n37533:21899,\r\n37534:23541,\r\n37535:24086,\r\n37536:24115,\r\n37537:24193,\r\n37538:24340,\r\n37539:24373,\r\n37540:24427,\r\n37541:24500,\r\n37542:25074,\r\n37543:25361,\r\n37544:26274,\r\n37545:26397,\r\n37546:28526,\r\n37547:29266,\r\n37548:30010,\r\n37549:30522,\r\n37550:32884,\r\n37551:33081,\r\n37552:33144,\r\n37553:34678,\r\n37554:35519,\r\n37555:35548,\r\n37556:36229,\r\n37557:36339,\r\n37558:37530,\r\n37559:38263,\r\n37560:38914,\r\n37561:40165,\r\n37562:21189,\r\n37563:25431,\r\n37564:30452,\r\n37565:26389,\r\n37566:27784,\r\n37567:29645,\r\n37568:36035,\r\n37569:37806,\r\n37570:38515,\r\n37571:27941,\r\n37572:22684,\r\n37573:26894,\r\n37574:27084,\r\n37575:36861,\r\n37576:37786,\r\n37577:30171,\r\n37578:36890,\r\n37579:22618,\r\n37580:26626,\r\n37581:25524,\r\n37582:27131,\r\n37583:20291,\r\n37584:28460,\r\n37585:26584,\r\n37586:36795,\r\n37587:34086,\r\n37588:32180,\r\n37589:37716,\r\n37590:26943,\r\n37591:28528,\r\n37592:22378,\r\n37593:22775,\r\n37594:23340,\r\n37595:32044,\r\n37596:29226,\r\n37597:21514,\r\n37598:37347,\r\n37599:40372,\r\n37600:20141,\r\n37601:20302,\r\n37602:20572,\r\n37603:20597,\r\n37604:21059,\r\n37605:35998,\r\n37606:21576,\r\n37607:22564,\r\n37608:23450,\r\n37609:24093,\r\n37610:24213,\r\n37611:24237,\r\n37612:24311,\r\n37613:24351,\r\n37614:24716,\r\n37615:25269,\r\n37616:25402,\r\n37617:25552,\r\n37618:26799,\r\n37619:27712,\r\n37620:30855,\r\n37621:31118,\r\n37622:31243,\r\n37623:32224,\r\n37624:33351,\r\n37625:35330,\r\n37626:35558,\r\n37627:36420,\r\n37628:36883,\r\n37696:37048,\r\n37697:37165,\r\n37698:37336,\r\n37699:40718,\r\n37700:27877,\r\n37701:25688,\r\n37702:25826,\r\n37703:25973,\r\n37704:28404,\r\n37705:30340,\r\n37706:31515,\r\n37707:36969,\r\n37708:37841,\r\n37709:28346,\r\n37710:21746,\r\n37711:24505,\r\n37712:25764,\r\n37713:36685,\r\n37714:36845,\r\n37715:37444,\r\n37716:20856,\r\n37717:22635,\r\n37718:22825,\r\n37719:23637,\r\n37720:24215,\r\n37721:28155,\r\n37722:32399,\r\n37723:29980,\r\n37724:36028,\r\n37725:36578,\r\n37726:39003,\r\n37727:28857,\r\n37728:20253,\r\n37729:27583,\r\n37730:28593,\r\n37731:30000,\r\n37732:38651,\r\n37733:20814,\r\n37734:21520,\r\n37735:22581,\r\n37736:22615,\r\n37737:22956,\r\n37738:23648,\r\n37739:24466,\r\n37740:26007,\r\n37741:26460,\r\n37742:28193,\r\n37743:30331,\r\n37744:33759,\r\n37745:36077,\r\n37746:36884,\r\n37747:37117,\r\n37748:37709,\r\n37749:30757,\r\n37750:30778,\r\n37751:21162,\r\n37752:24230,\r\n37753:22303,\r\n37754:22900,\r\n37755:24594,\r\n37756:20498,\r\n37757:20826,\r\n37758:20908,\r\n37760:20941,\r\n37761:20992,\r\n37762:21776,\r\n37763:22612,\r\n37764:22616,\r\n37765:22871,\r\n37766:23445,\r\n37767:23798,\r\n37768:23947,\r\n37769:24764,\r\n37770:25237,\r\n37771:25645,\r\n37772:26481,\r\n37773:26691,\r\n37774:26812,\r\n37775:26847,\r\n37776:30423,\r\n37777:28120,\r\n37778:28271,\r\n37779:28059,\r\n37780:28783,\r\n37781:29128,\r\n37782:24403,\r\n37783:30168,\r\n37784:31095,\r\n37785:31561,\r\n37786:31572,\r\n37787:31570,\r\n37788:31958,\r\n37789:32113,\r\n37790:21040,\r\n37791:33891,\r\n37792:34153,\r\n37793:34276,\r\n37794:35342,\r\n37795:35588,\r\n37796:35910,\r\n37797:36367,\r\n37798:36867,\r\n37799:36879,\r\n37800:37913,\r\n37801:38518,\r\n37802:38957,\r\n37803:39472,\r\n37804:38360,\r\n37805:20685,\r\n37806:21205,\r\n37807:21516,\r\n37808:22530,\r\n37809:23566,\r\n37810:24999,\r\n37811:25758,\r\n37812:27934,\r\n37813:30643,\r\n37814:31461,\r\n37815:33012,\r\n37816:33796,\r\n37817:36947,\r\n37818:37509,\r\n37819:23776,\r\n37820:40199,\r\n37821:21311,\r\n37822:24471,\r\n37823:24499,\r\n37824:28060,\r\n37825:29305,\r\n37826:30563,\r\n37827:31167,\r\n37828:31716,\r\n37829:27602,\r\n37830:29420,\r\n37831:35501,\r\n37832:26627,\r\n37833:27233,\r\n37834:20984,\r\n37835:31361,\r\n37836:26932,\r\n37837:23626,\r\n37838:40182,\r\n37839:33515,\r\n37840:23493,\r\n37841:37193,\r\n37842:28702,\r\n37843:22136,\r\n37844:23663,\r\n37845:24775,\r\n37846:25958,\r\n37847:27788,\r\n37848:35930,\r\n37849:36929,\r\n37850:38931,\r\n37851:21585,\r\n37852:26311,\r\n37853:37389,\r\n37854:22856,\r\n37855:37027,\r\n37856:20869,\r\n37857:20045,\r\n37858:20970,\r\n37859:34201,\r\n37860:35598,\r\n37861:28760,\r\n37862:25466,\r\n37863:37707,\r\n37864:26978,\r\n37865:39348,\r\n37866:32260,\r\n37867:30071,\r\n37868:21335,\r\n37869:26976,\r\n37870:36575,\r\n37871:38627,\r\n37872:27741,\r\n37873:20108,\r\n37874:23612,\r\n37875:24336,\r\n37876:36841,\r\n37877:21250,\r\n37878:36049,\r\n37879:32905,\r\n37880:34425,\r\n37881:24319,\r\n37882:26085,\r\n37883:20083,\r\n37884:20837,\r\n37952:22914,\r\n37953:23615,\r\n37954:38894,\r\n37955:20219,\r\n37956:22922,\r\n37957:24525,\r\n37958:35469,\r\n37959:28641,\r\n37960:31152,\r\n37961:31074,\r\n37962:23527,\r\n37963:33905,\r\n37964:29483,\r\n37965:29105,\r\n37966:24180,\r\n37967:24565,\r\n37968:25467,\r\n37969:25754,\r\n37970:29123,\r\n37971:31896,\r\n37972:20035,\r\n37973:24316,\r\n37974:20043,\r\n37975:22492,\r\n37976:22178,\r\n37977:24745,\r\n37978:28611,\r\n37979:32013,\r\n37980:33021,\r\n37981:33075,\r\n37982:33215,\r\n37983:36786,\r\n37984:35223,\r\n37985:34468,\r\n37986:24052,\r\n37987:25226,\r\n37988:25773,\r\n37989:35207,\r\n37990:26487,\r\n37991:27874,\r\n37992:27966,\r\n37993:29750,\r\n37994:30772,\r\n37995:23110,\r\n37996:32629,\r\n37997:33453,\r\n37998:39340,\r\n37999:20467,\r\n38000:24259,\r\n38001:25309,\r\n38002:25490,\r\n38003:25943,\r\n38004:26479,\r\n38005:30403,\r\n38006:29260,\r\n38007:32972,\r\n38008:32954,\r\n38009:36649,\r\n38010:37197,\r\n38011:20493,\r\n38012:22521,\r\n38013:23186,\r\n38014:26757,\r\n38016:26995,\r\n38017:29028,\r\n38018:29437,\r\n38019:36023,\r\n38020:22770,\r\n38021:36064,\r\n38022:38506,\r\n38023:36889,\r\n38024:34687,\r\n38025:31204,\r\n38026:30695,\r\n38027:33833,\r\n38028:20271,\r\n38029:21093,\r\n38030:21338,\r\n38031:25293,\r\n38032:26575,\r\n38033:27850,\r\n38034:30333,\r\n38035:31636,\r\n38036:31893,\r\n38037:33334,\r\n38038:34180,\r\n38039:36843,\r\n38040:26333,\r\n38041:28448,\r\n38042:29190,\r\n38043:32283,\r\n38044:33707,\r\n38045:39361,\r\n38046:40614,\r\n38047:20989,\r\n38048:31665,\r\n38049:30834,\r\n38050:31672,\r\n38051:32903,\r\n38052:31560,\r\n38053:27368,\r\n38054:24161,\r\n38055:32908,\r\n38056:30033,\r\n38057:30048,\r\n38058:20843,\r\n38059:37474,\r\n38060:28300,\r\n38061:30330,\r\n38062:37271,\r\n38063:39658,\r\n38064:20240,\r\n38065:32624,\r\n38066:25244,\r\n38067:31567,\r\n38068:38309,\r\n38069:40169,\r\n38070:22138,\r\n38071:22617,\r\n38072:34532,\r\n38073:38588,\r\n38074:20276,\r\n38075:21028,\r\n38076:21322,\r\n38077:21453,\r\n38078:21467,\r\n38079:24070,\r\n38080:25644,\r\n38081:26001,\r\n38082:26495,\r\n38083:27710,\r\n38084:27726,\r\n38085:29256,\r\n38086:29359,\r\n38087:29677,\r\n38088:30036,\r\n38089:32321,\r\n38090:33324,\r\n38091:34281,\r\n38092:36009,\r\n38093:31684,\r\n38094:37318,\r\n38095:29033,\r\n38096:38930,\r\n38097:39151,\r\n38098:25405,\r\n38099:26217,\r\n38100:30058,\r\n38101:30436,\r\n38102:30928,\r\n38103:34115,\r\n38104:34542,\r\n38105:21290,\r\n38106:21329,\r\n38107:21542,\r\n38108:22915,\r\n38109:24199,\r\n38110:24444,\r\n38111:24754,\r\n38112:25161,\r\n38113:25209,\r\n38114:25259,\r\n38115:26000,\r\n38116:27604,\r\n38117:27852,\r\n38118:30130,\r\n38119:30382,\r\n38120:30865,\r\n38121:31192,\r\n38122:32203,\r\n38123:32631,\r\n38124:32933,\r\n38125:34987,\r\n38126:35513,\r\n38127:36027,\r\n38128:36991,\r\n38129:38750,\r\n38130:39131,\r\n38131:27147,\r\n38132:31800,\r\n38133:20633,\r\n38134:23614,\r\n38135:24494,\r\n38136:26503,\r\n38137:27608,\r\n38138:29749,\r\n38139:30473,\r\n38140:32654,\r\n38208:40763,\r\n38209:26570,\r\n38210:31255,\r\n38211:21305,\r\n38212:30091,\r\n38213:39661,\r\n38214:24422,\r\n38215:33181,\r\n38216:33777,\r\n38217:32920,\r\n38218:24380,\r\n38219:24517,\r\n38220:30050,\r\n38221:31558,\r\n38222:36924,\r\n38223:26727,\r\n38224:23019,\r\n38225:23195,\r\n38226:32016,\r\n38227:30334,\r\n38228:35628,\r\n38229:20469,\r\n38230:24426,\r\n38231:27161,\r\n38232:27703,\r\n38233:28418,\r\n38234:29922,\r\n38235:31080,\r\n38236:34920,\r\n38237:35413,\r\n38238:35961,\r\n38239:24287,\r\n38240:25551,\r\n38241:30149,\r\n38242:31186,\r\n38243:33495,\r\n38244:37672,\r\n38245:37618,\r\n38246:33948,\r\n38247:34541,\r\n38248:39981,\r\n38249:21697,\r\n38250:24428,\r\n38251:25996,\r\n38252:27996,\r\n38253:28693,\r\n38254:36007,\r\n38255:36051,\r\n38256:38971,\r\n38257:25935,\r\n38258:29942,\r\n38259:19981,\r\n38260:20184,\r\n38261:22496,\r\n38262:22827,\r\n38263:23142,\r\n38264:23500,\r\n38265:20904,\r\n38266:24067,\r\n38267:24220,\r\n38268:24598,\r\n38269:25206,\r\n38270:25975,\r\n38272:26023,\r\n38273:26222,\r\n38274:28014,\r\n38275:29238,\r\n38276:31526,\r\n38277:33104,\r\n38278:33178,\r\n38279:33433,\r\n38280:35676,\r\n38281:36000,\r\n38282:36070,\r\n38283:36212,\r\n38284:38428,\r\n38285:38468,\r\n38286:20398,\r\n38287:25771,\r\n38288:27494,\r\n38289:33310,\r\n38290:33889,\r\n38291:34154,\r\n38292:37096,\r\n38293:23553,\r\n38294:26963,\r\n38295:39080,\r\n38296:33914,\r\n38297:34135,\r\n38298:20239,\r\n38299:21103,\r\n38300:24489,\r\n38301:24133,\r\n38302:26381,\r\n38303:31119,\r\n38304:33145,\r\n38305:35079,\r\n38306:35206,\r\n38307:28149,\r\n38308:24343,\r\n38309:25173,\r\n38310:27832,\r\n38311:20175,\r\n38312:29289,\r\n38313:39826,\r\n38314:20998,\r\n38315:21563,\r\n38316:22132,\r\n38317:22707,\r\n38318:24996,\r\n38319:25198,\r\n38320:28954,\r\n38321:22894,\r\n38322:31881,\r\n38323:31966,\r\n38324:32027,\r\n38325:38640,\r\n38326:25991,\r\n38327:32862,\r\n38328:19993,\r\n38329:20341,\r\n38330:20853,\r\n38331:22592,\r\n38332:24163,\r\n38333:24179,\r\n38334:24330,\r\n38335:26564,\r\n38336:20006,\r\n38337:34109,\r\n38338:38281,\r\n38339:38491,\r\n38340:31859,\r\n38341:38913,\r\n38342:20731,\r\n38343:22721,\r\n38344:30294,\r\n38345:30887,\r\n38346:21029,\r\n38347:30629,\r\n38348:34065,\r\n38349:31622,\r\n38350:20559,\r\n38351:22793,\r\n38352:29255,\r\n38353:31687,\r\n38354:32232,\r\n38355:36794,\r\n38356:36820,\r\n38357:36941,\r\n38358:20415,\r\n38359:21193,\r\n38360:23081,\r\n38361:24321,\r\n38362:38829,\r\n38363:20445,\r\n38364:33303,\r\n38365:37610,\r\n38366:22275,\r\n38367:25429,\r\n38368:27497,\r\n38369:29995,\r\n38370:35036,\r\n38371:36628,\r\n38372:31298,\r\n38373:21215,\r\n38374:22675,\r\n38375:24917,\r\n38376:25098,\r\n38377:26286,\r\n38378:27597,\r\n38379:31807,\r\n38380:33769,\r\n38381:20515,\r\n38382:20472,\r\n38383:21253,\r\n38384:21574,\r\n38385:22577,\r\n38386:22857,\r\n38387:23453,\r\n38388:23792,\r\n38389:23791,\r\n38390:23849,\r\n38391:24214,\r\n38392:25265,\r\n38393:25447,\r\n38394:25918,\r\n38395:26041,\r\n38396:26379,\r\n38464:27861,\r\n38465:27873,\r\n38466:28921,\r\n38467:30770,\r\n38468:32299,\r\n38469:32990,\r\n38470:33459,\r\n38471:33804,\r\n38472:34028,\r\n38473:34562,\r\n38474:35090,\r\n38475:35370,\r\n38476:35914,\r\n38477:37030,\r\n38478:37586,\r\n38479:39165,\r\n38480:40179,\r\n38481:40300,\r\n38482:20047,\r\n38483:20129,\r\n38484:20621,\r\n38485:21078,\r\n38486:22346,\r\n38487:22952,\r\n38488:24125,\r\n38489:24536,\r\n38490:24537,\r\n38491:25151,\r\n38492:26292,\r\n38493:26395,\r\n38494:26576,\r\n38495:26834,\r\n38496:20882,\r\n38497:32033,\r\n38498:32938,\r\n38499:33192,\r\n38500:35584,\r\n38501:35980,\r\n38502:36031,\r\n38503:37502,\r\n38504:38450,\r\n38505:21536,\r\n38506:38956,\r\n38507:21271,\r\n38508:20693,\r\n38509:21340,\r\n38510:22696,\r\n38511:25778,\r\n38512:26420,\r\n38513:29287,\r\n38514:30566,\r\n38515:31302,\r\n38516:37350,\r\n38517:21187,\r\n38518:27809,\r\n38519:27526,\r\n38520:22528,\r\n38521:24140,\r\n38522:22868,\r\n38523:26412,\r\n38524:32763,\r\n38525:20961,\r\n38526:30406,\r\n38528:25705,\r\n38529:30952,\r\n38530:39764,\r\n38531:40635,\r\n38532:22475,\r\n38533:22969,\r\n38534:26151,\r\n38535:26522,\r\n38536:27598,\r\n38537:21737,\r\n38538:27097,\r\n38539:24149,\r\n38540:33180,\r\n38541:26517,\r\n38542:39850,\r\n38543:26622,\r\n38544:40018,\r\n38545:26717,\r\n38546:20134,\r\n38547:20451,\r\n38548:21448,\r\n38549:25273,\r\n38550:26411,\r\n38551:27819,\r\n38552:36804,\r\n38553:20397,\r\n38554:32365,\r\n38555:40639,\r\n38556:19975,\r\n38557:24930,\r\n38558:28288,\r\n38559:28459,\r\n38560:34067,\r\n38561:21619,\r\n38562:26410,\r\n38563:39749,\r\n38564:24051,\r\n38565:31637,\r\n38566:23724,\r\n38567:23494,\r\n38568:34588,\r\n38569:28234,\r\n38570:34001,\r\n38571:31252,\r\n38572:33032,\r\n38573:22937,\r\n38574:31885,\r\n38575:27665,\r\n38576:30496,\r\n38577:21209,\r\n38578:22818,\r\n38579:28961,\r\n38580:29279,\r\n38581:30683,\r\n38582:38695,\r\n38583:40289,\r\n38584:26891,\r\n38585:23167,\r\n38586:23064,\r\n38587:20901,\r\n38588:21517,\r\n38589:21629,\r\n38590:26126,\r\n38591:30431,\r\n38592:36855,\r\n38593:37528,\r\n38594:40180,\r\n38595:23018,\r\n38596:29277,\r\n38597:28357,\r\n38598:20813,\r\n38599:26825,\r\n38600:32191,\r\n38601:32236,\r\n38602:38754,\r\n38603:40634,\r\n38604:25720,\r\n38605:27169,\r\n38606:33538,\r\n38607:22916,\r\n38608:23391,\r\n38609:27611,\r\n38610:29467,\r\n38611:30450,\r\n38612:32178,\r\n38613:32791,\r\n38614:33945,\r\n38615:20786,\r\n38616:26408,\r\n38617:40665,\r\n38618:30446,\r\n38619:26466,\r\n38620:21247,\r\n38621:39173,\r\n38622:23588,\r\n38623:25147,\r\n38624:31870,\r\n38625:36016,\r\n38626:21839,\r\n38627:24758,\r\n38628:32011,\r\n38629:38272,\r\n38630:21249,\r\n38631:20063,\r\n38632:20918,\r\n38633:22812,\r\n38634:29242,\r\n38635:32822,\r\n38636:37326,\r\n38637:24357,\r\n38638:30690,\r\n38639:21380,\r\n38640:24441,\r\n38641:32004,\r\n38642:34220,\r\n38643:35379,\r\n38644:36493,\r\n38645:38742,\r\n38646:26611,\r\n38647:34222,\r\n38648:37971,\r\n38649:24841,\r\n38650:24840,\r\n38651:27833,\r\n38652:30290,\r\n38720:35565,\r\n38721:36664,\r\n38722:21807,\r\n38723:20305,\r\n38724:20778,\r\n38725:21191,\r\n38726:21451,\r\n38727:23461,\r\n38728:24189,\r\n38729:24736,\r\n38730:24962,\r\n38731:25558,\r\n38732:26377,\r\n38733:26586,\r\n38734:28263,\r\n38735:28044,\r\n38736:29494,\r\n38737:29495,\r\n38738:30001,\r\n38739:31056,\r\n38740:35029,\r\n38741:35480,\r\n38742:36938,\r\n38743:37009,\r\n38744:37109,\r\n38745:38596,\r\n38746:34701,\r\n38747:22805,\r\n38748:20104,\r\n38749:20313,\r\n38750:19982,\r\n38751:35465,\r\n38752:36671,\r\n38753:38928,\r\n38754:20653,\r\n38755:24188,\r\n38756:22934,\r\n38757:23481,\r\n38758:24248,\r\n38759:25562,\r\n38760:25594,\r\n38761:25793,\r\n38762:26332,\r\n38763:26954,\r\n38764:27096,\r\n38765:27915,\r\n38766:28342,\r\n38767:29076,\r\n38768:29992,\r\n38769:31407,\r\n38770:32650,\r\n38771:32768,\r\n38772:33865,\r\n38773:33993,\r\n38774:35201,\r\n38775:35617,\r\n38776:36362,\r\n38777:36965,\r\n38778:38525,\r\n38779:39178,\r\n38780:24958,\r\n38781:25233,\r\n38782:27442,\r\n38784:27779,\r\n38785:28020,\r\n38786:32716,\r\n38787:32764,\r\n38788:28096,\r\n38789:32645,\r\n38790:34746,\r\n38791:35064,\r\n38792:26469,\r\n38793:33713,\r\n38794:38972,\r\n38795:38647,\r\n38796:27931,\r\n38797:32097,\r\n38798:33853,\r\n38799:37226,\r\n38800:20081,\r\n38801:21365,\r\n38802:23888,\r\n38803:27396,\r\n38804:28651,\r\n38805:34253,\r\n38806:34349,\r\n38807:35239,\r\n38808:21033,\r\n38809:21519,\r\n38810:23653,\r\n38811:26446,\r\n38812:26792,\r\n38813:29702,\r\n38814:29827,\r\n38815:30178,\r\n38816:35023,\r\n38817:35041,\r\n38818:37324,\r\n38819:38626,\r\n38820:38520,\r\n38821:24459,\r\n38822:29575,\r\n38823:31435,\r\n38824:33870,\r\n38825:25504,\r\n38826:30053,\r\n38827:21129,\r\n38828:27969,\r\n38829:28316,\r\n38830:29705,\r\n38831:30041,\r\n38832:30827,\r\n38833:31890,\r\n38834:38534,\r\n38835:31452,\r\n38836:40845,\r\n38837:20406,\r\n38838:24942,\r\n38839:26053,\r\n38840:34396,\r\n38841:20102,\r\n38842:20142,\r\n38843:20698,\r\n38844:20001,\r\n38845:20940,\r\n38846:23534,\r\n38847:26009,\r\n38848:26753,\r\n38849:28092,\r\n38850:29471,\r\n38851:30274,\r\n38852:30637,\r\n38853:31260,\r\n38854:31975,\r\n38855:33391,\r\n38856:35538,\r\n38857:36988,\r\n38858:37327,\r\n38859:38517,\r\n38860:38936,\r\n38861:21147,\r\n38862:32209,\r\n38863:20523,\r\n38864:21400,\r\n38865:26519,\r\n38866:28107,\r\n38867:29136,\r\n38868:29747,\r\n38869:33256,\r\n38870:36650,\r\n38871:38563,\r\n38872:40023,\r\n38873:40607,\r\n38874:29792,\r\n38875:22593,\r\n38876:28057,\r\n38877:32047,\r\n38878:39006,\r\n38879:20196,\r\n38880:20278,\r\n38881:20363,\r\n38882:20919,\r\n38883:21169,\r\n38884:23994,\r\n38885:24604,\r\n38886:29618,\r\n38887:31036,\r\n38888:33491,\r\n38889:37428,\r\n38890:38583,\r\n38891:38646,\r\n38892:38666,\r\n38893:40599,\r\n38894:40802,\r\n38895:26278,\r\n38896:27508,\r\n38897:21015,\r\n38898:21155,\r\n38899:28872,\r\n38900:35010,\r\n38901:24265,\r\n38902:24651,\r\n38903:24976,\r\n38904:28451,\r\n38905:29001,\r\n38906:31806,\r\n38907:32244,\r\n38908:32879,\r\n38976:34030,\r\n38977:36899,\r\n38978:37676,\r\n38979:21570,\r\n38980:39791,\r\n38981:27347,\r\n38982:28809,\r\n38983:36034,\r\n38984:36335,\r\n38985:38706,\r\n38986:21172,\r\n38987:23105,\r\n38988:24266,\r\n38989:24324,\r\n38990:26391,\r\n38991:27004,\r\n38992:27028,\r\n38993:28010,\r\n38994:28431,\r\n38995:29282,\r\n38996:29436,\r\n38997:31725,\r\n38998:32769,\r\n38999:32894,\r\n39000:34635,\r\n39001:37070,\r\n39002:20845,\r\n39003:40595,\r\n39004:31108,\r\n39005:32907,\r\n39006:37682,\r\n39007:35542,\r\n39008:20525,\r\n39009:21644,\r\n39010:35441,\r\n39011:27498,\r\n39012:36036,\r\n39013:33031,\r\n39014:24785,\r\n39015:26528,\r\n39016:40434,\r\n39017:20121,\r\n39018:20120,\r\n39019:39952,\r\n39020:35435,\r\n39021:34241,\r\n39022:34152,\r\n39023:26880,\r\n39024:28286,\r\n39025:30871,\r\n39026:33109,\r\n39071:24332,\r\n39072:19984,\r\n39073:19989,\r\n39074:20010,\r\n39075:20017,\r\n39076:20022,\r\n39077:20028,\r\n39078:20031,\r\n39079:20034,\r\n39080:20054,\r\n39081:20056,\r\n39082:20098,\r\n39083:20101,\r\n39084:35947,\r\n39085:20106,\r\n39086:33298,\r\n39087:24333,\r\n39088:20110,\r\n39089:20126,\r\n39090:20127,\r\n39091:20128,\r\n39092:20130,\r\n39093:20144,\r\n39094:20147,\r\n39095:20150,\r\n39096:20174,\r\n39097:20173,\r\n39098:20164,\r\n39099:20166,\r\n39100:20162,\r\n39101:20183,\r\n39102:20190,\r\n39103:20205,\r\n39104:20191,\r\n39105:20215,\r\n39106:20233,\r\n39107:20314,\r\n39108:20272,\r\n39109:20315,\r\n39110:20317,\r\n39111:20311,\r\n39112:20295,\r\n39113:20342,\r\n39114:20360,\r\n39115:20367,\r\n39116:20376,\r\n39117:20347,\r\n39118:20329,\r\n39119:20336,\r\n39120:20369,\r\n39121:20335,\r\n39122:20358,\r\n39123:20374,\r\n39124:20760,\r\n39125:20436,\r\n39126:20447,\r\n39127:20430,\r\n39128:20440,\r\n39129:20443,\r\n39130:20433,\r\n39131:20442,\r\n39132:20432,\r\n39133:20452,\r\n39134:20453,\r\n39135:20506,\r\n39136:20520,\r\n39137:20500,\r\n39138:20522,\r\n39139:20517,\r\n39140:20485,\r\n39141:20252,\r\n39142:20470,\r\n39143:20513,\r\n39144:20521,\r\n39145:20524,\r\n39146:20478,\r\n39147:20463,\r\n39148:20497,\r\n39149:20486,\r\n39150:20547,\r\n39151:20551,\r\n39152:26371,\r\n39153:20565,\r\n39154:20560,\r\n39155:20552,\r\n39156:20570,\r\n39157:20566,\r\n39158:20588,\r\n39159:20600,\r\n39160:20608,\r\n39161:20634,\r\n39162:20613,\r\n39163:20660,\r\n39164:20658,\r\n39232:20681,\r\n39233:20682,\r\n39234:20659,\r\n39235:20674,\r\n39236:20694,\r\n39237:20702,\r\n39238:20709,\r\n39239:20717,\r\n39240:20707,\r\n39241:20718,\r\n39242:20729,\r\n39243:20725,\r\n39244:20745,\r\n39245:20737,\r\n39246:20738,\r\n39247:20758,\r\n39248:20757,\r\n39249:20756,\r\n39250:20762,\r\n39251:20769,\r\n39252:20794,\r\n39253:20791,\r\n39254:20796,\r\n39255:20795,\r\n39256:20799,\r\n39257:20800,\r\n39258:20818,\r\n39259:20812,\r\n39260:20820,\r\n39261:20834,\r\n39262:31480,\r\n39263:20841,\r\n39264:20842,\r\n39265:20846,\r\n39266:20864,\r\n39267:20866,\r\n39268:22232,\r\n39269:20876,\r\n39270:20873,\r\n39271:20879,\r\n39272:20881,\r\n39273:20883,\r\n39274:20885,\r\n39275:20886,\r\n39276:20900,\r\n39277:20902,\r\n39278:20898,\r\n39279:20905,\r\n39280:20906,\r\n39281:20907,\r\n39282:20915,\r\n39283:20913,\r\n39284:20914,\r\n39285:20912,\r\n39286:20917,\r\n39287:20925,\r\n39288:20933,\r\n39289:20937,\r\n39290:20955,\r\n39291:20960,\r\n39292:34389,\r\n39293:20969,\r\n39294:20973,\r\n39296:20976,\r\n39297:20981,\r\n39298:20990,\r\n39299:20996,\r\n39300:21003,\r\n39301:21012,\r\n39302:21006,\r\n39303:21031,\r\n39304:21034,\r\n39305:21038,\r\n39306:21043,\r\n39307:21049,\r\n39308:21071,\r\n39309:21060,\r\n39310:21067,\r\n39311:21068,\r\n39312:21086,\r\n39313:21076,\r\n39314:21098,\r\n39315:21108,\r\n39316:21097,\r\n39317:21107,\r\n39318:21119,\r\n39319:21117,\r\n39320:21133,\r\n39321:21140,\r\n39322:21138,\r\n39323:21105,\r\n39324:21128,\r\n39325:21137,\r\n39326:36776,\r\n39327:36775,\r\n39328:21164,\r\n39329:21165,\r\n39330:21180,\r\n39331:21173,\r\n39332:21185,\r\n39333:21197,\r\n39334:21207,\r\n39335:21214,\r\n39336:21219,\r\n39337:21222,\r\n39338:39149,\r\n39339:21216,\r\n39340:21235,\r\n39341:21237,\r\n39342:21240,\r\n39343:21241,\r\n39344:21254,\r\n39345:21256,\r\n39346:30008,\r\n39347:21261,\r\n39348:21264,\r\n39349:21263,\r\n39350:21269,\r\n39351:21274,\r\n39352:21283,\r\n39353:21295,\r\n39354:21297,\r\n39355:21299,\r\n39356:21304,\r\n39357:21312,\r\n39358:21318,\r\n39359:21317,\r\n39360:19991,\r\n39361:21321,\r\n39362:21325,\r\n39363:20950,\r\n39364:21342,\r\n39365:21353,\r\n39366:21358,\r\n39367:22808,\r\n39368:21371,\r\n39369:21367,\r\n39370:21378,\r\n39371:21398,\r\n39372:21408,\r\n39373:21414,\r\n39374:21413,\r\n39375:21422,\r\n39376:21424,\r\n39377:21430,\r\n39378:21443,\r\n39379:31762,\r\n39380:38617,\r\n39381:21471,\r\n39382:26364,\r\n39383:29166,\r\n39384:21486,\r\n39385:21480,\r\n39386:21485,\r\n39387:21498,\r\n39388:21505,\r\n39389:21565,\r\n39390:21568,\r\n39391:21548,\r\n39392:21549,\r\n39393:21564,\r\n39394:21550,\r\n39395:21558,\r\n39396:21545,\r\n39397:21533,\r\n39398:21582,\r\n39399:21647,\r\n39400:21621,\r\n39401:21646,\r\n39402:21599,\r\n39403:21617,\r\n39404:21623,\r\n39405:21616,\r\n39406:21650,\r\n39407:21627,\r\n39408:21632,\r\n39409:21622,\r\n39410:21636,\r\n39411:21648,\r\n39412:21638,\r\n39413:21703,\r\n39414:21666,\r\n39415:21688,\r\n39416:21669,\r\n39417:21676,\r\n39418:21700,\r\n39419:21704,\r\n39420:21672,\r\n39488:21675,\r\n39489:21698,\r\n39490:21668,\r\n39491:21694,\r\n39492:21692,\r\n39493:21720,\r\n39494:21733,\r\n39495:21734,\r\n39496:21775,\r\n39497:21780,\r\n39498:21757,\r\n39499:21742,\r\n39500:21741,\r\n39501:21754,\r\n39502:21730,\r\n39503:21817,\r\n39504:21824,\r\n39505:21859,\r\n39506:21836,\r\n39507:21806,\r\n39508:21852,\r\n39509:21829,\r\n39510:21846,\r\n39511:21847,\r\n39512:21816,\r\n39513:21811,\r\n39514:21853,\r\n39515:21913,\r\n39516:21888,\r\n39517:21679,\r\n39518:21898,\r\n39519:21919,\r\n39520:21883,\r\n39521:21886,\r\n39522:21912,\r\n39523:21918,\r\n39524:21934,\r\n39525:21884,\r\n39526:21891,\r\n39527:21929,\r\n39528:21895,\r\n39529:21928,\r\n39530:21978,\r\n39531:21957,\r\n39532:21983,\r\n39533:21956,\r\n39534:21980,\r\n39535:21988,\r\n39536:21972,\r\n39537:22036,\r\n39538:22007,\r\n39539:22038,\r\n39540:22014,\r\n39541:22013,\r\n39542:22043,\r\n39543:22009,\r\n39544:22094,\r\n39545:22096,\r\n39546:29151,\r\n39547:22068,\r\n39548:22070,\r\n39549:22066,\r\n39550:22072,\r\n39552:22123,\r\n39553:22116,\r\n39554:22063,\r\n39555:22124,\r\n39556:22122,\r\n39557:22150,\r\n39558:22144,\r\n39559:22154,\r\n39560:22176,\r\n39561:22164,\r\n39562:22159,\r\n39563:22181,\r\n39564:22190,\r\n39565:22198,\r\n39566:22196,\r\n39567:22210,\r\n39568:22204,\r\n39569:22209,\r\n39570:22211,\r\n39571:22208,\r\n39572:22216,\r\n39573:22222,\r\n39574:22225,\r\n39575:22227,\r\n39576:22231,\r\n39577:22254,\r\n39578:22265,\r\n39579:22272,\r\n39580:22271,\r\n39581:22276,\r\n39582:22281,\r\n39583:22280,\r\n39584:22283,\r\n39585:22285,\r\n39586:22291,\r\n39587:22296,\r\n39588:22294,\r\n39589:21959,\r\n39590:22300,\r\n39591:22310,\r\n39592:22327,\r\n39593:22328,\r\n39594:22350,\r\n39595:22331,\r\n39596:22336,\r\n39597:22351,\r\n39598:22377,\r\n39599:22464,\r\n39600:22408,\r\n39601:22369,\r\n39602:22399,\r\n39603:22409,\r\n39604:22419,\r\n39605:22432,\r\n39606:22451,\r\n39607:22436,\r\n39608:22442,\r\n39609:22448,\r\n39610:22467,\r\n39611:22470,\r\n39612:22484,\r\n39613:22482,\r\n39614:22483,\r\n39615:22538,\r\n39616:22486,\r\n39617:22499,\r\n39618:22539,\r\n39619:22553,\r\n39620:22557,\r\n39621:22642,\r\n39622:22561,\r\n39623:22626,\r\n39624:22603,\r\n39625:22640,\r\n39626:27584,\r\n39627:22610,\r\n39628:22589,\r\n39629:22649,\r\n39630:22661,\r\n39631:22713,\r\n39632:22687,\r\n39633:22699,\r\n39634:22714,\r\n39635:22750,\r\n39636:22715,\r\n39637:22712,\r\n39638:22702,\r\n39639:22725,\r\n39640:22739,\r\n39641:22737,\r\n39642:22743,\r\n39643:22745,\r\n39644:22744,\r\n39645:22757,\r\n39646:22748,\r\n39647:22756,\r\n39648:22751,\r\n39649:22767,\r\n39650:22778,\r\n39651:22777,\r\n39652:22779,\r\n39653:22780,\r\n39654:22781,\r\n39655:22786,\r\n39656:22794,\r\n39657:22800,\r\n39658:22811,\r\n39659:26790,\r\n39660:22821,\r\n39661:22828,\r\n39662:22829,\r\n39663:22834,\r\n39664:22840,\r\n39665:22846,\r\n39666:31442,\r\n39667:22869,\r\n39668:22864,\r\n39669:22862,\r\n39670:22874,\r\n39671:22872,\r\n39672:22882,\r\n39673:22880,\r\n39674:22887,\r\n39675:22892,\r\n39676:22889,\r\n39744:22904,\r\n39745:22913,\r\n39746:22941,\r\n39747:20318,\r\n39748:20395,\r\n39749:22947,\r\n39750:22962,\r\n39751:22982,\r\n39752:23016,\r\n39753:23004,\r\n39754:22925,\r\n39755:23001,\r\n39756:23002,\r\n39757:23077,\r\n39758:23071,\r\n39759:23057,\r\n39760:23068,\r\n39761:23049,\r\n39762:23066,\r\n39763:23104,\r\n39764:23148,\r\n39765:23113,\r\n39766:23093,\r\n39767:23094,\r\n39768:23138,\r\n39769:23146,\r\n39770:23194,\r\n39771:23228,\r\n39772:23230,\r\n39773:23243,\r\n39774:23234,\r\n39775:23229,\r\n39776:23267,\r\n39777:23255,\r\n39778:23270,\r\n39779:23273,\r\n39780:23254,\r\n39781:23290,\r\n39782:23291,\r\n39783:23308,\r\n39784:23307,\r\n39785:23318,\r\n39786:23346,\r\n39787:23248,\r\n39788:23338,\r\n39789:23350,\r\n39790:23358,\r\n39791:23363,\r\n39792:23365,\r\n39793:23360,\r\n39794:23377,\r\n39795:23381,\r\n39796:23386,\r\n39797:23387,\r\n39798:23397,\r\n39799:23401,\r\n39800:23408,\r\n39801:23411,\r\n39802:23413,\r\n39803:23416,\r\n39804:25992,\r\n39805:23418,\r\n39806:23424,\r\n39808:23427,\r\n39809:23462,\r\n39810:23480,\r\n39811:23491,\r\n39812:23495,\r\n39813:23497,\r\n39814:23508,\r\n39815:23504,\r\n39816:23524,\r\n39817:23526,\r\n39818:23522,\r\n39819:23518,\r\n39820:23525,\r\n39821:23531,\r\n39822:23536,\r\n39823:23542,\r\n39824:23539,\r\n39825:23557,\r\n39826:23559,\r\n39827:23560,\r\n39828:23565,\r\n39829:23571,\r\n39830:23584,\r\n39831:23586,\r\n39832:23592,\r\n39833:23608,\r\n39834:23609,\r\n39835:23617,\r\n39836:23622,\r\n39837:23630,\r\n39838:23635,\r\n39839:23632,\r\n39840:23631,\r\n39841:23409,\r\n39842:23660,\r\n39843:23662,\r\n39844:20066,\r\n39845:23670,\r\n39846:23673,\r\n39847:23692,\r\n39848:23697,\r\n39849:23700,\r\n39850:22939,\r\n39851:23723,\r\n39852:23739,\r\n39853:23734,\r\n39854:23740,\r\n39855:23735,\r\n39856:23749,\r\n39857:23742,\r\n39858:23751,\r\n39859:23769,\r\n39860:23785,\r\n39861:23805,\r\n39862:23802,\r\n39863:23789,\r\n39864:23948,\r\n39865:23786,\r\n39866:23819,\r\n39867:23829,\r\n39868:23831,\r\n39869:23900,\r\n39870:23839,\r\n39871:23835,\r\n39872:23825,\r\n39873:23828,\r\n39874:23842,\r\n39875:23834,\r\n39876:23833,\r\n39877:23832,\r\n39878:23884,\r\n39879:23890,\r\n39880:23886,\r\n39881:23883,\r\n39882:23916,\r\n39883:23923,\r\n39884:23926,\r\n39885:23943,\r\n39886:23940,\r\n39887:23938,\r\n39888:23970,\r\n39889:23965,\r\n39890:23980,\r\n39891:23982,\r\n39892:23997,\r\n39893:23952,\r\n39894:23991,\r\n39895:23996,\r\n39896:24009,\r\n39897:24013,\r\n39898:24019,\r\n39899:24018,\r\n39900:24022,\r\n39901:24027,\r\n39902:24043,\r\n39903:24050,\r\n39904:24053,\r\n39905:24075,\r\n39906:24090,\r\n39907:24089,\r\n39908:24081,\r\n39909:24091,\r\n39910:24118,\r\n39911:24119,\r\n39912:24132,\r\n39913:24131,\r\n39914:24128,\r\n39915:24142,\r\n39916:24151,\r\n39917:24148,\r\n39918:24159,\r\n39919:24162,\r\n39920:24164,\r\n39921:24135,\r\n39922:24181,\r\n39923:24182,\r\n39924:24186,\r\n39925:40636,\r\n39926:24191,\r\n39927:24224,\r\n39928:24257,\r\n39929:24258,\r\n39930:24264,\r\n39931:24272,\r\n39932:24271,\r\n40000:24278,\r\n40001:24291,\r\n40002:24285,\r\n40003:24282,\r\n40004:24283,\r\n40005:24290,\r\n40006:24289,\r\n40007:24296,\r\n40008:24297,\r\n40009:24300,\r\n40010:24305,\r\n40011:24307,\r\n40012:24304,\r\n40013:24308,\r\n40014:24312,\r\n40015:24318,\r\n40016:24323,\r\n40017:24329,\r\n40018:24413,\r\n40019:24412,\r\n40020:24331,\r\n40021:24337,\r\n40022:24342,\r\n40023:24361,\r\n40024:24365,\r\n40025:24376,\r\n40026:24385,\r\n40027:24392,\r\n40028:24396,\r\n40029:24398,\r\n40030:24367,\r\n40031:24401,\r\n40032:24406,\r\n40033:24407,\r\n40034:24409,\r\n40035:24417,\r\n40036:24429,\r\n40037:24435,\r\n40038:24439,\r\n40039:24451,\r\n40040:24450,\r\n40041:24447,\r\n40042:24458,\r\n40043:24456,\r\n40044:24465,\r\n40045:24455,\r\n40046:24478,\r\n40047:24473,\r\n40048:24472,\r\n40049:24480,\r\n40050:24488,\r\n40051:24493,\r\n40052:24508,\r\n40053:24534,\r\n40054:24571,\r\n40055:24548,\r\n40056:24568,\r\n40057:24561,\r\n40058:24541,\r\n40059:24755,\r\n40060:24575,\r\n40061:24609,\r\n40062:24672,\r\n40064:24601,\r\n40065:24592,\r\n40066:24617,\r\n40067:24590,\r\n40068:24625,\r\n40069:24603,\r\n40070:24597,\r\n40071:24619,\r\n40072:24614,\r\n40073:24591,\r\n40074:24634,\r\n40075:24666,\r\n40076:24641,\r\n40077:24682,\r\n40078:24695,\r\n40079:24671,\r\n40080:24650,\r\n40081:24646,\r\n40082:24653,\r\n40083:24675,\r\n40084:24643,\r\n40085:24676,\r\n40086:24642,\r\n40087:24684,\r\n40088:24683,\r\n40089:24665,\r\n40090:24705,\r\n40091:24717,\r\n40092:24807,\r\n40093:24707,\r\n40094:24730,\r\n40095:24708,\r\n40096:24731,\r\n40097:24726,\r\n40098:24727,\r\n40099:24722,\r\n40100:24743,\r\n40101:24715,\r\n40102:24801,\r\n40103:24760,\r\n40104:24800,\r\n40105:24787,\r\n40106:24756,\r\n40107:24560,\r\n40108:24765,\r\n40109:24774,\r\n40110:24757,\r\n40111:24792,\r\n40112:24909,\r\n40113:24853,\r\n40114:24838,\r\n40115:24822,\r\n40116:24823,\r\n40117:24832,\r\n40118:24820,\r\n40119:24826,\r\n40120:24835,\r\n40121:24865,\r\n40122:24827,\r\n40123:24817,\r\n40124:24845,\r\n40125:24846,\r\n40126:24903,\r\n40127:24894,\r\n40128:24872,\r\n40129:24871,\r\n40130:24906,\r\n40131:24895,\r\n40132:24892,\r\n40133:24876,\r\n40134:24884,\r\n40135:24893,\r\n40136:24898,\r\n40137:24900,\r\n40138:24947,\r\n40139:24951,\r\n40140:24920,\r\n40141:24921,\r\n40142:24922,\r\n40143:24939,\r\n40144:24948,\r\n40145:24943,\r\n40146:24933,\r\n40147:24945,\r\n40148:24927,\r\n40149:24925,\r\n40150:24915,\r\n40151:24949,\r\n40152:24985,\r\n40153:24982,\r\n40154:24967,\r\n40155:25004,\r\n40156:24980,\r\n40157:24986,\r\n40158:24970,\r\n40159:24977,\r\n40160:25003,\r\n40161:25006,\r\n40162:25036,\r\n40163:25034,\r\n40164:25033,\r\n40165:25079,\r\n40166:25032,\r\n40167:25027,\r\n40168:25030,\r\n40169:25018,\r\n40170:25035,\r\n40171:32633,\r\n40172:25037,\r\n40173:25062,\r\n40174:25059,\r\n40175:25078,\r\n40176:25082,\r\n40177:25076,\r\n40178:25087,\r\n40179:25085,\r\n40180:25084,\r\n40181:25086,\r\n40182:25088,\r\n40183:25096,\r\n40184:25097,\r\n40185:25101,\r\n40186:25100,\r\n40187:25108,\r\n40188:25115,\r\n40256:25118,\r\n40257:25121,\r\n40258:25130,\r\n40259:25134,\r\n40260:25136,\r\n40261:25138,\r\n40262:25139,\r\n40263:25153,\r\n40264:25166,\r\n40265:25182,\r\n40266:25187,\r\n40267:25179,\r\n40268:25184,\r\n40269:25192,\r\n40270:25212,\r\n40271:25218,\r\n40272:25225,\r\n40273:25214,\r\n40274:25234,\r\n40275:25235,\r\n40276:25238,\r\n40277:25300,\r\n40278:25219,\r\n40279:25236,\r\n40280:25303,\r\n40281:25297,\r\n40282:25275,\r\n40283:25295,\r\n40284:25343,\r\n40285:25286,\r\n40286:25812,\r\n40287:25288,\r\n40288:25308,\r\n40289:25292,\r\n40290:25290,\r\n40291:25282,\r\n40292:25287,\r\n40293:25243,\r\n40294:25289,\r\n40295:25356,\r\n40296:25326,\r\n40297:25329,\r\n40298:25383,\r\n40299:25346,\r\n40300:25352,\r\n40301:25327,\r\n40302:25333,\r\n40303:25424,\r\n40304:25406,\r\n40305:25421,\r\n40306:25628,\r\n40307:25423,\r\n40308:25494,\r\n40309:25486,\r\n40310:25472,\r\n40311:25515,\r\n40312:25462,\r\n40313:25507,\r\n40314:25487,\r\n40315:25481,\r\n40316:25503,\r\n40317:25525,\r\n40318:25451,\r\n40320:25449,\r\n40321:25534,\r\n40322:25577,\r\n40323:25536,\r\n40324:25542,\r\n40325:25571,\r\n40326:25545,\r\n40327:25554,\r\n40328:25590,\r\n40329:25540,\r\n40330:25622,\r\n40331:25652,\r\n40332:25606,\r\n40333:25619,\r\n40334:25638,\r\n40335:25654,\r\n40336:25885,\r\n40337:25623,\r\n40338:25640,\r\n40339:25615,\r\n40340:25703,\r\n40341:25711,\r\n40342:25718,\r\n40343:25678,\r\n40344:25898,\r\n40345:25749,\r\n40346:25747,\r\n40347:25765,\r\n40348:25769,\r\n40349:25736,\r\n40350:25788,\r\n40351:25818,\r\n40352:25810,\r\n40353:25797,\r\n40354:25799,\r\n40355:25787,\r\n40356:25816,\r\n40357:25794,\r\n40358:25841,\r\n40359:25831,\r\n40360:33289,\r\n40361:25824,\r\n40362:25825,\r\n40363:25260,\r\n40364:25827,\r\n40365:25839,\r\n40366:25900,\r\n40367:25846,\r\n40368:25844,\r\n40369:25842,\r\n40370:25850,\r\n40371:25856,\r\n40372:25853,\r\n40373:25880,\r\n40374:25884,\r\n40375:25861,\r\n40376:25892,\r\n40377:25891,\r\n40378:25899,\r\n40379:25908,\r\n40380:25909,\r\n40381:25911,\r\n40382:25910,\r\n40383:25912,\r\n40384:30027,\r\n40385:25928,\r\n40386:25942,\r\n40387:25941,\r\n40388:25933,\r\n40389:25944,\r\n40390:25950,\r\n40391:25949,\r\n40392:25970,\r\n40393:25976,\r\n40394:25986,\r\n40395:25987,\r\n40396:35722,\r\n40397:26011,\r\n40398:26015,\r\n40399:26027,\r\n40400:26039,\r\n40401:26051,\r\n40402:26054,\r\n40403:26049,\r\n40404:26052,\r\n40405:26060,\r\n40406:26066,\r\n40407:26075,\r\n40408:26073,\r\n40409:26080,\r\n40410:26081,\r\n40411:26097,\r\n40412:26482,\r\n40413:26122,\r\n40414:26115,\r\n40415:26107,\r\n40416:26483,\r\n40417:26165,\r\n40418:26166,\r\n40419:26164,\r\n40420:26140,\r\n40421:26191,\r\n40422:26180,\r\n40423:26185,\r\n40424:26177,\r\n40425:26206,\r\n40426:26205,\r\n40427:26212,\r\n40428:26215,\r\n40429:26216,\r\n40430:26207,\r\n40431:26210,\r\n40432:26224,\r\n40433:26243,\r\n40434:26248,\r\n40435:26254,\r\n40436:26249,\r\n40437:26244,\r\n40438:26264,\r\n40439:26269,\r\n40440:26305,\r\n40441:26297,\r\n40442:26313,\r\n40443:26302,\r\n40444:26300,\r\n40512:26308,\r\n40513:26296,\r\n40514:26326,\r\n40515:26330,\r\n40516:26336,\r\n40517:26175,\r\n40518:26342,\r\n40519:26345,\r\n40520:26352,\r\n40521:26357,\r\n40522:26359,\r\n40523:26383,\r\n40524:26390,\r\n40525:26398,\r\n40526:26406,\r\n40527:26407,\r\n40528:38712,\r\n40529:26414,\r\n40530:26431,\r\n40531:26422,\r\n40532:26433,\r\n40533:26424,\r\n40534:26423,\r\n40535:26438,\r\n40536:26462,\r\n40537:26464,\r\n40538:26457,\r\n40539:26467,\r\n40540:26468,\r\n40541:26505,\r\n40542:26480,\r\n40543:26537,\r\n40544:26492,\r\n40545:26474,\r\n40546:26508,\r\n40547:26507,\r\n40548:26534,\r\n40549:26529,\r\n40550:26501,\r\n40551:26551,\r\n40552:26607,\r\n40553:26548,\r\n40554:26604,\r\n40555:26547,\r\n40556:26601,\r\n40557:26552,\r\n40558:26596,\r\n40559:26590,\r\n40560:26589,\r\n40561:26594,\r\n40562:26606,\r\n40563:26553,\r\n40564:26574,\r\n40565:26566,\r\n40566:26599,\r\n40567:27292,\r\n40568:26654,\r\n40569:26694,\r\n40570:26665,\r\n40571:26688,\r\n40572:26701,\r\n40573:26674,\r\n40574:26702,\r\n40576:26803,\r\n40577:26667,\r\n40578:26713,\r\n40579:26723,\r\n40580:26743,\r\n40581:26751,\r\n40582:26783,\r\n40583:26767,\r\n40584:26797,\r\n40585:26772,\r\n40586:26781,\r\n40587:26779,\r\n40588:26755,\r\n40589:27310,\r\n40590:26809,\r\n40591:26740,\r\n40592:26805,\r\n40593:26784,\r\n40594:26810,\r\n40595:26895,\r\n40596:26765,\r\n40597:26750,\r\n40598:26881,\r\n40599:26826,\r\n40600:26888,\r\n40601:26840,\r\n40602:26914,\r\n40603:26918,\r\n40604:26849,\r\n40605:26892,\r\n40606:26829,\r\n40607:26836,\r\n40608:26855,\r\n40609:26837,\r\n40610:26934,\r\n40611:26898,\r\n40612:26884,\r\n40613:26839,\r\n40614:26851,\r\n40615:26917,\r\n40616:26873,\r\n40617:26848,\r\n40618:26863,\r\n40619:26920,\r\n40620:26922,\r\n40621:26906,\r\n40622:26915,\r\n40623:26913,\r\n40624:26822,\r\n40625:27001,\r\n40626:26999,\r\n40627:26972,\r\n40628:27000,\r\n40629:26987,\r\n40630:26964,\r\n40631:27006,\r\n40632:26990,\r\n40633:26937,\r\n40634:26996,\r\n40635:26941,\r\n40636:26969,\r\n40637:26928,\r\n40638:26977,\r\n40639:26974,\r\n40640:26973,\r\n40641:27009,\r\n40642:26986,\r\n40643:27058,\r\n40644:27054,\r\n40645:27088,\r\n40646:27071,\r\n40647:27073,\r\n40648:27091,\r\n40649:27070,\r\n40650:27086,\r\n40651:23528,\r\n40652:27082,\r\n40653:27101,\r\n40654:27067,\r\n40655:27075,\r\n40656:27047,\r\n40657:27182,\r\n40658:27025,\r\n40659:27040,\r\n40660:27036,\r\n40661:27029,\r\n40662:27060,\r\n40663:27102,\r\n40664:27112,\r\n40665:27138,\r\n40666:27163,\r\n40667:27135,\r\n40668:27402,\r\n40669:27129,\r\n40670:27122,\r\n40671:27111,\r\n40672:27141,\r\n40673:27057,\r\n40674:27166,\r\n40675:27117,\r\n40676:27156,\r\n40677:27115,\r\n40678:27146,\r\n40679:27154,\r\n40680:27329,\r\n40681:27171,\r\n40682:27155,\r\n40683:27204,\r\n40684:27148,\r\n40685:27250,\r\n40686:27190,\r\n40687:27256,\r\n40688:27207,\r\n40689:27234,\r\n40690:27225,\r\n40691:27238,\r\n40692:27208,\r\n40693:27192,\r\n40694:27170,\r\n40695:27280,\r\n40696:27277,\r\n40697:27296,\r\n40698:27268,\r\n40699:27298,\r\n40700:27299,\r\n40768:27287,\r\n40769:34327,\r\n40770:27323,\r\n40771:27331,\r\n40772:27330,\r\n40773:27320,\r\n40774:27315,\r\n40775:27308,\r\n40776:27358,\r\n40777:27345,\r\n40778:27359,\r\n40779:27306,\r\n40780:27354,\r\n40781:27370,\r\n40782:27387,\r\n40783:27397,\r\n40784:34326,\r\n40785:27386,\r\n40786:27410,\r\n40787:27414,\r\n40788:39729,\r\n40789:27423,\r\n40790:27448,\r\n40791:27447,\r\n40792:30428,\r\n40793:27449,\r\n40794:39150,\r\n40795:27463,\r\n40796:27459,\r\n40797:27465,\r\n40798:27472,\r\n40799:27481,\r\n40800:27476,\r\n40801:27483,\r\n40802:27487,\r\n40803:27489,\r\n40804:27512,\r\n40805:27513,\r\n40806:27519,\r\n40807:27520,\r\n40808:27524,\r\n40809:27523,\r\n40810:27533,\r\n40811:27544,\r\n40812:27541,\r\n40813:27550,\r\n40814:27556,\r\n40815:27562,\r\n40816:27563,\r\n40817:27567,\r\n40818:27570,\r\n40819:27569,\r\n40820:27571,\r\n40821:27575,\r\n40822:27580,\r\n40823:27590,\r\n40824:27595,\r\n40825:27603,\r\n40826:27615,\r\n40827:27628,\r\n40828:27627,\r\n40829:27635,\r\n40830:27631,\r\n40832:40638,\r\n40833:27656,\r\n40834:27667,\r\n40835:27668,\r\n40836:27675,\r\n40837:27684,\r\n40838:27683,\r\n40839:27742,\r\n40840:27733,\r\n40841:27746,\r\n40842:27754,\r\n40843:27778,\r\n40844:27789,\r\n40845:27802,\r\n40846:27777,\r\n40847:27803,\r\n40848:27774,\r\n40849:27752,\r\n40850:27763,\r\n40851:27794,\r\n40852:27792,\r\n40853:27844,\r\n40854:27889,\r\n40855:27859,\r\n40856:27837,\r\n40857:27863,\r\n40858:27845,\r\n40859:27869,\r\n40860:27822,\r\n40861:27825,\r\n40862:27838,\r\n40863:27834,\r\n40864:27867,\r\n40865:27887,\r\n40866:27865,\r\n40867:27882,\r\n40868:27935,\r\n40869:34893,\r\n40870:27958,\r\n40871:27947,\r\n40872:27965,\r\n40873:27960,\r\n40874:27929,\r\n40875:27957,\r\n40876:27955,\r\n40877:27922,\r\n40878:27916,\r\n40879:28003,\r\n40880:28051,\r\n40881:28004,\r\n40882:27994,\r\n40883:28025,\r\n40884:27993,\r\n40885:28046,\r\n40886:28053,\r\n40887:28644,\r\n40888:28037,\r\n40889:28153,\r\n40890:28181,\r\n40891:28170,\r\n40892:28085,\r\n40893:28103,\r\n40894:28134,\r\n40895:28088,\r\n40896:28102,\r\n40897:28140,\r\n40898:28126,\r\n40899:28108,\r\n40900:28136,\r\n40901:28114,\r\n40902:28101,\r\n40903:28154,\r\n40904:28121,\r\n40905:28132,\r\n40906:28117,\r\n40907:28138,\r\n40908:28142,\r\n40909:28205,\r\n40910:28270,\r\n40911:28206,\r\n40912:28185,\r\n40913:28274,\r\n40914:28255,\r\n40915:28222,\r\n40916:28195,\r\n40917:28267,\r\n40918:28203,\r\n40919:28278,\r\n40920:28237,\r\n40921:28191,\r\n40922:28227,\r\n40923:28218,\r\n40924:28238,\r\n40925:28196,\r\n40926:28415,\r\n40927:28189,\r\n40928:28216,\r\n40929:28290,\r\n40930:28330,\r\n40931:28312,\r\n40932:28361,\r\n40933:28343,\r\n40934:28371,\r\n40935:28349,\r\n40936:28335,\r\n40937:28356,\r\n40938:28338,\r\n40939:28372,\r\n40940:28373,\r\n40941:28303,\r\n40942:28325,\r\n40943:28354,\r\n40944:28319,\r\n40945:28481,\r\n40946:28433,\r\n40947:28748,\r\n40948:28396,\r\n40949:28408,\r\n40950:28414,\r\n40951:28479,\r\n40952:28402,\r\n40953:28465,\r\n40954:28399,\r\n40955:28466,\r\n40956:28364,\r\n57408:28478,\r\n57409:28435,\r\n57410:28407,\r\n57411:28550,\r\n57412:28538,\r\n57413:28536,\r\n57414:28545,\r\n57415:28544,\r\n57416:28527,\r\n57417:28507,\r\n57418:28659,\r\n57419:28525,\r\n57420:28546,\r\n57421:28540,\r\n57422:28504,\r\n57423:28558,\r\n57424:28561,\r\n57425:28610,\r\n57426:28518,\r\n57427:28595,\r\n57428:28579,\r\n57429:28577,\r\n57430:28580,\r\n57431:28601,\r\n57432:28614,\r\n57433:28586,\r\n57434:28639,\r\n57435:28629,\r\n57436:28652,\r\n57437:28628,\r\n57438:28632,\r\n57439:28657,\r\n57440:28654,\r\n57441:28635,\r\n57442:28681,\r\n57443:28683,\r\n57444:28666,\r\n57445:28689,\r\n57446:28673,\r\n57447:28687,\r\n57448:28670,\r\n57449:28699,\r\n57450:28698,\r\n57451:28532,\r\n57452:28701,\r\n57453:28696,\r\n57454:28703,\r\n57455:28720,\r\n57456:28734,\r\n57457:28722,\r\n57458:28753,\r\n57459:28771,\r\n57460:28825,\r\n57461:28818,\r\n57462:28847,\r\n57463:28913,\r\n57464:28844,\r\n57465:28856,\r\n57466:28851,\r\n57467:28846,\r\n57468:28895,\r\n57469:28875,\r\n57470:28893,\r\n57472:28889,\r\n57473:28937,\r\n57474:28925,\r\n57475:28956,\r\n57476:28953,\r\n57477:29029,\r\n57478:29013,\r\n57479:29064,\r\n57480:29030,\r\n57481:29026,\r\n57482:29004,\r\n57483:29014,\r\n57484:29036,\r\n57485:29071,\r\n57486:29179,\r\n57487:29060,\r\n57488:29077,\r\n57489:29096,\r\n57490:29100,\r\n57491:29143,\r\n57492:29113,\r\n57493:29118,\r\n57494:29138,\r\n57495:29129,\r\n57496:29140,\r\n57497:29134,\r\n57498:29152,\r\n57499:29164,\r\n57500:29159,\r\n57501:29173,\r\n57502:29180,\r\n57503:29177,\r\n57504:29183,\r\n57505:29197,\r\n57506:29200,\r\n57507:29211,\r\n57508:29224,\r\n57509:29229,\r\n57510:29228,\r\n57511:29232,\r\n57512:29234,\r\n57513:29243,\r\n57514:29244,\r\n57515:29247,\r\n57516:29248,\r\n57517:29254,\r\n57518:29259,\r\n57519:29272,\r\n57520:29300,\r\n57521:29310,\r\n57522:29314,\r\n57523:29313,\r\n57524:29319,\r\n57525:29330,\r\n57526:29334,\r\n57527:29346,\r\n57528:29351,\r\n57529:29369,\r\n57530:29362,\r\n57531:29379,\r\n57532:29382,\r\n57533:29380,\r\n57534:29390,\r\n57535:29394,\r\n57536:29410,\r\n57537:29408,\r\n57538:29409,\r\n57539:29433,\r\n57540:29431,\r\n57541:20495,\r\n57542:29463,\r\n57543:29450,\r\n57544:29468,\r\n57545:29462,\r\n57546:29469,\r\n57547:29492,\r\n57548:29487,\r\n57549:29481,\r\n57550:29477,\r\n57551:29502,\r\n57552:29518,\r\n57553:29519,\r\n57554:40664,\r\n57555:29527,\r\n57556:29546,\r\n57557:29544,\r\n57558:29552,\r\n57559:29560,\r\n57560:29557,\r\n57561:29563,\r\n57562:29562,\r\n57563:29640,\r\n57564:29619,\r\n57565:29646,\r\n57566:29627,\r\n57567:29632,\r\n57568:29669,\r\n57569:29678,\r\n57570:29662,\r\n57571:29858,\r\n57572:29701,\r\n57573:29807,\r\n57574:29733,\r\n57575:29688,\r\n57576:29746,\r\n57577:29754,\r\n57578:29781,\r\n57579:29759,\r\n57580:29791,\r\n57581:29785,\r\n57582:29761,\r\n57583:29788,\r\n57584:29801,\r\n57585:29808,\r\n57586:29795,\r\n57587:29802,\r\n57588:29814,\r\n57589:29822,\r\n57590:29835,\r\n57591:29854,\r\n57592:29863,\r\n57593:29898,\r\n57594:29903,\r\n57595:29908,\r\n57596:29681,\r\n57664:29920,\r\n57665:29923,\r\n57666:29927,\r\n57667:29929,\r\n57668:29934,\r\n57669:29938,\r\n57670:29936,\r\n57671:29937,\r\n57672:29944,\r\n57673:29943,\r\n57674:29956,\r\n57675:29955,\r\n57676:29957,\r\n57677:29964,\r\n57678:29966,\r\n57679:29965,\r\n57680:29973,\r\n57681:29971,\r\n57682:29982,\r\n57683:29990,\r\n57684:29996,\r\n57685:30012,\r\n57686:30020,\r\n57687:30029,\r\n57688:30026,\r\n57689:30025,\r\n57690:30043,\r\n57691:30022,\r\n57692:30042,\r\n57693:30057,\r\n57694:30052,\r\n57695:30055,\r\n57696:30059,\r\n57697:30061,\r\n57698:30072,\r\n57699:30070,\r\n57700:30086,\r\n57701:30087,\r\n57702:30068,\r\n57703:30090,\r\n57704:30089,\r\n57705:30082,\r\n57706:30100,\r\n57707:30106,\r\n57708:30109,\r\n57709:30117,\r\n57710:30115,\r\n57711:30146,\r\n57712:30131,\r\n57713:30147,\r\n57714:30133,\r\n57715:30141,\r\n57716:30136,\r\n57717:30140,\r\n57718:30129,\r\n57719:30157,\r\n57720:30154,\r\n57721:30162,\r\n57722:30169,\r\n57723:30179,\r\n57724:30174,\r\n57725:30206,\r\n57726:30207,\r\n57728:30204,\r\n57729:30209,\r\n57730:30192,\r\n57731:30202,\r\n57732:30194,\r\n57733:30195,\r\n57734:30219,\r\n57735:30221,\r\n57736:30217,\r\n57737:30239,\r\n57738:30247,\r\n57739:30240,\r\n57740:30241,\r\n57741:30242,\r\n57742:30244,\r\n57743:30260,\r\n57744:30256,\r\n57745:30267,\r\n57746:30279,\r\n57747:30280,\r\n57748:30278,\r\n57749:30300,\r\n57750:30296,\r\n57751:30305,\r\n57752:30306,\r\n57753:30312,\r\n57754:30313,\r\n57755:30314,\r\n57756:30311,\r\n57757:30316,\r\n57758:30320,\r\n57759:30322,\r\n57760:30326,\r\n57761:30328,\r\n57762:30332,\r\n57763:30336,\r\n57764:30339,\r\n57765:30344,\r\n57766:30347,\r\n57767:30350,\r\n57768:30358,\r\n57769:30355,\r\n57770:30361,\r\n57771:30362,\r\n57772:30384,\r\n57773:30388,\r\n57774:30392,\r\n57775:30393,\r\n57776:30394,\r\n57777:30402,\r\n57778:30413,\r\n57779:30422,\r\n57780:30418,\r\n57781:30430,\r\n57782:30433,\r\n57783:30437,\r\n57784:30439,\r\n57785:30442,\r\n57786:34351,\r\n57787:30459,\r\n57788:30472,\r\n57789:30471,\r\n57790:30468,\r\n57791:30505,\r\n57792:30500,\r\n57793:30494,\r\n57794:30501,\r\n57795:30502,\r\n57796:30491,\r\n57797:30519,\r\n57798:30520,\r\n57799:30535,\r\n57800:30554,\r\n57801:30568,\r\n57802:30571,\r\n57803:30555,\r\n57804:30565,\r\n57805:30591,\r\n57806:30590,\r\n57807:30585,\r\n57808:30606,\r\n57809:30603,\r\n57810:30609,\r\n57811:30624,\r\n57812:30622,\r\n57813:30640,\r\n57814:30646,\r\n57815:30649,\r\n57816:30655,\r\n57817:30652,\r\n57818:30653,\r\n57819:30651,\r\n57820:30663,\r\n57821:30669,\r\n57822:30679,\r\n57823:30682,\r\n57824:30684,\r\n57825:30691,\r\n57826:30702,\r\n57827:30716,\r\n57828:30732,\r\n57829:30738,\r\n57830:31014,\r\n57831:30752,\r\n57832:31018,\r\n57833:30789,\r\n57834:30862,\r\n57835:30836,\r\n57836:30854,\r\n57837:30844,\r\n57838:30874,\r\n57839:30860,\r\n57840:30883,\r\n57841:30901,\r\n57842:30890,\r\n57843:30895,\r\n57844:30929,\r\n57845:30918,\r\n57846:30923,\r\n57847:30932,\r\n57848:30910,\r\n57849:30908,\r\n57850:30917,\r\n57851:30922,\r\n57852:30956,\r\n57920:30951,\r\n57921:30938,\r\n57922:30973,\r\n57923:30964,\r\n57924:30983,\r\n57925:30994,\r\n57926:30993,\r\n57927:31001,\r\n57928:31020,\r\n57929:31019,\r\n57930:31040,\r\n57931:31072,\r\n57932:31063,\r\n57933:31071,\r\n57934:31066,\r\n57935:31061,\r\n57936:31059,\r\n57937:31098,\r\n57938:31103,\r\n57939:31114,\r\n57940:31133,\r\n57941:31143,\r\n57942:40779,\r\n57943:31146,\r\n57944:31150,\r\n57945:31155,\r\n57946:31161,\r\n57947:31162,\r\n57948:31177,\r\n57949:31189,\r\n57950:31207,\r\n57951:31212,\r\n57952:31201,\r\n57953:31203,\r\n57954:31240,\r\n57955:31245,\r\n57956:31256,\r\n57957:31257,\r\n57958:31264,\r\n57959:31263,\r\n57960:31104,\r\n57961:31281,\r\n57962:31291,\r\n57963:31294,\r\n57964:31287,\r\n57965:31299,\r\n57966:31319,\r\n57967:31305,\r\n57968:31329,\r\n57969:31330,\r\n57970:31337,\r\n57971:40861,\r\n57972:31344,\r\n57973:31353,\r\n57974:31357,\r\n57975:31368,\r\n57976:31383,\r\n57977:31381,\r\n57978:31384,\r\n57979:31382,\r\n57980:31401,\r\n57981:31432,\r\n57982:31408,\r\n57984:31414,\r\n57985:31429,\r\n57986:31428,\r\n57987:31423,\r\n57988:36995,\r\n57989:31431,\r\n57990:31434,\r\n57991:31437,\r\n57992:31439,\r\n57993:31445,\r\n57994:31443,\r\n57995:31449,\r\n57996:31450,\r\n57997:31453,\r\n57998:31457,\r\n57999:31458,\r\n58000:31462,\r\n58001:31469,\r\n58002:31472,\r\n58003:31490,\r\n58004:31503,\r\n58005:31498,\r\n58006:31494,\r\n58007:31539,\r\n58008:31512,\r\n58009:31513,\r\n58010:31518,\r\n58011:31541,\r\n58012:31528,\r\n58013:31542,\r\n58014:31568,\r\n58015:31610,\r\n58016:31492,\r\n58017:31565,\r\n58018:31499,\r\n58019:31564,\r\n58020:31557,\r\n58021:31605,\r\n58022:31589,\r\n58023:31604,\r\n58024:31591,\r\n58025:31600,\r\n58026:31601,\r\n58027:31596,\r\n58028:31598,\r\n58029:31645,\r\n58030:31640,\r\n58031:31647,\r\n58032:31629,\r\n58033:31644,\r\n58034:31642,\r\n58035:31627,\r\n58036:31634,\r\n58037:31631,\r\n58038:31581,\r\n58039:31641,\r\n58040:31691,\r\n58041:31681,\r\n58042:31692,\r\n58043:31695,\r\n58044:31668,\r\n58045:31686,\r\n58046:31709,\r\n58047:31721,\r\n58048:31761,\r\n58049:31764,\r\n58050:31718,\r\n58051:31717,\r\n58052:31840,\r\n58053:31744,\r\n58054:31751,\r\n58055:31763,\r\n58056:31731,\r\n58057:31735,\r\n58058:31767,\r\n58059:31757,\r\n58060:31734,\r\n58061:31779,\r\n58062:31783,\r\n58063:31786,\r\n58064:31775,\r\n58065:31799,\r\n58066:31787,\r\n58067:31805,\r\n58068:31820,\r\n58069:31811,\r\n58070:31828,\r\n58071:31823,\r\n58072:31808,\r\n58073:31824,\r\n58074:31832,\r\n58075:31839,\r\n58076:31844,\r\n58077:31830,\r\n58078:31845,\r\n58079:31852,\r\n58080:31861,\r\n58081:31875,\r\n58082:31888,\r\n58083:31908,\r\n58084:31917,\r\n58085:31906,\r\n58086:31915,\r\n58087:31905,\r\n58088:31912,\r\n58089:31923,\r\n58090:31922,\r\n58091:31921,\r\n58092:31918,\r\n58093:31929,\r\n58094:31933,\r\n58095:31936,\r\n58096:31941,\r\n58097:31938,\r\n58098:31960,\r\n58099:31954,\r\n58100:31964,\r\n58101:31970,\r\n58102:39739,\r\n58103:31983,\r\n58104:31986,\r\n58105:31988,\r\n58106:31990,\r\n58107:31994,\r\n58108:32006,\r\n58176:32002,\r\n58177:32028,\r\n58178:32021,\r\n58179:32010,\r\n58180:32069,\r\n58181:32075,\r\n58182:32046,\r\n58183:32050,\r\n58184:32063,\r\n58185:32053,\r\n58186:32070,\r\n58187:32115,\r\n58188:32086,\r\n58189:32078,\r\n58190:32114,\r\n58191:32104,\r\n58192:32110,\r\n58193:32079,\r\n58194:32099,\r\n58195:32147,\r\n58196:32137,\r\n58197:32091,\r\n58198:32143,\r\n58199:32125,\r\n58200:32155,\r\n58201:32186,\r\n58202:32174,\r\n58203:32163,\r\n58204:32181,\r\n58205:32199,\r\n58206:32189,\r\n58207:32171,\r\n58208:32317,\r\n58209:32162,\r\n58210:32175,\r\n58211:32220,\r\n58212:32184,\r\n58213:32159,\r\n58214:32176,\r\n58215:32216,\r\n58216:32221,\r\n58217:32228,\r\n58218:32222,\r\n58219:32251,\r\n58220:32242,\r\n58221:32225,\r\n58222:32261,\r\n58223:32266,\r\n58224:32291,\r\n58225:32289,\r\n58226:32274,\r\n58227:32305,\r\n58228:32287,\r\n58229:32265,\r\n58230:32267,\r\n58231:32290,\r\n58232:32326,\r\n58233:32358,\r\n58234:32315,\r\n58235:32309,\r\n58236:32313,\r\n58237:32323,\r\n58238:32311,\r\n58240:32306,\r\n58241:32314,\r\n58242:32359,\r\n58243:32349,\r\n58244:32342,\r\n58245:32350,\r\n58246:32345,\r\n58247:32346,\r\n58248:32377,\r\n58249:32362,\r\n58250:32361,\r\n58251:32380,\r\n58252:32379,\r\n58253:32387,\r\n58254:32213,\r\n58255:32381,\r\n58256:36782,\r\n58257:32383,\r\n58258:32392,\r\n58259:32393,\r\n58260:32396,\r\n58261:32402,\r\n58262:32400,\r\n58263:32403,\r\n58264:32404,\r\n58265:32406,\r\n58266:32398,\r\n58267:32411,\r\n58268:32412,\r\n58269:32568,\r\n58270:32570,\r\n58271:32581,\r\n58272:32588,\r\n58273:32589,\r\n58274:32590,\r\n58275:32592,\r\n58276:32593,\r\n58277:32597,\r\n58278:32596,\r\n58279:32600,\r\n58280:32607,\r\n58281:32608,\r\n58282:32616,\r\n58283:32617,\r\n58284:32615,\r\n58285:32632,\r\n58286:32642,\r\n58287:32646,\r\n58288:32643,\r\n58289:32648,\r\n58290:32647,\r\n58291:32652,\r\n58292:32660,\r\n58293:32670,\r\n58294:32669,\r\n58295:32666,\r\n58296:32675,\r\n58297:32687,\r\n58298:32690,\r\n58299:32697,\r\n58300:32686,\r\n58301:32694,\r\n58302:32696,\r\n58303:35697,\r\n58304:32709,\r\n58305:32710,\r\n58306:32714,\r\n58307:32725,\r\n58308:32724,\r\n58309:32737,\r\n58310:32742,\r\n58311:32745,\r\n58312:32755,\r\n58313:32761,\r\n58314:39132,\r\n58315:32774,\r\n58316:32772,\r\n58317:32779,\r\n58318:32786,\r\n58319:32792,\r\n58320:32793,\r\n58321:32796,\r\n58322:32801,\r\n58323:32808,\r\n58324:32831,\r\n58325:32827,\r\n58326:32842,\r\n58327:32838,\r\n58328:32850,\r\n58329:32856,\r\n58330:32858,\r\n58331:32863,\r\n58332:32866,\r\n58333:32872,\r\n58334:32883,\r\n58335:32882,\r\n58336:32880,\r\n58337:32886,\r\n58338:32889,\r\n58339:32893,\r\n58340:32895,\r\n58341:32900,\r\n58342:32902,\r\n58343:32901,\r\n58344:32923,\r\n58345:32915,\r\n58346:32922,\r\n58347:32941,\r\n58348:20880,\r\n58349:32940,\r\n58350:32987,\r\n58351:32997,\r\n58352:32985,\r\n58353:32989,\r\n58354:32964,\r\n58355:32986,\r\n58356:32982,\r\n58357:33033,\r\n58358:33007,\r\n58359:33009,\r\n58360:33051,\r\n58361:33065,\r\n58362:33059,\r\n58363:33071,\r\n58364:33099,\r\n58432:38539,\r\n58433:33094,\r\n58434:33086,\r\n58435:33107,\r\n58436:33105,\r\n58437:33020,\r\n58438:33137,\r\n58439:33134,\r\n58440:33125,\r\n58441:33126,\r\n58442:33140,\r\n58443:33155,\r\n58444:33160,\r\n58445:33162,\r\n58446:33152,\r\n58447:33154,\r\n58448:33184,\r\n58449:33173,\r\n58450:33188,\r\n58451:33187,\r\n58452:33119,\r\n58453:33171,\r\n58454:33193,\r\n58455:33200,\r\n58456:33205,\r\n58457:33214,\r\n58458:33208,\r\n58459:33213,\r\n58460:33216,\r\n58461:33218,\r\n58462:33210,\r\n58463:33225,\r\n58464:33229,\r\n58465:33233,\r\n58466:33241,\r\n58467:33240,\r\n58468:33224,\r\n58469:33242,\r\n58470:33247,\r\n58471:33248,\r\n58472:33255,\r\n58473:33274,\r\n58474:33275,\r\n58475:33278,\r\n58476:33281,\r\n58477:33282,\r\n58478:33285,\r\n58479:33287,\r\n58480:33290,\r\n58481:33293,\r\n58482:33296,\r\n58483:33302,\r\n58484:33321,\r\n58485:33323,\r\n58486:33336,\r\n58487:33331,\r\n58488:33344,\r\n58489:33369,\r\n58490:33368,\r\n58491:33373,\r\n58492:33370,\r\n58493:33375,\r\n58494:33380,\r\n58496:33378,\r\n58497:33384,\r\n58498:33386,\r\n58499:33387,\r\n58500:33326,\r\n58501:33393,\r\n58502:33399,\r\n58503:33400,\r\n58504:33406,\r\n58505:33421,\r\n58506:33426,\r\n58507:33451,\r\n58508:33439,\r\n58509:33467,\r\n58510:33452,\r\n58511:33505,\r\n58512:33507,\r\n58513:33503,\r\n58514:33490,\r\n58515:33524,\r\n58516:33523,\r\n58517:33530,\r\n58518:33683,\r\n58519:33539,\r\n58520:33531,\r\n58521:33529,\r\n58522:33502,\r\n58523:33542,\r\n58524:33500,\r\n58525:33545,\r\n58526:33497,\r\n58527:33589,\r\n58528:33588,\r\n58529:33558,\r\n58530:33586,\r\n58531:33585,\r\n58532:33600,\r\n58533:33593,\r\n58534:33616,\r\n58535:33605,\r\n58536:33583,\r\n58537:33579,\r\n58538:33559,\r\n58539:33560,\r\n58540:33669,\r\n58541:33690,\r\n58542:33706,\r\n58543:33695,\r\n58544:33698,\r\n58545:33686,\r\n58546:33571,\r\n58547:33678,\r\n58548:33671,\r\n58549:33674,\r\n58550:33660,\r\n58551:33717,\r\n58552:33651,\r\n58553:33653,\r\n58554:33696,\r\n58555:33673,\r\n58556:33704,\r\n58557:33780,\r\n58558:33811,\r\n58559:33771,\r\n58560:33742,\r\n58561:33789,\r\n58562:33795,\r\n58563:33752,\r\n58564:33803,\r\n58565:33729,\r\n58566:33783,\r\n58567:33799,\r\n58568:33760,\r\n58569:33778,\r\n58570:33805,\r\n58571:33826,\r\n58572:33824,\r\n58573:33725,\r\n58574:33848,\r\n58575:34054,\r\n58576:33787,\r\n58577:33901,\r\n58578:33834,\r\n58579:33852,\r\n58580:34138,\r\n58581:33924,\r\n58582:33911,\r\n58583:33899,\r\n58584:33965,\r\n58585:33902,\r\n58586:33922,\r\n58587:33897,\r\n58588:33862,\r\n58589:33836,\r\n58590:33903,\r\n58591:33913,\r\n58592:33845,\r\n58593:33994,\r\n58594:33890,\r\n58595:33977,\r\n58596:33983,\r\n58597:33951,\r\n58598:34009,\r\n58599:33997,\r\n58600:33979,\r\n58601:34010,\r\n58602:34000,\r\n58603:33985,\r\n58604:33990,\r\n58605:34006,\r\n58606:33953,\r\n58607:34081,\r\n58608:34047,\r\n58609:34036,\r\n58610:34071,\r\n58611:34072,\r\n58612:34092,\r\n58613:34079,\r\n58614:34069,\r\n58615:34068,\r\n58616:34044,\r\n58617:34112,\r\n58618:34147,\r\n58619:34136,\r\n58620:34120,\r\n58688:34113,\r\n58689:34306,\r\n58690:34123,\r\n58691:34133,\r\n58692:34176,\r\n58693:34212,\r\n58694:34184,\r\n58695:34193,\r\n58696:34186,\r\n58697:34216,\r\n58698:34157,\r\n58699:34196,\r\n58700:34203,\r\n58701:34282,\r\n58702:34183,\r\n58703:34204,\r\n58704:34167,\r\n58705:34174,\r\n58706:34192,\r\n58707:34249,\r\n58708:34234,\r\n58709:34255,\r\n58710:34233,\r\n58711:34256,\r\n58712:34261,\r\n58713:34269,\r\n58714:34277,\r\n58715:34268,\r\n58716:34297,\r\n58717:34314,\r\n58718:34323,\r\n58719:34315,\r\n58720:34302,\r\n58721:34298,\r\n58722:34310,\r\n58723:34338,\r\n58724:34330,\r\n58725:34352,\r\n58726:34367,\r\n58727:34381,\r\n58728:20053,\r\n58729:34388,\r\n58730:34399,\r\n58731:34407,\r\n58732:34417,\r\n58733:34451,\r\n58734:34467,\r\n58735:34473,\r\n58736:34474,\r\n58737:34443,\r\n58738:34444,\r\n58739:34486,\r\n58740:34479,\r\n58741:34500,\r\n58742:34502,\r\n58743:34480,\r\n58744:34505,\r\n58745:34851,\r\n58746:34475,\r\n58747:34516,\r\n58748:34526,\r\n58749:34537,\r\n58750:34540,\r\n58752:34527,\r\n58753:34523,\r\n58754:34543,\r\n58755:34578,\r\n58756:34566,\r\n58757:34568,\r\n58758:34560,\r\n58759:34563,\r\n58760:34555,\r\n58761:34577,\r\n58762:34569,\r\n58763:34573,\r\n58764:34553,\r\n58765:34570,\r\n58766:34612,\r\n58767:34623,\r\n58768:34615,\r\n58769:34619,\r\n58770:34597,\r\n58771:34601,\r\n58772:34586,\r\n58773:34656,\r\n58774:34655,\r\n58775:34680,\r\n58776:34636,\r\n58777:34638,\r\n58778:34676,\r\n58779:34647,\r\n58780:34664,\r\n58781:34670,\r\n58782:34649,\r\n58783:34643,\r\n58784:34659,\r\n58785:34666,\r\n58786:34821,\r\n58787:34722,\r\n58788:34719,\r\n58789:34690,\r\n58790:34735,\r\n58791:34763,\r\n58792:34749,\r\n58793:34752,\r\n58794:34768,\r\n58795:38614,\r\n58796:34731,\r\n58797:34756,\r\n58798:34739,\r\n58799:34759,\r\n58800:34758,\r\n58801:34747,\r\n58802:34799,\r\n58803:34802,\r\n58804:34784,\r\n58805:34831,\r\n58806:34829,\r\n58807:34814,\r\n58808:34806,\r\n58809:34807,\r\n58810:34830,\r\n58811:34770,\r\n58812:34833,\r\n58813:34838,\r\n58814:34837,\r\n58815:34850,\r\n58816:34849,\r\n58817:34865,\r\n58818:34870,\r\n58819:34873,\r\n58820:34855,\r\n58821:34875,\r\n58822:34884,\r\n58823:34882,\r\n58824:34898,\r\n58825:34905,\r\n58826:34910,\r\n58827:34914,\r\n58828:34923,\r\n58829:34945,\r\n58830:34942,\r\n58831:34974,\r\n58832:34933,\r\n58833:34941,\r\n58834:34997,\r\n58835:34930,\r\n58836:34946,\r\n58837:34967,\r\n58838:34962,\r\n58839:34990,\r\n58840:34969,\r\n58841:34978,\r\n58842:34957,\r\n58843:34980,\r\n58844:34992,\r\n58845:35007,\r\n58846:34993,\r\n58847:35011,\r\n58848:35012,\r\n58849:35028,\r\n58850:35032,\r\n58851:35033,\r\n58852:35037,\r\n58853:35065,\r\n58854:35074,\r\n58855:35068,\r\n58856:35060,\r\n58857:35048,\r\n58858:35058,\r\n58859:35076,\r\n58860:35084,\r\n58861:35082,\r\n58862:35091,\r\n58863:35139,\r\n58864:35102,\r\n58865:35109,\r\n58866:35114,\r\n58867:35115,\r\n58868:35137,\r\n58869:35140,\r\n58870:35131,\r\n58871:35126,\r\n58872:35128,\r\n58873:35148,\r\n58874:35101,\r\n58875:35168,\r\n58876:35166,\r\n58944:35174,\r\n58945:35172,\r\n58946:35181,\r\n58947:35178,\r\n58948:35183,\r\n58949:35188,\r\n58950:35191,\r\n58951:35198,\r\n58952:35203,\r\n58953:35208,\r\n58954:35210,\r\n58955:35219,\r\n58956:35224,\r\n58957:35233,\r\n58958:35241,\r\n58959:35238,\r\n58960:35244,\r\n58961:35247,\r\n58962:35250,\r\n58963:35258,\r\n58964:35261,\r\n58965:35263,\r\n58966:35264,\r\n58967:35290,\r\n58968:35292,\r\n58969:35293,\r\n58970:35303,\r\n58971:35316,\r\n58972:35320,\r\n58973:35331,\r\n58974:35350,\r\n58975:35344,\r\n58976:35340,\r\n58977:35355,\r\n58978:35357,\r\n58979:35365,\r\n58980:35382,\r\n58981:35393,\r\n58982:35419,\r\n58983:35410,\r\n58984:35398,\r\n58985:35400,\r\n58986:35452,\r\n58987:35437,\r\n58988:35436,\r\n58989:35426,\r\n58990:35461,\r\n58991:35458,\r\n58992:35460,\r\n58993:35496,\r\n58994:35489,\r\n58995:35473,\r\n58996:35493,\r\n58997:35494,\r\n58998:35482,\r\n58999:35491,\r\n59000:35524,\r\n59001:35533,\r\n59002:35522,\r\n59003:35546,\r\n59004:35563,\r\n59005:35571,\r\n59006:35559,\r\n59008:35556,\r\n59009:35569,\r\n59010:35604,\r\n59011:35552,\r\n59012:35554,\r\n59013:35575,\r\n59014:35550,\r\n59015:35547,\r\n59016:35596,\r\n59017:35591,\r\n59018:35610,\r\n59019:35553,\r\n59020:35606,\r\n59021:35600,\r\n59022:35607,\r\n59023:35616,\r\n59024:35635,\r\n59025:38827,\r\n59026:35622,\r\n59027:35627,\r\n59028:35646,\r\n59029:35624,\r\n59030:35649,\r\n59031:35660,\r\n59032:35663,\r\n59033:35662,\r\n59034:35657,\r\n59035:35670,\r\n59036:35675,\r\n59037:35674,\r\n59038:35691,\r\n59039:35679,\r\n59040:35692,\r\n59041:35695,\r\n59042:35700,\r\n59043:35709,\r\n59044:35712,\r\n59045:35724,\r\n59046:35726,\r\n59047:35730,\r\n59048:35731,\r\n59049:35734,\r\n59050:35737,\r\n59051:35738,\r\n59052:35898,\r\n59053:35905,\r\n59054:35903,\r\n59055:35912,\r\n59056:35916,\r\n59057:35918,\r\n59058:35920,\r\n59059:35925,\r\n59060:35938,\r\n59061:35948,\r\n59062:35960,\r\n59063:35962,\r\n59064:35970,\r\n59065:35977,\r\n59066:35973,\r\n59067:35978,\r\n59068:35981,\r\n59069:35982,\r\n59070:35988,\r\n59071:35964,\r\n59072:35992,\r\n59073:25117,\r\n59074:36013,\r\n59075:36010,\r\n59076:36029,\r\n59077:36018,\r\n59078:36019,\r\n59079:36014,\r\n59080:36022,\r\n59081:36040,\r\n59082:36033,\r\n59083:36068,\r\n59084:36067,\r\n59085:36058,\r\n59086:36093,\r\n59087:36090,\r\n59088:36091,\r\n59089:36100,\r\n59090:36101,\r\n59091:36106,\r\n59092:36103,\r\n59093:36111,\r\n59094:36109,\r\n59095:36112,\r\n59096:40782,\r\n59097:36115,\r\n59098:36045,\r\n59099:36116,\r\n59100:36118,\r\n59101:36199,\r\n59102:36205,\r\n59103:36209,\r\n59104:36211,\r\n59105:36225,\r\n59106:36249,\r\n59107:36290,\r\n59108:36286,\r\n59109:36282,\r\n59110:36303,\r\n59111:36314,\r\n59112:36310,\r\n59113:36300,\r\n59114:36315,\r\n59115:36299,\r\n59116:36330,\r\n59117:36331,\r\n59118:36319,\r\n59119:36323,\r\n59120:36348,\r\n59121:36360,\r\n59122:36361,\r\n59123:36351,\r\n59124:36381,\r\n59125:36382,\r\n59126:36368,\r\n59127:36383,\r\n59128:36418,\r\n59129:36405,\r\n59130:36400,\r\n59131:36404,\r\n59132:36426,\r\n59200:36423,\r\n59201:36425,\r\n59202:36428,\r\n59203:36432,\r\n59204:36424,\r\n59205:36441,\r\n59206:36452,\r\n59207:36448,\r\n59208:36394,\r\n59209:36451,\r\n59210:36437,\r\n59211:36470,\r\n59212:36466,\r\n59213:36476,\r\n59214:36481,\r\n59215:36487,\r\n59216:36485,\r\n59217:36484,\r\n59218:36491,\r\n59219:36490,\r\n59220:36499,\r\n59221:36497,\r\n59222:36500,\r\n59223:36505,\r\n59224:36522,\r\n59225:36513,\r\n59226:36524,\r\n59227:36528,\r\n59228:36550,\r\n59229:36529,\r\n59230:36542,\r\n59231:36549,\r\n59232:36552,\r\n59233:36555,\r\n59234:36571,\r\n59235:36579,\r\n59236:36604,\r\n59237:36603,\r\n59238:36587,\r\n59239:36606,\r\n59240:36618,\r\n59241:36613,\r\n59242:36629,\r\n59243:36626,\r\n59244:36633,\r\n59245:36627,\r\n59246:36636,\r\n59247:36639,\r\n59248:36635,\r\n59249:36620,\r\n59250:36646,\r\n59251:36659,\r\n59252:36667,\r\n59253:36665,\r\n59254:36677,\r\n59255:36674,\r\n59256:36670,\r\n59257:36684,\r\n59258:36681,\r\n59259:36678,\r\n59260:36686,\r\n59261:36695,\r\n59262:36700,\r\n59264:36706,\r\n59265:36707,\r\n59266:36708,\r\n59267:36764,\r\n59268:36767,\r\n59269:36771,\r\n59270:36781,\r\n59271:36783,\r\n59272:36791,\r\n59273:36826,\r\n59274:36837,\r\n59275:36834,\r\n59276:36842,\r\n59277:36847,\r\n59278:36999,\r\n59279:36852,\r\n59280:36869,\r\n59281:36857,\r\n59282:36858,\r\n59283:36881,\r\n59284:36885,\r\n59285:36897,\r\n59286:36877,\r\n59287:36894,\r\n59288:36886,\r\n59289:36875,\r\n59290:36903,\r\n59291:36918,\r\n59292:36917,\r\n59293:36921,\r\n59294:36856,\r\n59295:36943,\r\n59296:36944,\r\n59297:36945,\r\n59298:36946,\r\n59299:36878,\r\n59300:36937,\r\n59301:36926,\r\n59302:36950,\r\n59303:36952,\r\n59304:36958,\r\n59305:36968,\r\n59306:36975,\r\n59307:36982,\r\n59308:38568,\r\n59309:36978,\r\n59310:36994,\r\n59311:36989,\r\n59312:36993,\r\n59313:36992,\r\n59314:37002,\r\n59315:37001,\r\n59316:37007,\r\n59317:37032,\r\n59318:37039,\r\n59319:37041,\r\n59320:37045,\r\n59321:37090,\r\n59322:37092,\r\n59323:25160,\r\n59324:37083,\r\n59325:37122,\r\n59326:37138,\r\n59327:37145,\r\n59328:37170,\r\n59329:37168,\r\n59330:37194,\r\n59331:37206,\r\n59332:37208,\r\n59333:37219,\r\n59334:37221,\r\n59335:37225,\r\n59336:37235,\r\n59337:37234,\r\n59338:37259,\r\n59339:37257,\r\n59340:37250,\r\n59341:37282,\r\n59342:37291,\r\n59343:37295,\r\n59344:37290,\r\n59345:37301,\r\n59346:37300,\r\n59347:37306,\r\n59348:37312,\r\n59349:37313,\r\n59350:37321,\r\n59351:37323,\r\n59352:37328,\r\n59353:37334,\r\n59354:37343,\r\n59355:37345,\r\n59356:37339,\r\n59357:37372,\r\n59358:37365,\r\n59359:37366,\r\n59360:37406,\r\n59361:37375,\r\n59362:37396,\r\n59363:37420,\r\n59364:37397,\r\n59365:37393,\r\n59366:37470,\r\n59367:37463,\r\n59368:37445,\r\n59369:37449,\r\n59370:37476,\r\n59371:37448,\r\n59372:37525,\r\n59373:37439,\r\n59374:37451,\r\n59375:37456,\r\n59376:37532,\r\n59377:37526,\r\n59378:37523,\r\n59379:37531,\r\n59380:37466,\r\n59381:37583,\r\n59382:37561,\r\n59383:37559,\r\n59384:37609,\r\n59385:37647,\r\n59386:37626,\r\n59387:37700,\r\n59388:37678,\r\n59456:37657,\r\n59457:37666,\r\n59458:37658,\r\n59459:37667,\r\n59460:37690,\r\n59461:37685,\r\n59462:37691,\r\n59463:37724,\r\n59464:37728,\r\n59465:37756,\r\n59466:37742,\r\n59467:37718,\r\n59468:37808,\r\n59469:37804,\r\n59470:37805,\r\n59471:37780,\r\n59472:37817,\r\n59473:37846,\r\n59474:37847,\r\n59475:37864,\r\n59476:37861,\r\n59477:37848,\r\n59478:37827,\r\n59479:37853,\r\n59480:37840,\r\n59481:37832,\r\n59482:37860,\r\n59483:37914,\r\n59484:37908,\r\n59485:37907,\r\n59486:37891,\r\n59487:37895,\r\n59488:37904,\r\n59489:37942,\r\n59490:37931,\r\n59491:37941,\r\n59492:37921,\r\n59493:37946,\r\n59494:37953,\r\n59495:37970,\r\n59496:37956,\r\n59497:37979,\r\n59498:37984,\r\n59499:37986,\r\n59500:37982,\r\n59501:37994,\r\n59502:37417,\r\n59503:38000,\r\n59504:38005,\r\n59505:38007,\r\n59506:38013,\r\n59507:37978,\r\n59508:38012,\r\n59509:38014,\r\n59510:38017,\r\n59511:38015,\r\n59512:38274,\r\n59513:38279,\r\n59514:38282,\r\n59515:38292,\r\n59516:38294,\r\n59517:38296,\r\n59518:38297,\r\n59520:38304,\r\n59521:38312,\r\n59522:38311,\r\n59523:38317,\r\n59524:38332,\r\n59525:38331,\r\n59526:38329,\r\n59527:38334,\r\n59528:38346,\r\n59529:28662,\r\n59530:38339,\r\n59531:38349,\r\n59532:38348,\r\n59533:38357,\r\n59534:38356,\r\n59535:38358,\r\n59536:38364,\r\n59537:38369,\r\n59538:38373,\r\n59539:38370,\r\n59540:38433,\r\n59541:38440,\r\n59542:38446,\r\n59543:38447,\r\n59544:38466,\r\n59545:38476,\r\n59546:38479,\r\n59547:38475,\r\n59548:38519,\r\n59549:38492,\r\n59550:38494,\r\n59551:38493,\r\n59552:38495,\r\n59553:38502,\r\n59554:38514,\r\n59555:38508,\r\n59556:38541,\r\n59557:38552,\r\n59558:38549,\r\n59559:38551,\r\n59560:38570,\r\n59561:38567,\r\n59562:38577,\r\n59563:38578,\r\n59564:38576,\r\n59565:38580,\r\n59566:38582,\r\n59567:38584,\r\n59568:38585,\r\n59569:38606,\r\n59570:38603,\r\n59571:38601,\r\n59572:38605,\r\n59573:35149,\r\n59574:38620,\r\n59575:38669,\r\n59576:38613,\r\n59577:38649,\r\n59578:38660,\r\n59579:38662,\r\n59580:38664,\r\n59581:38675,\r\n59582:38670,\r\n59583:38673,\r\n59584:38671,\r\n59585:38678,\r\n59586:38681,\r\n59587:38692,\r\n59588:38698,\r\n59589:38704,\r\n59590:38713,\r\n59591:38717,\r\n59592:38718,\r\n59593:38724,\r\n59594:38726,\r\n59595:38728,\r\n59596:38722,\r\n59597:38729,\r\n59598:38748,\r\n59599:38752,\r\n59600:38756,\r\n59601:38758,\r\n59602:38760,\r\n59603:21202,\r\n59604:38763,\r\n59605:38769,\r\n59606:38777,\r\n59607:38789,\r\n59608:38780,\r\n59609:38785,\r\n59610:38778,\r\n59611:38790,\r\n59612:38795,\r\n59613:38799,\r\n59614:38800,\r\n59615:38812,\r\n59616:38824,\r\n59617:38822,\r\n59618:38819,\r\n59619:38835,\r\n59620:38836,\r\n59621:38851,\r\n59622:38854,\r\n59623:38856,\r\n59624:38859,\r\n59625:38876,\r\n59626:38893,\r\n59627:40783,\r\n59628:38898,\r\n59629:31455,\r\n59630:38902,\r\n59631:38901,\r\n59632:38927,\r\n59633:38924,\r\n59634:38968,\r\n59635:38948,\r\n59636:38945,\r\n59637:38967,\r\n59638:38973,\r\n59639:38982,\r\n59640:38991,\r\n59641:38987,\r\n59642:39019,\r\n59643:39023,\r\n59644:39024,\r\n59712:39025,\r\n59713:39028,\r\n59714:39027,\r\n59715:39082,\r\n59716:39087,\r\n59717:39089,\r\n59718:39094,\r\n59719:39108,\r\n59720:39107,\r\n59721:39110,\r\n59722:39145,\r\n59723:39147,\r\n59724:39171,\r\n59725:39177,\r\n59726:39186,\r\n59727:39188,\r\n59728:39192,\r\n59729:39201,\r\n59730:39197,\r\n59731:39198,\r\n59732:39204,\r\n59733:39200,\r\n59734:39212,\r\n59735:39214,\r\n59736:39229,\r\n59737:39230,\r\n59738:39234,\r\n59739:39241,\r\n59740:39237,\r\n59741:39248,\r\n59742:39243,\r\n59743:39249,\r\n59744:39250,\r\n59745:39244,\r\n59746:39253,\r\n59747:39319,\r\n59748:39320,\r\n59749:39333,\r\n59750:39341,\r\n59751:39342,\r\n59752:39356,\r\n59753:39391,\r\n59754:39387,\r\n59755:39389,\r\n59756:39384,\r\n59757:39377,\r\n59758:39405,\r\n59759:39406,\r\n59760:39409,\r\n59761:39410,\r\n59762:39419,\r\n59763:39416,\r\n59764:39425,\r\n59765:39439,\r\n59766:39429,\r\n59767:39394,\r\n59768:39449,\r\n59769:39467,\r\n59770:39479,\r\n59771:39493,\r\n59772:39490,\r\n59773:39488,\r\n59774:39491,\r\n59776:39486,\r\n59777:39509,\r\n59778:39501,\r\n59779:39515,\r\n59780:39511,\r\n59781:39519,\r\n59782:39522,\r\n59783:39525,\r\n59784:39524,\r\n59785:39529,\r\n59786:39531,\r\n59787:39530,\r\n59788:39597,\r\n59789:39600,\r\n59790:39612,\r\n59791:39616,\r\n59792:39631,\r\n59793:39633,\r\n59794:39635,\r\n59795:39636,\r\n59796:39646,\r\n59797:39647,\r\n59798:39650,\r\n59799:39651,\r\n59800:39654,\r\n59801:39663,\r\n59802:39659,\r\n59803:39662,\r\n59804:39668,\r\n59805:39665,\r\n59806:39671,\r\n59807:39675,\r\n59808:39686,\r\n59809:39704,\r\n59810:39706,\r\n59811:39711,\r\n59812:39714,\r\n59813:39715,\r\n59814:39717,\r\n59815:39719,\r\n59816:39720,\r\n59817:39721,\r\n59818:39722,\r\n59819:39726,\r\n59820:39727,\r\n59821:39730,\r\n59822:39748,\r\n59823:39747,\r\n59824:39759,\r\n59825:39757,\r\n59826:39758,\r\n59827:39761,\r\n59828:39768,\r\n59829:39796,\r\n59830:39827,\r\n59831:39811,\r\n59832:39825,\r\n59833:39830,\r\n59834:39831,\r\n59835:39839,\r\n59836:39840,\r\n59837:39848,\r\n59838:39860,\r\n59839:39872,\r\n59840:39882,\r\n59841:39865,\r\n59842:39878,\r\n59843:39887,\r\n59844:39889,\r\n59845:39890,\r\n59846:39907,\r\n59847:39906,\r\n59848:39908,\r\n59849:39892,\r\n59850:39905,\r\n59851:39994,\r\n59852:39922,\r\n59853:39921,\r\n59854:39920,\r\n59855:39957,\r\n59856:39956,\r\n59857:39945,\r\n59858:39955,\r\n59859:39948,\r\n59860:39942,\r\n59861:39944,\r\n59862:39954,\r\n59863:39946,\r\n59864:39940,\r\n59865:39982,\r\n59866:39963,\r\n59867:39973,\r\n59868:39972,\r\n59869:39969,\r\n59870:39984,\r\n59871:40007,\r\n59872:39986,\r\n59873:40006,\r\n59874:39998,\r\n59875:40026,\r\n59876:40032,\r\n59877:40039,\r\n59878:40054,\r\n59879:40056,\r\n59880:40167,\r\n59881:40172,\r\n59882:40176,\r\n59883:40201,\r\n59884:40200,\r\n59885:40171,\r\n59886:40195,\r\n59887:40198,\r\n59888:40234,\r\n59889:40230,\r\n59890:40367,\r\n59891:40227,\r\n59892:40223,\r\n59893:40260,\r\n59894:40213,\r\n59895:40210,\r\n59896:40257,\r\n59897:40255,\r\n59898:40254,\r\n59899:40262,\r\n59900:40264,\r\n59968:40285,\r\n59969:40286,\r\n59970:40292,\r\n59971:40273,\r\n59972:40272,\r\n59973:40281,\r\n59974:40306,\r\n59975:40329,\r\n59976:40327,\r\n59977:40363,\r\n59978:40303,\r\n59979:40314,\r\n59980:40346,\r\n59981:40356,\r\n59982:40361,\r\n59983:40370,\r\n59984:40388,\r\n59985:40385,\r\n59986:40379,\r\n59987:40376,\r\n59988:40378,\r\n59989:40390,\r\n59990:40399,\r\n59991:40386,\r\n59992:40409,\r\n59993:40403,\r\n59994:40440,\r\n59995:40422,\r\n59996:40429,\r\n59997:40431,\r\n59998:40445,\r\n59999:40474,\r\n60000:40475,\r\n60001:40478,\r\n60002:40565,\r\n60003:40569,\r\n60004:40573,\r\n60005:40577,\r\n60006:40584,\r\n60007:40587,\r\n60008:40588,\r\n60009:40594,\r\n60010:40597,\r\n60011:40593,\r\n60012:40605,\r\n60013:40613,\r\n60014:40617,\r\n60015:40632,\r\n60016:40618,\r\n60017:40621,\r\n60018:38753,\r\n60019:40652,\r\n60020:40654,\r\n60021:40655,\r\n60022:40656,\r\n60023:40660,\r\n60024:40668,\r\n60025:40670,\r\n60026:40669,\r\n60027:40672,\r\n60028:40677,\r\n60029:40680,\r\n60030:40687,\r\n60032:40692,\r\n60033:40694,\r\n60034:40695,\r\n60035:40697,\r\n60036:40699,\r\n60037:40700,\r\n60038:40701,\r\n60039:40711,\r\n60040:40712,\r\n60041:30391,\r\n60042:40725,\r\n60043:40737,\r\n60044:40748,\r\n60045:40766,\r\n60046:40778,\r\n60047:40786,\r\n60048:40788,\r\n60049:40803,\r\n60050:40799,\r\n60051:40800,\r\n60052:40801,\r\n60053:40806,\r\n60054:40807,\r\n60055:40812,\r\n60056:40810,\r\n60057:40823,\r\n60058:40818,\r\n60059:40822,\r\n60060:40853,\r\n60061:40860,\r\n60062:40864,\r\n60063:22575,\r\n60064:27079,\r\n60065:36953,\r\n60066:29796,\r\n60067:20956,\r\n60068:29081,\r\n60736:32394,\r\n60737:35100,\r\n60738:37704,\r\n60739:37512,\r\n60740:34012,\r\n60741:20425,\r\n60742:28859,\r\n60743:26161,\r\n60744:26824,\r\n60745:37625,\r\n60746:26363,\r\n60747:24389,\r\n60748:20008,\r\n60749:20193,\r\n60750:20220,\r\n60751:20224,\r\n60752:20227,\r\n60753:20281,\r\n60754:20310,\r\n60755:20370,\r\n60756:20362,\r\n60757:20378,\r\n60758:20372,\r\n60759:20429,\r\n60760:20544,\r\n60761:20514,\r\n60762:20479,\r\n60763:20510,\r\n60764:20550,\r\n60765:20592,\r\n60766:20546,\r\n60767:20628,\r\n60768:20724,\r\n60769:20696,\r\n60770:20810,\r\n60771:20836,\r\n60772:20893,\r\n60773:20926,\r\n60774:20972,\r\n60775:21013,\r\n60776:21148,\r\n60777:21158,\r\n60778:21184,\r\n60779:21211,\r\n60780:21248,\r\n60781:21255,\r\n60782:21284,\r\n60783:21362,\r\n60784:21395,\r\n60785:21426,\r\n60786:21469,\r\n60787:64014,\r\n60788:21660,\r\n60789:21642,\r\n60790:21673,\r\n60791:21759,\r\n60792:21894,\r\n60793:22361,\r\n60794:22373,\r\n60795:22444,\r\n60796:22472,\r\n60797:22471,\r\n60798:64015,\r\n60800:64016,\r\n60801:22686,\r\n60802:22706,\r\n60803:22795,\r\n60804:22867,\r\n60805:22875,\r\n60806:22877,\r\n60807:22883,\r\n60808:22948,\r\n60809:22970,\r\n60810:23382,\r\n60811:23488,\r\n60812:29999,\r\n60813:23512,\r\n60814:23532,\r\n60815:23582,\r\n60816:23718,\r\n60817:23738,\r\n60818:23797,\r\n60819:23847,\r\n60820:23891,\r\n60821:64017,\r\n60822:23874,\r\n60823:23917,\r\n60824:23992,\r\n60825:23993,\r\n60826:24016,\r\n60827:24353,\r\n60828:24372,\r\n60829:24423,\r\n60830:24503,\r\n60831:24542,\r\n60832:24669,\r\n60833:24709,\r\n60834:24714,\r\n60835:24798,\r\n60836:24789,\r\n60837:24864,\r\n60838:24818,\r\n60839:24849,\r\n60840:24887,\r\n60841:24880,\r\n60842:24984,\r\n60843:25107,\r\n60844:25254,\r\n60845:25589,\r\n60846:25696,\r\n60847:25757,\r\n60848:25806,\r\n60849:25934,\r\n60850:26112,\r\n60851:26133,\r\n60852:26171,\r\n60853:26121,\r\n60854:26158,\r\n60855:26142,\r\n60856:26148,\r\n60857:26213,\r\n60858:26199,\r\n60859:26201,\r\n60860:64018,\r\n60861:26227,\r\n60862:26265,\r\n60863:26272,\r\n60864:26290,\r\n60865:26303,\r\n60866:26362,\r\n60867:26382,\r\n60868:63785,\r\n60869:26470,\r\n60870:26555,\r\n60871:26706,\r\n60872:26560,\r\n60873:26625,\r\n60874:26692,\r\n60875:26831,\r\n60876:64019,\r\n60877:26984,\r\n60878:64020,\r\n60879:27032,\r\n60880:27106,\r\n60881:27184,\r\n60882:27243,\r\n60883:27206,\r\n60884:27251,\r\n60885:27262,\r\n60886:27362,\r\n60887:27364,\r\n60888:27606,\r\n60889:27711,\r\n60890:27740,\r\n60891:27782,\r\n60892:27759,\r\n60893:27866,\r\n60894:27908,\r\n60895:28039,\r\n60896:28015,\r\n60897:28054,\r\n60898:28076,\r\n60899:28111,\r\n60900:28152,\r\n60901:28146,\r\n60902:28156,\r\n60903:28217,\r\n60904:28252,\r\n60905:28199,\r\n60906:28220,\r\n60907:28351,\r\n60908:28552,\r\n60909:28597,\r\n60910:28661,\r\n60911:28677,\r\n60912:28679,\r\n60913:28712,\r\n60914:28805,\r\n60915:28843,\r\n60916:28943,\r\n60917:28932,\r\n60918:29020,\r\n60919:28998,\r\n60920:28999,\r\n60921:64021,\r\n60922:29121,\r\n60923:29182,\r\n60924:29361,\r\n60992:29374,\r\n60993:29476,\r\n60994:64022,\r\n60995:29559,\r\n60996:29629,\r\n60997:29641,\r\n60998:29654,\r\n60999:29667,\r\n61000:29650,\r\n61001:29703,\r\n61002:29685,\r\n61003:29734,\r\n61004:29738,\r\n61005:29737,\r\n61006:29742,\r\n61007:29794,\r\n61008:29833,\r\n61009:29855,\r\n61010:29953,\r\n61011:30063,\r\n61012:30338,\r\n61013:30364,\r\n61014:30366,\r\n61015:30363,\r\n61016:30374,\r\n61017:64023,\r\n61018:30534,\r\n61019:21167,\r\n61020:30753,\r\n61021:30798,\r\n61022:30820,\r\n61023:30842,\r\n61024:31024,\r\n61025:64024,\r\n61026:64025,\r\n61027:64026,\r\n61028:31124,\r\n61029:64027,\r\n61030:31131,\r\n61031:31441,\r\n61032:31463,\r\n61033:64028,\r\n61034:31467,\r\n61035:31646,\r\n61036:64029,\r\n61037:32072,\r\n61038:32092,\r\n61039:32183,\r\n61040:32160,\r\n61041:32214,\r\n61042:32338,\r\n61043:32583,\r\n61044:32673,\r\n61045:64030,\r\n61046:33537,\r\n61047:33634,\r\n61048:33663,\r\n61049:33735,\r\n61050:33782,\r\n61051:33864,\r\n61052:33972,\r\n61053:34131,\r\n61054:34137,\r\n61056:34155,\r\n61057:64031,\r\n61058:34224,\r\n61059:64032,\r\n61060:64033,\r\n61061:34823,\r\n61062:35061,\r\n61063:35346,\r\n61064:35383,\r\n61065:35449,\r\n61066:35495,\r\n61067:35518,\r\n61068:35551,\r\n61069:64034,\r\n61070:35574,\r\n61071:35667,\r\n61072:35711,\r\n61073:36080,\r\n61074:36084,\r\n61075:36114,\r\n61076:36214,\r\n61077:64035,\r\n61078:36559,\r\n61079:64036,\r\n61080:64037,\r\n61081:36967,\r\n61082:37086,\r\n61083:64038,\r\n61084:37141,\r\n61085:37159,\r\n61086:37338,\r\n61087:37335,\r\n61088:37342,\r\n61089:37357,\r\n61090:37358,\r\n61091:37348,\r\n61092:37349,\r\n61093:37382,\r\n61094:37392,\r\n61095:37386,\r\n61096:37434,\r\n61097:37440,\r\n61098:37436,\r\n61099:37454,\r\n61100:37465,\r\n61101:37457,\r\n61102:37433,\r\n61103:37479,\r\n61104:37543,\r\n61105:37495,\r\n61106:37496,\r\n61107:37607,\r\n61108:37591,\r\n61109:37593,\r\n61110:37584,\r\n61111:64039,\r\n61112:37589,\r\n61113:37600,\r\n61114:37587,\r\n61115:37669,\r\n61116:37665,\r\n61117:37627,\r\n61118:64040,\r\n61119:37662,\r\n61120:37631,\r\n61121:37661,\r\n61122:37634,\r\n61123:37744,\r\n61124:37719,\r\n61125:37796,\r\n61126:37830,\r\n61127:37854,\r\n61128:37880,\r\n61129:37937,\r\n61130:37957,\r\n61131:37960,\r\n61132:38290,\r\n61133:63964,\r\n61134:64041,\r\n61135:38557,\r\n61136:38575,\r\n61137:38707,\r\n61138:38715,\r\n61139:38723,\r\n61140:38733,\r\n61141:38735,\r\n61142:38737,\r\n61143:38741,\r\n61144:38999,\r\n61145:39013,\r\n61146:64042,\r\n61147:64043,\r\n61148:39207,\r\n61149:64044,\r\n61150:39326,\r\n61151:39502,\r\n61152:39641,\r\n61153:39644,\r\n61154:39797,\r\n61155:39794,\r\n61156:39823,\r\n61157:39857,\r\n61158:39867,\r\n61159:39936,\r\n61160:40304,\r\n61161:40299,\r\n61162:64045,\r\n61163:40473,\r\n61164:40657,\r\n61167:8560,\r\n61168:8561,\r\n61169:8562,\r\n61170:8563,\r\n61171:8564,\r\n61172:8565,\r\n61173:8566,\r\n61174:8567,\r\n61175:8568,\r\n61176:8569,\r\n61177:65506,\r\n61178:65508,\r\n61179:65287,\r\n61180:65282,\r\n61504:57344,\r\n61505:57345,\r\n61506:57346,\r\n61507:57347,\r\n61508:57348,\r\n61509:57349,\r\n61510:57350,\r\n61511:57351,\r\n61512:57352,\r\n61513:57353,\r\n61514:57354,\r\n61515:57355,\r\n61516:57356,\r\n61517:57357,\r\n61518:57358,\r\n61519:57359,\r\n61520:57360,\r\n61521:57361,\r\n61522:57362,\r\n61523:57363,\r\n61524:57364,\r\n61525:57365,\r\n61526:57366,\r\n61527:57367,\r\n61528:57368,\r\n61529:57369,\r\n61530:57370,\r\n61531:57371,\r\n61532:57372,\r\n61533:57373,\r\n61534:57374,\r\n61535:57375,\r\n61536:57376,\r\n61537:57377,\r\n61538:57378,\r\n61539:57379,\r\n61540:57380,\r\n61541:57381,\r\n61542:57382,\r\n61543:57383,\r\n61544:57384,\r\n61545:57385,\r\n61546:57386,\r\n61547:57387,\r\n61548:57388,\r\n61549:57389,\r\n61550:57390,\r\n61551:57391,\r\n61552:57392,\r\n61553:57393,\r\n61554:57394,\r\n61555:57395,\r\n61556:57396,\r\n61557:57397,\r\n61558:57398,\r\n61559:57399,\r\n61560:57400,\r\n61561:57401,\r\n61562:57402,\r\n61563:57403,\r\n61564:57404,\r\n61565:57405,\r\n61566:57406,\r\n61568:57407,\r\n61569:57408,\r\n61570:57409,\r\n61571:57410,\r\n61572:57411,\r\n61573:57412,\r\n61574:57413,\r\n61575:57414,\r\n61576:57415,\r\n61577:57416,\r\n61578:57417,\r\n61579:57418,\r\n61580:57419,\r\n61581:57420,\r\n61582:57421,\r\n61583:57422,\r\n61584:57423,\r\n61585:57424,\r\n61586:57425,\r\n61587:57426,\r\n61588:57427,\r\n61589:57428,\r\n61590:57429,\r\n61591:57430,\r\n61592:57431,\r\n61593:57432,\r\n61594:57433,\r\n61595:57434,\r\n61596:57435,\r\n61597:57436,\r\n61598:57437,\r\n61599:57438,\r\n61600:57439,\r\n61601:57440,\r\n61602:57441,\r\n61603:57442,\r\n61604:57443,\r\n61605:57444,\r\n61606:57445,\r\n61607:57446,\r\n61608:57447,\r\n61609:57448,\r\n61610:57449,\r\n61611:57450,\r\n61612:57451,\r\n61613:57452,\r\n61614:57453,\r\n61615:57454,\r\n61616:57455,\r\n61617:57456,\r\n61618:57457,\r\n61619:57458,\r\n61620:57459,\r\n61621:57460,\r\n61622:57461,\r\n61623:57462,\r\n61624:57463,\r\n61625:57464,\r\n61626:57465,\r\n61627:57466,\r\n61628:57467,\r\n61629:57468,\r\n61630:57469,\r\n61631:57470,\r\n61632:57471,\r\n61633:57472,\r\n61634:57473,\r\n61635:57474,\r\n61636:57475,\r\n61637:57476,\r\n61638:57477,\r\n61639:57478,\r\n61640:57479,\r\n61641:57480,\r\n61642:57481,\r\n61643:57482,\r\n61644:57483,\r\n61645:57484,\r\n61646:57485,\r\n61647:57486,\r\n61648:57487,\r\n61649:57488,\r\n61650:57489,\r\n61651:57490,\r\n61652:57491,\r\n61653:57492,\r\n61654:57493,\r\n61655:57494,\r\n61656:57495,\r\n61657:57496,\r\n61658:57497,\r\n61659:57498,\r\n61660:57499,\r\n61661:57500,\r\n61662:57501,\r\n61663:57502,\r\n61664:57503,\r\n61665:57504,\r\n61666:57505,\r\n61667:57506,\r\n61668:57507,\r\n61669:57508,\r\n61670:57509,\r\n61671:57510,\r\n61672:57511,\r\n61673:57512,\r\n61674:57513,\r\n61675:57514,\r\n61676:57515,\r\n61677:57516,\r\n61678:57517,\r\n61679:57518,\r\n61680:57519,\r\n61681:57520,\r\n61682:57521,\r\n61683:57522,\r\n61684:57523,\r\n61685:57524,\r\n61686:57525,\r\n61687:57526,\r\n61688:57527,\r\n61689:57528,\r\n61690:57529,\r\n61691:57530,\r\n61692:57531,\r\n61760:57532,\r\n61761:57533,\r\n61762:57534,\r\n61763:57535,\r\n61764:57536,\r\n61765:57537,\r\n61766:57538,\r\n61767:57539,\r\n61768:57540,\r\n61769:57541,\r\n61770:57542,\r\n61771:57543,\r\n61772:57544,\r\n61773:57545,\r\n61774:57546,\r\n61775:57547,\r\n61776:57548,\r\n61777:57549,\r\n61778:57550,\r\n61779:57551,\r\n61780:57552,\r\n61781:57553,\r\n61782:57554,\r\n61783:57555,\r\n61784:57556,\r\n61785:57557,\r\n61786:57558,\r\n61787:57559,\r\n61788:57560,\r\n61789:57561,\r\n61790:57562,\r\n61791:57563,\r\n61792:57564,\r\n61793:57565,\r\n61794:57566,\r\n61795:57567,\r\n61796:57568,\r\n61797:57569,\r\n61798:57570,\r\n61799:57571,\r\n61800:57572,\r\n61801:57573,\r\n61802:57574,\r\n61803:57575,\r\n61804:57576,\r\n61805:57577,\r\n61806:57578,\r\n61807:57579,\r\n61808:57580,\r\n61809:57581,\r\n61810:57582,\r\n61811:57583,\r\n61812:57584,\r\n61813:57585,\r\n61814:57586,\r\n61815:57587,\r\n61816:57588,\r\n61817:57589,\r\n61818:57590,\r\n61819:57591,\r\n61820:57592,\r\n61821:57593,\r\n61822:57594,\r\n61824:57595,\r\n61825:57596,\r\n61826:57597,\r\n61827:57598,\r\n61828:57599,\r\n61829:57600,\r\n61830:57601,\r\n61831:57602,\r\n61832:57603,\r\n61833:57604,\r\n61834:57605,\r\n61835:57606,\r\n61836:57607,\r\n61837:57608,\r\n61838:57609,\r\n61839:57610,\r\n61840:57611,\r\n61841:57612,\r\n61842:57613,\r\n61843:57614,\r\n61844:57615,\r\n61845:57616,\r\n61846:57617,\r\n61847:57618,\r\n61848:57619,\r\n61849:57620,\r\n61850:57621,\r\n61851:57622,\r\n61852:57623,\r\n61853:57624,\r\n61854:57625,\r\n61855:57626,\r\n61856:57627,\r\n61857:57628,\r\n61858:57629,\r\n61859:57630,\r\n61860:57631,\r\n61861:57632,\r\n61862:57633,\r\n61863:57634,\r\n61864:57635,\r\n61865:57636,\r\n61866:57637,\r\n61867:57638,\r\n61868:57639,\r\n61869:57640,\r\n61870:57641,\r\n61871:57642,\r\n61872:57643,\r\n61873:57644,\r\n61874:57645,\r\n61875:57646,\r\n61876:57647,\r\n61877:57648,\r\n61878:57649,\r\n61879:57650,\r\n61880:57651,\r\n61881:57652,\r\n61882:57653,\r\n61883:57654,\r\n61884:57655,\r\n61885:57656,\r\n61886:57657,\r\n61887:57658,\r\n61888:57659,\r\n61889:57660,\r\n61890:57661,\r\n61891:57662,\r\n61892:57663,\r\n61893:57664,\r\n61894:57665,\r\n61895:57666,\r\n61896:57667,\r\n61897:57668,\r\n61898:57669,\r\n61899:57670,\r\n61900:57671,\r\n61901:57672,\r\n61902:57673,\r\n61903:57674,\r\n61904:57675,\r\n61905:57676,\r\n61906:57677,\r\n61907:57678,\r\n61908:57679,\r\n61909:57680,\r\n61910:57681,\r\n61911:57682,\r\n61912:57683,\r\n61913:57684,\r\n61914:57685,\r\n61915:57686,\r\n61916:57687,\r\n61917:57688,\r\n61918:57689,\r\n61919:57690,\r\n61920:57691,\r\n61921:57692,\r\n61922:57693,\r\n61923:57694,\r\n61924:57695,\r\n61925:57696,\r\n61926:57697,\r\n61927:57698,\r\n61928:57699,\r\n61929:57700,\r\n61930:57701,\r\n61931:57702,\r\n61932:57703,\r\n61933:57704,\r\n61934:57705,\r\n61935:57706,\r\n61936:57707,\r\n61937:57708,\r\n61938:57709,\r\n61939:57710,\r\n61940:57711,\r\n61941:57712,\r\n61942:57713,\r\n61943:57714,\r\n61944:57715,\r\n61945:57716,\r\n61946:57717,\r\n61947:57718,\r\n61948:57719,\r\n62016:57720,\r\n62017:57721,\r\n62018:57722,\r\n62019:57723,\r\n62020:57724,\r\n62021:57725,\r\n62022:57726,\r\n62023:57727,\r\n62024:57728,\r\n62025:57729,\r\n62026:57730,\r\n62027:57731,\r\n62028:57732,\r\n62029:57733,\r\n62030:57734,\r\n62031:57735,\r\n62032:57736,\r\n62033:57737,\r\n62034:57738,\r\n62035:57739,\r\n62036:57740,\r\n62037:57741,\r\n62038:57742,\r\n62039:57743,\r\n62040:57744,\r\n62041:57745,\r\n62042:57746,\r\n62043:57747,\r\n62044:57748,\r\n62045:57749,\r\n62046:57750,\r\n62047:57751,\r\n62048:57752,\r\n62049:57753,\r\n62050:57754,\r\n62051:57755,\r\n62052:57756,\r\n62053:57757,\r\n62054:57758,\r\n62055:57759,\r\n62056:57760,\r\n62057:57761,\r\n62058:57762,\r\n62059:57763,\r\n62060:57764,\r\n62061:57765,\r\n62062:57766,\r\n62063:57767,\r\n62064:57768,\r\n62065:57769,\r\n62066:57770,\r\n62067:57771,\r\n62068:57772,\r\n62069:57773,\r\n62070:57774,\r\n62071:57775,\r\n62072:57776,\r\n62073:57777,\r\n62074:57778,\r\n62075:57779,\r\n62076:57780,\r\n62077:57781,\r\n62078:57782,\r\n62080:57783,\r\n62081:57784,\r\n62082:57785,\r\n62083:57786,\r\n62084:57787,\r\n62085:57788,\r\n62086:57789,\r\n62087:57790,\r\n62088:57791,\r\n62089:57792,\r\n62090:57793,\r\n62091:57794,\r\n62092:57795,\r\n62093:57796,\r\n62094:57797,\r\n62095:57798,\r\n62096:57799,\r\n62097:57800,\r\n62098:57801,\r\n62099:57802,\r\n62100:57803,\r\n62101:57804,\r\n62102:57805,\r\n62103:57806,\r\n62104:57807,\r\n62105:57808,\r\n62106:57809,\r\n62107:57810,\r\n62108:57811,\r\n62109:57812,\r\n62110:57813,\r\n62111:57814,\r\n62112:57815,\r\n62113:57816,\r\n62114:57817,\r\n62115:57818,\r\n62116:57819,\r\n62117:57820,\r\n62118:57821,\r\n62119:57822,\r\n62120:57823,\r\n62121:57824,\r\n62122:57825,\r\n62123:57826,\r\n62124:57827,\r\n62125:57828,\r\n62126:57829,\r\n62127:57830,\r\n62128:57831,\r\n62129:57832,\r\n62130:57833,\r\n62131:57834,\r\n62132:57835,\r\n62133:57836,\r\n62134:57837,\r\n62135:57838,\r\n62136:57839,\r\n62137:57840,\r\n62138:57841,\r\n62139:57842,\r\n62140:57843,\r\n62141:57844,\r\n62142:57845,\r\n62143:57846,\r\n62144:57847,\r\n62145:57848,\r\n62146:57849,\r\n62147:57850,\r\n62148:57851,\r\n62149:57852,\r\n62150:57853,\r\n62151:57854,\r\n62152:57855,\r\n62153:57856,\r\n62154:57857,\r\n62155:57858,\r\n62156:57859,\r\n62157:57860,\r\n62158:57861,\r\n62159:57862,\r\n62160:57863,\r\n62161:57864,\r\n62162:57865,\r\n62163:57866,\r\n62164:57867,\r\n62165:57868,\r\n62166:57869,\r\n62167:57870,\r\n62168:57871,\r\n62169:57872,\r\n62170:57873,\r\n62171:57874,\r\n62172:57875,\r\n62173:57876,\r\n62174:57877,\r\n62175:57878,\r\n62176:57879,\r\n62177:57880,\r\n62178:57881,\r\n62179:57882,\r\n62180:57883,\r\n62181:57884,\r\n62182:57885,\r\n62183:57886,\r\n62184:57887,\r\n62185:57888,\r\n62186:57889,\r\n62187:57890,\r\n62188:57891,\r\n62189:57892,\r\n62190:57893,\r\n62191:57894,\r\n62192:57895,\r\n62193:57896,\r\n62194:57897,\r\n62195:57898,\r\n62196:57899,\r\n62197:57900,\r\n62198:57901,\r\n62199:57902,\r\n62200:57903,\r\n62201:57904,\r\n62202:57905,\r\n62203:57906,\r\n62204:57907,\r\n62272:57908,\r\n62273:57909,\r\n62274:57910,\r\n62275:57911,\r\n62276:57912,\r\n62277:57913,\r\n62278:57914,\r\n62279:57915,\r\n62280:57916,\r\n62281:57917,\r\n62282:57918,\r\n62283:57919,\r\n62284:57920,\r\n62285:57921,\r\n62286:57922,\r\n62287:57923,\r\n62288:57924,\r\n62289:57925,\r\n62290:57926,\r\n62291:57927,\r\n62292:57928,\r\n62293:57929,\r\n62294:57930,\r\n62295:57931,\r\n62296:57932,\r\n62297:57933,\r\n62298:57934,\r\n62299:57935,\r\n62300:57936,\r\n62301:57937,\r\n62302:57938,\r\n62303:57939,\r\n62304:57940,\r\n62305:57941,\r\n62306:57942,\r\n62307:57943,\r\n62308:57944,\r\n62309:57945,\r\n62310:57946,\r\n62311:57947,\r\n62312:57948,\r\n62313:57949,\r\n62314:57950,\r\n62315:57951,\r\n62316:57952,\r\n62317:57953,\r\n62318:57954,\r\n62319:57955,\r\n62320:57956,\r\n62321:57957,\r\n62322:57958,\r\n62323:57959,\r\n62324:57960,\r\n62325:57961,\r\n62326:57962,\r\n62327:57963,\r\n62328:57964,\r\n62329:57965,\r\n62330:57966,\r\n62331:57967,\r\n62332:57968,\r\n62333:57969,\r\n62334:57970,\r\n62336:57971,\r\n62337:57972,\r\n62338:57973,\r\n62339:57974,\r\n62340:57975,\r\n62341:57976,\r\n62342:57977,\r\n62343:57978,\r\n62344:57979,\r\n62345:57980,\r\n62346:57981,\r\n62347:57982,\r\n62348:57983,\r\n62349:57984,\r\n62350:57985,\r\n62351:57986,\r\n62352:57987,\r\n62353:57988,\r\n62354:57989,\r\n62355:57990,\r\n62356:57991,\r\n62357:57992,\r\n62358:57993,\r\n62359:57994,\r\n62360:57995,\r\n62361:57996,\r\n62362:57997,\r\n62363:57998,\r\n62364:57999,\r\n62365:58000,\r\n62366:58001,\r\n62367:58002,\r\n62368:58003,\r\n62369:58004,\r\n62370:58005,\r\n62371:58006,\r\n62372:58007,\r\n62373:58008,\r\n62374:58009,\r\n62375:58010,\r\n62376:58011,\r\n62377:58012,\r\n62378:58013,\r\n62379:58014,\r\n62380:58015,\r\n62381:58016,\r\n62382:58017,\r\n62383:58018,\r\n62384:58019,\r\n62385:58020,\r\n62386:58021,\r\n62387:58022,\r\n62388:58023,\r\n62389:58024,\r\n62390:58025,\r\n62391:58026,\r\n62392:58027,\r\n62393:58028,\r\n62394:58029,\r\n62395:58030,\r\n62396:58031,\r\n62397:58032,\r\n62398:58033,\r\n62399:58034,\r\n62400:58035,\r\n62401:58036,\r\n62402:58037,\r\n62403:58038,\r\n62404:58039,\r\n62405:58040,\r\n62406:58041,\r\n62407:58042,\r\n62408:58043,\r\n62409:58044,\r\n62410:58045,\r\n62411:58046,\r\n62412:58047,\r\n62413:58048,\r\n62414:58049,\r\n62415:58050,\r\n62416:58051,\r\n62417:58052,\r\n62418:58053,\r\n62419:58054,\r\n62420:58055,\r\n62421:58056,\r\n62422:58057,\r\n62423:58058,\r\n62424:58059,\r\n62425:58060,\r\n62426:58061,\r\n62427:58062,\r\n62428:58063,\r\n62429:58064,\r\n62430:58065,\r\n62431:58066,\r\n62432:58067,\r\n62433:58068,\r\n62434:58069,\r\n62435:58070,\r\n62436:58071,\r\n62437:58072,\r\n62438:58073,\r\n62439:58074,\r\n62440:58075,\r\n62441:58076,\r\n62442:58077,\r\n62443:58078,\r\n62444:58079,\r\n62445:58080,\r\n62446:58081,\r\n62447:58082,\r\n62448:58083,\r\n62449:58084,\r\n62450:58085,\r\n62451:58086,\r\n62452:58087,\r\n62453:58088,\r\n62454:58089,\r\n62455:58090,\r\n62456:58091,\r\n62457:58092,\r\n62458:58093,\r\n62459:58094,\r\n62460:58095,\r\n62528:58096,\r\n62529:58097,\r\n62530:58098,\r\n62531:58099,\r\n62532:58100,\r\n62533:58101,\r\n62534:58102,\r\n62535:58103,\r\n62536:58104,\r\n62537:58105,\r\n62538:58106,\r\n62539:58107,\r\n62540:58108,\r\n62541:58109,\r\n62542:58110,\r\n62543:58111,\r\n62544:58112,\r\n62545:58113,\r\n62546:58114,\r\n62547:58115,\r\n62548:58116,\r\n62549:58117,\r\n62550:58118,\r\n62551:58119,\r\n62552:58120,\r\n62553:58121,\r\n62554:58122,\r\n62555:58123,\r\n62556:58124,\r\n62557:58125,\r\n62558:58126,\r\n62559:58127,\r\n62560:58128,\r\n62561:58129,\r\n62562:58130,\r\n62563:58131,\r\n62564:58132,\r\n62565:58133,\r\n62566:58134,\r\n62567:58135,\r\n62568:58136,\r\n62569:58137,\r\n62570:58138,\r\n62571:58139,\r\n62572:58140,\r\n62573:58141,\r\n62574:58142,\r\n62575:58143,\r\n62576:58144,\r\n62577:58145,\r\n62578:58146,\r\n62579:58147,\r\n62580:58148,\r\n62581:58149,\r\n62582:58150,\r\n62583:58151,\r\n62584:58152,\r\n62585:58153,\r\n62586:58154,\r\n62587:58155,\r\n62588:58156,\r\n62589:58157,\r\n62590:58158,\r\n62592:58159,\r\n62593:58160,\r\n62594:58161,\r\n62595:58162,\r\n62596:58163,\r\n62597:58164,\r\n62598:58165,\r\n62599:58166,\r\n62600:58167,\r\n62601:58168,\r\n62602:58169,\r\n62603:58170,\r\n62604:58171,\r\n62605:58172,\r\n62606:58173,\r\n62607:58174,\r\n62608:58175,\r\n62609:58176,\r\n62610:58177,\r\n62611:58178,\r\n62612:58179,\r\n62613:58180,\r\n62614:58181,\r\n62615:58182,\r\n62616:58183,\r\n62617:58184,\r\n62618:58185,\r\n62619:58186,\r\n62620:58187,\r\n62621:58188,\r\n62622:58189,\r\n62623:58190,\r\n62624:58191,\r\n62625:58192,\r\n62626:58193,\r\n62627:58194,\r\n62628:58195,\r\n62629:58196,\r\n62630:58197,\r\n62631:58198,\r\n62632:58199,\r\n62633:58200,\r\n62634:58201,\r\n62635:58202,\r\n62636:58203,\r\n62637:58204,\r\n62638:58205,\r\n62639:58206,\r\n62640:58207,\r\n62641:58208,\r\n62642:58209,\r\n62643:58210,\r\n62644:58211,\r\n62645:58212,\r\n62646:58213,\r\n62647:58214,\r\n62648:58215,\r\n62649:58216,\r\n62650:58217,\r\n62651:58218,\r\n62652:58219,\r\n62653:58220,\r\n62654:58221,\r\n62655:58222,\r\n62656:58223,\r\n62657:58224,\r\n62658:58225,\r\n62659:58226,\r\n62660:58227,\r\n62661:58228,\r\n62662:58229,\r\n62663:58230,\r\n62664:58231,\r\n62665:58232,\r\n62666:58233,\r\n62667:58234,\r\n62668:58235,\r\n62669:58236,\r\n62670:58237,\r\n62671:58238,\r\n62672:58239,\r\n62673:58240,\r\n62674:58241,\r\n62675:58242,\r\n62676:58243,\r\n62677:58244,\r\n62678:58245,\r\n62679:58246,\r\n62680:58247,\r\n62681:58248,\r\n62682:58249,\r\n62683:58250,\r\n62684:58251,\r\n62685:58252,\r\n62686:58253,\r\n62687:58254,\r\n62688:58255,\r\n62689:58256,\r\n62690:58257,\r\n62691:58258,\r\n62692:58259,\r\n62693:58260,\r\n62694:58261,\r\n62695:58262,\r\n62696:58263,\r\n62697:58264,\r\n62698:58265,\r\n62699:58266,\r\n62700:58267,\r\n62701:58268,\r\n62702:58269,\r\n62703:58270,\r\n62704:58271,\r\n62705:58272,\r\n62706:58273,\r\n62707:58274,\r\n62708:58275,\r\n62709:58276,\r\n62710:58277,\r\n62711:58278,\r\n62712:58279,\r\n62713:58280,\r\n62714:58281,\r\n62715:58282,\r\n62716:58283,\r\n62784:58284,\r\n62785:58285,\r\n62786:58286,\r\n62787:58287,\r\n62788:58288,\r\n62789:58289,\r\n62790:58290,\r\n62791:58291,\r\n62792:58292,\r\n62793:58293,\r\n62794:58294,\r\n62795:58295,\r\n62796:58296,\r\n62797:58297,\r\n62798:58298,\r\n62799:58299,\r\n62800:58300,\r\n62801:58301,\r\n62802:58302,\r\n62803:58303,\r\n62804:58304,\r\n62805:58305,\r\n62806:58306,\r\n62807:58307,\r\n62808:58308,\r\n62809:58309,\r\n62810:58310,\r\n62811:58311,\r\n62812:58312,\r\n62813:58313,\r\n62814:58314,\r\n62815:58315,\r\n62816:58316,\r\n62817:58317,\r\n62818:58318,\r\n62819:58319,\r\n62820:58320,\r\n62821:58321,\r\n62822:58322,\r\n62823:58323,\r\n62824:58324,\r\n62825:58325,\r\n62826:58326,\r\n62827:58327,\r\n62828:58328,\r\n62829:58329,\r\n62830:58330,\r\n62831:58331,\r\n62832:58332,\r\n62833:58333,\r\n62834:58334,\r\n62835:58335,\r\n62836:58336,\r\n62837:58337,\r\n62838:58338,\r\n62839:58339,\r\n62840:58340,\r\n62841:58341,\r\n62842:58342,\r\n62843:58343,\r\n62844:58344,\r\n62845:58345,\r\n62846:58346,\r\n62848:58347,\r\n62849:58348,\r\n62850:58349,\r\n62851:58350,\r\n62852:58351,\r\n62853:58352,\r\n62854:58353,\r\n62855:58354,\r\n62856:58355,\r\n62857:58356,\r\n62858:58357,\r\n62859:58358,\r\n62860:58359,\r\n62861:58360,\r\n62862:58361,\r\n62863:58362,\r\n62864:58363,\r\n62865:58364,\r\n62866:58365,\r\n62867:58366,\r\n62868:58367,\r\n62869:58368,\r\n62870:58369,\r\n62871:58370,\r\n62872:58371,\r\n62873:58372,\r\n62874:58373,\r\n62875:58374,\r\n62876:58375,\r\n62877:58376,\r\n62878:58377,\r\n62879:58378,\r\n62880:58379,\r\n62881:58380,\r\n62882:58381,\r\n62883:58382,\r\n62884:58383,\r\n62885:58384,\r\n62886:58385,\r\n62887:58386,\r\n62888:58387,\r\n62889:58388,\r\n62890:58389,\r\n62891:58390,\r\n62892:58391,\r\n62893:58392,\r\n62894:58393,\r\n62895:58394,\r\n62896:58395,\r\n62897:58396,\r\n62898:58397,\r\n62899:58398,\r\n62900:58399,\r\n62901:58400,\r\n62902:58401,\r\n62903:58402,\r\n62904:58403,\r\n62905:58404,\r\n62906:58405,\r\n62907:58406,\r\n62908:58407,\r\n62909:58408,\r\n62910:58409,\r\n62911:58410,\r\n62912:58411,\r\n62913:58412,\r\n62914:58413,\r\n62915:58414,\r\n62916:58415,\r\n62917:58416,\r\n62918:58417,\r\n62919:58418,\r\n62920:58419,\r\n62921:58420,\r\n62922:58421,\r\n62923:58422,\r\n62924:58423,\r\n62925:58424,\r\n62926:58425,\r\n62927:58426,\r\n62928:58427,\r\n62929:58428,\r\n62930:58429,\r\n62931:58430,\r\n62932:58431,\r\n62933:58432,\r\n62934:58433,\r\n62935:58434,\r\n62936:58435,\r\n62937:58436,\r\n62938:58437,\r\n62939:58438,\r\n62940:58439,\r\n62941:58440,\r\n62942:58441,\r\n62943:58442,\r\n62944:58443,\r\n62945:58444,\r\n62946:58445,\r\n62947:58446,\r\n62948:58447,\r\n62949:58448,\r\n62950:58449,\r\n62951:58450,\r\n62952:58451,\r\n62953:58452,\r\n62954:58453,\r\n62955:58454,\r\n62956:58455,\r\n62957:58456,\r\n62958:58457,\r\n62959:58458,\r\n62960:58459,\r\n62961:58460,\r\n62962:58461,\r\n62963:58462,\r\n62964:58463,\r\n62965:58464,\r\n62966:58465,\r\n62967:58466,\r\n62968:58467,\r\n62969:58468,\r\n62970:58469,\r\n62971:58470,\r\n62972:58471,\r\n63040:58472,\r\n63041:58473,\r\n63042:58474,\r\n63043:58475,\r\n63044:58476,\r\n63045:58477,\r\n63046:58478,\r\n63047:58479,\r\n63048:58480,\r\n63049:58481,\r\n63050:58482,\r\n63051:58483,\r\n63052:58484,\r\n63053:58485,\r\n63054:58486,\r\n63055:58487,\r\n63056:58488,\r\n63057:58489,\r\n63058:58490,\r\n63059:58491,\r\n63060:58492,\r\n63061:58493,\r\n63062:58494,\r\n63063:58495,\r\n63064:58496,\r\n63065:58497,\r\n63066:58498,\r\n63067:58499,\r\n63068:58500,\r\n63069:58501,\r\n63070:58502,\r\n63071:58503,\r\n63072:58504,\r\n63073:58505,\r\n63074:58506,\r\n63075:58507,\r\n63076:58508,\r\n63077:58509,\r\n63078:58510,\r\n63079:58511,\r\n63080:58512,\r\n63081:58513,\r\n63082:58514,\r\n63083:58515,\r\n63084:58516,\r\n63085:58517,\r\n63086:58518,\r\n63087:58519,\r\n63088:58520,\r\n63089:58521,\r\n63090:58522,\r\n63091:58523,\r\n63092:58524,\r\n63093:58525,\r\n63094:58526,\r\n63095:58527,\r\n63096:58528,\r\n63097:58529,\r\n63098:58530,\r\n63099:58531,\r\n63100:58532,\r\n63101:58533,\r\n63102:58534,\r\n63104:58535,\r\n63105:58536,\r\n63106:58537,\r\n63107:58538,\r\n63108:58539,\r\n63109:58540,\r\n63110:58541,\r\n63111:58542,\r\n63112:58543,\r\n63113:58544,\r\n63114:58545,\r\n63115:58546,\r\n63116:58547,\r\n63117:58548,\r\n63118:58549,\r\n63119:58550,\r\n63120:58551,\r\n63121:58552,\r\n63122:58553,\r\n63123:58554,\r\n63124:58555,\r\n63125:58556,\r\n63126:58557,\r\n63127:58558,\r\n63128:58559,\r\n63129:58560,\r\n63130:58561,\r\n63131:58562,\r\n63132:58563,\r\n63133:58564,\r\n63134:58565,\r\n63135:58566,\r\n63136:58567,\r\n63137:58568,\r\n63138:58569,\r\n63139:58570,\r\n63140:58571,\r\n63141:58572,\r\n63142:58573,\r\n63143:58574,\r\n63144:58575,\r\n63145:58576,\r\n63146:58577,\r\n63147:58578,\r\n63148:58579,\r\n63149:58580,\r\n63150:58581,\r\n63151:58582,\r\n63152:58583,\r\n63153:58584,\r\n63154:58585,\r\n63155:58586,\r\n63156:58587,\r\n63157:58588,\r\n63158:58589,\r\n63159:58590,\r\n63160:58591,\r\n63161:58592,\r\n63162:58593,\r\n63163:58594,\r\n63164:58595,\r\n63165:58596,\r\n63166:58597,\r\n63167:58598,\r\n63168:58599,\r\n63169:58600,\r\n63170:58601,\r\n63171:58602,\r\n63172:58603,\r\n63173:58604,\r\n63174:58605,\r\n63175:58606,\r\n63176:58607,\r\n63177:58608,\r\n63178:58609,\r\n63179:58610,\r\n63180:58611,\r\n63181:58612,\r\n63182:58613,\r\n63183:58614,\r\n63184:58615,\r\n63185:58616,\r\n63186:58617,\r\n63187:58618,\r\n63188:58619,\r\n63189:58620,\r\n63190:58621,\r\n63191:58622,\r\n63192:58623,\r\n63193:58624,\r\n63194:58625,\r\n63195:58626,\r\n63196:58627,\r\n63197:58628,\r\n63198:58629,\r\n63199:58630,\r\n63200:58631,\r\n63201:58632,\r\n63202:58633,\r\n63203:58634,\r\n63204:58635,\r\n63205:58636,\r\n63206:58637,\r\n63207:58638,\r\n63208:58639,\r\n63209:58640,\r\n63210:58641,\r\n63211:58642,\r\n63212:58643,\r\n63213:58644,\r\n63214:58645,\r\n63215:58646,\r\n63216:58647,\r\n63217:58648,\r\n63218:58649,\r\n63219:58650,\r\n63220:58651,\r\n63221:58652,\r\n63222:58653,\r\n63223:58654,\r\n63224:58655,\r\n63225:58656,\r\n63226:58657,\r\n63227:58658,\r\n63228:58659,\r\n63296:58660,\r\n63297:58661,\r\n63298:58662,\r\n63299:58663,\r\n63300:58664,\r\n63301:58665,\r\n63302:58666,\r\n63303:58667,\r\n63304:58668,\r\n63305:58669,\r\n63306:58670,\r\n63307:58671,\r\n63308:58672,\r\n63309:58673,\r\n63310:58674,\r\n63311:58675,\r\n63312:58676,\r\n63313:58677,\r\n63314:58678,\r\n63315:58679,\r\n63316:58680,\r\n63317:58681,\r\n63318:58682,\r\n63319:58683,\r\n63320:58684,\r\n63321:58685,\r\n63322:58686,\r\n63323:58687,\r\n63324:58688,\r\n63325:58689,\r\n63326:58690,\r\n63327:58691,\r\n63328:58692,\r\n63329:58693,\r\n63330:58694,\r\n63331:58695,\r\n63332:58696,\r\n63333:58697,\r\n63334:58698,\r\n63335:58699,\r\n63336:58700,\r\n63337:58701,\r\n63338:58702,\r\n63339:58703,\r\n63340:58704,\r\n63341:58705,\r\n63342:58706,\r\n63343:58707,\r\n63344:58708,\r\n63345:58709,\r\n63346:58710,\r\n63347:58711,\r\n63348:58712,\r\n63349:58713,\r\n63350:58714,\r\n63351:58715,\r\n63352:58716,\r\n63353:58717,\r\n63354:58718,\r\n63355:58719,\r\n63356:58720,\r\n63357:58721,\r\n63358:58722,\r\n63360:58723,\r\n63361:58724,\r\n63362:58725,\r\n63363:58726,\r\n63364:58727,\r\n63365:58728,\r\n63366:58729,\r\n63367:58730,\r\n63368:58731,\r\n63369:58732,\r\n63370:58733,\r\n63371:58734,\r\n63372:58735,\r\n63373:58736,\r\n63374:58737,\r\n63375:58738,\r\n63376:58739,\r\n63377:58740,\r\n63378:58741,\r\n63379:58742,\r\n63380:58743,\r\n63381:58744,\r\n63382:58745,\r\n63383:58746,\r\n63384:58747,\r\n63385:58748,\r\n63386:58749,\r\n63387:58750,\r\n63388:58751,\r\n63389:58752,\r\n63390:58753,\r\n63391:58754,\r\n63392:58755,\r\n63393:58756,\r\n63394:58757,\r\n63395:58758,\r\n63396:58759,\r\n63397:58760,\r\n63398:58761,\r\n63399:58762,\r\n63400:58763,\r\n63401:58764,\r\n63402:58765,\r\n63403:58766,\r\n63404:58767,\r\n63405:58768,\r\n63406:58769,\r\n63407:58770,\r\n63408:58771,\r\n63409:58772,\r\n63410:58773,\r\n63411:58774,\r\n63412:58775,\r\n63413:58776,\r\n63414:58777,\r\n63415:58778,\r\n63416:58779,\r\n63417:58780,\r\n63418:58781,\r\n63419:58782,\r\n63420:58783,\r\n63421:58784,\r\n63422:58785,\r\n63423:58786,\r\n63424:58787,\r\n63425:58788,\r\n63426:58789,\r\n63427:58790,\r\n63428:58791,\r\n63429:58792,\r\n63430:58793,\r\n63431:58794,\r\n63432:58795,\r\n63433:58796,\r\n63434:58797,\r\n63435:58798,\r\n63436:58799,\r\n63437:58800,\r\n63438:58801,\r\n63439:58802,\r\n63440:58803,\r\n63441:58804,\r\n63442:58805,\r\n63443:58806,\r\n63444:58807,\r\n63445:58808,\r\n63446:58809,\r\n63447:58810,\r\n63448:58811,\r\n63449:58812,\r\n63450:58813,\r\n63451:58814,\r\n63452:58815,\r\n63453:58816,\r\n63454:58817,\r\n63455:58818,\r\n63456:58819,\r\n63457:58820,\r\n63458:58821,\r\n63459:58822,\r\n63460:58823,\r\n63461:58824,\r\n63462:58825,\r\n63463:58826,\r\n63464:58827,\r\n63465:58828,\r\n63466:58829,\r\n63467:58830,\r\n63468:58831,\r\n63469:58832,\r\n63470:58833,\r\n63471:58834,\r\n63472:58835,\r\n63473:58836,\r\n63474:58837,\r\n63475:58838,\r\n63476:58839,\r\n63477:58840,\r\n63478:58841,\r\n63479:58842,\r\n63480:58843,\r\n63481:58844,\r\n63482:58845,\r\n63483:58846,\r\n63484:58847,\r\n63552:58848,\r\n63553:58849,\r\n63554:58850,\r\n63555:58851,\r\n63556:58852,\r\n63557:58853,\r\n63558:58854,\r\n63559:58855,\r\n63560:58856,\r\n63561:58857,\r\n63562:58858,\r\n63563:58859,\r\n63564:58860,\r\n63565:58861,\r\n63566:58862,\r\n63567:58863,\r\n63568:58864,\r\n63569:58865,\r\n63570:58866,\r\n63571:58867,\r\n63572:58868,\r\n63573:58869,\r\n63574:58870,\r\n63575:58871,\r\n63576:58872,\r\n63577:58873,\r\n63578:58874,\r\n63579:58875,\r\n63580:58876,\r\n63581:58877,\r\n63582:58878,\r\n63583:58879,\r\n63584:58880,\r\n63585:58881,\r\n63586:58882,\r\n63587:58883,\r\n63588:58884,\r\n63589:58885,\r\n63590:58886,\r\n63591:58887,\r\n63592:58888,\r\n63593:58889,\r\n63594:58890,\r\n63595:58891,\r\n63596:58892,\r\n63597:58893,\r\n63598:58894,\r\n63599:58895,\r\n63600:58896,\r\n63601:58897,\r\n63602:58898,\r\n63603:58899,\r\n63604:58900,\r\n63605:58901,\r\n63606:58902,\r\n63607:58903,\r\n63608:58904,\r\n63609:58905,\r\n63610:58906,\r\n63611:58907,\r\n63612:58908,\r\n63613:58909,\r\n63614:58910,\r\n63616:58911,\r\n63617:58912,\r\n63618:58913,\r\n63619:58914,\r\n63620:58915,\r\n63621:58916,\r\n63622:58917,\r\n63623:58918,\r\n63624:58919,\r\n63625:58920,\r\n63626:58921,\r\n63627:58922,\r\n63628:58923,\r\n63629:58924,\r\n63630:58925,\r\n63631:58926,\r\n63632:58927,\r\n63633:58928,\r\n63634:58929,\r\n63635:58930,\r\n63636:58931,\r\n63637:58932,\r\n63638:58933,\r\n63639:58934,\r\n63640:58935,\r\n63641:58936,\r\n63642:58937,\r\n63643:58938,\r\n63644:58939,\r\n63645:58940,\r\n63646:58941,\r\n63647:58942,\r\n63648:58943,\r\n63649:58944,\r\n63650:58945,\r\n63651:58946,\r\n63652:58947,\r\n63653:58948,\r\n63654:58949,\r\n63655:58950,\r\n63656:58951,\r\n63657:58952,\r\n63658:58953,\r\n63659:58954,\r\n63660:58955,\r\n63661:58956,\r\n63662:58957,\r\n63663:58958,\r\n63664:58959,\r\n63665:58960,\r\n63666:58961,\r\n63667:58962,\r\n63668:58963,\r\n63669:58964,\r\n63670:58965,\r\n63671:58966,\r\n63672:58967,\r\n63673:58968,\r\n63674:58969,\r\n63675:58970,\r\n63676:58971,\r\n63677:58972,\r\n63678:58973,\r\n63679:58974,\r\n63680:58975,\r\n63681:58976,\r\n63682:58977,\r\n63683:58978,\r\n63684:58979,\r\n63685:58980,\r\n63686:58981,\r\n63687:58982,\r\n63688:58983,\r\n63689:58984,\r\n63690:58985,\r\n63691:58986,\r\n63692:58987,\r\n63693:58988,\r\n63694:58989,\r\n63695:58990,\r\n63696:58991,\r\n63697:58992,\r\n63698:58993,\r\n63699:58994,\r\n63700:58995,\r\n63701:58996,\r\n63702:58997,\r\n63703:58998,\r\n63704:58999,\r\n63705:59000,\r\n63706:59001,\r\n63707:59002,\r\n63708:59003,\r\n63709:59004,\r\n63710:59005,\r\n63711:59006,\r\n63712:59007,\r\n63713:59008,\r\n63714:59009,\r\n63715:59010,\r\n63716:59011,\r\n63717:59012,\r\n63718:59013,\r\n63719:59014,\r\n63720:59015,\r\n63721:59016,\r\n63722:59017,\r\n63723:59018,\r\n63724:59019,\r\n63725:59020,\r\n63726:59021,\r\n63727:59022,\r\n63728:59023,\r\n63729:59024,\r\n63730:59025,\r\n63731:59026,\r\n63732:59027,\r\n63733:59028,\r\n63734:59029,\r\n63735:59030,\r\n63736:59031,\r\n63737:59032,\r\n63738:59033,\r\n63739:59034,\r\n63740:59035,\r\n64064:8560,\r\n64065:8561,\r\n64066:8562,\r\n64067:8563,\r\n64068:8564,\r\n64069:8565,\r\n64070:8566,\r\n64071:8567,\r\n64072:8568,\r\n64073:8569,\r\n64074:8544,\r\n64075:8545,\r\n64076:8546,\r\n64077:8547,\r\n64078:8548,\r\n64079:8549,\r\n64080:8550,\r\n64081:8551,\r\n64082:8552,\r\n64083:8553,\r\n64084:65506,\r\n64085:65508,\r\n64086:65287,\r\n64087:65282,\r\n64088:12849,\r\n64089:8470,\r\n64090:8481,\r\n64091:8757,\r\n64092:32394,\r\n64093:35100,\r\n64094:37704,\r\n64095:37512,\r\n64096:34012,\r\n64097:20425,\r\n64098:28859,\r\n64099:26161,\r\n64100:26824,\r\n64101:37625,\r\n64102:26363,\r\n64103:24389,\r\n64104:20008,\r\n64105:20193,\r\n64106:20220,\r\n64107:20224,\r\n64108:20227,\r\n64109:20281,\r\n64110:20310,\r\n64111:20370,\r\n64112:20362,\r\n64113:20378,\r\n64114:20372,\r\n64115:20429,\r\n64116:20544,\r\n64117:20514,\r\n64118:20479,\r\n64119:20510,\r\n64120:20550,\r\n64121:20592,\r\n64122:20546,\r\n64123:20628,\r\n64124:20724,\r\n64125:20696,\r\n64126:20810,\r\n64128:20836,\r\n64129:20893,\r\n64130:20926,\r\n64131:20972,\r\n64132:21013,\r\n64133:21148,\r\n64134:21158,\r\n64135:21184,\r\n64136:21211,\r\n64137:21248,\r\n64138:21255,\r\n64139:21284,\r\n64140:21362,\r\n64141:21395,\r\n64142:21426,\r\n64143:21469,\r\n64144:64014,\r\n64145:21660,\r\n64146:21642,\r\n64147:21673,\r\n64148:21759,\r\n64149:21894,\r\n64150:22361,\r\n64151:22373,\r\n64152:22444,\r\n64153:22472,\r\n64154:22471,\r\n64155:64015,\r\n64156:64016,\r\n64157:22686,\r\n64158:22706,\r\n64159:22795,\r\n64160:22867,\r\n64161:22875,\r\n64162:22877,\r\n64163:22883,\r\n64164:22948,\r\n64165:22970,\r\n64166:23382,\r\n64167:23488,\r\n64168:29999,\r\n64169:23512,\r\n64170:23532,\r\n64171:23582,\r\n64172:23718,\r\n64173:23738,\r\n64174:23797,\r\n64175:23847,\r\n64176:23891,\r\n64177:64017,\r\n64178:23874,\r\n64179:23917,\r\n64180:23992,\r\n64181:23993,\r\n64182:24016,\r\n64183:24353,\r\n64184:24372,\r\n64185:24423,\r\n64186:24503,\r\n64187:24542,\r\n64188:24669,\r\n64189:24709,\r\n64190:24714,\r\n64191:24798,\r\n64192:24789,\r\n64193:24864,\r\n64194:24818,\r\n64195:24849,\r\n64196:24887,\r\n64197:24880,\r\n64198:24984,\r\n64199:25107,\r\n64200:25254,\r\n64201:25589,\r\n64202:25696,\r\n64203:25757,\r\n64204:25806,\r\n64205:25934,\r\n64206:26112,\r\n64207:26133,\r\n64208:26171,\r\n64209:26121,\r\n64210:26158,\r\n64211:26142,\r\n64212:26148,\r\n64213:26213,\r\n64214:26199,\r\n64215:26201,\r\n64216:64018,\r\n64217:26227,\r\n64218:26265,\r\n64219:26272,\r\n64220:26290,\r\n64221:26303,\r\n64222:26362,\r\n64223:26382,\r\n64224:63785,\r\n64225:26470,\r\n64226:26555,\r\n64227:26706,\r\n64228:26560,\r\n64229:26625,\r\n64230:26692,\r\n64231:26831,\r\n64232:64019,\r\n64233:26984,\r\n64234:64020,\r\n64235:27032,\r\n64236:27106,\r\n64237:27184,\r\n64238:27243,\r\n64239:27206,\r\n64240:27251,\r\n64241:27262,\r\n64242:27362,\r\n64243:27364,\r\n64244:27606,\r\n64245:27711,\r\n64246:27740,\r\n64247:27782,\r\n64248:27759,\r\n64249:27866,\r\n64250:27908,\r\n64251:28039,\r\n64252:28015,\r\n64320:28054,\r\n64321:28076,\r\n64322:28111,\r\n64323:28152,\r\n64324:28146,\r\n64325:28156,\r\n64326:28217,\r\n64327:28252,\r\n64328:28199,\r\n64329:28220,\r\n64330:28351,\r\n64331:28552,\r\n64332:28597,\r\n64333:28661,\r\n64334:28677,\r\n64335:28679,\r\n64336:28712,\r\n64337:28805,\r\n64338:28843,\r\n64339:28943,\r\n64340:28932,\r\n64341:29020,\r\n64342:28998,\r\n64343:28999,\r\n64344:64021,\r\n64345:29121,\r\n64346:29182,\r\n64347:29361,\r\n64348:29374,\r\n64349:29476,\r\n64350:64022,\r\n64351:29559,\r\n64352:29629,\r\n64353:29641,\r\n64354:29654,\r\n64355:29667,\r\n64356:29650,\r\n64357:29703,\r\n64358:29685,\r\n64359:29734,\r\n64360:29738,\r\n64361:29737,\r\n64362:29742,\r\n64363:29794,\r\n64364:29833,\r\n64365:29855,\r\n64366:29953,\r\n64367:30063,\r\n64368:30338,\r\n64369:30364,\r\n64370:30366,\r\n64371:30363,\r\n64372:30374,\r\n64373:64023,\r\n64374:30534,\r\n64375:21167,\r\n64376:30753,\r\n64377:30798,\r\n64378:30820,\r\n64379:30842,\r\n64380:31024,\r\n64381:64024,\r\n64382:64025,\r\n64384:64026,\r\n64385:31124,\r\n64386:64027,\r\n64387:31131,\r\n64388:31441,\r\n64389:31463,\r\n64390:64028,\r\n64391:31467,\r\n64392:31646,\r\n64393:64029,\r\n64394:32072,\r\n64395:32092,\r\n64396:32183,\r\n64397:32160,\r\n64398:32214,\r\n64399:32338,\r\n64400:32583,\r\n64401:32673,\r\n64402:64030,\r\n64403:33537,\r\n64404:33634,\r\n64405:33663,\r\n64406:33735,\r\n64407:33782,\r\n64408:33864,\r\n64409:33972,\r\n64410:34131,\r\n64411:34137,\r\n64412:34155,\r\n64413:64031,\r\n64414:34224,\r\n64415:64032,\r\n64416:64033,\r\n64417:34823,\r\n64418:35061,\r\n64419:35346,\r\n64420:35383,\r\n64421:35449,\r\n64422:35495,\r\n64423:35518,\r\n64424:35551,\r\n64425:64034,\r\n64426:35574,\r\n64427:35667,\r\n64428:35711,\r\n64429:36080,\r\n64430:36084,\r\n64431:36114,\r\n64432:36214,\r\n64433:64035,\r\n64434:36559,\r\n64435:64036,\r\n64436:64037,\r\n64437:36967,\r\n64438:37086,\r\n64439:64038,\r\n64440:37141,\r\n64441:37159,\r\n64442:37338,\r\n64443:37335,\r\n64444:37342,\r\n64445:37357,\r\n64446:37358,\r\n64447:37348,\r\n64448:37349,\r\n64449:37382,\r\n64450:37392,\r\n64451:37386,\r\n64452:37434,\r\n64453:37440,\r\n64454:37436,\r\n64455:37454,\r\n64456:37465,\r\n64457:37457,\r\n64458:37433,\r\n64459:37479,\r\n64460:37543,\r\n64461:37495,\r\n64462:37496,\r\n64463:37607,\r\n64464:37591,\r\n64465:37593,\r\n64466:37584,\r\n64467:64039,\r\n64468:37589,\r\n64469:37600,\r\n64470:37587,\r\n64471:37669,\r\n64472:37665,\r\n64473:37627,\r\n64474:64040,\r\n64475:37662,\r\n64476:37631,\r\n64477:37661,\r\n64478:37634,\r\n64479:37744,\r\n64480:37719,\r\n64481:37796,\r\n64482:37830,\r\n64483:37854,\r\n64484:37880,\r\n64485:37937,\r\n64486:37957,\r\n64487:37960,\r\n64488:38290,\r\n64489:63964,\r\n64490:64041,\r\n64491:38557,\r\n64492:38575,\r\n64493:38707,\r\n64494:38715,\r\n64495:38723,\r\n64496:38733,\r\n64497:38735,\r\n64498:38737,\r\n64499:38741,\r\n64500:38999,\r\n64501:39013,\r\n64502:64042,\r\n64503:64043,\r\n64504:39207,\r\n64505:64044,\r\n64506:39326,\r\n64507:39502,\r\n64508:39641,\r\n64576:39644,\r\n64577:39797,\r\n64578:39794,\r\n64579:39823,\r\n64580:39857,\r\n64581:39867,\r\n64582:39936,\r\n64583:40304,\r\n64584:40299,\r\n64585:64045,\r\n64586:40473,\r\n64587:40657\r\n};\n\n/**\r\n * @author takahiro / https://github.com/takahirox\r\n */\r\n\r\nfunction DataViewEx ( buffer, littleEndian ) {\r\n\r\n\tthis.dv = new DataView( buffer );\r\n\tthis.offset = 0;\r\n\tthis.littleEndian = ( littleEndian !== undefined ) ? littleEndian : true;\r\n\tthis.encoder = new CharsetEncoder();\r\n\r\n}\r\n\r\nDataViewEx.prototype = {\r\n\r\n\tconstructor: DataViewEx,\r\n\r\n\tgetInt8: function () {\r\n\r\n\t\tvar value = this.dv.getInt8( this.offset );\r\n\t\tthis.offset += 1;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetInt8Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getInt8() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetUint8: function () {\r\n\r\n\t\tvar value = this.dv.getUint8( this.offset );\r\n\t\tthis.offset += 1;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetUint8Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getUint8() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\r\n\tgetInt16: function () {\r\n\r\n\t\tvar value = this.dv.getInt16( this.offset, this.littleEndian );\r\n\t\tthis.offset += 2;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetInt16Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getInt16() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetUint16: function () {\r\n\r\n\t\tvar value = this.dv.getUint16( this.offset, this.littleEndian );\r\n\t\tthis.offset += 2;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetUint16Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getUint16() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetInt32: function () {\r\n\r\n\t\tvar value = this.dv.getInt32( this.offset, this.littleEndian );\r\n\t\tthis.offset += 4;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetInt32Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getInt32() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetUint32: function () {\r\n\r\n\t\tvar value = this.dv.getUint32( this.offset, this.littleEndian );\r\n\t\tthis.offset += 4;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetUint32Array: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getUint32() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetFloat32: function () {\r\n\r\n\t\tvar value = this.dv.getFloat32( this.offset, this.littleEndian );\r\n\t\tthis.offset += 4;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetFloat32Array: function( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getFloat32() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetFloat64: function () {\r\n\r\n\t\tvar value = this.dv.getFloat64( this.offset, this.littleEndian );\r\n\t\tthis.offset += 8;\r\n\t\treturn value;\r\n\r\n\t},\r\n\r\n\tgetFloat64Array: function( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getFloat64() );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetIndex: function ( type, isUnsigned ) {\r\n\r\n\t\tswitch ( type ) {\r\n\r\n\t\t\tcase 1:\r\n\t\t\t\treturn ( isUnsigned === true ) ? this.getUint8() : this.getInt8();\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\treturn ( isUnsigned === true ) ? this.getUint16() : this.getInt16();\r\n\r\n\t\t\tcase 4:\r\n\t\t\t\treturn this.getInt32(); // No Uint32\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow 'unknown number type ' + type + ' exception.';\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetIndexArray: function ( type, size, isUnsigned ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\tfor ( var i = 0; i < size; i++ ) {\r\n\r\n\t\t\ta.push( this.getIndex( type, isUnsigned ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn a;\r\n\r\n\t},\r\n\r\n\tgetChars: function ( size ) {\r\n\r\n\t\tvar str = '';\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tvar value = this.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t\tif ( value === 0 ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstr += String.fromCharCode( value );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tthis.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\r\n\t},\r\n\r\n\tgetSjisStringsAsUnicode: function ( size ) {\r\n\r\n\t\tvar a = [];\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tvar value = this.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t\tif ( value === 0 ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ta.push( value );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tthis.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.encoder.s2u( new Uint8Array( a ) );\r\n\r\n\t},\r\n\r\n\tgetUnicodeStrings: function ( size ) {\r\n\r\n\t\tvar str = '';\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tvar value = this.getUint16();\r\n\t\t\tsize -= 2;\r\n\r\n\t\t\tif ( value === 0 ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstr += String.fromCharCode( value );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( size > 0 ) {\r\n\r\n\t\t\tthis.getUint8();\r\n\t\t\tsize--;\r\n\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\r\n\t},\r\n\r\n\tgetTextBuffer: function () {\r\n\r\n\t\tvar size = this.getUint32();\r\n\t\treturn this.getUnicodeStrings( size );\r\n\r\n\t}\r\n\r\n};\n\n/**\r\n * @author takahiro / https://github.com/takahirox\r\n */\r\n\r\nfunction DataCreationHelper () {\r\n}\r\n\r\nDataCreationHelper.prototype = {\r\n\r\n\tconstructor: DataCreationHelper,\r\n\r\n\tleftToRightVector3: function ( v ) {\r\n\r\n\t\tv[ 2 ] = -v[ 2 ];\r\n\r\n\t},\r\n\r\n\tleftToRightQuaternion: function ( q ) {\r\n\r\n\t\tq[ 0 ] = -q[ 0 ];\r\n\t\tq[ 1 ] = -q[ 1 ];\r\n\r\n\t},\r\n\r\n\tleftToRightEuler: function ( r ) {\r\n\r\n\t\tr[ 0 ] = -r[ 0 ];\r\n\t\tr[ 1 ] = -r[ 1 ];\r\n\r\n\t},\r\n\r\n\tleftToRightIndexOrder: function ( p ) {\r\n\r\n\t\tvar tmp = p[ 2 ];\r\n\t\tp[ 2 ] = p[ 0 ];\r\n\t\tp[ 0 ] = tmp;\r\n\r\n\t},\r\n\r\n\tleftToRightVector3Range: function ( v1, v2 ) {\r\n\r\n\t\tvar tmp = -v2[ 2 ];\r\n\t\tv2[ 2 ] = -v1[ 2 ];\r\n\t\tv1[ 2 ] = tmp;\r\n\r\n\t},\r\n\r\n\tleftToRightEulerRange: function ( r1, r2 ) {\r\n\r\n\t\tvar tmp1 = -r2[ 0 ];\r\n\t\tvar tmp2 = -r2[ 1 ];\r\n\t\tr2[ 0 ] = -r1[ 0 ];\r\n\t\tr2[ 1 ] = -r1[ 1 ];\r\n\t\tr1[ 0 ] = tmp1;\r\n\t\tr1[ 1 ] = tmp2;\r\n\r\n\t}\r\n\r\n};\n\n/**\r\n * @author takahiro / https://github.com/takahirox\r\n */\r\n\r\nfunction Parser() {\r\n}\r\n\r\nParser.prototype.parsePmd = function ( buffer, leftToRight ) {\r\n\r\n\tvar pmd = {};\r\n\tvar dv = new DataViewEx( buffer );\r\n\r\n\tpmd.metadata = {};\r\n\tpmd.metadata.format = 'pmd';\r\n\tpmd.metadata.coordinateSystem = 'left';\r\n\r\n\tvar parseHeader = function () {\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.magic = dv.getChars( 3 );\r\n\r\n\t\tif ( metadata.magic !== 'Pmd' ) {\r\n\r\n\t\t\tthrow 'PMD file magic is not Pmd, but ' + metadata.magic;\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.version = dv.getFloat32();\r\n\t\tmetadata.modelName = dv.getSjisStringsAsUnicode( 20 );\r\n\t\tmetadata.comment = dv.getSjisStringsAsUnicode( 256 );\r\n\r\n\t};\r\n\r\n\tvar parseVertices = function () {\r\n\r\n\t\tvar parseVertex = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.normal = dv.getFloat32Array( 3 );\r\n\t\t\tp.uv = dv.getFloat32Array( 2 );\r\n\t\t\tp.skinIndices = dv.getUint16Array( 2 );\r\n\t\t\tp.skinWeights = [ dv.getUint8() / 100 ];\r\n\t\t\tp.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );\r\n\t\t\tp.edgeFlag = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.vertexCount = dv.getUint32();\r\n\r\n\t\tpmd.vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.vertexCount; i++ ) {\r\n\r\n\t\t\tpmd.vertices.push( parseVertex() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseFaces = function () {\r\n\r\n\t\tvar parseFace = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.indices = dv.getUint16Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.faceCount = dv.getUint32() / 3;\r\n\r\n\t\tpmd.faces = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.faceCount; i++ ) {\r\n\r\n\t\t\tpmd.faces.push( parseFace() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMaterials = function () {\r\n\r\n\t\tvar parseMaterial = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.diffuse = dv.getFloat32Array( 4 );\r\n\t\t\tp.shininess = dv.getFloat32();\r\n\t\t\tp.specular = dv.getFloat32Array( 3 );\r\n\t\t\tp.ambient = dv.getFloat32Array( 3 );\r\n\t\t\tp.toonIndex = dv.getInt8();\r\n\t\t\tp.edgeFlag = dv.getUint8();\r\n\t\t\tp.faceCount = dv.getUint32() / 3;\r\n\t\t\tp.fileName = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.materialCount = dv.getUint32();\r\n\r\n\t\tpmd.materials = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.materialCount; i++ ) {\r\n\r\n\t\t\tpmd.materials.push( parseMaterial() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBones = function () {\r\n\r\n\t\tvar parseBone = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.parentIndex = dv.getInt16();\r\n\t\t\tp.tailIndex = dv.getInt16();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.ikIndex = dv.getInt16();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.boneCount = dv.getUint16();\r\n\r\n\t\tpmd.bones = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneCount; i++ ) {\r\n\r\n\t\t\tpmd.bones.push( parseBone() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseIks = function () {\r\n\r\n\t\tvar parseIk = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.target = dv.getUint16();\r\n\t\t\tp.effector = dv.getUint16();\r\n\t\t\tp.linkCount = dv.getUint8();\r\n\t\t\tp.iteration = dv.getUint16();\r\n\t\t\tp.maxAngle = dv.getFloat32();\r\n\r\n\t\t\tp.links = [];\r\n\t\t\tfor ( var i = 0; i < p.linkCount; i++ ) {\r\n\r\n\t\t\t\tvar link = {};\r\n\t\t\t\tlink.index = dv.getUint16();\r\n\t\t\t\tp.links.push( link );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.ikCount = dv.getUint16();\r\n\r\n\t\tpmd.iks = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.ikCount; i++ ) {\r\n\r\n\t\t\tpmd.iks.push( parseIk() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMorphs = function () {\r\n\r\n\t\tvar parseMorph = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.elementCount = dv.getUint32();\r\n\t\t\tp.type = dv.getUint8();\r\n\r\n\t\t\tp.elements = [];\r\n\t\t\tfor ( var i = 0; i < p.elementCount; i++ ) {\r\n\r\n\t\t\t\tp.elements.push( {\r\n\t\t\t\t\tindex: dv.getUint32(),\r\n\t\t\t\t\tposition: dv.getFloat32Array( 3 )\r\n\t\t\t\t} ) ;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.morphCount = dv.getUint16();\r\n\r\n\t\tpmd.morphs = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphCount; i++ ) {\r\n\r\n\t\t\tpmd.morphs.push( parseMorph() );\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tvar parseMorphFrames = function () {\r\n\r\n\t\tvar parseMorphFrame = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.index = dv.getUint16();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.morphFrameCount = dv.getUint8();\r\n\r\n\t\tpmd.morphFrames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphFrameCount; i++ ) {\r\n\r\n\t\t\tpmd.morphFrames.push( parseMorphFrame() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBoneFrameNames = function () {\r\n\r\n\t\tvar parseBoneFrameName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 50 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.boneFrameNameCount = dv.getUint8();\r\n\r\n\t\tpmd.boneFrameNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneFrameNameCount; i++ ) {\r\n\r\n\t\t\tpmd.boneFrameNames.push( parseBoneFrameName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBoneFrames = function () {\r\n\r\n\t\tvar parseBoneFrame = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.boneIndex = dv.getInt16();\r\n\t\t\tp.frameIndex = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.boneFrameCount = dv.getUint32();\r\n\r\n\t\tpmd.boneFrames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneFrameCount; i++ ) {\r\n\r\n\t\t\tpmd.boneFrames.push( parseBoneFrame() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishHeader = function () {\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.englishCompatibility = dv.getUint8();\r\n\r\n\t\tif ( metadata.englishCompatibility > 0 ) {\r\n\r\n\t\t\tmetadata.englishModelName = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tmetadata.englishComment = dv.getSjisStringsAsUnicode( 256 );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishBoneNames = function () {\r\n\r\n\t\tvar parseEnglishBoneName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\r\n\t\tif ( metadata.englishCompatibility === 0 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tpmd.englishBoneNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneCount; i++ ) {\r\n\r\n\t\t\tpmd.englishBoneNames.push( parseEnglishBoneName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishMorphNames = function () {\r\n\r\n\t\tvar parseEnglishMorphName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\r\n\t\tif ( metadata.englishCompatibility === 0 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tpmd.englishMorphNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphCount - 1; i++ ) {\r\n\r\n\t\t\tpmd.englishMorphNames.push( parseEnglishMorphName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseEnglishBoneFrameNames = function () {\r\n\r\n\t\tvar parseEnglishBoneFrameName = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 50 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\r\n\t\tif ( metadata.englishCompatibility === 0 ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tpmd.englishBoneFrameNames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneFrameNameCount; i++ ) {\r\n\r\n\t\t\tpmd.englishBoneFrameNames.push( parseEnglishBoneFrameName() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseToonTextures = function () {\r\n\r\n\t\tvar parseToonTexture = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.fileName = dv.getSjisStringsAsUnicode( 100 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tpmd.toonTextures = [];\r\n\r\n\t\tfor ( var i = 0; i < 10; i++ ) {\r\n\r\n\t\t\tpmd.toonTextures.push( parseToonTexture() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseRigidBodies = function () {\r\n\r\n\t\tvar parseRigidBody = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.boneIndex = dv.getInt16();\r\n\t\t\tp.groupIndex = dv.getUint8();\r\n\t\t\tp.groupTarget = dv.getUint16();\r\n\t\t\tp.shapeType = dv.getUint8();\r\n\t\t\tp.width = dv.getFloat32();\r\n\t\t\tp.height = dv.getFloat32();\r\n\t\t\tp.depth = dv.getFloat32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.weight = dv.getFloat32();\r\n\t\t\tp.positionDamping = dv.getFloat32();\r\n\t\t\tp.rotationDamping = dv.getFloat32();\r\n\t\t\tp.restitution = dv.getFloat32();\r\n\t\t\tp.friction = dv.getFloat32();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.rigidBodyCount = dv.getUint32();\r\n\r\n\t\tpmd.rigidBodies = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.rigidBodyCount; i++ ) {\r\n\r\n\t\t\tpmd.rigidBodies.push( parseRigidBody() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseConstraints = function () {\r\n\r\n\t\tvar parseConstraint = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getSjisStringsAsUnicode( 20 );\r\n\t\t\tp.rigidBodyIndex1 = dv.getUint32();\r\n\t\t\tp.rigidBodyIndex2 = dv.getUint32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.springPosition = dv.getFloat32Array( 3 );\r\n\t\t\tp.springRotation = dv.getFloat32Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmd.metadata;\r\n\t\tmetadata.constraintCount = dv.getUint32();\r\n\r\n\t\tpmd.constraints = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.constraintCount; i++ ) {\r\n\r\n\t\t\tpmd.constraints.push( parseConstraint() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tparseHeader();\r\n\tparseVertices();\r\n\tparseFaces();\r\n\tparseMaterials();\r\n\tparseBones();\r\n\tparseIks();\r\n\tparseMorphs();\r\n\tparseMorphFrames();\r\n\tparseBoneFrameNames();\r\n\tparseBoneFrames();\r\n\tparseEnglishHeader();\r\n\tparseEnglishBoneNames();\r\n\tparseEnglishMorphNames();\r\n\tparseEnglishBoneFrameNames();\r\n\tparseToonTextures();\r\n\tparseRigidBodies();\r\n\tparseConstraints();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightModel( pmd );\r\n\r\n\t// console.log( pmd ); // for console debug\r\n\r\n\treturn pmd;\r\n\r\n};\r\n\r\nParser.prototype.parsePmx = function ( buffer, leftToRight ) {\r\n\r\n\tvar pmx = {};\r\n\tvar dv = new DataViewEx( buffer );\r\n\r\n\tpmx.metadata = {};\r\n\tpmx.metadata.format = 'pmx';\r\n\tpmx.metadata.coordinateSystem = 'left';\r\n\r\n\tvar parseHeader = function () {\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.magic = dv.getChars( 4 );\r\n\r\n\t\t// Note: don't remove the last blank space.\r\n\t\tif ( metadata.magic !== 'PMX ' ) {\r\n\r\n\t\t\tthrow 'PMX file magic is not PMX , but ' + metadata.magic;\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.version = dv.getFloat32();\r\n\r\n\t\tif ( metadata.version !== 2.0 && metadata.version !== 2.1 ) {\r\n\r\n\t\t\tthrow 'PMX version ' + metadata.version + ' is not supported.';\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.headerSize = dv.getUint8();\r\n\t\tmetadata.encoding = dv.getUint8();\r\n\t\tmetadata.additionalUvNum = dv.getUint8();\r\n\t\tmetadata.vertexIndexSize = dv.getUint8();\r\n\t\tmetadata.textureIndexSize = dv.getUint8();\r\n\t\tmetadata.materialIndexSize = dv.getUint8();\r\n\t\tmetadata.boneIndexSize = dv.getUint8();\r\n\t\tmetadata.morphIndexSize = dv.getUint8();\r\n\t\tmetadata.rigidBodyIndexSize = dv.getUint8();\r\n\t\tmetadata.modelName = dv.getTextBuffer();\r\n\t\tmetadata.englishModelName = dv.getTextBuffer();\r\n\t\tmetadata.comment = dv.getTextBuffer();\r\n\t\tmetadata.englishComment = dv.getTextBuffer();\r\n\r\n\t};\r\n\r\n\tvar parseVertices = function () {\r\n\r\n\t\tvar parseVertex = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.normal = dv.getFloat32Array( 3 );\r\n\t\t\tp.uv = dv.getFloat32Array( 2 );\r\n\r\n\t\t\tp.auvs = [];\r\n\r\n\t\t\tfor ( var i = 0; i < pmx.metadata.additionalUvNum; i++ ) {\r\n\r\n\t\t\t\tp.auvs.push( dv.getFloat32Array( 4 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp.type = dv.getUint8();\r\n\r\n\t\t\tvar indexSize = metadata.boneIndexSize;\r\n\r\n\t\t\tif ( p.type === 0 ) {  // BDEF1\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 1 );\r\n\t\t\t\tp.skinWeights = [ 1.0 ];\r\n\r\n\t\t\t} else if ( p.type === 1 ) {  // BDEF2\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 2 );\r\n\t\t\t\tp.skinWeights = dv.getFloat32Array( 1 );\r\n\t\t\t\tp.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );\r\n\r\n\t\t\t} else if ( p.type === 2 ) {  // BDEF4\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 4 );\r\n\t\t\t\tp.skinWeights = dv.getFloat32Array( 4 );\r\n\r\n\t\t\t} else if ( p.type === 3 ) {  // SDEF\r\n\r\n\t\t\t\tp.skinIndices = dv.getIndexArray( indexSize, 2 );\r\n\t\t\t\tp.skinWeights = dv.getFloat32Array( 1 );\r\n\t\t\t\tp.skinWeights.push( 1.0 - p.skinWeights[ 0 ] );\r\n\r\n\t\t\t\tp.skinC = dv.getFloat32Array( 3 );\r\n\t\t\t\tp.skinR0 = dv.getFloat32Array( 3 );\r\n\t\t\t\tp.skinR1 = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t\t// SDEF is not supported yet and is handled as BDEF2 so far.\r\n\t\t\t\t// TODO: SDEF support\r\n\t\t\t\tp.type = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'unsupport bone type ' + p.type + ' exception.';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp.edgeRatio = dv.getFloat32();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.vertexCount = dv.getUint32();\r\n\r\n\t\tpmx.vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.vertexCount; i++ ) {\r\n\r\n\t\t\tpmx.vertices.push( parseVertex() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseFaces = function () {\r\n\r\n\t\tvar parseFace = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.indices = dv.getIndexArray( metadata.vertexIndexSize, 3, true );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.faceCount = dv.getUint32() / 3;\r\n\r\n\t\tpmx.faces = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.faceCount; i++ ) {\r\n\r\n\t\t\tpmx.faces.push( parseFace() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseTextures = function () {\r\n\r\n\t\tvar parseTexture = function () {\r\n\r\n\t\t\treturn dv.getTextBuffer();\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.textureCount = dv.getUint32();\r\n\r\n\t\tpmx.textures = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.textureCount; i++ ) {\r\n\r\n\t\t\tpmx.textures.push( parseTexture() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMaterials = function () {\r\n\r\n\t\tvar parseMaterial = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.diffuse = dv.getFloat32Array( 4 );\r\n\t\t\tp.specular = dv.getFloat32Array( 3 );\r\n\t\t\tp.shininess = dv.getFloat32();\r\n\t\t\tp.ambient = dv.getFloat32Array( 3 );\r\n\t\t\tp.flag = dv.getUint8();\r\n\t\t\tp.edgeColor = dv.getFloat32Array( 4 );\r\n\t\t\tp.edgeSize = dv.getFloat32();\r\n\t\t\tp.textureIndex = dv.getIndex( pmx.metadata.textureIndexSize );\r\n\t\t\tp.envTextureIndex = dv.getIndex( pmx.metadata.textureIndexSize );\r\n\t\t\tp.envFlag = dv.getUint8();\r\n\t\t\tp.toonFlag = dv.getUint8();\r\n\r\n\t\t\tif ( p.toonFlag === 0 ) {\r\n\r\n\t\t\t\tp.toonIndex = dv.getIndex( pmx.metadata.textureIndexSize );\r\n\r\n\t\t\t} else if ( p.toonFlag === 1 ) {\r\n\r\n\t\t\t\tp.toonIndex = dv.getInt8();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'unknown toon flag ' + p.toonFlag + ' exception.';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp.comment = dv.getTextBuffer();\r\n\t\t\tp.faceCount = dv.getUint32() / 3;\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.materialCount = dv.getUint32();\r\n\r\n\t\tpmx.materials = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.materialCount; i++ ) {\r\n\r\n\t\t\tpmx.materials.push( parseMaterial() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseBones = function () {\r\n\r\n\t\tvar parseBone = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.parentIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\tp.transformationClass = dv.getUint32();\r\n\t\t\tp.flag = dv.getUint16();\r\n\r\n\t\t\tif ( p.flag & 0x1 ) {\r\n\r\n\t\t\t\tp.connectIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tp.offsetPosition = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x100 || p.flag & 0x200 ) {\r\n\r\n\t\t\t\t// Note: I don't think Grant is an appropriate name\r\n\t\t\t\t//       but I found that some English translated MMD tools use this term\r\n\t\t\t\t//       so I've named it Grant so far.\r\n\t\t\t\t//       I'd rename to more appropriate name from Grant later.\r\n\t\t\t\tvar grant = {};\r\n\r\n\t\t\t\tgrant.isLocal = ( p.flag & 0x80 ) !== 0 ? true : false;\r\n\t\t\t\tgrant.affectRotation = ( p.flag & 0x100 ) !== 0 ? true : false;\r\n\t\t\t\tgrant.affectPosition = ( p.flag & 0x200 ) !== 0 ? true : false;\r\n\t\t\t\tgrant.parentIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\tgrant.ratio = dv.getFloat32();\r\n\r\n\t\t\t\tp.grant = grant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x400 ) {\r\n\r\n\t\t\t\tp.fixAxis = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x800 ) {\r\n\r\n\t\t\t\tp.localXVector = dv.getFloat32Array( 3 );\r\n\t\t\t\tp.localZVector = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x2000 ) {\r\n\r\n\t\t\t\tp.key = dv.getUint32();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( p.flag & 0x20 ) {\r\n\r\n\t\t\t\tvar ik = {};\r\n\r\n\t\t\t\tik.effector = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\tik.target = null;\r\n\t\t\t\tik.iteration = dv.getUint32();\r\n\t\t\t\tik.maxAngle = dv.getFloat32();\r\n\t\t\t\tik.linkCount = dv.getUint32();\r\n\t\t\t\tik.links = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < ik.linkCount; i++ ) {\r\n\r\n\t\t\t\t\tvar link = {};\r\n\t\t\t\t\tlink.index = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\t\tlink.angleLimitation = dv.getUint8();\r\n\r\n\t\t\t\t\tif ( link.angleLimitation === 1 ) {\r\n\r\n\t\t\t\t\t\tlink.lowerLimitationAngle = dv.getFloat32Array( 3 );\r\n\t\t\t\t\t\tlink.upperLimitationAngle = dv.getFloat32Array( 3 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tik.links.push( link );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tp.ik = ik;\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.boneCount = dv.getUint32();\r\n\r\n\t\tpmx.bones = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.boneCount; i++ ) {\r\n\r\n\t\t\tpmx.bones.push( parseBone() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMorphs = function () {\r\n\r\n\t\tvar parseMorph = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.panel = dv.getUint8();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.elementCount = dv.getUint32();\r\n\t\t\tp.elements = [];\r\n\r\n\t\t\tfor ( var i = 0; i < p.elementCount; i++ ) {\r\n\r\n\t\t\t\tif ( p.type === 0 ) {  // group morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.morphIndexSize );\r\n\t\t\t\t\tm.ratio = dv.getFloat32();\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 1 ) {  // vertex morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.vertexIndexSize, true );\r\n\t\t\t\t\tm.position = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 2 ) {  // bone morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\t\t\tm.position = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tm.rotation = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 3 ) {  // uv morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.vertexIndexSize, true );\r\n\t\t\t\t\tm.uv = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t} else if ( p.type === 4 ) {  // additional uv1\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 5 ) {  // additional uv2\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 6 ) {  // additional uv3\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 7 ) {  // additional uv4\r\n\r\n\t\t\t\t\t// TODO: implement\r\n\r\n\t\t\t\t} else if ( p.type === 8 ) {  // material morph\r\n\r\n\t\t\t\t\tvar m = {};\r\n\t\t\t\t\tm.index = dv.getIndex( pmx.metadata.materialIndexSize );\r\n\t\t\t\t\tm.type = dv.getUint8();\r\n\t\t\t\t\tm.diffuse = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.specular = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tm.shininess = dv.getFloat32();\r\n\t\t\t\t\tm.ambient = dv.getFloat32Array( 3 );\r\n\t\t\t\t\tm.edgeColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.edgeSize = dv.getFloat32();\r\n\t\t\t\t\tm.textureColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.sphereTextureColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tm.toonColor = dv.getFloat32Array( 4 );\r\n\t\t\t\t\tp.elements.push( m );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.morphCount = dv.getUint32();\r\n\r\n\t\tpmx.morphs = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.morphCount; i++ ) {\r\n\r\n\t\t\tpmx.morphs.push( parseMorph() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseFrames = function () {\r\n\r\n\t\tvar parseFrame = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.elementCount = dv.getUint32();\r\n\t\t\tp.elements = [];\r\n\r\n\t\t\tfor ( var i = 0; i < p.elementCount; i++ ) {\r\n\r\n\t\t\t\tvar e = {};\r\n\t\t\t\te.target = dv.getUint8();\r\n\t\t\t\te.index = ( e.target === 0 ) ? dv.getIndex( pmx.metadata.boneIndexSize ) : dv.getIndex( pmx.metadata.morphIndexSize );\r\n\t\t\t\tp.elements.push( e );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.frameCount = dv.getUint32();\r\n\r\n\t\tpmx.frames = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.frameCount; i++ ) {\r\n\r\n\t\t\tpmx.frames.push( parseFrame() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseRigidBodies = function () {\r\n\r\n\t\tvar parseRigidBody = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.boneIndex = dv.getIndex( pmx.metadata.boneIndexSize );\r\n\t\t\tp.groupIndex = dv.getUint8();\r\n\t\t\tp.groupTarget = dv.getUint16();\r\n\t\t\tp.shapeType = dv.getUint8();\r\n\t\t\tp.width = dv.getFloat32();\r\n\t\t\tp.height = dv.getFloat32();\r\n\t\t\tp.depth = dv.getFloat32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.weight = dv.getFloat32();\r\n\t\t\tp.positionDamping = dv.getFloat32();\r\n\t\t\tp.rotationDamping = dv.getFloat32();\r\n\t\t\tp.restitution = dv.getFloat32();\r\n\t\t\tp.friction = dv.getFloat32();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.rigidBodyCount = dv.getUint32();\r\n\r\n\t\tpmx.rigidBodies = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.rigidBodyCount; i++ ) {\r\n\r\n\t\t\tpmx.rigidBodies.push( parseRigidBody() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseConstraints = function () {\r\n\r\n\t\tvar parseConstraint = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.name = dv.getTextBuffer();\r\n\t\t\tp.englishName = dv.getTextBuffer();\r\n\t\t\tp.type = dv.getUint8();\r\n\t\t\tp.rigidBodyIndex1 = dv.getIndex( pmx.metadata.rigidBodyIndexSize );\r\n\t\t\tp.rigidBodyIndex2 = dv.getIndex( pmx.metadata.rigidBodyIndexSize );\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.translationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation1 = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotationLimitation2 = dv.getFloat32Array( 3 );\r\n\t\t\tp.springPosition = dv.getFloat32Array( 3 );\r\n\t\t\tp.springRotation = dv.getFloat32Array( 3 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = pmx.metadata;\r\n\t\tmetadata.constraintCount = dv.getUint32();\r\n\r\n\t\tpmx.constraints = [];\r\n\r\n\t\tfor ( var i = 0; i < metadata.constraintCount; i++ ) {\r\n\r\n\t\t\tpmx.constraints.push( parseConstraint() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tparseHeader();\r\n\tparseVertices();\r\n\tparseFaces();\r\n\tparseTextures();\r\n\tparseMaterials();\r\n\tparseBones();\r\n\tparseMorphs();\r\n\tparseFrames();\r\n\tparseRigidBodies();\r\n\tparseConstraints();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightModel( pmx );\r\n\r\n\t// console.log( pmx ); // for console debug\r\n\r\n\treturn pmx;\r\n\r\n};\r\n\r\nParser.prototype.parseVmd = function ( buffer, leftToRight ) {\r\n\r\n\tvar vmd = {};\r\n\tvar dv = new DataViewEx( buffer );\r\n\r\n\tvmd.metadata = {};\r\n\tvmd.metadata.coordinateSystem = 'left';\r\n\r\n\tvar parseHeader = function () {\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.magic = dv.getChars( 30 );\r\n\r\n\t\tif ( metadata.magic !== 'Vocaloid Motion Data 0002' ) {\r\n\r\n\t\t\tthrow 'VMD file magic is not Vocaloid Motion Data 0002, but ' + metadata.magic;\r\n\r\n\t\t}\r\n\r\n\t\tmetadata.name = dv.getSjisStringsAsUnicode( 20 );\r\n\r\n\t};\r\n\r\n\tvar parseMotions = function () {\r\n\r\n\t\tvar parseMotion = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.boneName = dv.getSjisStringsAsUnicode( 15 );\r\n\t\t\tp.frameNum = dv.getUint32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 4 );\r\n\t\t\tp.interpolation = dv.getUint8Array( 64 );\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.motionCount = dv.getUint32();\r\n\r\n\t\tvmd.motions = [];\r\n\t\tfor ( var i = 0; i < metadata.motionCount; i++ ) {\r\n\r\n\t\t\tvmd.motions.push( parseMotion() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseMorphs = function () {\r\n\r\n\t\tvar parseMorph = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.morphName = dv.getSjisStringsAsUnicode( 15 );\r\n\t\t\tp.frameNum = dv.getUint32();\r\n\t\t\tp.weight = dv.getFloat32();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.morphCount = dv.getUint32();\r\n\r\n\t\tvmd.morphs = [];\r\n\t\tfor ( var i = 0; i < metadata.morphCount; i++ ) {\r\n\r\n\t\t\tvmd.morphs.push( parseMorph() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tvar parseCameras = function () {\r\n\r\n\t\tvar parseCamera = function () {\r\n\r\n\t\t\tvar p = {};\r\n\t\t\tp.frameNum = dv.getUint32();\r\n\t\t\tp.distance = dv.getFloat32();\r\n\t\t\tp.position = dv.getFloat32Array( 3 );\r\n\t\t\tp.rotation = dv.getFloat32Array( 3 );\r\n\t\t\tp.interpolation = dv.getUint8Array( 24 );\r\n\t\t\tp.fov = dv.getUint32();\r\n\t\t\tp.perspective = dv.getUint8();\r\n\t\t\treturn p;\r\n\r\n\t\t};\r\n\r\n\t\tvar metadata = vmd.metadata;\r\n\t\tmetadata.cameraCount = dv.getUint32();\r\n\r\n\t\tvmd.cameras = [];\r\n\t\tfor ( var i = 0; i < metadata.cameraCount; i++ ) {\r\n\r\n\t\t\tvmd.cameras.push( parseCamera() );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tparseHeader();\r\n\tparseMotions();\r\n\tparseMorphs();\r\n\tparseCameras();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightVmd( vmd );\r\n\r\n\t// console.log( vmd ); // for console debug\r\n\r\n\treturn vmd;\r\n\r\n};\r\n\r\nParser.prototype.parseVpd = function ( text, leftToRight ) {\r\n\r\n\tvar vpd = {};\r\n\r\n\tvpd.metadata = {};\r\n\tvpd.metadata.coordinateSystem = 'left';\r\n\r\n\tvpd.bones = [];\r\n\r\n\tvar commentPatternG = /\\/\\/\\w*(\\r|\\n|\\r\\n)/g;\r\n\tvar newlinePattern = /\\r|\\n|\\r\\n/;\r\n\r\n\tvar lines = text.replace( commentPatternG, '' ).split( newlinePattern );\r\n\r\n\tfunction throwError () {\r\n\r\n\t\tthrow 'the file seems not vpd file.';\r\n\r\n\t}\r\n\r\n\tfunction checkMagic () {\r\n\r\n\t\tif ( lines[ 0 ] !== 'Vocaloid Pose Data file' ) {\r\n\r\n\t\t\tthrowError();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction parseHeader () {\r\n\r\n\t\tif ( lines.length < 4 ) {\r\n\r\n\t\t\tthrowError();\r\n\r\n\t\t}\r\n\r\n\t\tvpd.metadata.parentFile = lines[ 2 ];\r\n\t\tvpd.metadata.boneCount = parseInt( lines[ 3 ] );\r\n\r\n\t}\r\n\r\n\tfunction parseBones () {\r\n\r\n\t\tvar boneHeaderPattern = /^\\s*(Bone[0-9]+)\\s*\\{\\s*(.*)$/;\r\n\t\tvar boneVectorPattern = /^\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*;/;\r\n\t\tvar boneQuaternionPattern = /^\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*,\\s*(-?[0-9]+\\.[0-9]+)\\s*;/;\r\n\t\tvar boneFooterPattern = /^\\s*}/;\r\n\r\n\t\tvar bones = vpd.bones;\r\n\t\tvar n = null;\r\n\t\tvar v = null;\r\n\t\tvar q = null;\r\n\r\n\t\tfor ( var i = 4; i < lines.length; i++ ) {\r\n\r\n\t\t\tvar line = lines[ i ];\r\n\r\n\t\t\tvar result;\r\n\r\n\t\t\tresult = line.match( boneHeaderPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( n !== null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tn = result[ 2 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = line.match( boneVectorPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( v !== null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tv = [\r\n\r\n\t\t\t\t\tparseFloat( result[ 1 ] ),\r\n\t\t\t\t\tparseFloat( result[ 2 ] ),\r\n\t\t\t\t\tparseFloat( result[ 3 ] )\r\n\r\n\t\t\t\t];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = line.match( boneQuaternionPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( q !== null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tq = [\r\n\r\n\t\t\t\t\tparseFloat( result[ 1 ] ),\r\n\t\t\t\t\tparseFloat( result[ 2 ] ),\r\n\t\t\t\t\tparseFloat( result[ 3 ] ),\r\n\t\t\t\t\tparseFloat( result[ 4 ] )\r\n\r\n\t\t\t\t];\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = line.match( boneFooterPattern );\r\n\r\n\t\t\tif ( result !== null ) {\r\n\r\n\t\t\t\tif ( n === null || v === null || q === null ) {\r\n\r\n\t\t\t\t\tthrowError();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbones.push( {\r\n\r\n\t\t\t\t\tname: n,\r\n\t\t\t\t\ttranslation: v,\r\n\t\t\t\t\tquaternion: q\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\tn = null;\r\n\t\t\t\tv = null;\r\n\t\t\t\tq = null;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( n !== null || v !== null || q !== null ) {\r\n\r\n\t\t\tthrowError();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcheckMagic();\r\n\tparseHeader();\r\n\tparseBones();\r\n\r\n\tif ( leftToRight === true ) this.leftToRightVpd( vpd );\r\n\r\n\t// console.log( vpd );  // for console debug\r\n\r\n\treturn vpd;\r\n\r\n};\r\n\r\nParser.prototype.mergeVmds = function ( vmds ) {\r\n\r\n\tvar v = {};\r\n\tv.metadata = {};\r\n\tv.metadata.name = vmds[ 0 ].metadata.name;\r\n\tv.metadata.coordinateSystem = vmds[ 0 ].metadata.coordinateSystem;\r\n\tv.metadata.motionCount = 0;\r\n\tv.metadata.morphCount = 0;\r\n\tv.metadata.cameraCount = 0;\r\n\tv.motions = [];\r\n\tv.morphs = [];\r\n\tv.cameras = [];\r\n\r\n\tfor ( var i = 0; i < vmds.length; i++ ) {\r\n\r\n\t\tvar v2 = vmds[ i ];\r\n\r\n\t\tv.metadata.motionCount += v2.metadata.motionCount;\r\n\t\tv.metadata.morphCount += v2.metadata.morphCount;\r\n\t\tv.metadata.cameraCount += v2.metadata.cameraCount;\r\n\r\n\t\tfor ( var j = 0; j < v2.metadata.motionCount; j++ ) {\r\n\r\n\t\t\tv.motions.push( v2.motions[ j ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 0; j < v2.metadata.morphCount; j++ ) {\r\n\r\n\t\t\tv.morphs.push( v2.morphs[ j ] );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 0; j < v2.metadata.cameraCount; j++ ) {\r\n\r\n\t\t\tv.cameras.push( v2.cameras[ j ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn v;\r\n\r\n};\r\n\r\nParser.prototype.leftToRightModel = function ( model ) {\r\n\r\n\tif ( model.metadata.coordinateSystem === 'right' ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tmodel.metadata.coordinateSystem = 'right';\r\n\r\n\tvar helper = new DataCreationHelper();\r\n\r\n\tfor ( var i = 0; i < model.metadata.vertexCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.vertices[ i ].position );\r\n\t\thelper.leftToRightVector3( model.vertices[ i ].normal );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.faceCount; i++ ) {\r\n\r\n\t\thelper.leftToRightIndexOrder( model.faces[ i ].indices );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.boneCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.bones[ i ].position );\r\n\r\n\t}\r\n\r\n\t// TODO: support other morph for PMX\r\n\tfor ( var i = 0; i < model.metadata.morphCount; i++ ) {\r\n\r\n\t\tvar m = model.morphs[ i ];\r\n\r\n\t\tif ( model.metadata.format === 'pmx' && m.type !== 1 ) {\r\n\r\n\t\t\t// TODO: implement\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var j = 0; j < m.elements.length; j++ ) {\r\n\r\n\t\t\thelper.leftToRightVector3( m.elements[ j ].position );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.rigidBodyCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.rigidBodies[ i ].position );\r\n\t\thelper.leftToRightEuler( model.rigidBodies[ i ].rotation );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < model.metadata.constraintCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( model.constraints[ i ].position );\r\n\t\thelper.leftToRightEuler( model.constraints[ i ].rotation );\r\n\t\thelper.leftToRightVector3Range( model.constraints[ i ].translationLimitation1, model.constraints[ i ].translationLimitation2 );\r\n\t\thelper.leftToRightEulerRange( model.constraints[ i ].rotationLimitation1, model.constraints[ i ].rotationLimitation2 );\r\n\r\n\t}\r\n\r\n};\r\n\r\nParser.prototype.leftToRightVmd = function ( vmd ) {\r\n\r\n\tif ( vmd.metadata.coordinateSystem === 'right' ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvmd.metadata.coordinateSystem = 'right';\r\n\r\n\tvar helper = new DataCreationHelper();\r\n\r\n\tfor ( var i = 0; i < vmd.metadata.motionCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( vmd.motions[ i ].position );\r\n\t\thelper.leftToRightQuaternion( vmd.motions[ i ].rotation );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < vmd.metadata.cameraCount; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( vmd.cameras[ i ].position );\r\n\t\thelper.leftToRightEuler( vmd.cameras[ i ].rotation );\r\n\r\n\t}\r\n\r\n};\r\n\r\nParser.prototype.leftToRightVpd = function ( vpd ) {\r\n\r\n\tif ( vpd.metadata.coordinateSystem === 'right' ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tvpd.metadata.coordinateSystem = 'right';\r\n\r\n\tvar helper = new DataCreationHelper();\r\n\r\n\tfor ( var i = 0; i < vpd.bones.length; i++ ) {\r\n\r\n\t\thelper.leftToRightVector3( vpd.bones[ i ].translation );\r\n\t\thelper.leftToRightQuaternion( vpd.bones[ i ].quaternion );\r\n\r\n\t}\r\n\r\n};\n\nexports.CharsetEncoder = CharsetEncoder;\nexports.Parser = Parser;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nvar GLTFLoader = function () {\n\n\tfunction GLTFLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\tthis.dracoLoader = null;\n\t}\n\n\tGLTFLoader.prototype = {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);\n\n\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\n\t\t\tloader.setResponseType('arraybuffer');\n\n\t\t\tloader.load(url, function (data) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse(data, path, onLoad, onError);\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tif (onError !== undefined) {\n\n\t\t\t\t\t\tonError(e);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\t\t},\n\n\t\tsetPath: function setPath(value) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\t\t},\n\n\t\tsetDRACOLoader: function setDRACOLoader(dracoLoader) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\t\t},\n\n\t\tparse: function parse(data, path, onLoad, onError) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\n\t\t\tif (typeof data === 'string') {\n\n\t\t\t\tcontent = data;\n\t\t\t} else {\n\n\t\t\t\tvar magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n\n\t\t\t\tif (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n\t\t\t\t\t} catch (error) {\n\n\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar json = JSON.parse(content);\n\n\t\t\tif (json.asset === undefined || json.asset.version[0] < 2) {\n\n\t\t\t\tif (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (json.extensionsUsed) {\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_LIGHTS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_LIGHTS] = new GLTFLightsExtension(json);\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_UNLIT) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_MATERIALS_UNLIT] = new GLTFMaterialsUnlitExtension(json);\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.KHR_DRACO_MESH_COMPRESSION) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION] = new GLTFDracoMeshCompressionExtension(this.dracoLoader);\n\t\t\t\t}\n\n\t\t\t\tif (json.extensionsUsed.indexOf(EXTENSIONS.MSFT_TEXTURE_DDS) >= 0) {\n\n\t\t\t\t\textensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parser = new GLTFParser(json, extensions, {\n\n\t\t\t\tpath: path || this.path || '',\n\t\t\t\tcrossOrigin: this.crossOrigin,\n\t\t\t\tmanager: this.manager\n\n\t\t\t});\n\n\t\t\tparser.parse(function (scene, scenes, cameras, animations, asset) {\n\n\t\t\t\tvar glTF = {\n\t\t\t\t\tscene: scene,\n\t\t\t\t\tscenes: scenes,\n\t\t\t\t\tcameras: cameras,\n\t\t\t\t\tanimations: animations,\n\t\t\t\t\tasset: asset\n\t\t\t\t};\n\n\t\t\t\tonLoad(glTF);\n\t\t\t}, onError);\n\t\t}\n\n\t};\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn {\n\n\t\t\tget: function get(key) {\n\n\t\t\t\treturn objects[key];\n\t\t\t},\n\n\t\t\tadd: function add(key, object) {\n\n\t\t\t\tobjects[key] = object;\n\t\t\t},\n\n\t\t\tremove: function remove(key) {\n\n\t\t\t\tdelete objects[key];\n\t\t\t},\n\n\t\t\tremoveAll: function removeAll() {\n\n\t\t\t\tobjects = {};\n\t\t\t}\n\n\t\t};\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS: 'KHR_lights',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n\t};\n\n\t/**\n  * DDS Texture Extension\n  *\n  * Specification:\n  * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n  *\n  */\n\tfunction GLTFTextureDDSExtension() {\n\n\t\tif (!THREE.DDSLoader) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');\n\t\t}\n\n\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n\t\tthis.ddsLoader = new THREE.DDSLoader();\n\t}\n\n\t/**\n  * Lights Extension\n  *\n  * Specification: PENDING\n  */\n\tfunction GLTFLightsExtension(json) {\n\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS;\n\n\t\tthis.lights = {};\n\n\t\tvar extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS] || {};\n\t\tvar lights = extension.lights || {};\n\n\t\tfor (var lightId in lights) {\n\n\t\t\tvar light = lights[lightId];\n\t\t\tvar lightNode;\n\n\t\t\tvar color = new THREE.Color().fromArray(light.color);\n\n\t\t\tswitch (light.type) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlightNode = new THREE.DirectionalLight(color);\n\t\t\t\t\tlightNode.target.position.set(0, 0, 1);\n\t\t\t\t\tlightNode.add(lightNode.target);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlightNode = new THREE.PointLight(color);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlightNode = new THREE.SpotLight(color);\n\t\t\t\t\t// Handle spotlight properties.\n\t\t\t\t\tlight.spot = light.spot || {};\n\t\t\t\t\tlight.spot.innerConeAngle = light.spot.innerConeAngle !== undefined ? light.spot.innerConeAngle : 0;\n\t\t\t\t\tlight.spot.outerConeAngle = light.spot.outerConeAngle !== undefined ? light.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\t\tlightNode.angle = light.spot.outerConeAngle;\n\t\t\t\t\tlightNode.penumbra = 1.0 - light.spot.innerConeAngle / light.spot.outerConeAngle;\n\t\t\t\t\tlightNode.target.position.set(0, 0, 1);\n\t\t\t\t\tlightNode.add(lightNode.target);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlightNode = new THREE.AmbientLight(color);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (lightNode) {\n\n\t\t\t\tlightNode.decay = 2;\n\n\t\t\t\tif (light.intensity !== undefined) {\n\n\t\t\t\t\tlightNode.intensity = light.intensity;\n\t\t\t\t}\n\n\t\t\t\tlightNode.name = light.name || 'light_' + lightId;\n\t\t\t\tthis.lights[lightId] = lightNode;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n  * Unlit Materials Extension (pending)\n  *\n  * PR: https://github.com/KhronosGroup/glTF/pull/1163\n  */\n\tfunction GLTFMaterialsUnlitExtension(json) {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function (material) {\n\n\t\treturn THREE.MeshBasicMaterial;\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, material, parser) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = material.pbrMetallicRoughness;\n\n\t\tif (metallicRoughness) {\n\n\t\t\tif (Array.isArray(metallicRoughness.baseColorFactor)) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray(array);\n\t\t\t\tmaterialParams.opacity = array[3];\n\t\t\t}\n\n\t\t\tif (metallicRoughness.baseColorTexture !== undefined) {\n\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.all(pending);\n\t};\n\n\t/* BINARY EXTENSION */\n\n\tvar BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension(data) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n\n\t\tthis.header = {\n\t\t\tmagic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n\t\t\tversion: headerView.getUint32(4, true),\n\t\t\tlength: headerView.getUint32(8, true)\n\t\t};\n\n\t\tif (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');\n\t\t} else if (this.header.version < 2.0) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');\n\t\t}\n\n\t\tvar chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n\t\tvar chunkIndex = 0;\n\n\t\twhile (chunkIndex < chunkView.byteLength) {\n\n\t\t\tvar chunkLength = chunkView.getUint32(chunkIndex, true);\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32(chunkIndex, true);\n\t\t\tchunkIndex += 4;\n\n\t\t\tif (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n\n\t\t\t\tvar contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n\t\t\t\tthis.content = THREE.LoaderUtils.decodeText(contentArray);\n\t\t\t} else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice(byteOffset, byteOffset + chunkLength);\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\t\t}\n\n\t\tif (this.content === null) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: JSON content not found.');\n\t\t}\n\t}\n\n\t/**\n  * DRACO Mesh Compression Extension\n  *\n  * Specification: https://github.com/KhronosGroup/glTF/pull/874\n  */\n\tfunction GLTFDracoMeshCompressionExtension(dracoLoader) {\n\n\t\tif (!dracoLoader) {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.dracoLoader = dracoLoader;\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {\n\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[this.name].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[this.name].attributes;\n\t\tvar threeAttributeMap = {};\n\n\t\tfor (var attributeName in gltfAttributeMap) {\n\n\t\t\tif (!(attributeName in ATTRIBUTES)) continue;\n\n\t\t\tthreeAttributeMap[ATTRIBUTES[attributeName]] = gltfAttributeMap[attributeName];\n\t\t}\n\n\t\treturn parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {\n\n\t\t\treturn new Promise(function (resolve) {\n\n\t\t\t\tdracoLoader.decodeDracoFile(bufferView, resolve, threeAttributeMap);\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specular-Glossiness Extension\n  *\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n  */\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],\n\n\t\t\tgetMaterialType: function getMaterialType() {\n\n\t\t\t\treturn THREE.ShaderMaterial;\n\t\t\t},\n\n\t\t\textendParams: function extendParams(params, material, parser) {\n\n\t\t\t\tvar pbrSpecularGlossiness = material.extensions[this.name];\n\n\t\t\t\tvar shader = THREE.ShaderLib['standard'];\n\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t\t\tvar specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '\tuniform sampler2D specularMap;', '#endif'].join('\\n');\n\n\t\t\t\tvar glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '\tuniform sampler2D glossinessMap;', '#endif'].join('\\n');\n\n\t\t\t\tvar specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '\tvec4 texelSpecular = texture2D( specularMap, vUv );', '\ttexelSpecular = sRGBToLinear( texelSpecular );', '\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tspecularFactor *= texelSpecular.rgb;', '#endif'].join('\\n');\n\n\t\t\t\tvar glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );', '\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '\tglossinessFactor *= texelGlossiness.a;', '#endif'].join('\\n');\n\n\t\t\t\tvar lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\\n');\n\n\t\t\t\tvar fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);\n\n\t\t\t\tdelete uniforms.roughness;\n\t\t\t\tdelete uniforms.metalness;\n\t\t\t\tdelete uniforms.roughnessMap;\n\t\t\t\tdelete uniforms.metalnessMap;\n\n\t\t\t\tuniforms.specular = { value: new THREE.Color().setHex(0x111111) };\n\t\t\t\tuniforms.glossiness = { value: 0.5 };\n\t\t\t\tuniforms.specularMap = { value: null };\n\t\t\t\tuniforms.glossinessMap = { value: null };\n\n\t\t\t\tparams.vertexShader = shader.vertexShader;\n\t\t\t\tparams.fragmentShader = fragmentShader;\n\t\t\t\tparams.uniforms = uniforms;\n\t\t\t\tparams.defines = { 'STANDARD': '' };\n\n\t\t\t\tparams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\t\t\tparams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tparams.color.fromArray(array);\n\t\t\t\t\tparams.opacity = array[3];\n\t\t\t\t}\n\n\t\t\t\tif (pbrSpecularGlossiness.diffuseTexture !== undefined) {\n\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'map', pbrSpecularGlossiness.diffuseTexture.index));\n\t\t\t\t}\n\n\t\t\t\tparams.emissive = new THREE.Color(0.0, 0.0, 0.0);\n\t\t\t\tparams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tparams.specular = new THREE.Color(1.0, 1.0, 1.0);\n\n\t\t\t\tif (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n\n\t\t\t\t\tparams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n\t\t\t\t}\n\n\t\t\t\tif (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\n\n\t\t\t\t\tvar specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'glossinessMap', specGlossIndex));\n\t\t\t\t\tpending.push(parser.assignTexture(params, 'specularMap', specGlossIndex));\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all(pending);\n\t\t\t},\n\n\t\t\tcreateMaterial: function createMaterial(params) {\n\n\t\t\t\t// setup material properties based on MeshStandardMaterial for Specular-Glossiness\n\n\t\t\t\tvar material = new THREE.ShaderMaterial({\n\t\t\t\t\tdefines: params.defines,\n\t\t\t\t\tvertexShader: params.vertexShader,\n\t\t\t\t\tfragmentShader: params.fragmentShader,\n\t\t\t\t\tuniforms: params.uniforms,\n\t\t\t\t\tfog: true,\n\t\t\t\t\tlights: true,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\ttransparent: params.transparent\n\t\t\t\t});\n\n\t\t\t\tmaterial.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tmaterial.color = params.color;\n\n\t\t\t\tmaterial.map = params.map === undefined ? null : params.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = params.aoMap === undefined ? null : params.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = params.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = params.normalMap === undefined ? null : params.normalMap;\n\t\t\t\tif (params.normalScale) material.normalScale = params.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = params.specularMap === undefined ? null : params.specularMap;\n\t\t\t\tmaterial.specular = params.specular;\n\n\t\t\t\tmaterial.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n\t\t\t\tmaterial.glossiness = params.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = params.envMap === undefined ? null : params.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\tmaterial.extensions.derivatives = true;\n\n\t\t\t\treturn material;\n\t\t\t},\n\n\t\t\t/**\n    * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n    * copy only properties it knows about or inherits, and misses many properties that would\n    * normally be defined by MeshStandardMaterial.\n    *\n    * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n    * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n    * AND also updating `.onBeforeRender` on the parent mesh.\n    *\n    * @param  {THREE.ShaderMaterial} source\n    * @return {THREE.ShaderMaterial}\n    */\n\t\t\tcloneMaterial: function cloneMaterial(source) {\n\n\t\t\t\tvar target = source.clone();\n\n\t\t\t\ttarget.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tvar params = this.specularGlossinessParams;\n\n\t\t\t\tfor (var i = 0, il = params.length; i < il; i++) {\n\n\t\t\t\t\ttarget[params[i]] = source[params[i]];\n\t\t\t\t}\n\n\t\t\t\treturn target;\n\t\t\t},\n\n\t\t\t// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n\t\t\trefreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material, group) {\n\n\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial !== true) {\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar uniforms = material.uniforms;\n\t\t\t\tvar defines = material.defines;\n\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\t\tuniforms.diffuse.value.copy(material.color);\n\t\t\t\tuniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\n\t\t\t\tvar uvScaleMap;\n\n\t\t\t\tif (material.map) {\n\n\t\t\t\t\tuvScaleMap = material.map;\n\t\t\t\t} else if (material.specularMap) {\n\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\t\t\t\t} else if (material.displacementMap) {\n\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\t\t\t\t} else if (material.normalMap) {\n\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\t\t\t\t} else if (material.bumpMap) {\n\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\t\t\t\t} else if (material.glossinessMap) {\n\n\t\t\t\t\tuvScaleMap = material.glossinessMap;\n\t\t\t\t} else if (material.alphaMap) {\n\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\t\t\t\t} else if (material.emissiveMap) {\n\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\t\t\t\t}\n\n\t\t\t\tif (uvScaleMap !== undefined) {\n\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif (uvScaleMap.isWebGLRenderTarget) {\n\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar offset;\n\t\t\t\t\tvar repeat;\n\n\t\t\t\t\tif (uvScaleMap.matrix !== undefined) {\n\n\t\t\t\t\t\t// > r88.\n\n\t\t\t\t\t\tif (uvScaleMap.matrixAutoUpdate === true) {\n\n\t\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\t\t\t\t\t\t\tvar rotation = uvScaleMap.rotation;\n\t\t\t\t\t\t\tvar center = uvScaleMap.center;\n\n\t\t\t\t\t\t\tuvScaleMap.matrix.setUvTransform(offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuniforms.uvTransform.value.copy(uvScaleMap.matrix);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// <= r87. Remove when reasonable.\n\n\t\t\t\t\t\toffset = uvScaleMap.offset;\n\t\t\t\t\t\trepeat = uvScaleMap.repeat;\n\n\t\t\t\t\t\tuniforms.offsetRepeat.value.set(offset.x, offset.y, repeat.x, repeat.y);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t\tuniforms.flipEnvMap.value = material.envMap && material.envMap.isCubeTexture ? -1 : 1;\n\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tuniforms.specular.value.copy(material.specular);\n\t\t\t\tuniforms.glossiness.value = material.glossiness;\n\n\t\t\t\tuniforms.glossinessMap.value = material.glossinessMap;\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\tif (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {\n\n\t\t\t\t\tdefines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\tdefines.USE_ROUGHNESSMAP = '';\n\t\t\t\t}\n\n\t\t\t\tif (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {\n\n\t\t\t\t\tdelete defines.USE_GLOSSINESSMAP;\n\t\t\t\t\tdelete defines.USE_ROUGHNESSMAP;\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n\n\t\tTHREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n\t};\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = (t - t0) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s0 = 2 * ppp - 3 * pp + 1;\n\t\tvar s1 = ppp - 2 * pp + p;\n\t\tvar s2 = -2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor (var i = 0; i !== stride; i++) {\n\n\t\t\tvar p0 = values[offset0 + i + stride]; // splineVertex_k\n\t\t\tvar m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[offset1 + i + stride]; // splineVertex_k+1\n\t\t\tvar m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_TYPE = {\n\t\t5126: Number,\n\t\t//35674: THREE.Matrix2,\n\t\t35675: THREE.Matrix3,\n\t\t35676: THREE.Matrix4,\n\t\t35664: THREE.Vector2,\n\t\t35665: THREE.Vector3,\n\t\t35666: THREE.Vector4,\n\t\t35678: THREE.Texture\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: THREE.NearestFilter,\n\t\t9729: THREE.LinearFilter,\n\t\t9984: THREE.NearestMipMapNearestFilter,\n\t\t9985: THREE.LinearMipMapNearestFilter,\n\t\t9986: THREE.NearestMipMapLinearFilter,\n\t\t9987: THREE.LinearMipMapLinearFilter\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t10497: THREE.RepeatWrapping\n\t};\n\n\tvar WEBGL_TEXTURE_FORMATS = {\n\t\t6406: THREE.AlphaFormat,\n\t\t6407: THREE.RGBFormat,\n\t\t6408: THREE.RGBAFormat,\n\t\t6409: THREE.LuminanceFormat,\n\t\t6410: THREE.LuminanceAlphaFormat\n\t};\n\n\tvar WEBGL_TEXTURE_DATATYPES = {\n\t\t5121: THREE.UnsignedByteType,\n\t\t32819: THREE.UnsignedShort4444Type,\n\t\t32820: THREE.UnsignedShort5551Type,\n\t\t33635: THREE.UnsignedShort565Type\n\t};\n\n\tvar WEBGL_SIDES = {\n\t\t1028: THREE.BackSide, // Culling front\n\t\t1029: THREE.FrontSide // Culling back\n\t\t//1032: THREE.NoSide   // Culling front and back, what to do?\n\t};\n\n\tvar WEBGL_DEPTH_FUNCS = {\n\t\t512: THREE.NeverDepth,\n\t\t513: THREE.LessDepth,\n\t\t514: THREE.EqualDepth,\n\t\t515: THREE.LessEqualDepth,\n\t\t516: THREE.GreaterEqualDepth,\n\t\t517: THREE.NotEqualDepth,\n\t\t518: THREE.GreaterEqualDepth,\n\t\t519: THREE.AlwaysDepth\n\t};\n\n\tvar WEBGL_BLEND_EQUATIONS = {\n\t\t32774: THREE.AddEquation,\n\t\t32778: THREE.SubtractEquation,\n\t\t32779: THREE.ReverseSubtractEquation\n\t};\n\n\tvar WEBGL_BLEND_FUNCS = {\n\t\t0: THREE.ZeroFactor,\n\t\t1: THREE.OneFactor,\n\t\t768: THREE.SrcColorFactor,\n\t\t769: THREE.OneMinusSrcColorFactor,\n\t\t770: THREE.SrcAlphaFactor,\n\t\t771: THREE.OneMinusSrcAlphaFactor,\n\t\t772: THREE.DstAlphaFactor,\n\t\t773: THREE.OneMinusDstAlphaFactor,\n\t\t774: THREE.DstColorFactor,\n\t\t775: THREE.OneMinusDstColorFactor,\n\t\t776: THREE.SrcAlphaSaturateFactor\n\t\t// The followings are not supported by Three.js yet\n\t\t//32769: CONSTANT_COLOR,\n\t\t//32770: ONE_MINUS_CONSTANT_COLOR,\n\t\t//32771: CONSTANT_ALPHA,\n\t\t//32772: ONE_MINUS_CONSTANT_COLOR\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD0: 'uv', // deprecated\n\t\tTEXCOORD: 'uv', // deprecated\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tCOLOR0: 'color', // deprecated\n\t\tCOLOR: 'color', // deprecated\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tWEIGHT: 'skinWeight', // deprecated\n\t\tJOINTS_0: 'skinIndex',\n\t\tJOINT: 'skinIndex' // deprecated\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.\n\t\t// KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,\n\t\t// using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.\n\t\t// See KeyframeTrack.optimize() for the detail.\n\t\tLINEAR: THREE.InterpolateLinear,\n\t\tSTEP: THREE.InterpolateDiscrete\n\t};\n\n\tvar STATES_ENABLES = {\n\t\t2884: 'CULL_FACE',\n\t\t2929: 'DEPTH_TEST',\n\t\t3042: 'BLEND',\n\t\t3089: 'SCISSOR_TEST',\n\t\t32823: 'POLYGON_OFFSET_FILL',\n\t\t32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL(url, path) {\n\n\t\t// Invalid URL\n\t\tif (typeof url !== 'string' || url === '') return '';\n\n\t\t// Absolute URL http://,https://,//\n\t\tif (/^(https?:)?\\/\\//i.test(url)) return url;\n\n\t\t// Data URI\n\t\tif (/^data:.*,.*$/i.test(url)) return url;\n\n\t\t// Blob URL\n\t\tif (/^blob:.*$/i.test(url)) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n  */\n\tfunction createDefaultMaterial() {\n\n\t\treturn new THREE.MeshStandardMaterial({\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: THREE.FrontSide\n\t\t});\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n  *\n  * @param {THREE.Mesh} mesh\n  * @param {GLTF.Mesh} meshDef\n  * @param {GLTF.Primitive} primitiveDef\n  * @param {Array<THREE.BufferAttribute>} accessors\n  */\n\tfunction addMorphTargets(mesh, meshDef, primitiveDef, accessors) {\n\n\t\tvar geometry = mesh.geometry;\n\t\tvar targets = primitiveDef.targets;\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tfor (var i = 0, il = targets.length; i < il; i++) {\n\n\t\t\tvar target = targets[i];\n\n\t\t\tif (target.POSITION !== undefined) hasMorphPosition = true;\n\t\t\tif (target.NORMAL !== undefined) hasMorphNormal = true;\n\n\t\t\tif (hasMorphPosition && hasMorphNormal) break;\n\t\t}\n\n\t\tif (!hasMorphPosition && !hasMorphNormal) return;\n\n\t\tvar morphPositions = [];\n\t\tvar morphNormals = [];\n\n\t\tfor (var i = 0, il = targets.length; i < il; i++) {\n\n\t\t\tvar target = targets[i];\n\t\t\tvar attributeName = 'morphTarget' + i;\n\n\t\t\tif (hasMorphPosition) {\n\n\t\t\t\t// Three.js morph position is absolute value. The formula is\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * ( morphPosition0 - basePosition )\n\t\t\t\t//     + weight1 * ( morphPosition1 - basePosition )\n\t\t\t\t//     ...\n\t\t\t\t// while the glTF one is relative\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * glTFmorphPosition0\n\t\t\t\t//     + weight1 * glTFmorphPosition1\n\t\t\t\t//     ...\n\t\t\t\t// then we need to convert from relative to absolute here.\n\n\t\t\t\tif (target.POSITION !== undefined) {\n\n\t\t\t\t\t// Cloning not to pollute original accessor\n\t\t\t\t\tvar positionAttribute = cloneBufferAttribute(accessors[target.POSITION]);\n\t\t\t\t\tpositionAttribute.name = attributeName;\n\n\t\t\t\t\tvar position = geometry.attributes.position;\n\n\t\t\t\t\tfor (var j = 0, jl = positionAttribute.count; j < jl; j++) {\n\n\t\t\t\t\t\tpositionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tpositionAttribute = geometry.attributes.position;\n\t\t\t\t}\n\n\t\t\t\tmorphPositions.push(positionAttribute);\n\t\t\t}\n\n\t\t\tif (hasMorphNormal) {\n\n\t\t\t\t// see target.POSITION's comment\n\n\t\t\t\tvar normalAttribute;\n\n\t\t\t\tif (target.NORMAL !== undefined) {\n\n\t\t\t\t\tvar normalAttribute = cloneBufferAttribute(accessors[target.NORMAL]);\n\t\t\t\t\tnormalAttribute.name = attributeName;\n\n\t\t\t\t\tvar normal = geometry.attributes.normal;\n\n\t\t\t\t\tfor (var j = 0, jl = normalAttribute.count; j < jl; j++) {\n\n\t\t\t\t\t\tnormalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = geometry.attributes.normal;\n\t\t\t\t}\n\n\t\t\t\tmorphNormals.push(normalAttribute);\n\t\t\t}\n\t\t}\n\n\t\tif (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\n\t\tif (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif (meshDef.weights !== undefined) {\n\n\t\t\tfor (var i = 0, il = meshDef.weights.length; i < il; i++) {\n\n\t\t\t\tmesh.morphTargetInfluences[i] = meshDef.weights[i];\n\t\t\t}\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif (mesh.morphTargetInfluences.length === targetNames.length) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor (var i = 0, il = targetNames.length; i < il; i++) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[targetNames[i]] = i;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction isPrimitiveEqual(a, b) {\n\n\t\tif (a.indices !== b.indices) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tvar attribA = a.attributes || {};\n\t\tvar attribB = b.attributes || {};\n\t\tvar keysA = Object.keys(attribA);\n\t\tvar keysB = Object.keys(attribB);\n\n\t\tif (keysA.length !== keysB.length) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (var i = 0, il = keysA.length; i < il; i++) {\n\n\t\t\tvar key = keysA[i];\n\n\t\t\tif (attribA[key] !== attribB[key]) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction getCachedGeometry(cache, newPrimitive) {\n\n\t\tfor (var i = 0, il = cache.length; i < il; i++) {\n\n\t\t\tvar cached = cache[i];\n\n\t\t\tif (isPrimitiveEqual(cached.primitive, newPrimitive)) {\n\n\t\t\t\treturn cached.promise;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction cloneBufferAttribute(attribute) {\n\n\t\tif (attribute.isInterleavedBufferAttribute) {\n\n\t\t\tvar count = attribute.count;\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar array = attribute.array.slice(0, count * itemSize);\n\n\t\t\tfor (var i = 0; i < count; ++i) {\n\n\t\t\t\tarray[i] = attribute.getX(i);\n\t\t\t\tif (itemSize >= 2) array[i + 1] = attribute.getY(i);\n\t\t\t\tif (itemSize >= 3) array[i + 2] = attribute.getZ(i);\n\t\t\t\tif (itemSize >= 4) array[i + 3] = attribute.getW(i);\n\t\t\t}\n\n\t\t\treturn new THREE.BufferAttribute(array, itemSize, attribute.normalized);\n\t\t}\n\n\t\treturn attribute.clone();\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser(json, extensions, options) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = extensions || {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = [];\n\n\t\tthis.textureLoader = new THREE.TextureLoader(this.options.manager);\n\t\tthis.textureLoader.setCrossOrigin(this.options.crossOrigin);\n\n\t\tthis.fileLoader = new THREE.FileLoader(this.options.manager);\n\t\tthis.fileLoader.setResponseType('arraybuffer');\n\t}\n\n\tGLTFParser.prototype.parse = function (onLoad, onError) {\n\n\t\tvar json = this.json;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis.markDefs();\n\n\t\t// Fire the callback on complete\n\t\tthis.getMultiDependencies(['scene', 'animation', 'camera']).then(function (dependencies) {\n\n\t\t\tvar scenes = dependencies.scenes || [];\n\t\t\tvar scene = scenes[json.scene || 0];\n\t\t\tvar animations = dependencies.animations || [];\n\t\t\tvar asset = json.asset;\n\t\t\tvar cameras = dependencies.cameras || [];\n\n\t\t\tonLoad(scene, scenes, cameras, animations, asset);\n\t\t}).catch(onError);\n\t};\n\n\t/**\n  * Marks the special nodes/meshes in json for efficient parse.\n  */\n\tGLTFParser.prototype.markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\tvar meshReferences = {};\n\t\tvar meshUses = {};\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n\n\t\t\tvar joints = skinDefs[skinIndex].joints;\n\n\t\t\tfor (var i = 0, il = joints.length; i < il; i++) {\n\n\t\t\t\tnodeDefs[joints[i]].isBone = true;\n\t\t\t}\n\t\t}\n\n\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t// references and rename instances below.\n\t\t//\n\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\tfor (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n\n\t\t\tvar nodeDef = nodeDefs[nodeIndex];\n\n\t\t\tif (nodeDef.mesh !== undefined) {\n\n\t\t\t\tif (meshReferences[nodeDef.mesh] === undefined) {\n\n\t\t\t\t\tmeshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;\n\t\t\t\t}\n\n\t\t\t\tmeshReferences[nodeDef.mesh]++;\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif (nodeDef.skin !== undefined) {\n\n\t\t\t\t\tmeshDefs[nodeDef.mesh].isSkinnedMesh = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.json.meshReferences = meshReferences;\n\t\tthis.json.meshUses = meshUses;\n\t};\n\n\t/**\n  * Requests the specified dependency asynchronously, with caching.\n  * @param {string} type\n  * @param {number} index\n  * @return {Promise<Object>}\n  */\n\tGLTFParser.prototype.getDependency = function (type, index) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get(cacheKey);\n\n\t\tif (!dependency) {\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this.loadMesh(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this.loadBufferView(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this.loadMaterial(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this.loadTexture(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera(index);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unknown type: ' + type);\n\n\t\t\t}\n\n\t\t\tthis.cache.add(cacheKey, dependency);\n\t\t}\n\n\t\treturn dependency;\n\t};\n\n\t/**\n  * Requests all dependencies of the specified type asynchronously, with caching.\n  * @param {string} type\n  * @return {Promise<Array<Object>>}\n  */\n\tGLTFParser.prototype.getDependencies = function (type) {\n\n\t\tvar dependencies = this.cache.get(type);\n\n\t\tif (!dependencies) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];\n\n\t\t\tdependencies = Promise.all(defs.map(function (def, index) {\n\n\t\t\t\treturn parser.getDependency(type, index);\n\t\t\t}));\n\n\t\t\tthis.cache.add(type, dependencies);\n\t\t}\n\n\t\treturn dependencies;\n\t};\n\n\t/**\n  * Requests all multiple dependencies of the specified types asynchronously, with caching.\n  * @param {Array<string>} types\n  * @return {Promise<Object<Array<Object>>>}\n  */\n\tGLTFParser.prototype.getMultiDependencies = function (types) {\n\n\t\tvar results = {};\n\t\tvar pendings = [];\n\n\t\tfor (var i = 0, il = types.length; i < il; i++) {\n\n\t\t\tvar type = types[i];\n\t\t\tvar value = this.getDependencies(type);\n\n\t\t\tvalue = value.then(function (key, value) {\n\n\t\t\t\tresults[key] = value;\n\t\t\t}.bind(this, type + (type === 'mesh' ? 'es' : 's')));\n\n\t\t\tpendings.push(value);\n\t\t}\n\n\t\treturn Promise.all(pendings).then(function () {\n\n\t\t\treturn results;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n  * @param {number} bufferIndex\n  * @return {Promise<ArrayBuffer>}\n  */\n\tGLTFParser.prototype.loadBuffer = function (bufferIndex) {\n\n\t\tvar bufferDef = this.json.buffers[bufferIndex];\n\t\tvar loader = this.fileLoader;\n\n\t\tif (bufferDef.type && bufferDef.type !== 'arraybuffer') {\n\n\t\t\tthrow new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif (bufferDef.uri === undefined && bufferIndex === 0) {\n\n\t\t\treturn Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise(function (resolve, reject) {\n\n\t\t\tloader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {\n\n\t\t\t\treject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n  * @param {number} bufferViewIndex\n  * @return {Promise<ArrayBuffer>}\n  */\n\tGLTFParser.prototype.loadBufferView = function (bufferViewIndex) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[bufferViewIndex];\n\n\t\treturn this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice(byteOffset, byteOffset + byteLength);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n  * @param {number} accessorIndex\n  * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n  */\n\tGLTFParser.prototype.loadAccessor = function (accessorIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[accessorIndex];\n\n\t\tif (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn null;\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif (accessorDef.bufferView !== undefined) {\n\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));\n\t\t} else {\n\n\t\t\tpendingBufferViews.push(null);\n\t\t}\n\n\t\tif (accessorDef.sparse !== undefined) {\n\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));\n\t\t\tpendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));\n\t\t}\n\n\t\treturn Promise.all(pendingBufferViews).then(function (bufferViews) {\n\n\t\t\tvar bufferView = bufferViews[0];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = json.bufferViews[accessorDef.bufferView].byteStride;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif (byteStride && byteStride !== itemBytes) {\n\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n\t\t\t\tvar ib = parser.cache.get(ibCacheKey);\n\n\t\t\t\tif (!ib) {\n\n\t\t\t\t\t// Use the full buffer if it's interleaved.\n\t\t\t\t\tarray = new TypedArray(bufferView);\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);\n\n\t\t\t\t\tparser.cache.add(ibCacheKey, ib);\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, byteOffset / elementBytes, normalized);\n\t\t\t} else {\n\n\t\t\t\tif (bufferView === null) {\n\n\t\t\t\t\tarray = new TypedArray(accessorDef.count * itemSize);\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif (accessorDef.sparse !== undefined) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n\t\t\t\tvar sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n\n\t\t\t\tif (bufferView !== null) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute.setArray(bufferAttribute.array.slice());\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, il = sparseIndices.length; i < il; i++) {\n\n\t\t\t\t\tvar index = sparseIndices[i];\n\n\t\t\t\t\tbufferAttribute.setX(index, sparseValues[i * itemSize]);\n\t\t\t\t\tif (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n\t\t\t\t\tif (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n\t\t\t\t\tif (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n\t\t\t\t\tif (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n  * @param {number} textureIndex\n  * @return {Promise<THREE.Texture>}\n  */\n\tGLTFParser.prototype.loadTexture = function (textureIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureLoader = this.textureLoader;\n\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tvar textureDef = json.textures[textureIndex];\n\n\t\tvar textureExtensions = textureDef.extensions || {};\n\n\t\tvar source;\n\n\t\tif (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n\n\t\t\tsource = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];\n\t\t} else {\n\n\t\t\tsource = json.images[textureDef.source];\n\t\t}\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\n\t\tif (source.bufferView !== undefined) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob([bufferView], { type: source.mimeType });\n\t\t\t\tsourceURI = URL.createObjectURL(blob);\n\t\t\t\treturn sourceURI;\n\t\t\t});\n\t\t}\n\n\t\treturn Promise.resolve(sourceURI).then(function (sourceURI) {\n\n\t\t\t// Load Texture resource.\n\n\t\t\tvar loader = THREE.Loader.Handlers.get(sourceURI);\n\n\t\t\tif (!loader) {\n\n\t\t\t\tloader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;\n\t\t\t}\n\n\t\t\treturn new Promise(function (resolve, reject) {\n\n\t\t\t\tloader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);\n\t\t\t});\n\t\t}).then(function (texture) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif (isObjectURL === true) {\n\n\t\t\t\tURL.revokeObjectURL(sourceURI);\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif (textureDef.name !== undefined) texture.name = textureDef.name;\n\n\t\t\t// .format of dds texture is set in DDSLoader\n\t\t\tif (!textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {\n\n\t\t\t\ttexture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[textureDef.format] : THREE.RGBAFormat;\n\t\t\t}\n\n\t\t\tif (textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[textureDef.internalFormat]) {\n\n\t\t\t\tconsole.warn('THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' + 'internalFormat will be forced to be the same value as format.');\n\t\t\t}\n\n\t\t\ttexture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[textureDef.type] : THREE.UnsignedByteType;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[textureDef.sampler] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipMapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;\n\n\t\t\treturn texture;\n\t\t});\n\t};\n\n\t/**\n  * Asynchronously assigns a texture to the given material parameters.\n  * @param {Object} materialParams\n  * @param {string} textureName\n  * @param {number} textureIndex\n  * @return {Promise}\n  */\n\tGLTFParser.prototype.assignTexture = function (materialParams, textureName, textureIndex) {\n\n\t\treturn this.getDependency('texture', textureIndex).then(function (texture) {\n\n\t\t\tmaterialParams[textureName] = texture;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n  * @param {number} materialIndex\n  * @return {Promise<THREE.Material>}\n  */\n\tGLTFParser.prototype.loadMaterial = function (materialIndex) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = this.json.materials[materialIndex];\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n\n\t\t\tvar sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n\t\t\tmaterialType = sgExtension.getMaterialType(materialDef);\n\t\t\tpending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n\t\t} else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n\n\t\t\tvar kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n\t\t\tmaterialType = kmuExtension.getMaterialType(materialDef);\n\t\t\tpending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new THREE.Color(1.0, 1.0, 1.0);\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif (Array.isArray(metallicRoughness.baseColorFactor)) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray(array);\n\t\t\t\tmaterialParams.opacity = array[3];\n\t\t\t}\n\n\t\t\tif (metallicRoughness.baseColorTexture !== undefined) {\n\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture.index));\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif (metallicRoughness.metallicRoughnessTexture !== undefined) {\n\n\t\t\t\tvar textureIndex = metallicRoughness.metallicRoughnessTexture.index;\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'metalnessMap', textureIndex));\n\t\t\t\tpending.push(parser.assignTexture(materialParams, 'roughnessMap', textureIndex));\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.doubleSided === true) {\n\n\t\t\tmaterialParams.side = THREE.DoubleSide;\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif (alphaMode === ALPHA_MODES.BLEND) {\n\n\t\t\tmaterialParams.transparent = true;\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif (alphaMode === ALPHA_MODES.MASK) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture.index));\n\n\t\t\tmaterialParams.normalScale = new THREE.Vector2(1, 1);\n\n\t\t\tif (materialDef.normalTexture.scale !== undefined) {\n\n\t\t\t\tmaterialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture.index));\n\n\t\t\tif (materialDef.occlusionTexture.strength !== undefined) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\t\t\t}\n\t\t}\n\n\t\tif (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tmaterialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);\n\t\t}\n\n\t\tif (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {\n\n\t\t\tpending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture.index));\n\t\t}\n\n\t\treturn Promise.all(pending).then(function () {\n\n\t\t\tvar material;\n\n\t\t\tif (materialType === THREE.ShaderMaterial) {\n\n\t\t\t\tmaterial = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType(materialParams);\n\t\t\t}\n\n\t\t\tif (materialDef.name !== undefined) material.name = materialDef.name;\n\n\t\t\t// Normal map textures use OpenGL conventions:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture\n\t\t\tif (material.normalScale) {\n\n\t\t\t\tmaterial.normalScale.y = -material.normalScale.y;\n\t\t\t}\n\n\t\t\t// emissiveTexture and baseColorTexture use sRGB encoding.\n\t\t\tif (material.map) material.map.encoding = THREE.sRGBEncoding;\n\t\t\tif (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\n\t\t\tif (materialDef.extras) material.userData = materialDef.extras;\n\n\t\t\treturn material;\n\t\t});\n\t};\n\n\t/**\n  * @param  {THREE.BufferGeometry} geometry\n  * @param  {GLTF.Primitive} primitiveDef\n  * @param  {Array<THREE.BufferAttribute>} accessors\n  */\n\tfunction addPrimitiveAttributes(geometry, primitiveDef, accessors) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tfor (var gltfAttributeName in attributes) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[gltfAttributeName];\n\t\t\tvar bufferAttribute = accessors[attributes[gltfAttributeName]];\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif (!threeAttributeName) continue;\n\t\t\tif (threeAttributeName in geometry.attributes) continue;\n\n\t\t\tgeometry.addAttribute(threeAttributeName, bufferAttribute);\n\t\t}\n\n\t\tif (primitiveDef.indices !== undefined && !geometry.index) {\n\n\t\t\tgeometry.setIndex(accessors[primitiveDef.indices]);\n\t\t}\n\t}\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n  * @param {Array<Object>} primitives\n  * @return {Promise<Array<THREE.BufferGeometry>>}\n  */\n\tGLTFParser.prototype.loadGeometries = function (primitives) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\t\treturn this.getDependencies('accessor').then(function (accessors) {\n\n\t\t\tvar pending = [];\n\n\t\t\tfor (var i = 0, il = primitives.length; i < il; i++) {\n\n\t\t\t\tvar primitive = primitives[i];\n\n\t\t\t\t// See if we've already created this geometry\n\t\t\t\tvar cached = getCachedGeometry(cache, primitive);\n\n\t\t\t\tif (cached) {\n\n\t\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\t\tpending.push(cached);\n\t\t\t\t} else if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tvar geometryPromise = extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {\n\n\t\t\t\t\t\taddPrimitiveAttributes(geometry, primitive, accessors);\n\n\t\t\t\t\t\treturn geometry;\n\t\t\t\t\t});\n\n\t\t\t\t\tcache.push({ primitive: primitive, promise: geometryPromise });\n\n\t\t\t\t\tpending.push(geometryPromise);\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\taddPrimitiveAttributes(geometry, primitive, accessors);\n\n\t\t\t\t\tvar geometryPromise = Promise.resolve(geometry);\n\n\t\t\t\t\t// Cache this geometry\n\t\t\t\t\tcache.push({\n\n\t\t\t\t\t\tprimitive: primitive,\n\t\t\t\t\t\tpromise: geometryPromise\n\n\t\t\t\t\t});\n\n\t\t\t\t\tpending.push(geometryPromise);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Promise.all(pending);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n  * @param {number} meshIndex\n  * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n  */\n\tGLTFParser.prototype.loadMesh = function (meshIndex) {\n\n\t\tvar scope = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = this.json.meshes[meshIndex];\n\n\t\treturn this.getMultiDependencies(['accessor', 'material']).then(function (dependencies) {\n\n\t\t\tvar group = new THREE.Group();\n\n\t\t\tvar primitives = meshDef.primitives;\n\n\t\t\treturn scope.loadGeometries(primitives).then(function (geometries) {\n\n\t\t\t\tfor (var i = 0, il = primitives.length; i < il; i++) {\n\n\t\t\t\t\tvar primitive = primitives[i];\n\t\t\t\t\tvar geometry = geometries[i];\n\n\t\t\t\t\tvar material = primitive.material === undefined ? createDefaultMaterial() : dependencies.materials[primitive.material];\n\n\t\t\t\t\tif (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {\n\n\t\t\t\t\t\tconsole.log('THREE.GLTFLoader: Duplicating UVs to support aoMap.');\n\t\t\t\t\t\tgeometry.addAttribute('uv2', new THREE.BufferAttribute(geometry.attributes.uv.array, 2));\n\t\t\t\t\t}\n\n\t\t\t\t\t// If the material will be modified later on, clone it now.\n\t\t\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\t\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\t\t\t\tvar useSkinning = meshDef.isSkinnedMesh === true;\n\t\t\t\t\tvar useMorphTargets = primitive.targets !== undefined;\n\n\t\t\t\t\tif (useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n\n\t\t\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial) {\n\n\t\t\t\t\t\t\tvar specGlossExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n\t\t\t\t\t\t\tmaterial = specGlossExtension.cloneMaterial(material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = material.clone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useVertexColors) {\n\n\t\t\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\tmaterial.needsUpdate = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useFlatShading) {\n\n\t\t\t\t\t\tmaterial.flatShading = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {\n\n\t\t\t\t\t\tif (useSkinning) {\n\n\t\t\t\t\t\t\tmesh = new THREE.SkinnedMesh(geometry, material);\n\t\t\t\t\t\t\tmaterial.skinning = true;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleStripDrawMode;\n\t\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleFanDrawMode;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINES || primitive.mode === WEBGL_CONSTANTS.LINE_STRIP || primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n\n\t\t\t\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar lineMaterial = scope.cache.get(cacheKey);\n\n\t\t\t\t\t\tif (!lineMaterial) {\n\n\t\t\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(lineMaterial, material);\n\t\t\t\t\t\t\tlineMaterial.color.copy(material.color);\n\t\t\t\t\t\t\tlineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add(cacheKey, lineMaterial);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = lineMaterial;\n\n\t\t\t\t\t\tif (primitive.mode === WEBGL_CONSTANTS.LINES) {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineSegments(geometry, material);\n\t\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n\n\t\t\t\t\t\t\tmesh = new THREE.Line(geometry, material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmesh = new THREE.LineLoop(geometry, material);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n\n\t\t\t\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\t\t\t\tvar pointsMaterial = scope.cache.get(cacheKey);\n\n\t\t\t\t\t\tif (!pointsMaterial) {\n\n\t\t\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(pointsMaterial, material);\n\t\t\t\t\t\t\tpointsMaterial.color.copy(material.color);\n\t\t\t\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\t\t\t\tpointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\tscope.cache.add(cacheKey, pointsMaterial);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial = pointsMaterial;\n\n\t\t\t\t\t\tmesh = new THREE.Points(geometry, material);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || 'mesh_' + meshIndex;\n\n\t\t\t\t\tif (useMorphTargets) {\n\n\t\t\t\t\t\taddMorphTargets(mesh, meshDef, primitive, dependencies.accessors);\n\n\t\t\t\t\t\tmaterial.morphTargets = true;\n\n\t\t\t\t\t\tif (mesh.geometry.morphAttributes.normal !== undefined) material.morphNormals = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meshDef.extras !== undefined) mesh.userData = meshDef.extras;\n\t\t\t\t\tif (primitive.extras !== undefined) mesh.geometry.userData = primitive.extras;\n\n\t\t\t\t\t// for Specular-Glossiness.\n\t\t\t\t\tif (material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\tmesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (primitives.length > 1) {\n\n\t\t\t\t\t\tmesh.name += '_' + i;\n\n\t\t\t\t\t\tgroup.add(mesh);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\treturn mesh;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n  * @param {number} cameraIndex\n  * @return {Promise<THREE.Camera>}\n  */\n\tGLTFParser.prototype.loadCamera = function (cameraIndex) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[cameraIndex];\n\t\tvar params = cameraDef[cameraDef.type];\n\n\t\tif (!params) {\n\n\t\t\tconsole.warn('THREE.GLTFLoader: Missing camera parameters.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (cameraDef.type === 'perspective') {\n\n\t\t\tcamera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n\t\t} else if (cameraDef.type === 'orthographic') {\n\n\t\t\tcamera = new THREE.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);\n\t\t}\n\n\t\tif (cameraDef.name !== undefined) camera.name = cameraDef.name;\n\t\tif (cameraDef.extras) camera.userData = cameraDef.extras;\n\n\t\treturn Promise.resolve(camera);\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n  * @param {number} skinIndex\n  * @return {Promise<Object>}\n  */\n\tGLTFParser.prototype.loadSkin = function (skinIndex) {\n\n\t\tvar skinDef = this.json.skins[skinIndex];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif (skinDef.inverseBindMatrices === undefined) {\n\n\t\t\treturn Promise.resolve(skinEntry);\n\t\t}\n\n\t\treturn this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n  * @param {number} animationIndex\n  * @return {Promise<THREE.AnimationClip>}\n  */\n\tGLTFParser.prototype.loadAnimation = function (animationIndex) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = this.json.animations[animationIndex];\n\n\t\treturn this.getMultiDependencies(['accessor', 'node']).then(function (dependencies) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor (var i = 0, il = animationDef.channels.length; i < il; i++) {\n\n\t\t\t\tvar channel = animationDef.channels[i];\n\t\t\t\tvar sampler = animationDef.samplers[channel.sampler];\n\n\t\t\t\tif (sampler) {\n\n\t\t\t\t\tvar target = channel.target;\n\t\t\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;\n\t\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;\n\n\t\t\t\t\tvar inputAccessor = dependencies.accessors[input];\n\t\t\t\t\tvar outputAccessor = dependencies.accessors[output];\n\n\t\t\t\t\tvar node = dependencies.nodes[name];\n\n\t\t\t\t\tif (node) {\n\n\t\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\t\t\tswitch (PATH_PROPERTIES[target.path]) {\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;\n\n\t\t\t\t\t\tvar targetNames = [];\n\n\t\t\t\t\t\tif (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n\n\t\t\t\t\t\t\t// node should be THREE.Group here but\n\t\t\t\t\t\t\t// PATH_PROPERTIES.weights(morphTargetInfluences) should be\n\t\t\t\t\t\t\t// the property of a mesh object under node.\n\t\t\t\t\t\t\t// So finding targets here.\n\n\t\t\t\t\t\t\tnode.traverse(function (object) {\n\n\t\t\t\t\t\t\t\tif (object.isMesh === true && object.material.morphTargets === true) {\n\n\t\t\t\t\t\t\t\t\ttargetNames.push(object.name ? object.name : object.uuid);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttargetNames.push(targetName);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// KeyframeTrack.optimize() will modify given 'times' and 'values'\n\t\t\t\t\t\t// buffers before creating a truncated copy to keep. Because buffers may\n\t\t\t\t\t\t// be reused by other tracks, make copies here.\n\t\t\t\t\t\tfor (var j = 0, jl = targetNames.length; j < jl; j++) {\n\n\t\t\t\t\t\t\tvar track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], THREE.AnimationUtils.arraySlice(inputAccessor.array, 0), THREE.AnimationUtils.arraySlice(outputAccessor.array, 0), interpolation);\n\n\t\t\t\t\t\t\t// Here is the trick to enable custom interpolation.\n\t\t\t\t\t\t\t// Overrides .createInterpolant in a factory method which creates custom interpolation.\n\t\t\t\t\t\t\tif (sampler.interpolation === 'CUBICSPLINE') {\n\n\t\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n\n\t\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.\n\t\t\t\t\t\t\t\t// track.getInterpolation() doesn't return valid value for custom interpolant.\n\t\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttracks.push(track);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new THREE.AnimationClip(name, undefined, tracks);\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n  * @param {number} nodeIndex\n  * @return {Promise<THREE.Object3D>}\n  */\n\tGLTFParser.prototype.loadNode = function (nodeIndex) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshReferences = this.json.meshReferences;\n\t\tvar meshUses = this.json.meshUses;\n\n\t\tvar nodeDef = this.json.nodes[nodeIndex];\n\n\t\treturn this.getMultiDependencies(['mesh', 'skin', 'camera', 'light']).then(function (dependencies) {\n\n\t\t\tvar node;\n\n\t\t\tif (nodeDef.isBone === true) {\n\n\t\t\t\tnode = new THREE.Bone();\n\t\t\t} else if (nodeDef.mesh !== undefined) {\n\n\t\t\t\tvar mesh = dependencies.meshes[nodeDef.mesh];\n\n\t\t\t\tnode = mesh.clone();\n\n\t\t\t\t// for Specular-Glossiness\n\t\t\t\tif (mesh.isGroup === true) {\n\n\t\t\t\t\tfor (var i = 0, il = mesh.children.length; i < il; i++) {\n\n\t\t\t\t\t\tvar child = mesh.children[i];\n\n\t\t\t\t\t\tif (child.material && child.material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\t\tnode.children[i].onBeforeRender = child.onBeforeRender;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (mesh.material && mesh.material.isGLTFSpecularGlossinessMaterial === true) {\n\n\t\t\t\t\t\tnode.onBeforeRender = mesh.onBeforeRender;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (meshReferences[nodeDef.mesh] > 1) {\n\n\t\t\t\t\tnode.name += '_instance_' + meshUses[nodeDef.mesh]++;\n\t\t\t\t}\n\t\t\t} else if (nodeDef.camera !== undefined) {\n\n\t\t\t\tnode = dependencies.cameras[nodeDef.camera];\n\t\t\t} else if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n\n\t\t\t\tvar lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n\t\t\t\tnode = lights[nodeDef.extensions[EXTENSIONS.KHR_LIGHTS].light];\n\t\t\t} else {\n\n\t\t\t\tnode = new THREE.Object3D();\n\t\t\t}\n\n\t\t\tif (nodeDef.name !== undefined) {\n\n\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName(nodeDef.name);\n\t\t\t}\n\n\t\t\tif (nodeDef.extras) node.userData = nodeDef.extras;\n\n\t\t\tif (nodeDef.matrix !== undefined) {\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.fromArray(nodeDef.matrix);\n\t\t\t\tnode.applyMatrix(matrix);\n\t\t\t} else {\n\n\t\t\t\tif (nodeDef.translation !== undefined) {\n\n\t\t\t\t\tnode.position.fromArray(nodeDef.translation);\n\t\t\t\t}\n\n\t\t\t\tif (nodeDef.rotation !== undefined) {\n\n\t\t\t\t\tnode.quaternion.fromArray(nodeDef.rotation);\n\t\t\t\t}\n\n\t\t\t\tif (nodeDef.scale !== undefined) {\n\n\t\t\t\t\tnode.scale.fromArray(nodeDef.scale);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t});\n\t};\n\n\t/**\n  * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n  * @param {number} sceneIndex\n  * @return {Promise<THREE.Scene>}\n  */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy(nodeId, parentObject, json, allNodes, skins) {\n\n\t\t\tvar node = allNodes[nodeId];\n\t\t\tvar nodeDef = json.nodes[nodeId];\n\n\t\t\t// build skeleton here as well\n\n\t\t\tif (nodeDef.skin !== undefined) {\n\n\t\t\t\tvar meshes = node.isGroup === true ? node.children : [node];\n\n\t\t\t\tfor (var i = 0, il = meshes.length; i < il; i++) {\n\n\t\t\t\t\tvar mesh = meshes[i];\n\t\t\t\t\tvar skinEntry = skins[nodeDef.skin];\n\n\t\t\t\t\tvar bones = [];\n\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\tfor (var j = 0, jl = skinEntry.joints.length; j < jl; j++) {\n\n\t\t\t\t\t\tvar jointId = skinEntry.joints[j];\n\t\t\t\t\t\tvar jointNode = allNodes[jointId];\n\n\t\t\t\t\t\tif (jointNode) {\n\n\t\t\t\t\t\t\tbones.push(jointNode);\n\n\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\tif (skinEntry.inverseBindMatrices !== undefined) {\n\n\t\t\t\t\t\t\t\tmat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tboneInverses.push(mat);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', jointId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build node hierachy\n\n\t\t\tparentObject.add(node);\n\n\t\t\tif (nodeDef.children) {\n\n\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\tfor (var i = 0, il = children.length; i < il; i++) {\n\n\t\t\t\t\tvar child = children[i];\n\t\t\t\t\tbuildNodeHierachy(child, node, json, allNodes, skins);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn function loadScene(sceneIndex) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[sceneIndex];\n\n\t\t\treturn this.getMultiDependencies(['node', 'skin']).then(function (dependencies) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tif (sceneDef.name !== undefined) scene.name = sceneDef.name;\n\n\t\t\t\tif (sceneDef.extras) scene.userData = sceneDef.extras;\n\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\t\tfor (var i = 0, il = nodeIds.length; i < il; i++) {\n\n\t\t\t\t\tbuildNodeHierachy(nodeIds[i], scene, json, dependencies.nodes, dependencies.skins);\n\t\t\t\t}\n\n\t\t\t\t// Ambient lighting, if present, is always attached to the scene root.\n\t\t\t\tif (sceneDef.extensions && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS] && sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light !== undefined) {\n\n\t\t\t\t\tvar lights = extensions[EXTENSIONS.KHR_LIGHTS].lights;\n\t\t\t\t\tscene.add(lights[sceneDef.extensions[EXTENSIONS.KHR_LIGHTS].light]);\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\t\t\t});\n\t\t};\n\t}();\n\n\treturn GLTFLoader;\n}();\n\nexports.default = GLTFLoader;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Nikos M. / https://github.com/foo123/\n */\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = function RGBELoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\n// extend THREE.DataTextureLoader\nRGBELoader.prototype = Object.create(THREE.DataTextureLoader.prototype);\n\n// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\nRGBELoader.prototype._parser = function (buffer) {\n\n\tvar\n\t/* return codes for rgbe routines */\n\tRGBE_RETURN_SUCCESS = 0,\n\t    RGBE_RETURN_FAILURE = -1,\n\n\n\t/* default error routine.  change this to change error handling */\n\trgbe_read_error = 1,\n\t    rgbe_write_error = 2,\n\t    rgbe_format_error = 3,\n\t    rgbe_memory_error = 4,\n\t    rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n\n\t\tswitch (rgbe_error_code) {\n\n\t\t\tcase rgbe_read_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader Read Error: \" + (msg || ''));\n\t\t\t\tbreak;\n\t\t\tcase rgbe_write_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader Write Error: \" + (msg || ''));\n\t\t\t\tbreak;\n\t\t\tcase rgbe_format_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader Bad File Format: \" + (msg || ''));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase rgbe_memory_error:\n\t\t\t\tconsole.error(\"THREE.RGBELoader: Error: \" + (msg || ''));\n\n\t\t}\n\t\treturn RGBE_RETURN_FAILURE;\n\t},\n\n\n\t/* offsets to red, green, and blue components in a data (float) pixel */\n\tRGBE_DATA_RED = 0,\n\t    RGBE_DATA_GREEN = 1,\n\t    RGBE_DATA_BLUE = 2,\n\n\n\t/* number of floats per pixel, use 4 since stored in rgba image format */\n\tRGBE_DATA_SIZE = 4,\n\n\n\t/* flags indicating which fields in an rgbe_header_info are valid */\n\tRGBE_VALID_PROGRAMTYPE = 1,\n\t    RGBE_VALID_FORMAT = 2,\n\t    RGBE_VALID_DIMENSIONS = 4,\n\t    NEWLINE = \"\\n\",\n\t    fgets = function fgets(buffer, lineLimit, consume) {\n\n\t\tlineLimit = !lineLimit ? 1024 : lineLimit;\n\t\tvar p = buffer.pos,\n\t\t    i = -1,\n\t\t    len = 0,\n\t\t    s = '',\n\t\t    chunkSize = 128,\n\t\t    chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\t\twhile (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n\n\t\t\ts += chunk;len += chunk.length;\n\t\t\tp += chunkSize;\n\t\t\tchunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\t\t}\n\n\t\tif (-1 < i) {\n\n\t\t\t/*for (i=l-1; i>=0; i--) {\n   \tbyteCode = m.charCodeAt(i);\n   \tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n   \telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n   \tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n   }*/\n\t\t\tif (false !== consume) buffer.pos += len + i + 1;\n\t\t\treturn s + chunk.slice(0, i);\n\t\t}\n\t\treturn false;\n\t},\n\n\n\t/* minimal header reading.  modify if you want to parse more information */\n\tRGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n\n\t\tvar line,\n\t\t    match,\n\n\n\t\t// regexes to parse header info fields\n\t\tmagic_token_re = /^#\\?(\\S+)$/,\n\t\t    gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t    exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n\t\t    format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n\t\t    dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n\n\n\t\t// RGBE format header struct\n\t\theader = {\n\n\t\t\tvalid: 0, /* indicate which fields are valid */\n\n\t\t\tstring: '', /* the actual header string */\n\n\t\t\tcomments: '', /* comments found in header */\n\n\t\t\tprogramtype: 'RGBE', /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n\n\t\t\tformat: '', /* RGBE format, default 32-bit_rle_rgbe */\n\n\t\t\tgamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n\n\t\t\texposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n\n\t\t\twidth: 0, height: 0 /* image dimensions, width/height */\n\n\t\t};\n\n\t\tif (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n\n\t\t\treturn rgbe_error(rgbe_read_error, \"no header found\");\n\t\t}\n\t\t/* if you want to require the magic token then uncomment the next line */\n\t\tif (!(match = line.match(magic_token_re))) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"bad initial token\");\n\t\t}\n\t\theader.valid |= RGBE_VALID_PROGRAMTYPE;\n\t\theader.programtype = match[1];\n\t\theader.string += line + \"\\n\";\n\n\t\twhile (true) {\n\n\t\t\tline = fgets(buffer);\n\t\t\tif (false === line) break;\n\t\t\theader.string += line + \"\\n\";\n\n\t\t\tif ('#' === line.charAt(0)) {\n\n\t\t\t\theader.comments += line + \"\\n\";\n\t\t\t\tcontinue; // comment line\n\t\t\t}\n\n\t\t\tif (match = line.match(gamma_re)) {\n\n\t\t\t\theader.gamma = parseFloat(match[1], 10);\n\t\t\t}\n\t\t\tif (match = line.match(exposure_re)) {\n\n\t\t\t\theader.exposure = parseFloat(match[1], 10);\n\t\t\t}\n\t\t\tif (match = line.match(format_re)) {\n\n\t\t\t\theader.valid |= RGBE_VALID_FORMAT;\n\t\t\t\theader.format = match[1]; //'32-bit_rle_rgbe';\n\t\t\t}\n\t\t\tif (match = line.match(dimensions_re)) {\n\n\t\t\t\theader.valid |= RGBE_VALID_DIMENSIONS;\n\t\t\t\theader.height = parseInt(match[1], 10);\n\t\t\t\theader.width = parseInt(match[2], 10);\n\t\t\t}\n\n\t\t\tif (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n\t\t}\n\n\t\tif (!(header.valid & RGBE_VALID_FORMAT)) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"missing format specifier\");\n\t\t}\n\t\tif (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"missing image size specifier\");\n\t\t}\n\n\t\treturn header;\n\t},\n\t    RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n\n\t\tvar data_rgba,\n\t\t    offset,\n\t\t    pos,\n\t\t    count,\n\t\t    byteValue,\n\t\t    scanline_buffer,\n\t\t    ptr,\n\t\t    ptr_end,\n\t\t    i,\n\t\t    l,\n\t\t    off,\n\t\t    isEncodedRun,\n\t\t    scanline_width = w,\n\t\t    num_scanlines = h,\n\t\t    rgbeStart;\n\n\t\tif (\n\t\t// run length encoding is not allowed so read flat\n\t\tscanline_width < 8 || scanline_width > 0x7fff ||\n\t\t// this file is not run length encoded\n\t\t2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n\n\t\t\t// return the flat buffer\n\t\t\treturn new Uint8Array(buffer);\n\t\t}\n\n\t\tif (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n\n\t\t\treturn rgbe_error(rgbe_format_error, \"wrong scanline width\");\n\t\t}\n\n\t\tdata_rgba = new Uint8Array(4 * w * h);\n\n\t\tif (!data_rgba || !data_rgba.length) {\n\n\t\t\treturn rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n\t\t}\n\n\t\toffset = 0;pos = 0;ptr_end = 4 * scanline_width;\n\t\trgbeStart = new Uint8Array(4);\n\t\tscanline_buffer = new Uint8Array(ptr_end);\n\n\t\t// read in each successive scanline\n\t\twhile (num_scanlines > 0 && pos < buffer.byteLength) {\n\n\t\t\tif (pos + 4 > buffer.byteLength) {\n\n\t\t\t\treturn rgbe_error(rgbe_read_error);\n\t\t\t}\n\n\t\t\trgbeStart[0] = buffer[pos++];\n\t\t\trgbeStart[1] = buffer[pos++];\n\t\t\trgbeStart[2] = buffer[pos++];\n\t\t\trgbeStart[3] = buffer[pos++];\n\n\t\t\tif (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n\n\t\t\t\treturn rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n\t\t\t}\n\n\t\t\t// read each of the four channels for the scanline into the buffer\n\t\t\t// first red, then green, then blue, then exponent\n\t\t\tptr = 0;\n\t\t\twhile (ptr < ptr_end && pos < buffer.byteLength) {\n\n\t\t\t\tcount = buffer[pos++];\n\t\t\t\tisEncodedRun = count > 128;\n\t\t\t\tif (isEncodedRun) count -= 128;\n\n\t\t\t\tif (0 === count || ptr + count > ptr_end) {\n\n\t\t\t\t\treturn rgbe_error(rgbe_format_error, \"bad scanline data\");\n\t\t\t\t}\n\n\t\t\t\tif (isEncodedRun) {\n\n\t\t\t\t\t// a (encoded) run of the same value\n\t\t\t\t\tbyteValue = buffer[pos++];\n\t\t\t\t\tfor (i = 0; i < count; i++) {\n\n\t\t\t\t\t\tscanline_buffer[ptr++] = byteValue;\n\t\t\t\t\t}\n\t\t\t\t\t//ptr += count;\n\t\t\t\t} else {\n\n\t\t\t\t\t// a literal-run\n\t\t\t\t\tscanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n\t\t\t\t\tptr += count;pos += count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now convert data from buffer into rgba\n\t\t\t// first red, then green, then blue, then exponent (alpha)\n\t\t\tl = scanline_width; //scanline_buffer.byteLength;\n\t\t\tfor (i = 0; i < l; i++) {\n\n\t\t\t\toff = 0;\n\t\t\t\tdata_rgba[offset] = scanline_buffer[i + off];\n\t\t\t\toff += scanline_width; //1;\n\t\t\t\tdata_rgba[offset + 1] = scanline_buffer[i + off];\n\t\t\t\toff += scanline_width; //1;\n\t\t\t\tdata_rgba[offset + 2] = scanline_buffer[i + off];\n\t\t\t\toff += scanline_width; //1;\n\t\t\t\tdata_rgba[offset + 3] = scanline_buffer[i + off];\n\t\t\t\toffset += 4;\n\t\t\t}\n\n\t\t\tnum_scanlines--;\n\t\t}\n\n\t\treturn data_rgba;\n\t};\n\n\tvar byteArray = new Uint8Array(buffer),\n\t    byteLength = byteArray.byteLength;\n\tbyteArray.pos = 0;\n\tvar rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n\tif (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n\n\t\tvar w = rgbe_header_info.width,\n\t\t    h = rgbe_header_info.height,\n\t\t    image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\t\tif (RGBE_RETURN_FAILURE !== image_rgba_data) {\n\n\t\t\treturn {\n\t\t\t\twidth: w, height: h,\n\t\t\t\tdata: image_rgba_data,\n\t\t\t\theader: rgbe_header_info.string,\n\t\t\t\tgamma: rgbe_header_info.gamma,\n\t\t\t\texposure: rgbe_header_info.exposure,\n\t\t\t\tformat: THREE.RGBEFormat, // handled as THREE.RGBAFormat in shaders\n\t\t\t\ttype: THREE.UnsignedByteType\n\t\t\t};\n\t\t}\n\t}\n\treturn null;\n};\n\nexports.default = RGBELoader;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _global = __webpack_require__(8);\n\nvar _global2 = _interopRequireDefault(_global);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar window = _global2.default;\n\n/**\n  * @author Kai Salmen / https://kaisalmen.de\n  * Development repository: https://github.com/kaisalmen/WWOBJLoader\n  */\n\n'use strict';\n\n// if ( THREE.LoaderSupport === undefined ) { THREE.LoaderSupport = {} }\nvar LoaderSupport = {};\n\n/**\n * Validation functions.\n * @class\n */\nLoaderSupport.Validator = {\n\t/**\n  * If given input is null or undefined, false is returned otherwise true.\n  *\n  * @param input Can be anything\n  * @returns {boolean}\n  */\n\tisValid: function isValid(input) {\n\t\treturn input !== null && input !== undefined;\n\t},\n\t/**\n  * If given input is null or undefined, the defaultValue is returned otherwise the given input.\n  *\n  * @param input Can be anything\n  * @param defaultValue Can be anything\n  * @returns {*}\n  */\n\tverifyInput: function verifyInput(input, defaultValue) {\n\t\treturn input === null || input === undefined ? defaultValue : input;\n\t}\n};\n\n/**\n * Callbacks utilized by loaders and builders.\n * @class\n */\nLoaderSupport.Callbacks = function () {\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction Callbacks() {\n\t\tthis.onProgress = null;\n\t\tthis.onMeshAlter = null;\n\t\tthis.onLoad = null;\n\t\tthis.onLoadMaterials = null;\n\t}\n\n\t/**\n  * Register callback function that is invoked by internal function \"announceProgress\" to print feedback.\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnProgress Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnProgress = function (callbackOnProgress) {\n\t\tthis.onProgress = Validator.verifyInput(callbackOnProgress, this.onProgress);\n\t};\n\n\t/**\n  * Register callback function that is called every time a mesh was loaded.\n  * Use {@link THREE.LoaderSupport.LoadedMeshUserOverride} for alteration instructions (geometry, material or disregard mesh).\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnMeshAlter Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnMeshAlter = function (callbackOnMeshAlter) {\n\t\tthis.onMeshAlter = Validator.verifyInput(callbackOnMeshAlter, this.onMeshAlter);\n\t};\n\n\t/**\n  * Register callback function that is called once loading of the complete OBJ file is completed.\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnLoad Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnLoad = function (callbackOnLoad) {\n\t\tthis.onLoad = Validator.verifyInput(callbackOnLoad, this.onLoad);\n\t};\n\n\t/**\n  * Register callback function that is called when materials have been loaded.\n  * @memberOf THREE.LoaderSupport.Callbacks\n  *\n  * @param {callback} callbackOnLoadMaterials Callback function for described functionality\n  */\n\tCallbacks.prototype.setCallbackOnLoadMaterials = function (callbackOnLoadMaterials) {\n\t\tthis.onLoadMaterials = Validator.verifyInput(callbackOnLoadMaterials, this.onLoadMaterials);\n\t};\n\n\treturn Callbacks;\n}();\n\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nLoaderSupport.LoadedMeshUserOverride = function () {\n\n\tfunction LoadedMeshUserOverride(disregardMesh, alteredMesh) {\n\t\tthis.disregardMesh = disregardMesh === true;\n\t\tthis.alteredMesh = alteredMesh === true;\n\t\tthis.meshes = [];\n\t}\n\n\t/**\n  * Add a mesh created within callback.\n  *\n  * @memberOf THREE.OBJLoader2.LoadedMeshUserOverride\n  *\n  * @param {THREE.Mesh} mesh\n  */\n\tLoadedMeshUserOverride.prototype.addMesh = function (mesh) {\n\t\tthis.meshes.push(mesh);\n\t\tthis.alteredMesh = true;\n\t};\n\n\t/**\n  * Answers if mesh shall be disregarded completely.\n  *\n  * @returns {boolean}\n  */\n\tLoadedMeshUserOverride.prototype.isDisregardMesh = function () {\n\t\treturn this.disregardMesh;\n\t};\n\n\t/**\n  * Answers if new mesh(es) were created.\n  *\n  * @returns {boolean}\n  */\n\tLoadedMeshUserOverride.prototype.providesAlteredMeshes = function () {\n\t\treturn this.alteredMesh;\n\t};\n\n\treturn LoadedMeshUserOverride;\n}();\n\n/**\n * A resource description used by {@link THREE.LoaderSupport.PrepData} and others.\n * @class\n *\n * @param {string} url URL to the file\n * @param {string} extension The file extension (type)\n */\nLoaderSupport.ResourceDescriptor = function () {\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction ResourceDescriptor(url, extension) {\n\t\tvar urlParts = url.split('/');\n\n\t\tif (urlParts.length < 2) {\n\n\t\t\tthis.path = null;\n\t\t\tthis.name = url;\n\t\t\tthis.url = url;\n\t\t} else {\n\n\t\t\tthis.path = Validator.verifyInput(urlParts.slice(0, urlParts.length - 1).join('/') + '/', null);\n\t\t\tthis.name = Validator.verifyInput(urlParts[urlParts.length - 1], null);\n\t\t\tthis.url = url;\n\t\t}\n\t\tthis.extension = Validator.verifyInput(extension, \"default\");\n\t\tthis.extension = this.extension.trim();\n\t\tthis.content = null;\n\t}\n\n\t/**\n  * Set the content of this resource\n  * @memberOf THREE.LoaderSupport.ResourceDescriptor\n  *\n  * @param {Object} content The file content as arraybuffer or text\n  */\n\tResourceDescriptor.prototype.setContent = function (content) {\n\t\tthis.content = Validator.verifyInput(content, null);\n\t};\n\n\treturn ResourceDescriptor;\n}();\n\n/**\n * Configuration instructions to be used by run method.\n * @class\n */\nLoaderSupport.PrepData = function () {\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction PrepData(modelName) {\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\t\tthis.modelName = Validator.verifyInput(modelName, '');\n\t\tthis.resources = [];\n\t\tthis.callbacks = new LoaderSupport.Callbacks();\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tPrepData.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t};\n\n\t/**\n  * Returns all callbacks as {@link THREE.LoaderSupport.Callbacks}\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @returns {THREE.LoaderSupport.Callbacks}\n  */\n\tPrepData.prototype.getCallbacks = function () {\n\t\treturn this.callbacks;\n\t};\n\n\t/**\n  * Add a resource description.\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @param {THREE.LoaderSupport.ResourceDescriptor} Adds a {@link THREE.LoaderSupport.ResourceDescriptor}\n  */\n\tPrepData.prototype.addResource = function (resource) {\n\t\tthis.resources.push(resource);\n\t};\n\n\t/**\n  * Clones this object and returns it afterwards. Callbacks and resources are not cloned deep (references!).\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @returns {@link THREE.LoaderSupport.PrepData}\n  */\n\tPrepData.prototype.clone = function () {\n\t\tvar clone = new LoaderSupport.PrepData(this.modelName);\n\t\tclone.logging.enabled = this.logging.enabled;\n\t\tclone.logging.debug = this.logging.debug;\n\t\tclone.resources = this.resources;\n\t\tclone.callbacks = this.callbacks;\n\n\t\tvar property, value;\n\t\tfor (property in this) {\n\n\t\t\tvalue = this[property];\n\t\t\tif (!clone.hasOwnProperty(property) && typeof this[property] !== 'function') {\n\n\t\t\t\tclone[property] = value;\n\t\t\t}\n\t\t}\n\n\t\treturn clone;\n\t};\n\n\t/**\n  * Identify files or content of interest from an Array of {@link THREE.LoaderSupport.ResourceDescriptor}.\n  * @memberOf THREE.LoaderSupport.PrepData\n  *\n  * @param {THREE.LoaderSupport.ResourceDescriptor[]} resources Array of {@link THREE.LoaderSupport.ResourceDescriptor}\n  * @param Object fileDesc Object describing which resources are of interest (ext, type (string or UInt8Array) and ignore (boolean))\n  * @returns {{}} Object with each \"ext\" and the corresponding {@link THREE.LoaderSupport.ResourceDescriptor}\n  */\n\tPrepData.prototype.checkResourceDescriptorFiles = function (resources, fileDesc) {\n\t\tvar resource, triple, i, found;\n\t\tvar result = {};\n\n\t\tfor (var index in resources) {\n\n\t\t\tresource = resources[index];\n\t\t\tfound = false;\n\t\t\tif (!Validator.isValid(resource.name)) continue;\n\t\t\tif (Validator.isValid(resource.content)) {\n\n\t\t\t\tfor (i = 0; i < fileDesc.length && !found; i++) {\n\n\t\t\t\t\ttriple = fileDesc[i];\n\t\t\t\t\tif (resource.extension.toLowerCase() === triple.ext.toLowerCase()) {\n\n\t\t\t\t\t\tif (triple.ignore) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t} else if (triple.type === \"ArrayBuffer\") {\n\n\t\t\t\t\t\t\t// fast-fail on bad type\n\t\t\t\t\t\t\tif (!(resource.content instanceof ArrayBuffer || resource.content instanceof Uint8Array)) throw 'Provided content is not of type ArrayBuffer! Aborting...';\n\t\t\t\t\t\t\tresult[triple.ext] = resource;\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t} else if (triple.type === \"String\") {\n\n\t\t\t\t\t\t\tif (!(typeof resource.content === 'string' || resource.content instanceof String)) throw 'Provided  content is not of type String! Aborting...';\n\t\t\t\t\t\t\tresult[triple.ext] = resource;\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url;\n\t\t\t} else {\n\n\t\t\t\t// fast-fail on bad type\n\t\t\t\tif (!(typeof resource.name === 'string' || resource.name instanceof String)) throw 'Provided file is not properly defined! Aborting...';\n\t\t\t\tfor (i = 0; i < fileDesc.length && !found; i++) {\n\n\t\t\t\t\ttriple = fileDesc[i];\n\t\t\t\t\tif (resource.extension.toLowerCase() === triple.ext.toLowerCase()) {\n\n\t\t\t\t\t\tif (!triple.ignore) result[triple.ext] = resource;\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!found) throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\treturn PrepData;\n}();\n\n/**\n * Builds one or many THREE.Mesh from one raw set of Arraybuffers, materialGroup descriptions and further parameters.\n * Supports vertex, vertexColor, normal, uv and index buffers.\n * @class\n */\nLoaderSupport.MeshBuilder = function () {\n\n\tvar LOADER_MESH_BUILDER_VERSION = '1.2.0';\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tfunction MeshBuilder() {\n\t\tconsole.info('Using THREE.LoaderSupport.MeshBuilder version: ' + LOADER_MESH_BUILDER_VERSION);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\tthis.callbacks = new LoaderSupport.Callbacks();\n\t\tthis.materials = [];\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tMeshBuilder.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t};\n\n\t/**\n  * Initializes the MeshBuilder (currently only default material initialisation).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  */\n\tMeshBuilder.prototype.init = function () {\n\t\tvar defaultMaterial = new THREE.MeshStandardMaterial({ color: 0xDCF1FF });\n\t\tdefaultMaterial.name = 'defaultMaterial';\n\n\t\tvar defaultVertexColorMaterial = new THREE.MeshStandardMaterial({ color: 0xDCF1FF });\n\t\tdefaultVertexColorMaterial.name = 'defaultVertexColorMaterial';\n\t\tdefaultVertexColorMaterial.vertexColors = THREE.VertexColors;\n\n\t\tvar defaultLineMaterial = new THREE.LineBasicMaterial();\n\t\tdefaultLineMaterial.name = 'defaultLineMaterial';\n\n\t\tvar defaultPointMaterial = new THREE.PointsMaterial({ size: 1 });\n\t\tdefaultPointMaterial.name = 'defaultPointMaterial';\n\n\t\tvar runtimeMaterials = {};\n\t\truntimeMaterials[defaultMaterial.name] = defaultMaterial;\n\t\truntimeMaterials[defaultVertexColorMaterial.name] = defaultVertexColorMaterial;\n\t\truntimeMaterials[defaultLineMaterial.name] = defaultLineMaterial;\n\t\truntimeMaterials[defaultPointMaterial.name] = defaultPointMaterial;\n\n\t\tthis.updateMaterials({\n\t\t\tcmd: 'materialData',\n\t\t\tmaterials: {\n\t\t\t\tmaterialCloneInstructions: null,\n\t\t\t\tserializedMaterials: null,\n\t\t\t\truntimeMaterials: runtimeMaterials\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n  * Set materials loaded by any supplier of an Array of {@link THREE.Material}.\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {THREE.Material[]} materials Array of {@link THREE.Material}\n  */\n\tMeshBuilder.prototype.setMaterials = function (materials) {\n\t\tvar payload = {\n\t\t\tcmd: 'materialData',\n\t\t\tmaterials: {\n\t\t\t\tmaterialCloneInstructions: null,\n\t\t\t\tserializedMaterials: null,\n\t\t\t\truntimeMaterials: Validator.isValid(this.callbacks.onLoadMaterials) ? this.callbacks.onLoadMaterials(materials) : materials\n\t\t\t}\n\t\t};\n\t\tthis.updateMaterials(payload);\n\t};\n\n\tMeshBuilder.prototype._setCallbacks = function (callbacks) {\n\t\tif (Validator.isValid(callbacks.onProgress)) this.callbacks.setCallbackOnProgress(callbacks.onProgress);\n\t\tif (Validator.isValid(callbacks.onMeshAlter)) this.callbacks.setCallbackOnMeshAlter(callbacks.onMeshAlter);\n\t\tif (Validator.isValid(callbacks.onLoad)) this.callbacks.setCallbackOnLoad(callbacks.onLoad);\n\t\tif (Validator.isValid(callbacks.onLoadMaterials)) this.callbacks.setCallbackOnLoadMaterials(callbacks.onLoadMaterials);\n\t};\n\n\t/**\n  * Delegates processing of the payload (mesh building or material update) to the corresponding functions (BW-compatibility).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {Object} payload Raw Mesh or Material descriptions.\n  * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh} or null in case of material update\n  */\n\tMeshBuilder.prototype.processPayload = function (payload) {\n\t\tif (payload.cmd === 'meshData') {\n\n\t\t\treturn this.buildMeshes(payload);\n\t\t} else if (payload.cmd === 'materialData') {\n\n\t\t\tthis.updateMaterials(payload);\n\t\t\treturn null;\n\t\t}\n\t};\n\n\t/**\n  * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n  * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh}\n  */\n\tMeshBuilder.prototype.buildMeshes = function (meshPayload) {\n\t\tvar meshName = meshPayload.params.meshName;\n\n\t\tvar bufferGeometry = new THREE.BufferGeometry();\n\t\tbufferGeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.vertices), 3));\n\t\tif (Validator.isValid(meshPayload.buffers.indices)) {\n\n\t\t\tbufferGeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(meshPayload.buffers.indices), 1));\n\t\t}\n\t\tvar haveVertexColors = Validator.isValid(meshPayload.buffers.colors);\n\t\tif (haveVertexColors) {\n\n\t\t\tbufferGeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.colors), 3));\n\t\t}\n\t\tif (Validator.isValid(meshPayload.buffers.normals)) {\n\n\t\t\tbufferGeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.normals), 3));\n\t\t} else {\n\n\t\t\tbufferGeometry.computeVertexNormals();\n\t\t}\n\t\tif (Validator.isValid(meshPayload.buffers.uvs)) {\n\n\t\t\tbufferGeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(meshPayload.buffers.uvs), 2));\n\t\t}\n\n\t\tvar material, materialName, key;\n\t\tvar materialNames = meshPayload.materials.materialNames;\n\t\tvar createMultiMaterial = meshPayload.materials.multiMaterial;\n\t\tvar multiMaterials = [];\n\t\tfor (key in materialNames) {\n\n\t\t\tmaterialName = materialNames[key];\n\t\t\tmaterial = this.materials[materialName];\n\t\t\tif (createMultiMaterial) multiMaterials.push(material);\n\t\t}\n\t\tif (createMultiMaterial) {\n\n\t\t\tmaterial = multiMaterials;\n\t\t\tvar materialGroups = meshPayload.materials.materialGroups;\n\t\t\tvar materialGroup;\n\t\t\tfor (key in materialGroups) {\n\n\t\t\t\tmaterialGroup = materialGroups[key];\n\t\t\t\tbufferGeometry.addGroup(materialGroup.start, materialGroup.count, materialGroup.index);\n\t\t\t}\n\t\t}\n\n\t\tvar meshes = [];\n\t\tvar mesh;\n\t\tvar callbackOnMeshAlter = this.callbacks.onMeshAlter;\n\t\tvar callbackOnMeshAlterResult;\n\t\tvar useOrgMesh = true;\n\t\tvar geometryType = Validator.verifyInput(meshPayload.geometryType, 0);\n\t\tif (Validator.isValid(callbackOnMeshAlter)) {\n\n\t\t\tcallbackOnMeshAlterResult = callbackOnMeshAlter({\n\t\t\t\tdetail: {\n\t\t\t\t\tmeshName: meshName,\n\t\t\t\t\tbufferGeometry: bufferGeometry,\n\t\t\t\t\tmaterial: material,\n\t\t\t\t\tgeometryType: geometryType\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (Validator.isValid(callbackOnMeshAlterResult)) {\n\n\t\t\t\tif (!callbackOnMeshAlterResult.isDisregardMesh() && callbackOnMeshAlterResult.providesAlteredMeshes()) {\n\n\t\t\t\t\tfor (var i in callbackOnMeshAlterResult.meshes) {\n\n\t\t\t\t\t\tmeshes.push(callbackOnMeshAlterResult.meshes[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuseOrgMesh = false;\n\t\t\t}\n\t\t}\n\t\tif (useOrgMesh) {\n\n\t\t\tif (meshPayload.computeBoundingSphere) bufferGeometry.computeBoundingSphere();\n\t\t\tif (geometryType === 0) {\n\n\t\t\t\tmesh = new THREE.Mesh(bufferGeometry, material);\n\t\t\t} else if (geometryType === 1) {\n\n\t\t\t\tmesh = new THREE.LineSegments(bufferGeometry, material);\n\t\t\t} else {\n\n\t\t\t\tmesh = new THREE.Points(bufferGeometry, material);\n\t\t\t}\n\t\t\tmesh.name = meshName;\n\t\t\tmeshes.push(mesh);\n\t\t}\n\n\t\tvar progressMessage;\n\t\tif (Validator.isValid(meshes) && meshes.length > 0) {\n\n\t\t\tvar meshNames = [];\n\t\t\tfor (var i in meshes) {\n\n\t\t\t\tmesh = meshes[i];\n\t\t\t\tmeshNames[i] = mesh.name;\n\t\t\t}\n\t\t\tprogressMessage = 'Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n\t\t} else {\n\n\t\t\tprogressMessage = 'Not adding mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + (meshPayload.progress.numericalValue * 100).toFixed(2) + '%)';\n\t\t}\n\t\tvar callbackOnProgress = this.callbacks.onProgress;\n\t\tif (Validator.isValid(callbackOnProgress)) {\n\n\t\t\tvar event = new CustomEvent('MeshBuilderEvent', {\n\t\t\t\tdetail: {\n\t\t\t\t\ttype: 'progress',\n\t\t\t\t\tmodelName: meshPayload.params.meshName,\n\t\t\t\t\ttext: progressMessage,\n\t\t\t\t\tnumericalValue: meshPayload.progress.numericalValue\n\t\t\t\t}\n\t\t\t});\n\t\t\tcallbackOnProgress(event);\n\t\t}\n\n\t\treturn meshes;\n\t};\n\n\t/**\n  * Updates the materials with contained material objects (sync) or from alteration instructions (async).\n  * @memberOf THREE.LoaderSupport.MeshBuilder\n  *\n  * @param {Object} materialPayload Material update instructions\n  */\n\tMeshBuilder.prototype.updateMaterials = function (materialPayload) {\n\t\tvar material, materialName;\n\t\tvar materialCloneInstructions = materialPayload.materials.materialCloneInstructions;\n\t\tif (Validator.isValid(materialCloneInstructions)) {\n\n\t\t\tvar materialNameOrg = materialCloneInstructions.materialNameOrg;\n\t\t\tvar materialOrg = this.materials[materialNameOrg];\n\n\t\t\tif (Validator.isValid(materialNameOrg)) {\n\n\t\t\t\tmaterial = materialOrg.clone();\n\n\t\t\t\tmaterialName = materialCloneInstructions.materialName;\n\t\t\t\tmaterial.name = materialName;\n\n\t\t\t\tvar materialProperties = materialCloneInstructions.materialProperties;\n\t\t\t\tfor (var key in materialProperties) {\n\n\t\t\t\t\tif (material.hasOwnProperty(key) && materialProperties.hasOwnProperty(key)) material[key] = materialProperties[key];\n\t\t\t\t}\n\t\t\t\tthis.materials[materialName] = material;\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('Requested material \"' + materialNameOrg + '\" is not available!');\n\t\t\t}\n\t\t}\n\n\t\tvar materials = materialPayload.materials.serializedMaterials;\n\t\tif (Validator.isValid(materials) && Object.keys(materials).length > 0) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\t\t\tvar materialJson;\n\t\t\tfor (materialName in materials) {\n\n\t\t\t\tmaterialJson = materials[materialName];\n\t\t\t\tif (Validator.isValid(materialJson)) {\n\n\t\t\t\t\tmaterial = loader.parse(materialJson);\n\t\t\t\t\tif (this.logging.enabled) console.info('De-serialized material with name \"' + materialName + '\" will be added.');\n\t\t\t\t\tthis.materials[materialName] = material;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmaterials = materialPayload.materials.runtimeMaterials;\n\t\tif (Validator.isValid(materials) && Object.keys(materials).length > 0) {\n\n\t\t\tfor (materialName in materials) {\n\n\t\t\t\tmaterial = materials[materialName];\n\t\t\t\tif (this.logging.enabled) console.info('Material with name \"' + materialName + '\" will be added.');\n\t\t\t\tthis.materials[materialName] = material;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Returns the mapping object of material name and corresponding jsonified material.\n  *\n  * @returns {Object} Map of Materials in JSON representation\n  */\n\tMeshBuilder.prototype.getMaterialsJSON = function () {\n\t\tvar materialsJSON = {};\n\t\tvar material;\n\t\tfor (var materialName in this.materials) {\n\n\t\t\tmaterial = this.materials[materialName];\n\t\t\tmaterialsJSON[materialName] = material.toJSON();\n\t\t}\n\n\t\treturn materialsJSON;\n\t};\n\n\t/**\n  * Returns the mapping object of material name and corresponding material.\n  *\n  * @returns {Object} Map of {@link THREE.Material}\n  */\n\tMeshBuilder.prototype.getMaterials = function () {\n\t\treturn this.materials;\n\t};\n\n\treturn MeshBuilder;\n}();\n\n/**\n * Default implementation of the WorkerRunner responsible for creation and configuration of the parser within the worker.\n *\n * @class\n */\nLoaderSupport.WorkerRunnerRefImpl = function () {\n\n\tfunction WorkerRunnerRefImpl() {\n\t\tvar scope = this;\n\t\tvar scopedRunner = function scopedRunner(event) {\n\t\t\tscope.processMessage(event.data);\n\t\t};\n\t\tself.addEventListener('message', scopedRunner, false);\n\t}\n\n\t/**\n  * Applies values from parameter object via set functions or via direct assignment.\n  * @memberOf THREE.LoaderSupport.WorkerRunnerRefImpl\n  *\n  * @param {Object} parser The parser instance\n  * @param {Object} params The parameter object\n  */\n\tWorkerRunnerRefImpl.prototype.applyProperties = function (parser, params) {\n\t\tvar property, funcName, values;\n\t\tfor (property in params) {\n\t\t\tfuncName = 'set' + property.substring(0, 1).toLocaleUpperCase() + property.substring(1);\n\t\t\tvalues = params[property];\n\n\t\t\tif (typeof parser[funcName] === 'function') {\n\n\t\t\t\tparser[funcName](values);\n\t\t\t} else if (parser.hasOwnProperty(property)) {\n\n\t\t\t\tparser[property] = values;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Configures the Parser implementation according the supplied configuration object.\n  * @memberOf THREE.LoaderSupport.WorkerRunnerRefImpl\n  *\n  * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n  */\n\tWorkerRunnerRefImpl.prototype.processMessage = function (payload) {\n\t\tif (payload.cmd === 'run') {\n\n\t\t\tvar callbacks = {\n\t\t\t\tcallbackMeshBuilder: function callbackMeshBuilder(payload) {\n\t\t\t\t\tself.postMessage(payload);\n\t\t\t\t},\n\t\t\t\tcallbackProgress: function callbackProgress(text) {\n\t\t\t\t\tif (payload.logging.enabled && payload.logging.debug) console.debug('WorkerRunner: progress: ' + text);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Parser is expected to be named as such\n\t\t\tvar parser = new Parser();\n\t\t\tif (typeof parser['setLogging'] === 'function') parser.setLogging(payload.logging.enabled, payload.logging.debug);\n\t\t\tthis.applyProperties(parser, payload.params);\n\t\t\tthis.applyProperties(parser, payload.materials);\n\t\t\tthis.applyProperties(parser, callbacks);\n\t\t\tparser.workerScope = self;\n\t\t\tparser.parse(payload.data.input, payload.data.options);\n\n\t\t\tif (payload.logging.enabled) console.log('WorkerRunner: Run complete!');\n\n\t\t\tcallbacks.callbackMeshBuilder({\n\t\t\t\tcmd: 'complete',\n\t\t\t\tmsg: 'WorkerRunner completed run.'\n\t\t\t});\n\t\t} else {\n\n\t\t\tconsole.error('WorkerRunner: Received unknown command: ' + payload.cmd);\n\t\t}\n\t};\n\n\treturn WorkerRunnerRefImpl;\n}();\n\n/**\n * This class provides means to transform existing parser code into a web worker. It defines a simple communication protocol\n * which allows to configure the worker and receive raw mesh data during execution.\n * @class\n */\nLoaderSupport.WorkerSupport = function () {\n\n\tvar WORKER_SUPPORT_VERSION = '2.2.0';\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tvar LoaderWorker = function () {\n\n\t\tfunction LoaderWorker() {\n\t\t\tthis._reset();\n\t\t}\n\n\t\tLoaderWorker.prototype._reset = function () {\n\t\t\tthis.logging = {\n\t\t\t\tenabled: true,\n\t\t\t\tdebug: false\n\t\t\t};\n\t\t\tthis.worker = null;\n\t\t\tthis.runnerImplName = null;\n\t\t\tthis.callbacks = {\n\t\t\t\tmeshBuilder: null,\n\t\t\t\tonLoad: null\n\t\t\t};\n\t\t\tthis.terminateRequested = false;\n\t\t\tthis.queuedMessage = null;\n\t\t\tthis.started = false;\n\t\t\tthis.forceCopy = false;\n\t\t};\n\n\t\tLoaderWorker.prototype.setLogging = function (enabled, debug) {\n\t\t\tthis.logging.enabled = enabled === true;\n\t\t\tthis.logging.debug = debug === true;\n\t\t};\n\n\t\tLoaderWorker.prototype.setForceCopy = function (forceCopy) {\n\t\t\tthis.forceCopy = forceCopy === true;\n\t\t};\n\n\t\tLoaderWorker.prototype.initWorker = function (code, runnerImplName) {\n\t\t\tthis.runnerImplName = runnerImplName;\n\t\t\tvar blob = new Blob([code], { type: 'application/javascript' });\n\t\t\tthis.worker = new Worker(window.URL.createObjectURL(blob));\n\t\t\tthis.worker.onmessage = this._receiveWorkerMessage;\n\n\t\t\t// set referemce to this, then processing in worker scope within \"_receiveWorkerMessage\" can access members\n\t\t\tthis.worker.runtimeRef = this;\n\n\t\t\t// process stored queuedMessage\n\t\t\tthis._postMessage();\n\t\t};\n\n\t\t/**\n   * Executed in worker scope\n  \t */\n\t\tLoaderWorker.prototype._receiveWorkerMessage = function (e) {\n\t\t\tvar payload = e.data;\n\t\t\tswitch (payload.cmd) {\n\t\t\t\tcase 'meshData':\n\t\t\t\tcase 'materialData':\n\t\t\t\tcase 'imageData':\n\t\t\t\t\tthis.runtimeRef.callbacks.meshBuilder(payload);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'complete':\n\t\t\t\t\tthis.runtimeRef.queuedMessage = null;\n\t\t\t\t\tthis.started = false;\n\t\t\t\t\tthis.runtimeRef.callbacks.onLoad(payload.msg);\n\n\t\t\t\t\tif (this.runtimeRef.terminateRequested) {\n\n\t\t\t\t\t\tif (this.runtimeRef.logging.enabled) console.info('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run is complete. Terminating application on request!');\n\t\t\t\t\t\tthis.runtimeRef._terminate();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tconsole.error('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Reported error: ' + payload.msg);\n\t\t\t\t\tthis.runtimeRef.queuedMessage = null;\n\t\t\t\t\tthis.started = false;\n\t\t\t\t\tthis.runtimeRef.callbacks.onLoad(payload.msg);\n\n\t\t\t\t\tif (this.runtimeRef.terminateRequested) {\n\n\t\t\t\t\t\tif (this.runtimeRef.logging.enabled) console.info('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run reported error. Terminating application on request!');\n\t\t\t\t\t\tthis.runtimeRef._terminate();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error('WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Received unknown command: ' + payload.cmd);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t};\n\n\t\tLoaderWorker.prototype.setCallbacks = function (meshBuilder, onLoad) {\n\t\t\tthis.callbacks.meshBuilder = Validator.verifyInput(meshBuilder, this.callbacks.meshBuilder);\n\t\t\tthis.callbacks.onLoad = Validator.verifyInput(onLoad, this.callbacks.onLoad);\n\t\t};\n\n\t\tLoaderWorker.prototype.run = function (payload) {\n\t\t\tif (Validator.isValid(this.queuedMessage)) {\n\n\t\t\t\tconsole.warn('Already processing message. Rejecting new run instruction');\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tthis.queuedMessage = payload;\n\t\t\t\tthis.started = true;\n\t\t\t}\n\t\t\tif (!Validator.isValid(this.callbacks.meshBuilder)) throw 'Unable to run as no \"MeshBuilder\" callback is set.';\n\t\t\tif (!Validator.isValid(this.callbacks.onLoad)) throw 'Unable to run as no \"onLoad\" callback is set.';\n\t\t\tif (payload.cmd !== 'run') payload.cmd = 'run';\n\t\t\tif (Validator.isValid(payload.logging)) {\n\n\t\t\t\tpayload.logging.enabled = payload.logging.enabled === true;\n\t\t\t\tpayload.logging.debug = payload.logging.debug === true;\n\t\t\t} else {\n\n\t\t\t\tpayload.logging = {\n\t\t\t\t\tenabled: true,\n\t\t\t\t\tdebug: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tthis._postMessage();\n\t\t};\n\n\t\tLoaderWorker.prototype._postMessage = function () {\n\t\t\tif (Validator.isValid(this.queuedMessage) && Validator.isValid(this.worker)) {\n\n\t\t\t\tif (this.queuedMessage.data.input instanceof ArrayBuffer) {\n\n\t\t\t\t\tvar content;\n\t\t\t\t\tif (this.forceCopy) {\n\n\t\t\t\t\t\tcontent = this.queuedMessage.data.input.slice(0);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontent = this.queuedMessage.data.input;\n\t\t\t\t\t}\n\t\t\t\t\tthis.worker.postMessage(this.queuedMessage, [content]);\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.worker.postMessage(this.queuedMessage);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tLoaderWorker.prototype.setTerminateRequested = function (terminateRequested) {\n\t\t\tthis.terminateRequested = terminateRequested === true;\n\t\t\tif (this.terminateRequested && Validator.isValid(this.worker) && !Validator.isValid(this.queuedMessage) && this.started) {\n\n\t\t\t\tif (this.logging.enabled) console.info('Worker is terminated immediately as it is not running!');\n\t\t\t\tthis._terminate();\n\t\t\t}\n\t\t};\n\n\t\tLoaderWorker.prototype._terminate = function () {\n\t\t\tthis.worker.terminate();\n\t\t\tthis._reset();\n\t\t};\n\n\t\treturn LoaderWorker;\n\t}();\n\n\tfunction WorkerSupport() {\n\t\tconsole.info('Using THREE.LoaderSupport.WorkerSupport version: ' + WORKER_SUPPORT_VERSION);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\t// check worker support first\n\t\tif (window.Worker === undefined) throw \"This browser does not support web workers!\";\n\t\tif (window.Blob === undefined) throw \"This browser does not support Blob!\";\n\t\tif (typeof window.URL.createObjectURL !== 'function') throw \"This browser does not support Object creation from URL!\";\n\n\t\tthis.loaderWorker = new LoaderWorker();\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tWorkerSupport.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\tthis.loaderWorker.setLogging(this.logging.enabled, this.logging.debug);\n\t};\n\n\t/**\n  * Forces all ArrayBuffers to be transferred to worker to be copied.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {boolean} forceWorkerDataCopy True or false.\n  */\n\tWorkerSupport.prototype.setForceWorkerDataCopy = function (forceWorkerDataCopy) {\n\t\tthis.loaderWorker.setForceCopy(forceWorkerDataCopy);\n\t};\n\n\t/**\n  * Validate the status of worker code and the derived worker.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {Function} functionCodeBuilder Function that is invoked with funcBuildObject and funcBuildSingleton that allows stringification of objects and singletons.\n  * @param {String} parserName Name of the Parser object\n  * @param {String[]} libLocations URL of libraries that shall be added to worker code relative to libPath\n  * @param {String} libPath Base path used for loading libraries\n  * @param {THREE.LoaderSupport.WorkerRunnerRefImpl} runnerImpl The default worker parser wrapper implementation (communication and execution). An extended class could be passed here.\n  */\n\tWorkerSupport.prototype.validate = function (functionCodeBuilder, parserName, libLocations, libPath, runnerImpl) {\n\t\tif (Validator.isValid(this.loaderWorker.worker)) return;\n\n\t\tif (this.logging.enabled) {\n\n\t\t\tconsole.info('WorkerSupport: Building worker code...');\n\t\t\tconsole.time('buildWebWorkerCode');\n\t\t}\n\t\tif (Validator.isValid(runnerImpl)) {\n\n\t\t\tif (this.logging.enabled) console.info('WorkerSupport: Using \"' + runnerImpl.name + '\" as Runner class for worker.');\n\t\t} else {\n\n\t\t\trunnerImpl = LoaderSupport.WorkerRunnerRefImpl;\n\t\t\tif (this.logging.enabled) console.info('WorkerSupport: Using DEFAULT \"THREE.LoaderSupport.WorkerRunnerRefImpl\" as Runner class for worker.');\n\t\t}\n\n\t\tvar userWorkerCode = functionCodeBuilder(buildObject, buildSingleton);\n\t\tuserWorkerCode += 'var Parser = ' + parserName + ';\\n\\n';\n\t\tuserWorkerCode += buildSingleton(runnerImpl.name, runnerImpl);\n\t\tuserWorkerCode += 'new ' + runnerImpl.name + '();\\n\\n';\n\n\t\tvar scope = this;\n\t\tif (Validator.isValid(libLocations) && libLocations.length > 0) {\n\n\t\t\tvar libsContent = '';\n\t\t\tvar loadAllLibraries = function loadAllLibraries(path, locations) {\n\t\t\t\tif (locations.length === 0) {\n\n\t\t\t\t\tscope.loaderWorker.initWorker(libsContent + userWorkerCode, runnerImpl.name);\n\t\t\t\t\tif (scope.logging.enabled) console.timeEnd('buildWebWorkerCode');\n\t\t\t\t} else {\n\n\t\t\t\t\tvar loadedLib = function loadedLib(contentAsString) {\n\t\t\t\t\t\tlibsContent += contentAsString;\n\t\t\t\t\t\tloadAllLibraries(path, locations);\n\t\t\t\t\t};\n\n\t\t\t\t\tvar fileLoader = new THREE.FileLoader();\n\t\t\t\t\tfileLoader.setPath(path);\n\t\t\t\t\tfileLoader.setResponseType('text');\n\t\t\t\t\tfileLoader.load(locations[0], loadedLib);\n\t\t\t\t\tlocations.shift();\n\t\t\t\t}\n\t\t\t};\n\t\t\tloadAllLibraries(libPath, libLocations);\n\t\t} else {\n\n\t\t\tthis.loaderWorker.initWorker(userWorkerCode, runnerImpl.name);\n\t\t\tif (this.logging.enabled) console.timeEnd('buildWebWorkerCode');\n\t\t}\n\t};\n\n\t/**\n  * Specify functions that should be build when new raw mesh data becomes available and when the parser is finished.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {Function} meshBuilder The mesh builder function. Default is {@link THREE.LoaderSupport.MeshBuilder}.\n  * @param {Function} onLoad The function that is called when parsing is complete.\n  */\n\tWorkerSupport.prototype.setCallbacks = function (meshBuilder, onLoad) {\n\t\tthis.loaderWorker.setCallbacks(meshBuilder, onLoad);\n\t};\n\n\t/**\n  * Runs the parser with the provided configuration.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n  */\n\tWorkerSupport.prototype.run = function (payload) {\n\t\tthis.loaderWorker.run(payload);\n\t};\n\n\t/**\n  * Request termination of worker once parser is finished.\n  * @memberOf THREE.LoaderSupport.WorkerSupport\n  *\n  * @param {boolean} terminateRequested True or false.\n  */\n\tWorkerSupport.prototype.setTerminateRequested = function (terminateRequested) {\n\t\tthis.loaderWorker.setTerminateRequested(terminateRequested);\n\t};\n\n\tvar buildObject = function buildObject(fullName, object) {\n\t\tvar objectString = fullName + ' = {\\n';\n\t\tvar part;\n\t\tfor (var name in object) {\n\n\t\t\tpart = object[name];\n\t\t\tif (typeof part === 'string' || part instanceof String) {\n\n\t\t\t\tpart = part.replace('\\n', '\\\\n');\n\t\t\t\tpart = part.replace('\\r', '\\\\r');\n\t\t\t\tobjectString += '\\t' + name + ': \"' + part + '\",\\n';\n\t\t\t} else if (part instanceof Array) {\n\n\t\t\t\tobjectString += '\\t' + name + ': [' + part + '],\\n';\n\t\t\t} else if (Number.isInteger(part)) {\n\n\t\t\t\tobjectString += '\\t' + name + ': ' + part + ',\\n';\n\t\t\t} else if (typeof part === 'function') {\n\n\t\t\t\tobjectString += '\\t' + name + ': ' + part + ',\\n';\n\t\t\t}\n\t\t}\n\t\tobjectString += '}\\n\\n';\n\n\t\treturn objectString;\n\t};\n\n\tvar buildSingleton = function buildSingleton(fullName, object, internalName, basePrototypeName, ignoreFunctions) {\n\t\tvar objectString = '';\n\t\tvar objectName = Validator.isValid(internalName) ? internalName : object.name;\n\n\t\tvar funcString, objectPart, constructorString;\n\t\tignoreFunctions = Validator.verifyInput(ignoreFunctions, []);\n\t\tfor (var name in object.prototype) {\n\n\t\t\tobjectPart = object.prototype[name];\n\t\t\tif (name === 'constructor') {\n\n\t\t\t\tfuncString = objectPart.toString();\n\t\t\t\tfuncString = funcString.replace('function', '');\n\t\t\t\tconstructorString = '\\tfunction ' + objectName + funcString + ';\\n\\n';\n\t\t\t} else if (typeof objectPart === 'function') {\n\n\t\t\t\tif (ignoreFunctions.indexOf(name) < 0) {\n\n\t\t\t\t\tfuncString = objectPart.toString();\n\t\t\t\t\tobjectString += '\\t' + objectName + '.prototype.' + name + ' = ' + funcString + ';\\n\\n';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tobjectString += '\\treturn ' + objectName + ';\\n';\n\t\tobjectString += '})();\\n\\n';\n\n\t\tvar inheritanceBlock = '';\n\t\tif (Validator.isValid(basePrototypeName)) {\n\n\t\t\tinheritanceBlock += '\\n';\n\t\t\tinheritanceBlock += objectName + '.prototype = Object.create( ' + basePrototypeName + '.prototype );\\n';\n\t\t\tinheritanceBlock += objectName + '.constructor = ' + objectName + ';\\n';\n\t\t\tinheritanceBlock += '\\n';\n\t\t}\n\t\tif (!Validator.isValid(constructorString)) {\n\n\t\t\tconstructorString = fullName + ' = (function () {\\n\\n';\n\t\t\tconstructorString += inheritanceBlock + '\\t' + object.prototype.constructor.toString() + '\\n\\n';\n\t\t\tobjectString = constructorString + objectString;\n\t\t} else {\n\n\t\t\tobjectString = fullName + ' = (function () {\\n\\n' + inheritanceBlock + constructorString + objectString;\n\t\t}\n\n\t\treturn objectString;\n\t};\n\n\treturn WorkerSupport;\n}();\n\n/**\n * Orchestrate loading of multiple OBJ files/data from an instruction queue with a configurable amount of workers (1-16).\n * Workflow:\n *   prepareWorkers\n *   enqueueForRun\n *   processQueue\n *   tearDown (to force stop)\n *\n * @class\n *\n * @param {string} classDef Class definition to be used for construction\n */\nLoaderSupport.WorkerDirector = function () {\n\n\tvar LOADER_WORKER_DIRECTOR_VERSION = '2.2.0';\n\n\tvar Validator = LoaderSupport.Validator;\n\n\tvar MAX_WEB_WORKER = 16;\n\tvar MAX_QUEUE_SIZE = 8192;\n\n\tfunction WorkerDirector(classDef) {\n\t\tconsole.info('Using THREE.LoaderSupport.WorkerDirector version: ' + LOADER_WORKER_DIRECTOR_VERSION);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\tthis.maxQueueSize = MAX_QUEUE_SIZE;\n\t\tthis.maxWebWorkers = MAX_WEB_WORKER;\n\t\tthis.crossOrigin = null;\n\n\t\tif (!Validator.isValid(classDef)) throw 'Provided invalid classDef: ' + classDef;\n\n\t\tthis.workerDescription = {\n\t\t\tclassDef: classDef,\n\t\t\tglobalCallbacks: {},\n\t\t\tworkerSupports: {},\n\t\t\tforceWorkerDataCopy: true\n\t\t};\n\t\tthis.objectsCompleted = 0;\n\t\tthis.instructionQueue = [];\n\t\tthis.instructionQueuePointer = 0;\n\n\t\tthis.callbackOnFinishedProcessing = null;\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tWorkerDirector.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t};\n\n\t/**\n  * Returns the maximum length of the instruction queue.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @returns {number}\n  */\n\tWorkerDirector.prototype.getMaxQueueSize = function () {\n\t\treturn this.maxQueueSize;\n\t};\n\n\t/**\n  * Returns the maximum number of workers.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @returns {number}\n  */\n\tWorkerDirector.prototype.getMaxWebWorkers = function () {\n\t\treturn this.maxWebWorkers;\n\t};\n\n\t/**\n  * Sets the CORS string to be used.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {string} crossOrigin CORS value\n  */\n\tWorkerDirector.prototype.setCrossOrigin = function (crossOrigin) {\n\t\tthis.crossOrigin = crossOrigin;\n\t};\n\n\t/**\n  * Forces all ArrayBuffers to be transferred to worker to be copied.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {boolean} forceWorkerDataCopy True or false.\n  */\n\tWorkerDirector.prototype.setForceWorkerDataCopy = function (forceWorkerDataCopy) {\n\t\tthis.workerDescription.forceWorkerDataCopy = forceWorkerDataCopy === true;\n\t};\n\n\t/**\n  * Create or destroy workers according limits. Set the name and register callbacks for dynamically created web workers.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {THREE.OBJLoader2.WWOBJLoader2.PrepDataCallbacks} globalCallbacks  Register global callbacks used by all web workers\n  * @param {number} maxQueueSize Set the maximum size of the instruction queue (1-1024)\n  * @param {number} maxWebWorkers Set the maximum amount of workers (1-16)\n  */\n\tWorkerDirector.prototype.prepareWorkers = function (globalCallbacks, maxQueueSize, maxWebWorkers) {\n\t\tif (Validator.isValid(globalCallbacks)) this.workerDescription.globalCallbacks = globalCallbacks;\n\t\tthis.maxQueueSize = Math.min(maxQueueSize, MAX_QUEUE_SIZE);\n\t\tthis.maxWebWorkers = Math.min(maxWebWorkers, MAX_WEB_WORKER);\n\t\tthis.maxWebWorkers = Math.min(this.maxWebWorkers, this.maxQueueSize);\n\t\tthis.objectsCompleted = 0;\n\t\tthis.instructionQueue = [];\n\t\tthis.instructionQueuePointer = 0;\n\n\t\tfor (var instanceNo = 0; instanceNo < this.maxWebWorkers; instanceNo++) {\n\n\t\t\tvar workerSupport = new THREE.LoaderSupport.WorkerSupport();\n\t\t\tworkerSupport.setLogging(this.logging.enabled, this.logging.debug);\n\t\t\tworkerSupport.setForceWorkerDataCopy(this.workerDescription.forceWorkerDataCopy);\n\t\t\tthis.workerDescription.workerSupports[instanceNo] = {\n\t\t\t\tinstanceNo: instanceNo,\n\t\t\t\tinUse: false,\n\t\t\t\tterminateRequested: false,\n\t\t\t\tworkerSupport: workerSupport,\n\t\t\t\tloader: null\n\t\t\t};\n\t\t}\n\t};\n\n\t/**\n  * Store run instructions in internal instructionQueue.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {THREE.LoaderSupport.PrepData} prepData\n  */\n\tWorkerDirector.prototype.enqueueForRun = function (prepData) {\n\t\tif (this.instructionQueue.length < this.maxQueueSize) {\n\t\t\tthis.instructionQueue.push(prepData);\n\t\t}\n\t};\n\n\t/**\n  * Returns if any workers are running.\n  *\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  * @returns {boolean}\n  */\n\tWorkerDirector.prototype.isRunning = function () {\n\t\tvar wsKeys = Object.keys(this.workerDescription.workerSupports);\n\t\treturn this.instructionQueue.length > 0 && this.instructionQueuePointer < this.instructionQueue.length || wsKeys.length > 0;\n\t};\n\n\t/**\n  * Process the instructionQueue until it is depleted.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  */\n\tWorkerDirector.prototype.processQueue = function () {\n\t\tvar prepData, supportDesc;\n\t\tfor (var instanceNo in this.workerDescription.workerSupports) {\n\n\t\t\tsupportDesc = this.workerDescription.workerSupports[instanceNo];\n\t\t\tif (!supportDesc.inUse) {\n\n\t\t\t\tif (this.instructionQueuePointer < this.instructionQueue.length) {\n\n\t\t\t\t\tprepData = this.instructionQueue[this.instructionQueuePointer];\n\t\t\t\t\tthis._kickWorkerRun(prepData, supportDesc);\n\t\t\t\t\tthis.instructionQueuePointer++;\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._deregister(supportDesc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isRunning() && this.callbackOnFinishedProcessing !== null) {\n\n\t\t\tthis.callbackOnFinishedProcessing();\n\t\t\tthis.callbackOnFinishedProcessing = null;\n\t\t}\n\t};\n\n\tWorkerDirector.prototype._kickWorkerRun = function (prepData, supportDesc) {\n\t\tsupportDesc.inUse = true;\n\t\tsupportDesc.workerSupport.setTerminateRequested(supportDesc.terminateRequested);\n\n\t\tif (this.logging.enabled) console.info('\\nAssigning next item from queue to worker (queue length: ' + this.instructionQueue.length + ')\\n\\n');\n\n\t\tvar scope = this;\n\t\tvar prepDataCallbacks = prepData.getCallbacks();\n\t\tvar globalCallbacks = this.workerDescription.globalCallbacks;\n\t\tvar wrapperOnLoad = function wrapperOnLoad(event) {\n\t\t\tif (Validator.isValid(globalCallbacks.onLoad)) globalCallbacks.onLoad(event);\n\t\t\tif (Validator.isValid(prepDataCallbacks.onLoad)) prepDataCallbacks.onLoad(event);\n\t\t\tscope.objectsCompleted++;\n\t\t\tsupportDesc.inUse = false;\n\n\t\t\tscope.processQueue();\n\t\t};\n\n\t\tvar wrapperOnProgress = function wrapperOnProgress(event) {\n\t\t\tif (Validator.isValid(globalCallbacks.onProgress)) globalCallbacks.onProgress(event);\n\t\t\tif (Validator.isValid(prepDataCallbacks.onProgress)) prepDataCallbacks.onProgress(event);\n\t\t};\n\n\t\tvar wrapperOnMeshAlter = function wrapperOnMeshAlter(event) {\n\t\t\tif (Validator.isValid(globalCallbacks.onMeshAlter)) globalCallbacks.onMeshAlter(event);\n\t\t\tif (Validator.isValid(prepDataCallbacks.onMeshAlter)) prepDataCallbacks.onMeshAlter(event);\n\t\t};\n\n\t\tsupportDesc.loader = this._buildLoader(supportDesc.instanceNo);\n\n\t\tvar updatedCallbacks = new LoaderSupport.Callbacks();\n\t\tupdatedCallbacks.setCallbackOnLoad(wrapperOnLoad);\n\t\tupdatedCallbacks.setCallbackOnProgress(wrapperOnProgress);\n\t\tupdatedCallbacks.setCallbackOnMeshAlter(wrapperOnMeshAlter);\n\t\tprepData.callbacks = updatedCallbacks;\n\n\t\tsupportDesc.loader.run(prepData, supportDesc.workerSupport);\n\t};\n\n\tWorkerDirector.prototype._buildLoader = function (instanceNo) {\n\t\tvar classDef = this.workerDescription.classDef;\n\t\tvar loader = Object.create(classDef.prototype);\n\t\tclassDef.call(loader, THREE.DefaultLoadingManager);\n\n\t\t// verify that all required functions are implemented\n\t\tif (!loader.hasOwnProperty('instanceNo')) throw classDef.name + ' has no property \"instanceNo\".';\n\t\tloader.instanceNo = instanceNo;\n\n\t\tif (!loader.hasOwnProperty('workerSupport')) {\n\n\t\t\tthrow classDef.name + ' has no property \"workerSupport\".';\n\t\t}\n\t\tif (typeof loader.run !== 'function') throw classDef.name + ' has no function \"run\".';\n\t\tif (!loader.hasOwnProperty('callbacks') || !Validator.isValid(loader.callbacks)) {\n\n\t\t\tconsole.warn(classDef.name + ' has an invalid property \"callbacks\". Will change to \"THREE.LoaderSupport.Callbacks\"');\n\t\t\tloader.callbacks = new THREE.LoaderSupport.Callbacks();\n\t\t}\n\n\t\treturn loader;\n\t};\n\n\tWorkerDirector.prototype._deregister = function (supportDesc) {\n\t\tif (Validator.isValid(supportDesc)) {\n\n\t\t\tsupportDesc.workerSupport.setTerminateRequested(true);\n\t\t\tif (this.logging.enabled) console.info('Requested termination of worker #' + supportDesc.instanceNo + '.');\n\n\t\t\tvar loaderCallbacks = supportDesc.loader.callbacks;\n\t\t\tif (Validator.isValid(loaderCallbacks.onProgress)) loaderCallbacks.onProgress({ detail: { text: '' } });\n\t\t\tdelete this.workerDescription.workerSupports[supportDesc.instanceNo];\n\t\t}\n\t};\n\n\t/**\n  * Terminate all workers.\n  * @memberOf THREE.LoaderSupport.WorkerDirector\n  *\n  * @param {callback} callbackOnFinishedProcessing Function called once all workers finished processing.\n  */\n\tWorkerDirector.prototype.tearDown = function (callbackOnFinishedProcessing) {\n\t\tif (this.logging.enabled) console.info('WorkerDirector received the deregister call. Terminating all workers!');\n\n\t\tthis.instructionQueuePointer = this.instructionQueue.length;\n\t\tthis.callbackOnFinishedProcessing = Validator.verifyInput(callbackOnFinishedProcessing, null);\n\n\t\tfor (var name in this.workerDescription.workerSupports) {\n\n\t\t\tthis.workerDescription.workerSupports[name].terminateRequested = true;\n\t\t}\n\t};\n\n\treturn WorkerDirector;\n}();\n\nexports.default = LoaderSupport;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67)))\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Loads a Wavefront .mtl file specifying materials\n *\n * @author angelxuanchang\n */\n\nvar MTLLoader = function MTLLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nMTLLoader.prototype = {\n\n\tconstructor: MTLLoader,\n\n\t/**\n  * Loads and parses a MTL asset from a URL.\n  *\n  * @param {String} url - URL to the MTL file.\n  * @param {Function} [onLoad] - Callback invoked with the loaded object.\n  * @param {Function} [onProgress] - Callback for download progress.\n  * @param {Function} [onError] - Callback for download errors.\n  *\n  * @see setPath setTexturePath\n  *\n  * @note In order for relative texture references to resolve correctly\n  * you must call setPath and/or setTexturePath explicitly prior to load.\n  */\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setPath(this.path);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\t/**\n  * Set base path for resolving references.\n  * If set this path will be prepended to each loaded and found reference.\n  *\n  * @see setTexturePath\n  * @param {String} path\n  * @return {THREE.MTLLoader}\n  *\n  * @example\n  *     mtlLoader.setPath( 'assets/obj/' );\n  *     mtlLoader.load( 'my.mtl', ... );\n  */\n\tsetPath: function setPath(path) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\t},\n\n\t/**\n  * Set base path for resolving texture references.\n  * If set this path will be prepended found texture reference.\n  * If not set and setPath is, it will be used as texture base path.\n  *\n  * @see setPath\n  * @param {String} path\n  * @return {THREE.MTLLoader}\n  *\n  * @example\n  *     mtlLoader.setPath( 'assets/obj/' );\n  *     mtlLoader.setTexturePath( 'assets/textures/' );\n  *     mtlLoader.load( 'my.mtl', ... );\n  */\n\tsetTexturePath: function setTexturePath(path) {\n\n\t\tthis.texturePath = path;\n\t\treturn this;\n\t},\n\n\tsetBaseUrl: function setBaseUrl(path) {\n\n\t\tconsole.warn('THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.');\n\n\t\treturn this.setTexturePath(path);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t\treturn this;\n\t},\n\n\tsetMaterialOptions: function setMaterialOptions(value) {\n\n\t\tthis.materialOptions = value;\n\t\treturn this;\n\t},\n\n\t/**\n  * Parses a MTL file.\n  *\n  * @param {String} text - Content of MTL file\n  * @return {MTLLoader.MaterialCreator}\n  *\n  * @see setPath setTexturePath\n  *\n  * @note In order for relative texture references to resolve correctly\n  * you must call setPath and/or setTexturePath explicitly prior to parse.\n  */\n\tparse: function parse(text) {\n\n\t\tvar lines = text.split('\\n');\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialsInfo = {};\n\n\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\tvar line = lines[i];\n\t\t\tline = line.trim();\n\n\t\t\tif (line.length === 0 || line.charAt(0) === '#') {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf(' ');\n\n\t\t\tvar key = pos >= 0 ? line.substring(0, pos) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = pos >= 0 ? line.substring(pos + 1) : '';\n\t\t\tvalue = value.trim();\n\n\t\t\tif (key === 'newmtl') {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value };\n\t\t\t\tmaterialsInfo[value] = info;\n\t\t\t} else if (info) {\n\n\t\t\t\tif (key === 'ka' || key === 'kd' || key === 'ks') {\n\n\t\t\t\t\tvar ss = value.split(delimiter_pattern, 3);\n\t\t\t\t\tinfo[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar materialCreator = new MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);\n\t\tmaterialCreator.setCrossOrigin(this.crossOrigin);\n\t\tmaterialCreator.setManager(this.manager);\n\t\tmaterialCreator.setMaterials(materialsInfo);\n\t\treturn materialCreator;\n\t}\n\n};\n\n/**\n * Create a new THREE-MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n * @constructor\n */\n\nMTLLoader.MaterialCreator = function (baseUrl, options) {\n\n\tthis.baseUrl = baseUrl || '';\n\tthis.options = options;\n\tthis.materialsInfo = {};\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\n\tthis.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;\n\tthis.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;\n};\n\nMTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: MTLLoader.MaterialCreator,\n\n\tcrossOrigin: 'Anonymous',\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tsetManager: function setManager(value) {\n\n\t\tthis.manager = value;\n\t},\n\n\tsetMaterials: function setMaterials(materialsInfo) {\n\n\t\tthis.materialsInfo = this.convert(materialsInfo);\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\t},\n\n\tconvert: function convert(materialsInfo) {\n\n\t\tif (!this.options) return materialsInfo;\n\n\t\tvar converted = {};\n\n\t\tfor (var mn in materialsInfo) {\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[mn];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[mn] = covmat;\n\n\t\t\tfor (var prop in mat) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[prop];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch (lprop) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif (this.options && this.options.normalizeRGB) {\n\n\t\t\t\t\t\t\tvalue = [value[0] / 255, value[1] / 255, value[2] / 255];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (this.options && this.options.ignoreZeroRGBs) {\n\n\t\t\t\t\t\t\tif (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (save) {\n\n\t\t\t\t\tcovmat[lprop] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn converted;\n\t},\n\n\tpreload: function preload() {\n\n\t\tfor (var mn in this.materialsInfo) {\n\n\t\t\tthis.create(mn);\n\t\t}\n\t},\n\n\tgetIndex: function getIndex(materialName) {\n\n\t\treturn this.nameLookup[materialName];\n\t},\n\n\tgetAsArray: function getAsArray() {\n\n\t\tvar index = 0;\n\n\t\tfor (var mn in this.materialsInfo) {\n\n\t\t\tthis.materialsArray[index] = this.create(mn);\n\t\t\tthis.nameLookup[mn] = index;\n\t\t\tindex++;\n\t\t}\n\n\t\treturn this.materialsArray;\n\t},\n\n\tcreate: function create(materialName) {\n\n\t\tif (this.materials[materialName] === undefined) {\n\n\t\t\tthis.createMaterial_(materialName);\n\t\t}\n\n\t\treturn this.materials[materialName];\n\t},\n\n\tcreateMaterial_: function createMaterial_(materialName) {\n\n\t\t// Create material\n\n\t\tvar scope = this;\n\t\tvar mat = this.materialsInfo[materialName];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfunction resolveURL(baseUrl, url) {\n\n\t\t\tif (typeof url !== 'string' || url === '') return '';\n\n\t\t\t// Absolute URL\n\t\t\tif (/^https?:\\/\\//i.test(url)) return url;\n\n\t\t\treturn baseUrl + url;\n\t\t}\n\n\t\tfunction setMapForType(mapType, value) {\n\n\t\t\tif (params[mapType]) return; // Keep the first encountered texture\n\n\t\t\tvar texParams = scope.getTextureParams(value, params);\n\t\t\tvar map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n\t\t\tmap.repeat.copy(texParams.scale);\n\t\t\tmap.offset.copy(texParams.offset);\n\n\t\t\tmap.wrapS = scope.wrap;\n\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\tparams[mapType] = map;\n\t\t}\n\n\t\tfor (var prop in mat) {\n\n\t\t\tvar value = mat[prop];\n\t\t\tvar n;\n\n\t\t\tif (value === '') continue;\n\n\t\t\tswitch (prop.toLowerCase()) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams.color = new THREE.Color().fromArray(value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams.specular = new THREE.Color().fromArray(value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\tsetMapForType(\"map\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t// Specular map\n\n\t\t\t\t\tsetMapForType(\"specularMap\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'norm':\n\n\t\t\t\t\tsetMapForType(\"normalMap\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tsetMapForType(\"bumpMap\", value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams.shininess = parseFloat(value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\t\t\t\t\tn = parseFloat(value);\n\n\t\t\t\t\tif (n < 1) {\n\n\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\tparams.transparent = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'tr':\n\t\t\t\t\tn = parseFloat(value);\n\n\t\t\t\t\tif (this.options && this.options.invertTrProperty) n = 1 - n;\n\n\t\t\t\t\tif (n > 0) {\n\n\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\tparams.transparent = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\tthis.materials[materialName] = new THREE.MeshPhongMaterial(params);\n\t\treturn this.materials[materialName];\n\t},\n\n\tgetTextureParams: function getTextureParams(value, matParams) {\n\n\t\tvar texParams = {\n\n\t\t\tscale: new THREE.Vector2(1, 1),\n\t\t\toffset: new THREE.Vector2(0, 0)\n\n\t\t};\n\n\t\tvar items = value.split(/\\s+/);\n\t\tvar pos;\n\n\t\tpos = items.indexOf('-bm');\n\n\t\tif (pos >= 0) {\n\n\t\t\tmatParams.bumpScale = parseFloat(items[pos + 1]);\n\t\t\titems.splice(pos, 2);\n\t\t}\n\n\t\tpos = items.indexOf('-s');\n\n\t\tif (pos >= 0) {\n\n\t\t\ttexParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\n\t\t}\n\n\t\tpos = items.indexOf('-o');\n\n\t\tif (pos >= 0) {\n\n\t\t\ttexParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\n\t\t}\n\n\t\ttexParams.url = items.join(' ').trim();\n\t\treturn texParams;\n\t},\n\n\tloadTexture: function loadTexture(url, mapping, onLoad, onProgress, onError) {\n\n\t\tvar texture;\n\t\tvar loader = THREE.Loader.Handlers.get(url);\n\t\tvar manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;\n\n\t\tif (loader === null) {\n\n\t\t\tloader = new THREE.TextureLoader(manager);\n\t\t}\n\n\t\tif (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n\t\ttexture = loader.load(url, onLoad, onProgress, onError);\n\n\t\tif (mapping !== undefined) texture.mapping = mapping;\n\n\t\treturn texture;\n\t}\n\n};\n\nexports.default = MTLLoader;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * This class had been written to handle the output of the NRRD loader.\n * It contains a volume of data and informations about it.\n * For now it only handles 3 dimensional data.\n * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.\n * @class\n * @author Valentin Demeusy / https://github.com/stity\n * @param   {number}        xLength         Width of the volume\n * @param   {number}        yLength         Length of the volume\n * @param   {number}        zLength         Depth of the volume\n * @param   {string}        type            The type of data (uint8, uint16, ...)\n * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data\n */\nvar Volume = function Volume(xLength, yLength, zLength, type, arrayBuffer) {\n\n\tif (arguments.length > 0) {\n\n\t\t/**\n   * @member {number} xLength Width of the volume in the IJK coordinate system\n   */\n\t\tthis.xLength = Number(xLength) || 1;\n\t\t/**\n   * @member {number} yLength Height of the volume in the IJK coordinate system\n   */\n\t\tthis.yLength = Number(yLength) || 1;\n\t\t/**\n   * @member {number} zLength Depth of the volume in the IJK coordinate system\n   */\n\t\tthis.zLength = Number(zLength) || 1;\n\n\t\t/**\n   * @member {TypedArray} data Data of the volume\n   */\n\n\t\tswitch (type) {\n\n\t\t\tcase 'Uint8':\n\t\t\tcase 'uint8':\n\t\t\tcase 'uchar':\n\t\t\tcase 'unsigned char':\n\t\t\tcase 'uint8_t':\n\t\t\t\tthis.data = new Uint8Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Int8':\n\t\t\tcase 'int8':\n\t\t\tcase 'signed char':\n\t\t\tcase 'int8_t':\n\t\t\t\tthis.data = new Int8Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Int16':\n\t\t\tcase 'int16':\n\t\t\tcase 'short':\n\t\t\tcase 'short int':\n\t\t\tcase 'signed short':\n\t\t\tcase 'signed short int':\n\t\t\tcase 'int16_t':\n\t\t\t\tthis.data = new Int16Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Uint16':\n\t\t\tcase 'uint16':\n\t\t\tcase 'ushort':\n\t\t\tcase 'unsigned short':\n\t\t\tcase 'unsigned short int':\n\t\t\tcase 'uint16_t':\n\t\t\t\tthis.data = new Uint16Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Int32':\n\t\t\tcase 'int32':\n\t\t\tcase 'int':\n\t\t\tcase 'signed int':\n\t\t\tcase 'int32_t':\n\t\t\t\tthis.data = new Int32Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Uint32':\n\t\t\tcase 'uint32':\n\t\t\tcase 'uint':\n\t\t\tcase 'unsigned int':\n\t\t\tcase 'uint32_t':\n\t\t\t\tthis.data = new Uint32Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'longlong':\n\t\t\tcase 'long long':\n\t\t\tcase 'long long int':\n\t\t\tcase 'signed long long':\n\t\t\tcase 'signed long long int':\n\t\t\tcase 'int64':\n\t\t\tcase 'int64_t':\n\t\t\tcase 'ulonglong':\n\t\t\tcase 'unsigned long long':\n\t\t\tcase 'unsigned long long int':\n\t\t\tcase 'uint64':\n\t\t\tcase 'uint64_t':\n\t\t\t\tthrow 'Error in THREE.Volume constructor : this type is not supported in JavaScript';\n\t\t\t\tbreak;\n\t\t\tcase 'Float32':\n\t\t\tcase 'float32':\n\t\t\tcase 'float':\n\t\t\t\tthis.data = new Float32Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tcase 'Float64':\n\t\t\tcase 'float64':\n\t\t\tcase 'double':\n\t\t\t\tthis.data = new Float64Array(arrayBuffer);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.data = new Uint8Array(arrayBuffer);\n\n\t\t}\n\n\t\tif (this.data.length !== this.xLength * this.yLength * this.zLength) {\n\n\t\t\tthrow 'Error in THREE.Volume constructor, lengths are not matching arrayBuffer size';\n\t\t}\n\t}\n\n\t/**\n  * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system\n  */\n\tthis.spacing = [1, 1, 1];\n\t/**\n  * @member {Array}  offset Offset of the volume in the RAS coordinate system\n  */\n\tthis.offset = [0, 0, 0];\n\t/**\n  * @member {THREE.Martrix3} matrix The IJK to RAS matrix\n  */\n\tthis.matrix = new THREE.Matrix3();\n\tthis.matrix.identity();\n\t/**\n  * @member {THREE.Martrix3} inverseMatrix The RAS to IJK matrix\n  */\n\t/**\n  * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.\n  *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n  */\n\tvar lowerThreshold = -Infinity;\n\tObject.defineProperty(this, 'lowerThreshold', {\n\t\tget: function get() {\n\n\t\t\treturn lowerThreshold;\n\t\t},\n\t\tset: function set(value) {\n\n\t\t\tlowerThreshold = value;\n\t\t\tthis.sliceList.forEach(function (slice) {\n\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t});\n\t\t}\n\t});\n\t/**\n  * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.\n  *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n  */\n\tvar upperThreshold = Infinity;\n\tObject.defineProperty(this, 'upperThreshold', {\n\t\tget: function get() {\n\n\t\t\treturn upperThreshold;\n\t\t},\n\t\tset: function set(value) {\n\n\t\t\tupperThreshold = value;\n\t\t\tthis.sliceList.forEach(function (slice) {\n\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t});\n\t\t}\n\t});\n\n\t/**\n  * @member {Array} sliceList The list of all the slices associated to this volume\n  */\n\tthis.sliceList = [];\n\n\t/**\n  * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space\n  */\n};\n\nVolume.prototype = {\n\n\tconstructor: Volume,\n\n\t/**\n  * @member {Function} getData Shortcut for data[access(i,j,k)]\n  * @memberof THREE.Volume\n  * @param {number} i    First coordinate\n  * @param {number} j    Second coordinate\n  * @param {number} k    Third coordinate\n  * @returns {number}  value in the data array\n  */\n\tgetData: function getData(i, j, k) {\n\n\t\treturn this.data[k * this.xLength * this.yLength + j * this.xLength + i];\n\t},\n\n\t/**\n  * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system\n  * @memberof THREE.Volume\n  * @param {number} i    First coordinate\n  * @param {number} j    Second coordinate\n  * @param {number} k    Third coordinate\n  * @returns {number}  index\n  */\n\taccess: function access(i, j, k) {\n\n\t\treturn k * this.xLength * this.yLength + j * this.xLength + i;\n\t},\n\n\t/**\n  * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data\n  * @memberof THREE.Volume\n  * @param {number} index index of the voxel\n  * @returns {Array}  [x,y,z]\n  */\n\treverseAccess: function reverseAccess(index) {\n\n\t\tvar z = Math.floor(index / (this.yLength * this.xLength));\n\t\tvar y = Math.floor((index - z * this.yLength * this.xLength) / this.xLength);\n\t\tvar x = index - z * this.yLength * this.xLength - y * this.xLength;\n\t\treturn [x, y, z];\n\t},\n\n\t/**\n  * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced\n  * @memberof THREE.Volume\n  * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :\n  *                                 value of the voxel\n  *                                 index of the voxel\n  *                                 the data (TypedArray)\n  * @param {Object}   context    You can specify a context in which call the function, default if this Volume\n  * @returns {THREE.Volume}   this\n  */\n\tmap: function map(functionToMap, context) {\n\n\t\tvar length = this.data.length;\n\t\tcontext = context || this;\n\n\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\tthis.data[i] = functionToMap.call(context, this.data[i], i, this.data);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n  * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\n  * @memberof THREE.Volume\n  * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n  * @param {number}            index the index of the slice\n  * @returns {Object} an object containing all the usefull information on the geometry of the slice\n  */\n\textractPerpendicularPlane: function extractPerpendicularPlane(axis, RASIndex) {\n\n\t\tvar iLength,\n\t\t    jLength,\n\t\t    sliceAccess,\n\t\t    planeMatrix = new THREE.Matrix4().identity(),\n\t\t    volume = this,\n\t\t    planeWidth,\n\t\t    planeHeight,\n\t\t    firstSpacing,\n\t\t    secondSpacing,\n\t\t    positionOffset,\n\t\t    IJKIndex;\n\n\t\tvar axisInIJK = new THREE.Vector3(),\n\t\t    firstDirection = new THREE.Vector3(),\n\t\t    secondDirection = new THREE.Vector3();\n\n\t\tvar dimensions = new THREE.Vector3(this.xLength, this.yLength, this.zLength);\n\n\t\tswitch (axis) {\n\n\t\t\tcase 'x':\n\t\t\t\taxisInIJK.set(1, 0, 0);\n\t\t\t\tfirstDirection.set(0, 0, -1);\n\t\t\t\tsecondDirection.set(0, -1, 0);\n\t\t\t\tfirstSpacing = this.spacing[2];\n\t\t\t\tsecondSpacing = this.spacing[1];\n\t\t\t\tIJKIndex = new THREE.Vector3(RASIndex, 0, 0);\n\n\t\t\t\tplaneMatrix.multiply(new THREE.Matrix4().makeRotationY(Math.PI / 2));\n\t\t\t\tpositionOffset = (volume.RASDimensions[0] - 1) / 2;\n\t\t\t\tplaneMatrix.setPosition(new THREE.Vector3(RASIndex - positionOffset, 0, 0));\n\t\t\t\tbreak;\n\t\t\tcase 'y':\n\t\t\t\taxisInIJK.set(0, 1, 0);\n\t\t\t\tfirstDirection.set(1, 0, 0);\n\t\t\t\tsecondDirection.set(0, 0, 1);\n\t\t\t\tfirstSpacing = this.spacing[0];\n\t\t\t\tsecondSpacing = this.spacing[2];\n\t\t\t\tIJKIndex = new THREE.Vector3(0, RASIndex, 0);\n\n\t\t\t\tplaneMatrix.multiply(new THREE.Matrix4().makeRotationX(-Math.PI / 2));\n\t\t\t\tpositionOffset = (volume.RASDimensions[1] - 1) / 2;\n\t\t\t\tplaneMatrix.setPosition(new THREE.Vector3(0, RASIndex - positionOffset, 0));\n\t\t\t\tbreak;\n\t\t\tcase 'z':\n\t\t\tdefault:\n\t\t\t\taxisInIJK.set(0, 0, 1);\n\t\t\t\tfirstDirection.set(1, 0, 0);\n\t\t\t\tsecondDirection.set(0, -1, 0);\n\t\t\t\tfirstSpacing = this.spacing[0];\n\t\t\t\tsecondSpacing = this.spacing[1];\n\t\t\t\tIJKIndex = new THREE.Vector3(0, 0, RASIndex);\n\n\t\t\t\tpositionOffset = (volume.RASDimensions[2] - 1) / 2;\n\t\t\t\tplaneMatrix.setPosition(new THREE.Vector3(0, 0, RASIndex - positionOffset));\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfirstDirection.applyMatrix4(volume.inverseMatrix).normalize();\n\t\tfirstDirection.argVar = 'i';\n\t\tsecondDirection.applyMatrix4(volume.inverseMatrix).normalize();\n\t\tsecondDirection.argVar = 'j';\n\t\taxisInIJK.applyMatrix4(volume.inverseMatrix).normalize();\n\t\tiLength = Math.floor(Math.abs(firstDirection.dot(dimensions)));\n\t\tjLength = Math.floor(Math.abs(secondDirection.dot(dimensions)));\n\t\tplaneWidth = Math.abs(iLength * firstSpacing);\n\t\tplaneHeight = Math.abs(jLength * secondSpacing);\n\n\t\tIJKIndex = Math.abs(Math.round(IJKIndex.applyMatrix4(volume.inverseMatrix).dot(axisInIJK)));\n\t\tvar base = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];\n\t\tvar iDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n\n\t\t\treturn Math.abs(x.dot(base[0])) > 0.9;\n\t\t});\n\t\tvar jDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n\n\t\t\treturn Math.abs(x.dot(base[1])) > 0.9;\n\t\t});\n\t\tvar kDirection = [firstDirection, secondDirection, axisInIJK].find(function (x) {\n\n\t\t\treturn Math.abs(x.dot(base[2])) > 0.9;\n\t\t});\n\t\tvar argumentsWithInversion = ['volume.xLength-1-', 'volume.yLength-1-', 'volume.zLength-1-'];\n\t\t// var arguments = [ 'i', 'j', 'k' ];\n\t\tvar argArray = [iDirection, jDirection, kDirection].map(function (direction, n) {\n\n\t\t\treturn (direction.dot(base[n]) > 0 ? '' : argumentsWithInversion[n]) + (direction === axisInIJK ? 'IJKIndex' : direction.argVar);\n\t\t});\n\t\tvar argString = argArray.join(',');\n\t\tsliceAccess = eval('(function sliceAccess (i,j) {return volume.access( ' + argString + ');})');\n\n\t\treturn {\n\t\t\tiLength: iLength,\n\t\t\tjLength: jLength,\n\t\t\tsliceAccess: sliceAccess,\n\t\t\tmatrix: planeMatrix,\n\t\t\tplaneWidth: planeWidth,\n\t\t\tplaneHeight: planeHeight\n\t\t};\n\t},\n\n\t/**\n  * @member {Function} extractSlice Returns a slice corresponding to the given axis and index\n  *                        The coordinate are given in the Right Anterior Superior coordinate format\n  * @memberof THREE.Volume\n  * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n  * @param {number}            index the index of the slice\n  * @returns {THREE.VolumeSlice} the extracted slice\n  */\n\textractSlice: function extractSlice(axis, index) {\n\n\t\tvar slice = new THREE.VolumeSlice(this, index, axis);\n\t\tthis.sliceList.push(slice);\n\t\treturn slice;\n\t},\n\n\t/**\n  * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume\n  * @see THREE.VolumeSlice.repaint\n  * @memberof THREE.Volume\n  * @returns {THREE.Volume} this\n  */\n\trepaintAllSlices: function repaintAllSlices() {\n\n\t\tthis.sliceList.forEach(function (slice) {\n\n\t\t\tslice.repaint();\n\t\t});\n\n\t\treturn this;\n\t},\n\n\t/**\n  * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume\n  * @memberof THREE.Volume\n  * @returns {Array} [min,max]\n  */\n\tcomputeMinMax: function computeMinMax() {\n\n\t\tvar min = Infinity;\n\t\tvar max = -Infinity;\n\n\t\t// buffer the length\n\t\tvar datasize = this.data.length;\n\n\t\tvar i = 0;\n\t\tfor (i = 0; i < datasize; i++) {\n\n\t\t\tif (!isNaN(this.data[i])) {\n\n\t\t\t\tvar value = this.data[i];\n\t\t\t\tmin = Math.min(min, value);\n\t\t\t\tmax = Math.max(max, value);\n\t\t\t}\n\t\t}\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t\treturn [min, max];\n\t}\n\n};\n\nexports.default = Volume;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nvar LuminosityShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"float l = linearToRelativeLuminance( texel.rgb );\", \"gl_FragColor = vec4( l, l, l, texel.w );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = LuminosityShader;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author miibond\n *\n * Full-screen tone-mapping shader based on http://www.cis.rit.edu/people/faculty/ferwerda/publications/sig02_paper.pdf\n */\n\nvar ToneMapShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"averageLuminance\": { value: 1.0 },\n\t\t\"luminanceMap\": { value: null },\n\t\t\"maxLuminance\": { value: 16.0 },\n\t\t\"minLuminance\": { value: 0.01 },\n\t\t\"middleGrey\": { value: 0.6 }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform float middleGrey;\", \"uniform float minLuminance;\", \"uniform float maxLuminance;\", \"#ifdef ADAPTED_LUMINANCE\", \"uniform sampler2D luminanceMap;\", \"#else\", \"uniform float averageLuminance;\", \"#endif\", \"vec3 ToneMap( vec3 vColor ) {\", \"#ifdef ADAPTED_LUMINANCE\",\n\t// Get the calculated average luminance\n\t\"float fLumAvg = texture2D(luminanceMap, vec2(0.5, 0.5)).r;\", \"#else\", \"float fLumAvg = averageLuminance;\", \"#endif\",\n\n\t// Calculate the luminance of the current pixel\n\t\"float fLumPixel = linearToRelativeLuminance( vColor );\",\n\n\t// Apply the modified operator (Eq. 4)\n\t\"float fLumScaled = (fLumPixel * middleGrey) / max( minLuminance, fLumAvg );\", \"float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (maxLuminance * maxLuminance)))) / (1.0 + fLumScaled);\", \"return fLumCompressed * vColor;\", \"}\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = vec4( ToneMap( texel.xyz ), texel.w );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ToneMapShader;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nvar ConvolutionShader = {\n\n\tdefines: {\n\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\"KERNEL_SIZE_INT\": \"25\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"uImageIncrement\": { value: new THREE.Vector2(0.001953125, 0.0) },\n\t\t\"cKernel\": { value: [] }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float cKernel[ KERNEL_SIZE_INT ];\", \"uniform sampler2D tDiffuse;\", \"uniform vec2 uImageIncrement;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 imageCoord = vUv;\", \"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\", \"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\", \"imageCoord += uImageIncrement;\", \"}\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\"),\n\n\tbuildKernel: function buildKernel(sigma) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tfunction gauss(x, sigma) {\n\n\t\t\treturn Math.exp(-(x * x) / (2.0 * sigma * sigma));\n\t\t}\n\n\t\tvar i,\n\t\t    values,\n\t\t    sum,\n\t\t    halfWidth,\n\t\t    kMaxKernelSize = 25,\n\t\t    kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;\n\n\t\tif (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;\n\t\thalfWidth = (kernelSize - 1) * 0.5;\n\n\t\tvalues = new Array(kernelSize);\n\t\tsum = 0.0;\n\t\tfor (i = 0; i < kernelSize; ++i) {\n\n\t\t\tvalues[i] = gauss(i - halfWidth, sigma);\n\t\t\tsum += values[i];\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor (i = 0; i < kernelSize; ++i) {\n\t\t\tvalues[i] /= sum;\n\t\t}return values;\n\t}\n\n};\n\nexports.default = ConvolutionShader;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n */\n\nvar BokehShader = {\n\n\tdefines: {\n\t\t\"DEPTH_PACKING\": 1,\n\t\t\"PERSPECTIVE_CAMERA\": 1\n\t},\n\n\tuniforms: {\n\n\t\t\"tColor\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"focus\": { value: 1.0 },\n\t\t\"aspect\": { value: 1.0 },\n\t\t\"aperture\": { value: 0.025 },\n\t\t\"maxblur\": { value: 1.0 },\n\t\t\"nearClip\": { value: 1.0 },\n\t\t\"farClip\": { value: 1000.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"varying vec2 vUv;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"uniform float maxblur;\", // max blur amount\n\t\"uniform float aperture;\", // aperture - bigger values for shallower depth of field\n\n\t\"uniform float nearClip;\", \"uniform float farClip;\", \"uniform float focus;\", \"uniform float aspect;\", \"#include <packing>\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, nearClip, farClip );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, nearClip, farClip );\", \"\t#endif\", \"}\", \"void main() {\", \"vec2 aspectcorrect = vec2( 1.0, aspect );\", \"float viewZ = getViewZ( getDepth( vUv ) );\", \"float factor = ( focus + viewZ );\", // viewZ is <= 0, so this is a difference equation\n\n\t\"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\", \"vec2 dofblur9 = dofblur * 0.9;\", \"vec2 dofblur7 = dofblur * 0.7;\", \"vec2 dofblur4 = dofblur * 0.4;\", \"vec4 col = vec4( 0.0 );\", \"col += texture2D( tColor, vUv.xy );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\", \"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\", \"gl_FragColor = col / 41.0;\", \"gl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BokehShader;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nvar DotScreenShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tSize\": { value: new THREE.Vector2(256, 256) },\n\t\t\"center\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\"angle\": { value: 1.57 },\n\t\t\"scale\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform vec2 center;\", \"uniform float angle;\", \"uniform float scale;\", \"uniform vec2 tSize;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"float pattern() {\", \"float s = sin( angle ), c = cos( angle );\", \"vec2 tex = vUv * tSize - center;\", \"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\", \"return ( sin( point.x ) * sin( point.y ) ) * 4.0;\", \"}\", \"void main() {\", \"vec4 color = texture2D( tDiffuse, vUv );\", \"float average = ( color.r + color.g + color.b ) / 3.0;\", \"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = DotScreenShader;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nvar FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"time\": { value: 0.0 },\n\t\t\"nIntensity\": { value: 0.5 },\n\t\t\"sIntensity\": { value: 0.05 },\n\t\t\"sCount\": { value: 4096 },\n\t\t\"grayscale\": { value: 1 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\",\n\n\t// control parameter\n\t\"uniform float time;\", \"uniform bool grayscale;\",\n\n\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\"uniform float nIntensity;\",\n\n\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\"uniform float sIntensity;\",\n\n\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\"uniform float sCount;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\",\n\n\t// sample the source\n\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t// make some noise\n\t\"float dx = rand( vUv + time );\",\n\n\t// add noise\n\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx, 0.0, 1.0 );\",\n\n\t// get us a sine and cosine\n\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t// add scanlines\n\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t// interpolate between source and result by intensity\n\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t// convert to grayscale if desired\n\t\"if( grayscale ) {\", \"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\", \"}\", \"gl_FragColor =  vec4( cResult, cTextureScreen.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = FilmShader;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nvar DigitalGlitch = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }, //diffuse texture\n\t\t\"tDisp\": { value: null }, //displacement texture for digital glitch squares\n\t\t\"byp\": { value: 0 }, //apply the glitch ?\n\t\t\"amount\": { value: 0.08 },\n\t\t\"angle\": { value: 0.02 },\n\t\t\"seed\": { value: 0.02 },\n\t\t\"seed_x\": { value: 0.02 }, //-1,1\n\t\t\"seed_y\": { value: 0.02 }, //-1,1\n\t\t\"distortion_x\": { value: 0.5 },\n\t\t\"distortion_y\": { value: 0.6 },\n\t\t\"col_s\": { value: 0.05 }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform int byp;\", //should we apply the glitch ?\n\n\t\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDisp;\", \"uniform float amount;\", \"uniform float angle;\", \"uniform float seed;\", \"uniform float seed_x;\", \"uniform float seed_y;\", \"uniform float distortion_x;\", \"uniform float distortion_y;\", \"uniform float col_s;\", \"varying vec2 vUv;\", \"float rand(vec2 co){\", \"return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\", \"}\", \"void main() {\", \"if(byp<1) {\", \"vec2 p = vUv;\", \"float xs = floor(gl_FragCoord.x / 0.5);\", \"float ys = floor(gl_FragCoord.y / 0.5);\",\n\t//based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch\n\t\"vec4 normal = texture2D (tDisp, p*seed*seed);\", \"if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {\", \"if(seed_x>0.){\", \"p.y = 1. - (p.y + distortion_y);\", \"}\", \"else {\", \"p.y = distortion_y;\", \"}\", \"}\", \"if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {\", \"if(seed_y>0.){\", \"p.x=distortion_x;\", \"}\", \"else {\", \"p.x = 1. - (p.x + distortion_x);\", \"}\", \"}\", \"p.x+=normal.x*seed_x*(seed/5.);\", \"p.y+=normal.y*seed_y*(seed/5.);\",\n\t//base from RGB shift shader\n\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\", \"vec4 cr = texture2D(tDiffuse, p + offset);\", \"vec4 cga = texture2D(tDiffuse, p);\", \"vec4 cb = texture2D(tDiffuse, p - offset);\", \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n\t//add noise\n\t\"vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);\", \"gl_FragColor = gl_FragColor+ snow;\", \"}\", \"else {\", \"gl_FragColor=texture2D (tDiffuse, vUv);\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = DigitalGlitch;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author meatbags / xavierburrow.com, github/meatbags\n *\n * RGB Halftone shader for three.js.\n *\tNOTE:\n * \t\tShape (1 = Dot, 2 = Ellipse, 3 = Line, 4 = Square)\n *\t\tBlending Mode (1 = Linear, 2 = Multiply, 3 = Add, 4 = Lighter, 5 = Darker)\n */\n\nvar HalftoneShader = {\n\n\tuniforms: {\n\t\t\"tDiffuse\": { value: null },\n\t\t\"shape\": { value: 1 },\n\t\t\"radius\": { value: 4 },\n\t\t\"rotateR\": { value: Math.PI / 12 * 1 },\n\t\t\"rotateG\": { value: Math.PI / 12 * 2 },\n\t\t\"rotateB\": { value: Math.PI / 12 * 3 },\n\t\t\"scatter\": { value: 0 },\n\t\t\"width\": { value: 1 },\n\t\t\"height\": { value: 1 },\n\t\t\"blending\": { value: 1 },\n\t\t\"blendingMode\": { value: 1 },\n\t\t\"greyscale\": { value: false },\n\t\t\"disable\": { value: false }\n\t},\n\n\tvertexShader: [\"varying vec2 vUV;\", \"void main() {\", \"vUV = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#define SQRT2_MINUS_ONE 0.41421356\", \"#define SQRT2_HALF_MINUS_ONE 0.20710678\", \"#define PI2 6.28318531\", \"#define SHAPE_DOT 1\", \"#define SHAPE_ELLIPSE 2\", \"#define SHAPE_LINE 3\", \"#define SHAPE_SQUARE 4\", \"#define BLENDING_LINEAR 1\", \"#define BLENDING_MULTIPLY 2\", \"#define BLENDING_ADD 3\", \"#define BLENDING_LIGHTER 4\", \"#define BLENDING_DARKER 5\", \"uniform sampler2D tDiffuse;\", \"uniform float radius;\", \"uniform float rotateR;\", \"uniform float rotateG;\", \"uniform float rotateB;\", \"uniform float scatter;\", \"uniform float width;\", \"uniform float height;\", \"uniform int shape;\", \"uniform bool disable;\", \"uniform float blending;\", \"uniform int blendingMode;\", \"varying vec2 vUV;\", \"uniform bool greyscale;\", \"const int samples = 8;\", \"float blend( float a, float b, float t ) {\",\n\n\t// linear blend\n\t\"return a * ( 1.0 - t ) + b * t;\", \"}\", \"float hypot( float x, float y ) {\",\n\n\t// vector magnitude\n\t\"return sqrt( x * x + y * y );\", \"}\", \"float rand( vec2 seed ){\",\n\n\t// get pseudo-random number\n\t\"return fract( sin( dot( seed.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\", \"}\", \"float distanceToDotRadius( float channel, vec2 coord, vec2 normal, vec2 p, float angle, float rad_max ) {\",\n\n\t// apply shape-specific transforms\n\t\"float dist = hypot( coord.x - p.x, coord.y - p.y );\", \"float rad = channel;\", \"if ( shape == SHAPE_DOT ) {\", \"rad = pow( abs( rad ), 1.125 ) * rad_max;\", \"} else if ( shape == SHAPE_ELLIPSE ) {\", \"rad = pow( abs( rad ), 1.125 ) * rad_max;\", \"if ( dist != 0.0 ) {\", \"float dot_p = abs( ( p.x - coord.x ) / dist * normal.x + ( p.y - coord.y ) / dist * normal.y );\", \"dist = ( dist * ( 1.0 - SQRT2_HALF_MINUS_ONE ) ) + dot_p * dist * SQRT2_MINUS_ONE;\", \"}\", \"} else if ( shape == SHAPE_LINE ) {\", \"rad = pow( abs( rad ), 1.5) * rad_max;\", \"float dot_p = ( p.x - coord.x ) * normal.x + ( p.y - coord.y ) * normal.y;\", \"dist = hypot( normal.x * dot_p, normal.y * dot_p );\", \"} else if ( shape == SHAPE_SQUARE ) {\", \"float theta = atan( p.y - coord.y, p.x - coord.x ) - angle;\", \"float sin_t = abs( sin( theta ) );\", \"float cos_t = abs( cos( theta ) );\", \"rad = pow( abs( rad ), 1.4 );\", \"rad = rad_max * ( rad + ( ( sin_t > cos_t ) ? rad - sin_t * rad : rad - cos_t * rad ) );\", \"}\", \"return rad - dist;\", \"}\", \"struct Cell {\",\n\n\t// grid sample positions\n\t\"vec2 normal;\", \"vec2 p1;\", \"vec2 p2;\", \"vec2 p3;\", \"vec2 p4;\", \"float samp2;\", \"float samp1;\", \"float samp3;\", \"float samp4;\", \"};\", \"vec4 getSample( vec2 point ) {\",\n\n\t// multi-sampled point\n\t\"vec4 tex = texture2D( tDiffuse, vec2( point.x / width, point.y / height ) );\", \"float base = rand( vec2( floor( point.x ), floor( point.y ) ) ) * PI2;\", \"float step = PI2 / float( samples );\", \"float dist = radius * 0.66;\", \"for ( int i = 0; i < samples; ++i ) {\", \"float r = base + step * float( i );\", \"vec2 coord = point + vec2( cos( r ) * dist, sin( r ) * dist );\", \"tex += texture2D( tDiffuse, vec2( coord.x / width, coord.y / height ) );\", \"}\", \"tex /= float( samples ) + 1.0;\", \"return tex;\", \"}\", \"float getDotColour( Cell c, vec2 p, int channel, float angle, float aa ) {\",\n\n\t// get colour for given point\n\t\"float dist_c_1, dist_c_2, dist_c_3, dist_c_4, res;\", \"if ( channel == 0 ) {\", \"c.samp1 = getSample( c.p1 ).r;\", \"c.samp2 = getSample( c.p2 ).r;\", \"c.samp3 = getSample( c.p3 ).r;\", \"c.samp4 = getSample( c.p4 ).r;\", \"} else if (channel == 1) {\", \"c.samp1 = getSample( c.p1 ).g;\", \"c.samp2 = getSample( c.p2 ).g;\", \"c.samp3 = getSample( c.p3 ).g;\", \"c.samp4 = getSample( c.p4 ).g;\", \"} else {\", \"c.samp1 = getSample( c.p1 ).b;\", \"c.samp3 = getSample( c.p3 ).b;\", \"c.samp2 = getSample( c.p2 ).b;\", \"c.samp4 = getSample( c.p4 ).b;\", \"}\", \"dist_c_1 = distanceToDotRadius( c.samp1, c.p1, c.normal, p, angle, radius );\", \"dist_c_2 = distanceToDotRadius( c.samp2, c.p2, c.normal, p, angle, radius );\", \"dist_c_3 = distanceToDotRadius( c.samp3, c.p3, c.normal, p, angle, radius );\", \"dist_c_4 = distanceToDotRadius( c.samp4, c.p4, c.normal, p, angle, radius );\", \"res = ( dist_c_1 > 0.0 ) ? clamp( dist_c_1 / aa, 0.0, 1.0 ) : 0.0;\", \"res += ( dist_c_2 > 0.0 ) ? clamp( dist_c_2 / aa, 0.0, 1.0 ) : 0.0;\", \"res += ( dist_c_3 > 0.0 ) ? clamp( dist_c_3 / aa, 0.0, 1.0 ) : 0.0;\", \"res += ( dist_c_4 > 0.0 ) ? clamp( dist_c_4 / aa, 0.0, 1.0 ) : 0.0;\", \"res = clamp( res, 0.0, 1.0 );\", \"return res;\", \"}\", \"Cell getReferenceCell( vec2 p, vec2 origin, float grid_angle, float step ) {\",\n\n\t// get containing cell\n\t\"Cell c;\",\n\n\t// calc grid\n\t\"vec2 n = vec2( cos( grid_angle ), sin( grid_angle ) );\", \"float threshold = step * 0.5;\", \"float dot_normal = n.x * ( p.x - origin.x ) + n.y * ( p.y - origin.y );\", \"float dot_line = -n.y * ( p.x - origin.x ) + n.x * ( p.y - origin.y );\", \"vec2 offset = vec2( n.x * dot_normal, n.y * dot_normal );\", \"float offset_normal = mod( hypot( offset.x, offset.y ), step );\", \"float normal_dir = ( dot_normal < 0.0 ) ? 1.0 : -1.0;\", \"float normal_scale = ( ( offset_normal < threshold ) ? -offset_normal : step - offset_normal ) * normal_dir;\", \"float offset_line = mod( hypot( ( p.x - offset.x ) - origin.x, ( p.y - offset.y ) - origin.y ), step );\", \"float line_dir = ( dot_line < 0.0 ) ? 1.0 : -1.0;\", \"float line_scale = ( ( offset_line < threshold ) ? -offset_line : step - offset_line ) * line_dir;\",\n\n\t// get closest corner\n\t\"c.normal = n;\", \"c.p1.x = p.x - n.x * normal_scale + n.y * line_scale;\", \"c.p1.y = p.y - n.y * normal_scale - n.x * line_scale;\",\n\n\t// scatter\n\t\"if ( scatter != 0.0 ) {\", \"float off_mag = scatter * threshold * 0.5;\", \"float off_angle = rand( vec2( floor( c.p1.x ), floor( c.p1.y ) ) ) * PI2;\", \"c.p1.x += cos( off_angle ) * off_mag;\", \"c.p1.y += sin( off_angle ) * off_mag;\", \"}\",\n\n\t// find corners\n\t\"float normal_step = normal_dir * ( ( offset_normal < threshold ) ? step : -step );\", \"float line_step = line_dir * ( ( offset_line < threshold ) ? step : -step );\", \"c.p2.x = c.p1.x - n.x * normal_step;\", \"c.p2.y = c.p1.y - n.y * normal_step;\", \"c.p3.x = c.p1.x + n.y * line_step;\", \"c.p3.y = c.p1.y - n.x * line_step;\", \"c.p4.x = c.p1.x - n.x * normal_step + n.y * line_step;\", \"c.p4.y = c.p1.y - n.y * normal_step - n.x * line_step;\", \"return c;\", \"}\", \"float blendColour( float a, float b, float t ) {\",\n\n\t// blend colours\n\t\"if ( blendingMode == BLENDING_LINEAR ) {\", \"return blend( a, b, 1.0 - t );\", \"} else if ( blendingMode == BLENDING_ADD ) {\", \"return blend( a, min( 1.0, a + b ), t );\", \"} else if ( blendingMode == BLENDING_MULTIPLY ) {\", \"return blend( a, max( 0.0, a * b ), t );\", \"} else if ( blendingMode == BLENDING_LIGHTER ) {\", \"return blend( a, max( a, b ), t );\", \"} else if ( blendingMode == BLENDING_DARKER ) {\", \"return blend( a, min( a, b ), t );\", \"} else {\", \"return blend( a, b, 1.0 - t );\", \"}\", \"}\", \"void main() {\", \"if ( ! disable ) {\",\n\n\t// setup\n\t\"vec2 p = vec2( vUV.x * width, vUV.y * height );\", \"vec2 origin = vec2( 0, 0 );\", \"float aa = ( radius < 2.5 ) ? radius * 0.5 : 1.25;\",\n\n\t// get channel samples\n\t\"Cell cell_r = getReferenceCell( p, origin, rotateR, radius );\", \"Cell cell_g = getReferenceCell( p, origin, rotateG, radius );\", \"Cell cell_b = getReferenceCell( p, origin, rotateB, radius );\", \"float r = getDotColour( cell_r, p, 0, rotateR, aa );\", \"float g = getDotColour( cell_g, p, 1, rotateG, aa );\", \"float b = getDotColour( cell_b, p, 2, rotateB, aa );\",\n\n\t// blend with original\n\t\"vec4 colour = texture2D( tDiffuse, vUV );\", \"r = blendColour( r, colour.r, blending );\", \"g = blendColour( g, colour.g, blending );\", \"b = blendColour( b, colour.b, blending );\", \"if ( greyscale ) {\", \"r = g = b = (r + b + g) / 3.0;\", \"}\", \"gl_FragColor = vec4( r, g, b, 1.0 );\", \"} else {\", \"gl_FragColor = texture2D( tDiffuse, vUV );\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HalftoneShader;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar SAOShader = {\n\tdefines: {\n\t\t'NUM_SAMPLES': 7,\n\t\t'NUM_RINGS': 4,\n\t\t'NORMAL_TEXTURE': 0,\n\t\t'DIFFUSE_TEXTURE': 0,\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\tuniforms: {\n\n\t\t'tDepth': { type: 't', value: null },\n\t\t'tDiffuse': { type: 't', value: null },\n\t\t'tNormal': { type: 't', value: null },\n\t\t'size': { type: 'v2', value: new THREE.Vector2(512, 512) },\n\n\t\t'cameraNear': { type: 'f', value: 1 },\n\t\t'cameraFar': { type: 'f', value: 100 },\n\t\t'cameraProjectionMatrix': { type: 'm4', value: new THREE.Matrix4() },\n\t\t'cameraInverseProjectionMatrix': { type: 'm4', value: new THREE.Matrix4() },\n\n\t\t'scale': { type: 'f', value: 1.0 },\n\t\t'intensity': { type: 'f', value: 0.1 },\n\t\t'bias': { type: 'f', value: 0.5 },\n\n\t\t'minResolution': { type: 'f', value: 0.0 },\n\t\t'kernelRadius': { type: 'f', value: 100.0 },\n\t\t'randomSeed': { type: 'f', value: 0.0 }\n\t},\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"\tvUv = uv;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\tfragmentShader: [\"#include <common>\", \"varying vec2 vUv;\", \"#if DIFFUSE_TEXTURE == 1\", \"uniform sampler2D tDiffuse;\", \"#endif\", \"uniform sampler2D tDepth;\", \"#if NORMAL_TEXTURE == 1\", \"uniform sampler2D tNormal;\", \"#endif\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform mat4 cameraProjectionMatrix;\", \"uniform mat4 cameraInverseProjectionMatrix;\", \"uniform float scale;\", \"uniform float intensity;\", \"uniform float bias;\", \"uniform float kernelRadius;\", \"uniform float minResolution;\", \"uniform vec2 size;\", \"uniform float randomSeed;\", \"// RGBA depth\", \"#include <packing>\", \"vec4 getDefaultColor( const in vec2 screenPosition ) {\", \"\t#if DIFFUSE_TEXTURE == 1\", \"\treturn texture2D( tDiffuse, vUv );\", \"\t#else\", \"\treturn vec4( 1.0 );\", \"\t#endif\", \"}\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\", \"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\", \"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\", \"\tclipPosition *= clipW; // unprojection.\", \"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\", \"}\", \"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\", \"\t#if NORMAL_TEXTURE == 1\", \"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\", \"\t#else\", \"\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\", \"\t#endif\", \"}\", \"float scaleDividedByCameraFar;\", \"float minResolutionMultipliedByCameraFar;\", \"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\", \"\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\", \"\tfloat viewDistance = length( viewDelta );\", \"\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\", \"\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\", \"}\", \"// moving costly divides into consts\", \"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\", \"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\", \"float getAmbientOcclusion( const in vec3 centerViewPosition ) {\", \"\t// precompute some variables require in getOcclusion.\", \"\tscaleDividedByCameraFar = scale / cameraFar;\", \"\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\", \"\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\", \"\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\", \"\tfloat angle = rand( vUv + randomSeed ) * PI2;\", \"\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\", \"\tvec2 radiusStep = radius;\", \"\tfloat occlusionSum = 0.0;\", \"\tfloat weightSum = 0.0;\", \"\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\", \"\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\", \"\t\tradius += radiusStep;\", \"\t\tangle += ANGLE_STEP;\", \"\t\tfloat sampleDepth = getDepth( sampleUv );\", \"\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\", \"\t\t\tcontinue;\", \"\t\t}\", \"\t\tfloat sampleViewZ = getViewZ( sampleDepth );\", \"\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\", \"\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\", \"\t\tweightSum += 1.0;\", \"\t}\", \"\tif( weightSum == 0.0 ) discard;\", \"\treturn occlusionSum * ( intensity / weightSum );\", \"}\", \"void main() {\", \"\tfloat centerDepth = getDepth( vUv );\", \"\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = getViewZ( centerDepth );\", \"\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\", \"\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\", \"\tgl_FragColor = getDefaultColor( vUv );\", \"\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\", \"}\"].join(\"\\n\")\n};\n\nexports.default = SAOShader;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar DepthLimitedBlurShader = {\n\tdefines: {\n\t\t'KERNEL_RADIUS': 4,\n\t\t'DEPTH_PACKING': 1,\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\tuniforms: {\n\t\t'tDiffuse': { type: 't', value: null },\n\t\t'size': { type: 'v2', value: new THREE.Vector2(512, 512) },\n\t\t'sampleUvOffsets': { type: 'v2v', value: [new THREE.Vector2(0, 0)] },\n\t\t'sampleWeights': { type: '1fv', value: [1.0] },\n\t\t'tDepth': { type: 't', value: null },\n\t\t'cameraNear': { type: 'f', value: 10 },\n\t\t'cameraFar': { type: 'f', value: 1000 },\n\t\t'depthCutoff': { type: 'f', value: 10 }\n\t},\n\tvertexShader: [\"#include <common>\", \"uniform vec2 size;\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"void main() {\", \"\tvUv = uv;\", \"\tvInvSize = 1.0 / size;\", \"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\tfragmentShader: [\"#include <common>\", \"#include <packing>\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"uniform float cameraNear;\", \"uniform float cameraFar;\", \"uniform float depthCutoff;\", \"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\", \"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\", \"varying vec2 vUv;\", \"varying vec2 vInvSize;\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float getViewZ( const in float depth ) {\", \"\t#if PERSPECTIVE_CAMERA == 1\", \"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#else\", \"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\", \"\t#endif\", \"}\", \"void main() {\", \"\tfloat depth = getDepth( vUv );\", \"\tif( depth >= ( 1.0 - EPSILON ) ) {\", \"\t\tdiscard;\", \"\t}\", \"\tfloat centerViewZ = -getViewZ( depth );\", \"\tbool rBreak = false, lBreak = false;\", \"\tfloat weightSum = sampleWeights[0];\", \"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\", \"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\", \"\t\tfloat sampleWeight = sampleWeights[i];\", \"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\", \"\t\tvec2 sampleUv = vUv + sampleUvOffset;\", \"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\", \"\t\tif( ! rBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t\tsampleUv = vUv - sampleUvOffset;\", \"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\", \"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\", \"\t\tif( ! lBreak ) {\", \"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\", \"\t\t\tweightSum += sampleWeight;\", \"\t\t}\", \"\t}\", \"\tgl_FragColor = diffuseSum / weightSum;\", \"}\"].join(\"\\n\")\n};\n\nexports.default = DepthLimitedBlurShader;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nvar UnpackDepthRGBAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"#include <packing>\", \"void main() {\", \"float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\", \"gl_FragColor = vec4( vec3( depth ), opacity );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = UnpackDepthRGBAShader;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar BlurShaderUtils = {\n\n  createSampleWeights: function createSampleWeights(kernelRadius, stdDev) {\n\n    var gaussian = function gaussian(x, stdDev) {\n\n      return Math.exp(-(x * x) / (2.0 * (stdDev * stdDev))) / (Math.sqrt(2.0 * Math.PI) * stdDev);\n    };\n\n    var weights = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n\n      weights.push(gaussian(i, stdDev));\n    }\n\n    return weights;\n  },\n\n  createSampleOffsets: function createSampleOffsets(kernelRadius, uvIncrement) {\n\n    var offsets = [];\n\n    for (var i = 0; i <= kernelRadius; i++) {\n\n      offsets.push(uvIncrement.clone().multiplyScalar(i));\n    }\n\n    return offsets;\n  },\n\n  configure: function configure(material, kernelRadius, stdDev, uvIncrement) {\n\n    material.defines['KERNEL_RADIUS'] = kernelRadius;\n    material.uniforms['sampleUvOffsets'].value = BlurShaderUtils.createSampleOffsets(kernelRadius, uvIncrement);\n    material.uniforms['sampleWeights'].value = BlurShaderUtils.createSampleWeights(kernelRadius, stdDev);\n    material.needsUpdate = true;\n  }\n\n};\n\nexports.default = BlurShaderUtils;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mpk / http://polko.me/\n *\n * WebGL port of Subpixel Morphological Antialiasing (SMAA) v2.8\n * Preset: SMAA 1x Medium (with color edge detection)\n * https://github.com/iryoku/smaa/releases/tag/v2.8\n */\n\nvar SMAAShader = [{\n\n\tdefines: {\n\n\t\t\"SMAA_THRESHOLD\": \"0.1\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 3 ];\", \"void SMAAEdgeDetectionVS( vec2 texcoord ) {\", \"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\", // WebGL port note: Changed sign in W component\n\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\", // WebGL port note: Changed sign in W component\n\t\"vOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\", // WebGL port note: Changed sign in W component\n\t\"}\", \"void main() {\", \"vUv = uv;\", \"SMAAEdgeDetectionVS( vUv );\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 3 ];\", \"vec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\", \"vec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\",\n\n\t// Calculate color deltas:\n\t\"vec4 delta;\", \"vec3 C = texture2D( colorTex, texcoord ).rgb;\", \"vec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\", \"vec3 t = abs( C - Cleft );\", \"delta.x = max( max( t.r, t.g ), t.b );\", \"vec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\", \"t = abs( C - Ctop );\", \"delta.y = max( max( t.r, t.g ), t.b );\",\n\n\t// We do the usual threshold:\n\t\"vec2 edges = step( threshold, delta.xy );\",\n\n\t// Then discard if there is no edge:\n\t\"if ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\", \"discard;\",\n\n\t// Calculate right and bottom deltas:\n\t\"vec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\", \"t = abs( C - Cright );\", \"delta.z = max( max( t.r, t.g ), t.b );\", \"vec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\", \"t = abs( C - Cbottom );\", \"delta.w = max( max( t.r, t.g ), t.b );\",\n\n\t// Calculate the maximum delta in the direct neighborhood:\n\t\"float maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\",\n\n\t// Calculate left-left and top-top deltas:\n\t\"vec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\", \"t = abs( C - Cleftleft );\", \"delta.z = max( max( t.r, t.g ), t.b );\", \"vec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\", \"t = abs( C - Ctoptop );\", \"delta.w = max( max( t.r, t.g ), t.b );\",\n\n\t// Calculate the final maximum delta:\n\t\"maxDelta = max( max( maxDelta, delta.z ), delta.w );\",\n\n\t// Local contrast adaptation in action:\n\t\"edges.xy *= step( 0.5 * maxDelta, delta.xy );\", \"return vec4( edges, 0.0, 0.0 );\", \"}\", \"void main() {\", \"gl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\", \"}\"].join(\"\\n\")\n\n}, {\n\n\tdefines: {\n\n\t\t\"SMAA_MAX_SEARCH_STEPS\": \"8\",\n\t\t\"SMAA_AREATEX_MAX_DISTANCE\": \"16\",\n\t\t\"SMAA_AREATEX_PIXEL_SIZE\": \"( 1.0 / vec2( 160.0, 560.0 ) )\",\n\t\t\"SMAA_AREATEX_SUBTEX_SIZE\": \"( 1.0 / 7.0 )\"\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tArea\": { value: null },\n\t\t\"tSearch\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 3 ];\", \"varying vec2 vPixcoord;\", \"void SMAABlendingWeightCalculationVS( vec2 texcoord ) {\", \"vPixcoord = texcoord / resolution;\",\n\n\t// We will use these offsets for the searches later on (see @PSEUDO_GATHER4):\n\t\"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\", // WebGL port note: Changed sign in Y and W components\n\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\", // WebGL port note: Changed sign in Y and W components\n\n\t// And these for the searches, they indicate the ends of the loops:\n\t\"vOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\", \"}\", \"void main() {\", \"vUv = uv;\", \"SMAABlendingWeightCalculationVS( vUv );\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\", \"uniform sampler2D tDiffuse;\", \"uniform sampler2D tArea;\", \"uniform sampler2D tSearch;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[3];\", \"varying vec2 vPixcoord;\", \"vec2 round( vec2 x ) {\", \"return sign( x ) * floor( abs( x ) + 0.5 );\", \"}\", \"float SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\",\n\t// Not required if searchTex accesses are set to point:\n\t// float2 SEARCH_TEX_PIXEL_SIZE = 1.0 / float2(66.0, 33.0);\n\t// e = float2(bias, 0.0) + 0.5 * SEARCH_TEX_PIXEL_SIZE +\n\t//     e * float2(scale, 1.0) * float2(64.0, 32.0) * SEARCH_TEX_PIXEL_SIZE;\n\t\"e.r = bias + e.r * scale;\", \"return 255.0 * texture2D( searchTex, e, 0.0 ).r;\", \"}\", \"float SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\",\n\t/**\n * @PSEUDO_GATHER4\n * This texcoord has been offset by (-0.25, -0.125) in the vertex shader to\n * sample between edge, thus fetching four edges in a row.\n * Sampling with different offsets in each direction allows to disambiguate\n * which edges are active from the four fetched ones.\n */\n\t\"vec2 e = vec2( 0.0, 1.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord -= vec2( 2.0, 0.0 ) * resolution;\", \"if ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\", \"}\",\n\n\t// We correct the previous (-0.25, -0.125) offset we applied:\n\t\"texcoord.x += 0.25 * resolution.x;\",\n\n\t// The searches are bias by 1, so adjust the coords accordingly:\n\t\"texcoord.x += resolution.x;\",\n\n\t// Disambiguate the length added by the last step:\n\t\"texcoord.x += 2.0 * resolution.x;\", // Undo last step\n\t\"texcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\", \"return texcoord.x;\", \"}\", \"float SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\", \"vec2 e = vec2( 0.0, 1.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord += vec2( 2.0, 0.0 ) * resolution;\", \"if ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\", \"}\", \"texcoord.x -= 0.25 * resolution.x;\", \"texcoord.x -= resolution.x;\", \"texcoord.x -= 2.0 * resolution.x;\", \"texcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\", \"return texcoord.x;\", \"}\", \"float SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\", \"vec2 e = vec2( 1.0, 0.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord += vec2( 0.0, 2.0 ) * resolution;\", // WebGL port note: Changed sign\n\t\"if ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\", \"}\", \"texcoord.y -= 0.25 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y -= resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y -= 2.0 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\", // WebGL port note: Changed sign\n\n\t\"return texcoord.y;\", \"}\", \"float SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\", \"vec2 e = vec2( 1.0, 0.0 );\", \"for ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\", // WebGL port note: Changed while to for\n\t\"e = texture2D( edgesTex, texcoord, 0.0 ).rg;\", \"texcoord -= vec2( 0.0, 2.0 ) * resolution;\", // WebGL port note: Changed sign\n\t\"if ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\", \"}\", \"texcoord.y += 0.25 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y += resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y += 2.0 * resolution.y;\", // WebGL port note: Changed sign\n\t\"texcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\", // WebGL port note: Changed sign\n\n\t\"return texcoord.y;\", \"}\", \"vec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\",\n\t// Rounding prevents precision errors of bilinear filtering:\n\t\"vec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\",\n\n\t// We do a scale and bias for mapping to texel space:\n\t\"texcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\",\n\n\t// Move to proper place, according to the subpixel offset:\n\t\"texcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\", \"return texture2D( areaTex, texcoord, 0.0 ).rg;\", \"}\", \"vec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\", \"vec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\", \"vec2 e = texture2D( edgesTex, texcoord ).rg;\", \"if ( e.g > 0.0 ) {\", // Edge at north\n\t\"vec2 d;\",\n\n\t// Find the distance to the left:\n\t\"vec2 coords;\", \"coords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\", \"coords.y = offset[ 1 ].y;\", // offset[1].y = texcoord.y - 0.25 * resolution.y (@CROSSING_OFFSET)\n\t\"d.x = coords.x;\",\n\n\t// Now fetch the left crossing edges, two at a time using bilinear\n\t// filtering. Sampling at -0.25 (see @CROSSING_OFFSET) enables to\n\t// discern what value each edge has:\n\t\"float e1 = texture2D( edgesTex, coords, 0.0 ).r;\",\n\n\t// Find the distance to the right:\n\t\"coords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\", \"d.y = coords.x;\",\n\n\t// We want the distances to be in pixel units (doing this here allow to\n\t// better interleave arithmetic and memory accesses):\n\t\"d = d / resolution.x - pixcoord.x;\",\n\n\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t// quadratically:\n\t\"vec2 sqrt_d = sqrt( abs( d ) );\",\n\n\t// Fetch the right crossing edges:\n\t\"coords.y -= 1.0 * resolution.y;\", // WebGL port note: Added\n\t\"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\",\n\n\t// Ok, we know how this pattern looks like, now it is time for getting\n\t// the actual area:\n\t\"weights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\", \"}\", \"if ( e.r > 0.0 ) {\", // Edge at west\n\t\"vec2 d;\",\n\n\t// Find the distance to the top:\n\t\"vec2 coords;\", \"coords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\", \"coords.x = offset[ 0 ].x;\", // offset[1].x = texcoord.x - 0.25 * resolution.x;\n\t\"d.x = coords.y;\",\n\n\t// Fetch the top crossing edges:\n\t\"float e1 = texture2D( edgesTex, coords, 0.0 ).g;\",\n\n\t// Find the distance to the bottom:\n\t\"coords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\", \"d.y = coords.y;\",\n\n\t// We want the distances to be in pixel units:\n\t\"d = d / resolution.y - pixcoord.y;\",\n\n\t// SMAAArea below needs a sqrt, as the areas texture is compressed\n\t// quadratically:\n\t\"vec2 sqrt_d = sqrt( abs( d ) );\",\n\n\t// Fetch the bottom crossing edges:\n\t\"coords.y -= 1.0 * resolution.y;\", // WebGL port note: Added\n\t\"float e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\",\n\n\t// Get the area for this direction:\n\t\"weights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\", \"}\", \"return weights;\", \"}\", \"void main() {\", \"gl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\", \"}\"].join(\"\\n\")\n\n}, {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tColor\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n\t},\n\n\tvertexShader: [\"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 2 ];\", \"void SMAANeighborhoodBlendingVS( vec2 texcoord ) {\", \"vOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\", // WebGL port note: Changed sign in W component\n\t\"vOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\", // WebGL port note: Changed sign in W component\n\t\"}\", \"void main() {\", \"vUv = uv;\", \"SMAANeighborhoodBlendingVS( vUv );\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tColor;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"varying vec4 vOffset[ 2 ];\", \"vec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\",\n\t// Fetch the blending weights for current pixel:\n\t\"vec4 a;\", \"a.xz = texture2D( blendTex, texcoord ).xz;\", \"a.y = texture2D( blendTex, offset[ 1 ].zw ).g;\", \"a.w = texture2D( blendTex, offset[ 1 ].xy ).a;\",\n\n\t// Is there any blending weight with a value greater than 0.0?\n\t\"if ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\", \"return texture2D( colorTex, texcoord, 0.0 );\", \"} else {\",\n\t// Up to 4 lines can be crossing a pixel (one through each edge). We\n\t// favor blending by choosing the line with the maximum weight for each\n\t// direction:\n\t\"vec2 offset;\", \"offset.x = a.a > a.b ? a.a : -a.b;\", // left vs. right\n\t\"offset.y = a.g > a.r ? -a.g : a.r;\", // top vs. bottom // WebGL port note: Changed signs\n\n\t// Then we go in the direction that has the maximum weight:\n\t\"if ( abs( offset.x ) > abs( offset.y )) {\", // horizontal vs. vertical\n\t\"offset.y = 0.0;\", \"} else {\", \"offset.x = 0.0;\", \"}\",\n\n\t// Fetch the opposite color and lerp by hand:\n\t\"vec4 C = texture2D( colorTex, texcoord, 0.0 );\", \"texcoord += sign( offset ) * resolution;\", \"vec4 Cop = texture2D( colorTex, texcoord, 0.0 );\", \"float s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\",\n\n\t// WebGL port note: Added gamma correction\n\t\"C.xyz = pow(C.xyz, vec3(2.2));\", \"Cop.xyz = pow(Cop.xyz, vec3(2.2));\", \"vec4 mixed = mix(C, Cop, s);\", \"mixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\", \"return mixed;\", \"}\", \"}\", \"void main() {\", \"gl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\", \"}\"].join(\"\\n\")\n\n}];\n\nexports.default = SMAAShader;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n*\n* Supersample Anti-Aliasing Render Pass\n*\n* @author bhouston / http://clara.io/\n*\n* This manual approach to SSAA re-renders the scene ones for each sample with camera jitter and accumulates the results.\n*\n* References: https://en.wikipedia.org/wiki/Supersampling\n*\n*/\n\nvar SSAARenderPass = function SSAARenderPass(scene, camera, clearColor, clearAlpha) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.sampleLevel = 4; // specified as n, where the number of samples is 2^n, so sampleLevel = 4, is 2^4 samples, 16.\n\tthis.unbiased = true;\n\n\t// as we need to clear the buffer in this pass, clearColor must be set to something, defaults to black.\n\tthis.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.SSAARenderPass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\n\tthis.copyMaterial = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tpremultipliedAlpha: true,\n\t\ttransparent: true,\n\t\tblending: THREE.AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\t});\n\n\tthis.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene2 = new THREE.Scene();\n\tthis.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.copyMaterial);\n\tthis.quad2.frustumCulled = false; // Avoid getting clipped\n\tthis.scene2.add(this.quad2);\n};\n\nSSAARenderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: SSAARenderPass,\n\n\tdispose: function dispose() {\n\n\t\tif (this.sampleRenderTarget) {\n\n\t\t\tthis.sampleRenderTarget.dispose();\n\t\t\tthis.sampleRenderTarget = null;\n\t\t}\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tif (this.sampleRenderTarget) this.sampleRenderTarget.setSize(width, height);\n\t},\n\n\trender: function render(renderer, writeBuffer, readBuffer) {\n\n\t\tif (!this.sampleRenderTarget) {\n\n\t\t\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat });\n\t\t\tthis.sampleRenderTarget.texture.name = \"SSAARenderPass.sample\";\n\t\t}\n\n\t\tvar jitterOffsets = SSAARenderPass.JitterVectors[Math.max(0, Math.min(this.sampleLevel, 5))];\n\n\t\tvar autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tvar oldClearColor = renderer.getClearColor().getHex();\n\t\tvar oldClearAlpha = renderer.getClearAlpha();\n\n\t\tvar baseSampleWeight = 1.0 / jitterOffsets.length;\n\t\tvar roundingRange = 1 / 32;\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n\n\t\tvar width = readBuffer.width,\n\t\t    height = readBuffer.height;\n\n\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\tfor (var i = 0; i < jitterOffsets.length; i++) {\n\n\t\t\tvar jitterOffset = jitterOffsets[i];\n\n\t\t\tif (this.camera.setViewOffset) {\n\n\t\t\t\tthis.camera.setViewOffset(width, height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\twidth, height);\n\t\t\t}\n\n\t\t\tvar sampleWeight = baseSampleWeight;\n\n\t\t\tif (this.unbiased) {\n\n\t\t\t\t// the theory is that equal weights for each sample lead to an accumulation of rounding errors.\n\t\t\t\t// The following equation varies the sampleWeight per sample so that it is uniformly distributed\n\t\t\t\t// across a range of values whose rounding errors cancel each other out.\n\n\t\t\t\tvar uniformCenteredDistribution = -0.5 + (i + 0.5) / jitterOffsets.length;\n\t\t\t\tsampleWeight += roundingRange * uniformCenteredDistribution;\n\t\t\t}\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = sampleWeight;\n\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\trenderer.render(this.scene, this.camera, this.sampleRenderTarget, true);\n\n\t\t\tif (i === 0) {\n\n\t\t\t\trenderer.setClearColor(0x000000, 0.0);\n\t\t\t}\n\n\t\t\trenderer.render(this.scene2, this.camera2, this.renderToScreen ? null : writeBuffer, i === 0);\n\t\t}\n\n\t\tif (this.camera.clearViewOffset) this.camera.clearViewOffset();\n\n\t\trenderer.autoClear = autoClear;\n\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t}\n\n});\n\n// These jitter vectors are specified in integers because it is easier.\n// I am assuming a [-8,8) integer grid, but it needs to be mapped onto [-0.5,0.5)\n// before being used, thus these integers need to be scaled by 1/16.\n//\n// Sample patterns reference: https://msdn.microsoft.com/en-us/library/windows/desktop/ff476218%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\nSSAARenderPass.JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\n\nexports.default = SSAARenderPass;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Screen-space ambient occlusion shader\n * - ported from\n *   SSAO GLSL shader v1.2\n *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\n *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n * - modifications\n * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\n * - refactoring and optimizations\n */\n\nvar SSAOShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"size\": { value: new THREE.Vector2(512, 512) },\n\t\t\"cameraNear\": { value: 1 },\n\t\t\"cameraFar\": { value: 100 },\n\t\t\"radius\": { value: 32 },\n\t\t\"onlyAO\": { value: 0 },\n\t\t\"aoClamp\": { value: 0.25 },\n\t\t\"lumInfluence\": { value: 0.7 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float cameraNear;\", \"uniform float cameraFar;\", \"#ifdef USE_LOGDEPTHBUF\", \"uniform float logDepthBufFC;\", \"#endif\", \"uniform float radius;\", // ao radius\n\t\"uniform bool onlyAO;\", // use only ambient occlusion pass?\n\n\t\"uniform vec2 size;\", // texture width, height\n\t\"uniform float aoClamp;\", // depth clamp - reduces haloing at screen edges\n\n\t\"uniform float lumInfluence;\", // how much luminance affects occlusion\n\n\t\"uniform sampler2D tDiffuse;\", \"uniform sampler2D tDepth;\", \"varying vec2 vUv;\",\n\n\t// \"#define PI 3.14159265\",\n\t\"#define DL 2.399963229728653\", // PI * ( 3.0 - sqrt( 5.0 ) )\n\t\"#define EULER 2.718281828459045\",\n\n\t// user variables\n\n\t\"const int samples = 64;\", // ao sample count\n\n\t\"const bool useNoise = true;\", // use noise instead of pattern for sample dithering\n\t\"const float noiseAmount = 0.0004;\", // dithering amount\n\n\t\"const float diffArea = 0.4;\", // self-shadowing reduction\n\t\"const float gDisplace = 0.4;\", // gauss bell center\n\n\n\t// RGBA depth\n\n\t\"#include <packing>\",\n\n\t// generating noise / pattern texture for dithering\n\n\t\"vec2 rand( const vec2 coord ) {\", \"vec2 noise;\", \"if ( useNoise ) {\", \"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\", \"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\", \"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\", \"} else {\", \"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\", \"float gg = fract( coord.t * ( size.y / 2.0 ) );\", \"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\", \"}\", \"return ( noise * 2.0  - 1.0 ) * noiseAmount;\", \"}\", \"float readDepth( const in vec2 coord ) {\", \"float cameraFarPlusNear = cameraFar + cameraNear;\", \"float cameraFarMinusNear = cameraFar - cameraNear;\", \"float cameraCoef = 2.0 * cameraNear;\", \"#ifdef USE_LOGDEPTHBUF\", \"float logz = unpackRGBAToDepth( texture2D( tDepth, coord ) );\", \"float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\", \"float z = (logz / w) + 1.0;\", \"#else\", \"float z = unpackRGBAToDepth( texture2D( tDepth, coord ) );\", \"#endif\", \"return cameraCoef / ( cameraFarPlusNear - z * cameraFarMinusNear );\", \"}\", \"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\", \"float garea = 8.0;\", // gauss bell width\n\t\"float diff = ( depth1 - depth2 ) * 100.0;\", // depth difference (0-100)\n\n\t// reduce left bell width to avoid self-shadowing\n\n\t\"if ( diff < gDisplace ) {\", \"garea = diffArea;\", \"} else {\", \"far = 1;\", \"}\", \"float dd = diff - gDisplace;\", \"float gauss = pow( EULER, -2.0 * ( dd * dd ) / ( garea * garea ) );\", \"return gauss;\", \"}\", \"float calcAO( float depth, float dw, float dh ) {\", \"vec2 vv = vec2( dw, dh );\", \"vec2 coord1 = vUv + radius * vv;\", \"vec2 coord2 = vUv - radius * vv;\", \"float temp1 = 0.0;\", \"float temp2 = 0.0;\", \"int far = 0;\", \"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\n\n\t// DEPTH EXTRAPOLATION\n\n\t\"if ( far > 0 ) {\", \"temp2 = compareDepths( readDepth( coord2 ), depth, far );\", \"temp1 += ( 1.0 - temp1 ) * temp2;\", \"}\", \"return temp1;\", \"}\", \"void main() {\", \"vec2 noise = rand( vUv );\", \"float depth = readDepth( vUv );\", \"float tt = clamp( depth, aoClamp, 1.0 );\", \"float w = ( 1.0 / size.x ) / tt + ( noise.x * ( 1.0 - noise.x ) );\", \"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );\", \"float ao = 0.0;\", \"float dz = 1.0 / float( samples );\", \"float l = 0.0;\", \"float z = 1.0 - dz / 2.0;\", \"for ( int i = 0; i <= samples; i ++ ) {\", \"float r = sqrt( 1.0 - z );\", \"float pw = cos( l ) * r;\", \"float ph = sin( l ) * r;\", \"ao += calcAO( depth, pw * w, ph * h );\", \"z = z - dz;\", \"l = l + DL;\", \"}\", \"ao /= float( samples );\", \"ao = 1.0 - ao;\", \"vec3 color = texture2D( tDiffuse, vUv ).rgb;\", \"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\", \"float lum = dot( color.rgb, lumcoeff );\", \"vec3 luminance = vec3( lum );\", \"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // mix( color * ao, white, luminance )\n\n\t\"if ( onlyAO ) {\", \"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\", // ambient occlusion only\n\n\t\"}\", \"gl_FragColor = vec4( final, 1.0 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = SSAOShader;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author bhouston / http://clara.io/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nvar LuminosityHighPassShader = {\n\n\tshaderID: \"luminosityHighPass\",\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"luminosityThreshold\": { type: \"f\", value: 1.0 },\n\t\t\"smoothWidth\": { type: \"f\", value: 1.0 },\n\t\t\"defaultColor\": { type: \"c\", value: new THREE.Color(0x000000) },\n\t\t\"defaultOpacity\": { type: \"f\", value: 0.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 defaultColor;\", \"uniform float defaultOpacity;\", \"uniform float luminosityThreshold;\", \"uniform float smoothWidth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\", \"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\", \"gl_FragColor = mix( outputColor, texel, alpha );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = LuminosityHighPassShader;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _controls = __webpack_require__(28);\n\nObject.keys(_controls).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _controls[key];\n    }\n  });\n});\n\nvar _exporters = __webpack_require__(40);\n\nObject.keys(_exporters).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _exporters[key];\n    }\n  });\n});\n\nvar _loaders = __webpack_require__(48);\n\nObject.keys(_loaders).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _loaders[key];\n    }\n  });\n});\n\nvar _postprocessing = __webpack_require__(90);\n\nObject.keys(_postprocessing).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _postprocessing[key];\n    }\n  });\n});\n\nvar _shaders = __webpack_require__(112);\n\nObject.keys(_shaders).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _shaders[key];\n    }\n  });\n});\n\nvar _uncategories = __webpack_require__(144);\n\nObject.keys(_uncategories).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _uncategories[key];\n    }\n  });\n});\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VRControls = exports.TransformControls = exports.TrackballControls = exports.PointerLockControls = exports.OrthographicTrackballControls = exports.OrbitControls = exports.FlyControls = exports.FirstPersonControls = exports.EditorControls = exports.DragControls = exports.DeviceOrientationControls = undefined;\n\nvar _DeviceOrientationControls = __webpack_require__(29);\n\nvar _DeviceOrientationControls2 = _interopRequireDefault(_DeviceOrientationControls);\n\nvar _DragControls = __webpack_require__(30);\n\nvar _DragControls2 = _interopRequireDefault(_DragControls);\n\nvar _EditorControls = __webpack_require__(31);\n\nvar _EditorControls2 = _interopRequireDefault(_EditorControls);\n\nvar _FirstPersonControls = __webpack_require__(32);\n\nvar _FirstPersonControls2 = _interopRequireDefault(_FirstPersonControls);\n\nvar _FlyControls = __webpack_require__(33);\n\nvar _FlyControls2 = _interopRequireDefault(_FlyControls);\n\nvar _OrbitControls = __webpack_require__(34);\n\nvar _OrbitControls2 = _interopRequireDefault(_OrbitControls);\n\nvar _OrthographicTrackballControls = __webpack_require__(35);\n\nvar _OrthographicTrackballControls2 = _interopRequireDefault(_OrthographicTrackballControls);\n\nvar _PointerLockControls = __webpack_require__(36);\n\nvar _PointerLockControls2 = _interopRequireDefault(_PointerLockControls);\n\nvar _TrackballControls = __webpack_require__(37);\n\nvar _TrackballControls2 = _interopRequireDefault(_TrackballControls);\n\nvar _TransformControls = __webpack_require__(38);\n\nvar _TransformControls2 = _interopRequireDefault(_TransformControls);\n\nvar _VRControls = __webpack_require__(39);\n\nvar _VRControls2 = _interopRequireDefault(_VRControls);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.DeviceOrientationControls = _DeviceOrientationControls2.default;\nexports.DragControls = _DragControls2.default;\nexports.EditorControls = _EditorControls2.default;\nexports.FirstPersonControls = _FirstPersonControls2.default;\nexports.FlyControls = _FlyControls2.default;\nexports.OrbitControls = _OrbitControls2.default;\nexports.OrthographicTrackballControls = _OrthographicTrackballControls2.default;\nexports.PointerLockControls = _PointerLockControls2.default;\nexports.TrackballControls = _TrackballControls2.default;\nexports.TransformControls = _TransformControls2.default;\nexports.VRControls = _VRControls2.default;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author richt / http://richt.me\n * @author WestLangley / http://github.com/WestLangley\n *\n * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)\n */\n\nvar DeviceOrientationControls = function DeviceOrientationControls(object) {\n\n\tvar scope = this;\n\n\tthis.object = object;\n\tthis.object.rotation.reorder('YXZ');\n\n\tthis.enabled = true;\n\n\tthis.deviceOrientation = {};\n\tthis.screenOrientation = 0;\n\n\tthis.alphaOffset = 0; // radians\n\n\tvar onDeviceOrientationChangeEvent = function onDeviceOrientationChangeEvent(event) {\n\n\t\tscope.deviceOrientation = event;\n\t};\n\n\tvar onScreenOrientationChangeEvent = function onScreenOrientationChangeEvent() {\n\n\t\tscope.screenOrientation = window.orientation || 0;\n\t};\n\n\t// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''\n\n\tvar setObjectQuaternion = function () {\n\n\t\tvar zee = new THREE.Vector3(0, 0, 1);\n\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar q0 = new THREE.Quaternion();\n\n\t\tvar q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); // - PI/2 around the x-axis\n\n\t\treturn function (quaternion, alpha, beta, gamma, orient) {\n\n\t\t\teuler.set(beta, alpha, -gamma, 'YXZ'); // 'ZXY' for the device, but 'YXZ' for us\n\n\t\t\tquaternion.setFromEuler(euler); // orient the device\n\n\t\t\tquaternion.multiply(q1); // camera looks out the back of the device, not the top\n\n\t\t\tquaternion.multiply(q0.setFromAxisAngle(zee, -orient)); // adjust for screen orientation\n\t\t};\n\t}();\n\n\tthis.connect = function () {\n\n\t\tonScreenOrientationChangeEvent(); // run once on load\n\n\t\twindow.addEventListener('orientationchange', onScreenOrientationChangeEvent, false);\n\t\twindow.addEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);\n\n\t\tscope.enabled = true;\n\t};\n\n\tthis.disconnect = function () {\n\n\t\twindow.removeEventListener('orientationchange', onScreenOrientationChangeEvent, false);\n\t\twindow.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent, false);\n\n\t\tscope.enabled = false;\n\t};\n\n\tthis.update = function () {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tvar device = scope.deviceOrientation;\n\n\t\tif (device) {\n\n\t\t\tvar alpha = device.alpha ? THREE.Math.degToRad(device.alpha) + scope.alphaOffset : 0; // Z\n\n\t\t\tvar beta = device.beta ? THREE.Math.degToRad(device.beta) : 0; // X'\n\n\t\t\tvar gamma = device.gamma ? THREE.Math.degToRad(device.gamma) : 0; // Y''\n\n\t\t\tvar orient = scope.screenOrientation ? THREE.Math.degToRad(scope.screenOrientation) : 0; // O\n\n\t\t\tsetObjectQuaternion(scope.object.quaternion, alpha, beta, gamma, orient);\n\t\t}\n\t};\n\n\tthis.dispose = function () {\n\n\t\tscope.disconnect();\n\t};\n\n\tthis.connect();\n};\n\nexports.default = DeviceOrientationControls;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author zz85 / https://github.com/zz85\n * @author mrdoob / http://mrdoob.com\n * Running this will allow you to drag three.js objects around the screen.\n */\n\nvar DragControls = function DragControls(_objects, _camera, _domElement) {\n\n\tif (_objects instanceof THREE.Camera) {\n\n\t\tconsole.warn('THREE.DragControls: Constructor now expects ( objects, camera, domElement )');\n\t\tvar temp = _objects;_objects = _camera;_camera = temp;\n\t}\n\n\tvar _plane = new THREE.Plane();\n\tvar _raycaster = new THREE.Raycaster();\n\n\tvar _mouse = new THREE.Vector2();\n\tvar _offset = new THREE.Vector3();\n\tvar _intersection = new THREE.Vector3();\n\n\tvar _selected = null,\n\t    _hovered = null;\n\n\t//\n\n\tvar scope = this;\n\n\tfunction activate() {\n\n\t\t_domElement.addEventListener('mousemove', onDocumentMouseMove, false);\n\t\t_domElement.addEventListener('mousedown', onDocumentMouseDown, false);\n\t\t_domElement.addEventListener('mouseup', onDocumentMouseCancel, false);\n\t\t_domElement.addEventListener('mouseleave', onDocumentMouseCancel, false);\n\t\t_domElement.addEventListener('touchmove', onDocumentTouchMove, false);\n\t\t_domElement.addEventListener('touchstart', onDocumentTouchStart, false);\n\t\t_domElement.addEventListener('touchend', onDocumentTouchEnd, false);\n\t}\n\n\tfunction deactivate() {\n\n\t\t_domElement.removeEventListener('mousemove', onDocumentMouseMove, false);\n\t\t_domElement.removeEventListener('mousedown', onDocumentMouseDown, false);\n\t\t_domElement.removeEventListener('mouseup', onDocumentMouseCancel, false);\n\t\t_domElement.removeEventListener('mouseleave', onDocumentMouseCancel, false);\n\t\t_domElement.removeEventListener('touchmove', onDocumentTouchMove, false);\n\t\t_domElement.removeEventListener('touchstart', onDocumentTouchStart, false);\n\t\t_domElement.removeEventListener('touchend', onDocumentTouchEnd, false);\n\t}\n\n\tfunction dispose() {\n\n\t\tdeactivate();\n\t}\n\n\tfunction onDocumentMouseMove(event) {\n\n\t\tevent.preventDefault();\n\n\t\tvar rect = _domElement.getBoundingClientRect();\n\n\t\t_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n\t\t_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tif (_selected && scope.enabled) {\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_selected.position.copy(_intersection.sub(_offset));\n\t\t\t}\n\n\t\t\tscope.dispatchEvent({ type: 'drag', object: _selected });\n\n\t\t\treturn;\n\t\t}\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tvar intersects = _raycaster.intersectObjects(_objects);\n\n\t\tif (intersects.length > 0) {\n\n\t\t\tvar object = intersects[0].object;\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), object.position);\n\n\t\t\tif (_hovered !== object) {\n\n\t\t\t\tscope.dispatchEvent({ type: 'hoveron', object: object });\n\n\t\t\t\t_domElement.style.cursor = 'pointer';\n\t\t\t\t_hovered = object;\n\t\t\t}\n\t\t} else {\n\n\t\t\tif (_hovered !== null) {\n\n\t\t\t\tscope.dispatchEvent({ type: 'hoveroff', object: _hovered });\n\n\t\t\t\t_domElement.style.cursor = 'auto';\n\t\t\t\t_hovered = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onDocumentMouseDown(event) {\n\n\t\tevent.preventDefault();\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tvar intersects = _raycaster.intersectObjects(_objects);\n\n\t\tif (intersects.length > 0) {\n\n\t\t\t_selected = intersects[0].object;\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_offset.copy(_intersection).sub(_selected.position);\n\t\t\t}\n\n\t\t\t_domElement.style.cursor = 'move';\n\n\t\t\tscope.dispatchEvent({ type: 'dragstart', object: _selected });\n\t\t}\n\t}\n\n\tfunction onDocumentMouseCancel(event) {\n\n\t\tevent.preventDefault();\n\n\t\tif (_selected) {\n\n\t\t\tscope.dispatchEvent({ type: 'dragend', object: _selected });\n\n\t\t\t_selected = null;\n\t\t}\n\n\t\t_domElement.style.cursor = 'auto';\n\t}\n\n\tfunction onDocumentTouchMove(event) {\n\n\t\tevent.preventDefault();\n\t\tevent = event.changedTouches[0];\n\n\t\tvar rect = _domElement.getBoundingClientRect();\n\n\t\t_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n\t\t_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tif (_selected && scope.enabled) {\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_selected.position.copy(_intersection.sub(_offset));\n\t\t\t}\n\n\t\t\tscope.dispatchEvent({ type: 'drag', object: _selected });\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfunction onDocumentTouchStart(event) {\n\n\t\tevent.preventDefault();\n\t\tevent = event.changedTouches[0];\n\n\t\tvar rect = _domElement.getBoundingClientRect();\n\n\t\t_mouse.x = (event.clientX - rect.left) / rect.width * 2 - 1;\n\t\t_mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n\n\t\t_raycaster.setFromCamera(_mouse, _camera);\n\n\t\tvar intersects = _raycaster.intersectObjects(_objects);\n\n\t\tif (intersects.length > 0) {\n\n\t\t\t_selected = intersects[0].object;\n\n\t\t\t_plane.setFromNormalAndCoplanarPoint(_camera.getWorldDirection(_plane.normal), _selected.position);\n\n\t\t\tif (_raycaster.ray.intersectPlane(_plane, _intersection)) {\n\n\t\t\t\t_offset.copy(_intersection).sub(_selected.position);\n\t\t\t}\n\n\t\t\t_domElement.style.cursor = 'move';\n\n\t\t\tscope.dispatchEvent({ type: 'dragstart', object: _selected });\n\t\t}\n\t}\n\n\tfunction onDocumentTouchEnd(event) {\n\n\t\tevent.preventDefault();\n\n\t\tif (_selected) {\n\n\t\t\tscope.dispatchEvent({ type: 'dragend', object: _selected });\n\n\t\t\t_selected = null;\n\t\t}\n\n\t\t_domElement.style.cursor = 'auto';\n\t}\n\n\tactivate();\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.activate = activate;\n\tthis.deactivate = deactivate;\n\tthis.dispose = dispose;\n\n\t// Backward compatibility\n\n\tthis.setObjects = function () {\n\n\t\tconsole.error('THREE.DragControls: setObjects() has been removed.');\n\t};\n\n\tthis.on = function (type, listener) {\n\n\t\tconsole.warn('THREE.DragControls: on() has been deprecated. Use addEventListener() instead.');\n\t\tscope.addEventListener(type, listener);\n\t};\n\n\tthis.off = function (type, listener) {\n\n\t\tconsole.warn('THREE.DragControls: off() has been deprecated. Use removeEventListener() instead.');\n\t\tscope.removeEventListener(type, listener);\n\t};\n\n\tthis.notify = function (type) {\n\n\t\tconsole.error('THREE.DragControls: notify() has been deprecated. Use dispatchEvent() instead.');\n\t\tscope.dispatchEvent({ type: type });\n\t};\n};\n\nDragControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nDragControls.prototype.constructor = DragControls;\n\nexports.default = DragControls;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nvar EditorControls = function EditorControls(object, domElement) {\n\n\tdomElement = domElement !== undefined ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\tthis.center = new THREE.Vector3();\n\tthis.panSpeed = 0.001;\n\tthis.zoomSpeed = 0.001;\n\tthis.rotationSpeed = 0.005;\n\n\t// internals\n\n\tvar scope = this;\n\tvar vector = new THREE.Vector3();\n\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };\n\tvar state = STATE.NONE;\n\n\tvar center = this.center;\n\tvar normalMatrix = new THREE.Matrix3();\n\tvar pointer = new THREE.Vector2();\n\tvar pointerOld = new THREE.Vector2();\n\tvar spherical = new THREE.Spherical();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\n\tthis.focus = function (target) {\n\n\t\tvar box = new THREE.Box3().setFromObject(target);\n\n\t\tvar distance;\n\n\t\tif (box.isEmpty() === false) {\n\n\t\t\tcenter.copy(box.getCenter());\n\t\t\tdistance = box.getBoundingSphere().radius;\n\t\t} else {\n\n\t\t\t// Focusing on an Group, AmbientLight, etc\n\n\t\t\tcenter.setFromMatrixPosition(target.matrixWorld);\n\t\t\tdistance = 0.1;\n\t\t}\n\n\t\tvar delta = new THREE.Vector3(0, 0, 1);\n\t\tdelta.applyQuaternion(object.quaternion);\n\t\tdelta.multiplyScalar(distance * 4);\n\n\t\tobject.position.copy(center).add(delta);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\tthis.pan = function (delta) {\n\n\t\tvar distance = object.position.distanceTo(center);\n\n\t\tdelta.multiplyScalar(distance * scope.panSpeed);\n\t\tdelta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));\n\n\t\tobject.position.add(delta);\n\t\tcenter.add(delta);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\tthis.zoom = function (delta) {\n\n\t\tvar distance = object.position.distanceTo(center);\n\n\t\tdelta.multiplyScalar(distance * scope.zoomSpeed);\n\n\t\tif (delta.length() > distance) return;\n\n\t\tdelta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));\n\n\t\tobject.position.add(delta);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\tthis.rotate = function (delta) {\n\n\t\tvector.copy(object.position).sub(center);\n\n\t\tspherical.setFromVector3(vector);\n\n\t\tspherical.theta += delta.x;\n\t\tspherical.phi += delta.y;\n\n\t\tspherical.makeSafe();\n\n\t\tvector.setFromSpherical(spherical);\n\n\t\tobject.position.copy(center).add(vector);\n\n\t\tobject.lookAt(center);\n\n\t\tscope.dispatchEvent(changeEvent);\n\t};\n\n\t// mouse\n\n\tfunction onMouseDown(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tif (event.button === 0) {\n\n\t\t\tstate = STATE.ROTATE;\n\t\t} else if (event.button === 1) {\n\n\t\t\tstate = STATE.ZOOM;\n\t\t} else if (event.button === 2) {\n\n\t\t\tstate = STATE.PAN;\n\t\t}\n\n\t\tpointerOld.set(event.clientX, event.clientY);\n\n\t\tdomElement.addEventListener('mousemove', onMouseMove, false);\n\t\tdomElement.addEventListener('mouseup', onMouseUp, false);\n\t\tdomElement.addEventListener('mouseout', onMouseUp, false);\n\t\tdomElement.addEventListener('dblclick', onMouseUp, false);\n\t}\n\n\tfunction onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tpointer.set(event.clientX, event.clientY);\n\n\t\tvar movementX = pointer.x - pointerOld.x;\n\t\tvar movementY = pointer.y - pointerOld.y;\n\n\t\tif (state === STATE.ROTATE) {\n\n\t\t\tscope.rotate(new THREE.Vector3(-movementX * scope.rotationSpeed, -movementY * scope.rotationSpeed, 0));\n\t\t} else if (state === STATE.ZOOM) {\n\n\t\t\tscope.zoom(new THREE.Vector3(0, 0, movementY));\n\t\t} else if (state === STATE.PAN) {\n\n\t\t\tscope.pan(new THREE.Vector3(-movementX, movementY, 0));\n\t\t}\n\n\t\tpointerOld.set(event.clientX, event.clientY);\n\t}\n\n\tfunction onMouseUp(event) {\n\n\t\tdomElement.removeEventListener('mousemove', onMouseMove, false);\n\t\tdomElement.removeEventListener('mouseup', onMouseUp, false);\n\t\tdomElement.removeEventListener('mouseout', onMouseUp, false);\n\t\tdomElement.removeEventListener('dblclick', onMouseUp, false);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onMouseWheel(event) {\n\n\t\tevent.preventDefault();\n\n\t\t// if ( scope.enabled === false ) return;\n\n\t\tscope.zoom(new THREE.Vector3(0, 0, event.deltaY));\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tdomElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tdomElement.removeEventListener('mousedown', onMouseDown, false);\n\t\tdomElement.removeEventListener('wheel', onMouseWheel, false);\n\n\t\tdomElement.removeEventListener('mousemove', onMouseMove, false);\n\t\tdomElement.removeEventListener('mouseup', onMouseUp, false);\n\t\tdomElement.removeEventListener('mouseout', onMouseUp, false);\n\t\tdomElement.removeEventListener('dblclick', onMouseUp, false);\n\n\t\tdomElement.removeEventListener('touchstart', touchStart, false);\n\t\tdomElement.removeEventListener('touchmove', touchMove, false);\n\t};\n\n\tdomElement.addEventListener('contextmenu', contextmenu, false);\n\tdomElement.addEventListener('mousedown', onMouseDown, false);\n\tdomElement.addEventListener('wheel', onMouseWheel, false);\n\n\t// touch\n\n\tvar touches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n\tvar prevTouches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];\n\n\tvar prevDistance = null;\n\n\tfunction touchStart(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);\n\t\t\t\tprevDistance = touches[0].distanceTo(touches[1]);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tprevTouches[0].copy(touches[0]);\n\t\tprevTouches[1].copy(touches[1]);\n\t}\n\n\tfunction touchMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tfunction getClosest(touch, touches) {\n\n\t\t\tvar closest = touches[0];\n\n\t\t\tfor (var i in touches) {\n\n\t\t\t\tif (closest.distanceTo(touch) > touches[i].distanceTo(touch)) closest = touches[i];\n\t\t\t}\n\n\t\t\treturn closest;\n\t\t}\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\tscope.rotate(touches[0].sub(getClosest(touches[0], prevTouches)).multiplyScalar(-scope.rotationSpeed));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\ttouches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0);\n\t\t\t\ttouches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0);\n\t\t\t\tvar distance = touches[0].distanceTo(touches[1]);\n\t\t\t\tscope.zoom(new THREE.Vector3(0, 0, prevDistance - distance));\n\t\t\t\tprevDistance = distance;\n\n\t\t\t\tvar offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));\n\t\t\t\tvar offset1 = touches[1].clone().sub(getClosest(touches[1], prevTouches));\n\t\t\t\toffset0.x = -offset0.x;\n\t\t\t\toffset1.x = -offset1.x;\n\n\t\t\t\tscope.pan(offset0.add(offset1).multiplyScalar(0.5));\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tprevTouches[0].copy(touches[0]);\n\t\tprevTouches[1].copy(touches[1]);\n\t}\n\n\tdomElement.addEventListener('touchstart', touchStart, false);\n\tdomElement.addEventListener('touchmove', touchMove, false);\n};\n\nEditorControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nEditorControls.prototype.constructor = EditorControls;\n\nexports.default = EditorControls;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author paulirish / http://paulirish.com/\n */\n\nvar FirstPersonControls = function FirstPersonControls(object, domElement) {\n\n\tthis.object = object;\n\tthis.target = new THREE.Vector3(0, 0, 0);\n\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\tthis.enabled = true;\n\n\tthis.movementSpeed = 1.0;\n\tthis.lookSpeed = 0.005;\n\n\tthis.lookVertical = true;\n\tthis.autoForward = false;\n\n\tthis.activeLook = true;\n\n\tthis.heightSpeed = false;\n\tthis.heightCoef = 1.0;\n\tthis.heightMin = 0.0;\n\tthis.heightMax = 1.0;\n\n\tthis.constrainVertical = false;\n\tthis.verticalMin = 0;\n\tthis.verticalMax = Math.PI;\n\n\tthis.autoSpeedFactor = 0.0;\n\n\tthis.mouseX = 0;\n\tthis.mouseY = 0;\n\n\tthis.lat = 0;\n\tthis.lon = 0;\n\tthis.phi = 0;\n\tthis.theta = 0;\n\n\tthis.moveForward = false;\n\tthis.moveBackward = false;\n\tthis.moveLeft = false;\n\tthis.moveRight = false;\n\n\tthis.mouseDragOn = false;\n\n\tthis.viewHalfX = 0;\n\tthis.viewHalfY = 0;\n\n\tif (this.domElement !== document) {\n\n\t\tthis.domElement.setAttribute('tabindex', -1);\n\t}\n\n\t//\n\n\tthis.handleResize = function () {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.viewHalfX = window.innerWidth / 2;\n\t\t\tthis.viewHalfY = window.innerHeight / 2;\n\t\t} else {\n\n\t\t\tthis.viewHalfX = this.domElement.offsetWidth / 2;\n\t\t\tthis.viewHalfY = this.domElement.offsetHeight / 2;\n\t\t}\n\t};\n\n\tthis.onMouseDown = function (event) {\n\n\t\tif (this.domElement !== document) {\n\n\t\t\tthis.domElement.focus();\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.activeLook) {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveForward = true;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveBackward = true;break;\n\n\t\t\t}\n\t\t}\n\n\t\tthis.mouseDragOn = true;\n\t};\n\n\tthis.onMouseUp = function (event) {\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.activeLook) {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveForward = false;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveBackward = false;break;\n\n\t\t\t}\n\t\t}\n\n\t\tthis.mouseDragOn = false;\n\t};\n\n\tthis.onMouseMove = function (event) {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.mouseX = event.pageX - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.viewHalfY;\n\t\t} else {\n\n\t\t\tthis.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\n\t\t}\n\t};\n\n\tthis.onKeyDown = function (event) {\n\n\t\t//event.preventDefault();\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveForward = true;break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveLeft = true;break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveBackward = true;break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveRight = true;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveUp = true;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveDown = true;break;\n\n\t\t}\n\t};\n\n\tthis.onKeyUp = function (event) {\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveForward = false;break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveLeft = false;break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveBackward = false;break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveRight = false;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveUp = false;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveDown = false;break;\n\n\t\t}\n\t};\n\n\tthis.update = function (delta) {\n\n\t\tif (this.enabled === false) return;\n\n\t\tif (this.heightSpeed) {\n\n\t\t\tvar y = THREE.Math.clamp(this.object.position.y, this.heightMin, this.heightMax);\n\t\t\tvar heightDelta = y - this.heightMin;\n\n\t\t\tthis.autoSpeedFactor = delta * (heightDelta * this.heightCoef);\n\t\t} else {\n\n\t\t\tthis.autoSpeedFactor = 0.0;\n\t\t}\n\n\t\tvar actualMoveSpeed = delta * this.movementSpeed;\n\n\t\tif (this.moveForward || this.autoForward && !this.moveBackward) this.object.translateZ(-(actualMoveSpeed + this.autoSpeedFactor));\n\t\tif (this.moveBackward) this.object.translateZ(actualMoveSpeed);\n\n\t\tif (this.moveLeft) this.object.translateX(-actualMoveSpeed);\n\t\tif (this.moveRight) this.object.translateX(actualMoveSpeed);\n\n\t\tif (this.moveUp) this.object.translateY(actualMoveSpeed);\n\t\tif (this.moveDown) this.object.translateY(-actualMoveSpeed);\n\n\t\tvar actualLookSpeed = delta * this.lookSpeed;\n\n\t\tif (!this.activeLook) {\n\n\t\t\tactualLookSpeed = 0;\n\t\t}\n\n\t\tvar verticalLookRatio = 1;\n\n\t\tif (this.constrainVertical) {\n\n\t\t\tverticalLookRatio = Math.PI / (this.verticalMax - this.verticalMin);\n\t\t}\n\n\t\tthis.lon += this.mouseX * actualLookSpeed;\n\t\tif (this.lookVertical) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;\n\n\t\tthis.lat = Math.max(-85, Math.min(85, this.lat));\n\t\tthis.phi = THREE.Math.degToRad(90 - this.lat);\n\n\t\tthis.theta = THREE.Math.degToRad(this.lon);\n\n\t\tif (this.constrainVertical) {\n\n\t\t\tthis.phi = THREE.Math.mapLinear(this.phi, 0, Math.PI, this.verticalMin, this.verticalMax);\n\t\t}\n\n\t\tvar targetPosition = this.target,\n\t\t    position = this.object.position;\n\n\t\ttargetPosition.x = position.x + 100 * Math.sin(this.phi) * Math.cos(this.theta);\n\t\ttargetPosition.y = position.y + 100 * Math.cos(this.phi);\n\t\ttargetPosition.z = position.z + 100 * Math.sin(this.phi) * Math.sin(this.theta);\n\n\t\tthis.object.lookAt(targetPosition);\n\t};\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', _onMouseDown, false);\n\t\tthis.domElement.removeEventListener('mousemove', _onMouseMove, false);\n\t\tthis.domElement.removeEventListener('mouseup', _onMouseUp, false);\n\n\t\twindow.removeEventListener('keydown', _onKeyDown, false);\n\t\twindow.removeEventListener('keyup', _onKeyUp, false);\n\t};\n\n\tvar _onMouseMove = bind(this, this.onMouseMove);\n\tvar _onMouseDown = bind(this, this.onMouseDown);\n\tvar _onMouseUp = bind(this, this.onMouseUp);\n\tvar _onKeyDown = bind(this, this.onKeyDown);\n\tvar _onKeyUp = bind(this, this.onKeyUp);\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\tthis.domElement.addEventListener('mousemove', _onMouseMove, false);\n\tthis.domElement.addEventListener('mousedown', _onMouseDown, false);\n\tthis.domElement.addEventListener('mouseup', _onMouseUp, false);\n\n\twindow.addEventListener('keydown', _onKeyDown, false);\n\twindow.addEventListener('keyup', _onKeyUp, false);\n\n\tfunction bind(scope, fn) {\n\n\t\treturn function () {\n\n\t\t\tfn.apply(scope, arguments);\n\t\t};\n\t}\n\n\tthis.handleResize();\n};\n\nexports.default = FirstPersonControls;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author James Baicoianu / http://www.baicoianu.com/\n */\n\nvar FlyControls = function FlyControls(object, domElement) {\n\n\tthis.object = object;\n\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\tif (domElement) this.domElement.setAttribute('tabindex', -1);\n\n\t// API\n\n\tthis.movementSpeed = 1.0;\n\tthis.rollSpeed = 0.005;\n\n\tthis.dragToLook = false;\n\tthis.autoForward = false;\n\n\t// disable default target object behavior\n\n\t// internals\n\n\tthis.tmpQuaternion = new THREE.Quaternion();\n\n\tthis.mouseStatus = 0;\n\n\tthis.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };\n\tthis.moveVector = new THREE.Vector3(0, 0, 0);\n\tthis.rotationVector = new THREE.Vector3(0, 0, 0);\n\n\tthis.handleEvent = function (event) {\n\n\t\tif (typeof this[event.type] == 'function') {\n\n\t\t\tthis[event.type](event);\n\t\t}\n\t};\n\n\tthis.keydown = function (event) {\n\n\t\tif (event.altKey) {\n\n\t\t\treturn;\n\t\t}\n\n\t\t//event.preventDefault();\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 16:\n\t\t\t\t/* shift */this.movementSpeedMultiplier = .1;break;\n\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveState.forward = 1;break;\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveState.back = 1;break;\n\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveState.left = 1;break;\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveState.right = 1;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveState.up = 1;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveState.down = 1;break;\n\n\t\t\tcase 38:\n\t\t\t\t/*up*/this.moveState.pitchUp = 1;break;\n\t\t\tcase 40:\n\t\t\t\t/*down*/this.moveState.pitchDown = 1;break;\n\n\t\t\tcase 37:\n\t\t\t\t/*left*/this.moveState.yawLeft = 1;break;\n\t\t\tcase 39:\n\t\t\t\t/*right*/this.moveState.yawRight = 1;break;\n\n\t\t\tcase 81:\n\t\t\t\t/*Q*/this.moveState.rollLeft = 1;break;\n\t\t\tcase 69:\n\t\t\t\t/*E*/this.moveState.rollRight = 1;break;\n\n\t\t}\n\n\t\tthis.updateMovementVector();\n\t\tthis.updateRotationVector();\n\t};\n\n\tthis.keyup = function (event) {\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase 16:\n\t\t\t\t/* shift */this.movementSpeedMultiplier = 1;break;\n\n\t\t\tcase 87:\n\t\t\t\t/*W*/this.moveState.forward = 0;break;\n\t\t\tcase 83:\n\t\t\t\t/*S*/this.moveState.back = 0;break;\n\n\t\t\tcase 65:\n\t\t\t\t/*A*/this.moveState.left = 0;break;\n\t\t\tcase 68:\n\t\t\t\t/*D*/this.moveState.right = 0;break;\n\n\t\t\tcase 82:\n\t\t\t\t/*R*/this.moveState.up = 0;break;\n\t\t\tcase 70:\n\t\t\t\t/*F*/this.moveState.down = 0;break;\n\n\t\t\tcase 38:\n\t\t\t\t/*up*/this.moveState.pitchUp = 0;break;\n\t\t\tcase 40:\n\t\t\t\t/*down*/this.moveState.pitchDown = 0;break;\n\n\t\t\tcase 37:\n\t\t\t\t/*left*/this.moveState.yawLeft = 0;break;\n\t\t\tcase 39:\n\t\t\t\t/*right*/this.moveState.yawRight = 0;break;\n\n\t\t\tcase 81:\n\t\t\t\t/*Q*/this.moveState.rollLeft = 0;break;\n\t\t\tcase 69:\n\t\t\t\t/*E*/this.moveState.rollRight = 0;break;\n\n\t\t}\n\n\t\tthis.updateMovementVector();\n\t\tthis.updateRotationVector();\n\t};\n\n\tthis.mousedown = function (event) {\n\n\t\tif (this.domElement !== document) {\n\n\t\t\tthis.domElement.focus();\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.dragToLook) {\n\n\t\t\tthis.mouseStatus++;\n\t\t} else {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveState.forward = 1;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveState.back = 1;break;\n\n\t\t\t}\n\n\t\t\tthis.updateMovementVector();\n\t\t}\n\t};\n\n\tthis.mousemove = function (event) {\n\n\t\tif (!this.dragToLook || this.mouseStatus > 0) {\n\n\t\t\tvar container = this.getContainerDimensions();\n\t\t\tvar halfWidth = container.size[0] / 2;\n\t\t\tvar halfHeight = container.size[1] / 2;\n\n\t\t\tthis.moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;\n\t\t\tthis.moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;\n\n\t\t\tthis.updateRotationVector();\n\t\t}\n\t};\n\n\tthis.mouseup = function (event) {\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (this.dragToLook) {\n\n\t\t\tthis.mouseStatus--;\n\n\t\t\tthis.moveState.yawLeft = this.moveState.pitchDown = 0;\n\t\t} else {\n\n\t\t\tswitch (event.button) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\tthis.moveState.forward = 0;break;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis.moveState.back = 0;break;\n\n\t\t\t}\n\n\t\t\tthis.updateMovementVector();\n\t\t}\n\n\t\tthis.updateRotationVector();\n\t};\n\n\tthis.update = function (delta) {\n\n\t\tvar moveMult = delta * this.movementSpeed;\n\t\tvar rotMult = delta * this.rollSpeed;\n\n\t\tthis.object.translateX(this.moveVector.x * moveMult);\n\t\tthis.object.translateY(this.moveVector.y * moveMult);\n\t\tthis.object.translateZ(this.moveVector.z * moveMult);\n\n\t\tthis.tmpQuaternion.set(this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1).normalize();\n\t\tthis.object.quaternion.multiply(this.tmpQuaternion);\n\n\t\t// expose the rotation vector for convenience\n\t\tthis.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);\n\t};\n\n\tthis.updateMovementVector = function () {\n\n\t\tvar forward = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;\n\n\t\tthis.moveVector.x = -this.moveState.left + this.moveState.right;\n\t\tthis.moveVector.y = -this.moveState.down + this.moveState.up;\n\t\tthis.moveVector.z = -forward + this.moveState.back;\n\n\t\t//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );\n\t};\n\n\tthis.updateRotationVector = function () {\n\n\t\tthis.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp;\n\t\tthis.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft;\n\t\tthis.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft;\n\n\t\t//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );\n\t};\n\n\tthis.getContainerDimensions = function () {\n\n\t\tif (this.domElement != document) {\n\n\t\t\treturn {\n\t\t\t\tsize: [this.domElement.offsetWidth, this.domElement.offsetHeight],\n\t\t\t\toffset: [this.domElement.offsetLeft, this.domElement.offsetTop]\n\t\t\t};\n\t\t} else {\n\n\t\t\treturn {\n\t\t\t\tsize: [window.innerWidth, window.innerHeight],\n\t\t\t\toffset: [0, 0]\n\t\t\t};\n\t\t}\n\t};\n\n\tfunction bind(scope, fn) {\n\n\t\treturn function () {\n\n\t\t\tfn.apply(scope, arguments);\n\t\t};\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', _mousedown, false);\n\t\tthis.domElement.removeEventListener('mousemove', _mousemove, false);\n\t\tthis.domElement.removeEventListener('mouseup', _mouseup, false);\n\n\t\twindow.removeEventListener('keydown', _keydown, false);\n\t\twindow.removeEventListener('keyup', _keyup, false);\n\t};\n\n\tvar _mousemove = bind(this, this.mousemove);\n\tvar _mousedown = bind(this, this.mousedown);\n\tvar _mouseup = bind(this, this.mouseup);\n\tvar _keydown = bind(this, this.keydown);\n\tvar _keyup = bind(this, this.keyup);\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\n\tthis.domElement.addEventListener('mousemove', _mousemove, false);\n\tthis.domElement.addEventListener('mousedown', _mousedown, false);\n\tthis.domElement.addEventListener('mouseup', _mouseup, false);\n\n\twindow.addEventListener('keydown', _keydown, false);\n\twindow.addEventListener('keyup', _keyup, false);\n\n\tthis.updateMovementVector();\n\tthis.updateRotationVector();\n};\n\nexports.default = FlyControls;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or arrow keys / touch: two-finger move\n\nvar OrbitControls = function OrbitControls(object, domElement) {\n\n\tthis.object = object;\n\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new THREE.Vector3();\n\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = -Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.25;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.panSpeed = 1.0;\n\tthis.screenSpacePanning = false; // if true, pan in screen-space\n\tthis.keyPanSpeed = 7.0; // pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\t// Mouse buttons\n\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\n\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t//\n\t// public methods\n\t//\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn spherical.phi;\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn spherical.theta;\n\t};\n\n\tthis.saveState = function () {\n\n\t\tscope.target0.copy(scope.target);\n\t\tscope.position0.copy(scope.object.position);\n\t\tscope.zoom0 = scope.object.zoom;\n\t};\n\n\tthis.reset = function () {\n\n\t\tscope.target.copy(scope.target0);\n\t\tscope.object.position.copy(scope.position0);\n\t\tscope.object.zoom = scope.zoom0;\n\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent(changeEvent);\n\n\t\tscope.update();\n\n\t\tstate = STATE.NONE;\n\t};\n\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n\t\tvar quatInverse = quat.clone().inverse();\n\n\t\tvar lastPosition = new THREE.Vector3();\n\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\treturn function update() {\n\n\t\t\tvar position = scope.object.position;\n\n\t\t\toffset.copy(position).sub(scope.target);\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion(quat);\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3(offset);\n\n\t\t\tif (scope.autoRotate && state === STATE.NONE) {\n\n\t\t\t\trotateLeft(getAutoRotationAngle());\n\t\t\t}\n\n\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t// restrict theta to be between desired limits\n\t\t\tspherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n\n\t\t\tspherical.makeSafe();\n\n\t\t\tspherical.radius *= scale;\n\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n\n\t\t\t// move target to panned location\n\t\t\tscope.target.add(panOffset);\n\n\t\t\toffset.setFromSpherical(spherical);\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion(quatInverse);\n\n\t\t\tposition.copy(scope.target).add(offset);\n\n\t\t\tscope.object.lookAt(scope.target);\n\n\t\t\tif (scope.enableDamping === true) {\n\n\t\t\t\tsphericalDelta.theta *= 1 - scope.dampingFactor;\n\t\t\t\tsphericalDelta.phi *= 1 - scope.dampingFactor;\n\n\t\t\t\tpanOffset.multiplyScalar(1 - scope.dampingFactor);\n\t\t\t} else {\n\n\t\t\t\tsphericalDelta.set(0, 0, 0);\n\n\t\t\t\tpanOffset.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tscale = 1;\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\n\t\t\t\tlastPosition.copy(scope.object.position);\n\t\t\t\tlastQuaternion.copy(scope.object.quaternion);\n\t\t\t\tzoomChanged = false;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn false;\n\t\t};\n\t}();\n\n\tthis.dispose = function () {\n\n\t\tscope.domElement.removeEventListener('contextmenu', onContextMenu, false);\n\t\tscope.domElement.removeEventListener('mousedown', onMouseDown, false);\n\t\tscope.domElement.removeEventListener('wheel', onMouseWheel, false);\n\n\t\tscope.domElement.removeEventListener('touchstart', onTouchStart, false);\n\t\tscope.domElement.removeEventListener('touchend', onTouchEnd, false);\n\t\tscope.domElement.removeEventListener('touchmove', onTouchMove, false);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\twindow.removeEventListener('keydown', onKeyDown, false);\n\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\t};\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\tvar STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY_PAN: 4 };\n\n\tvar state = STATE.NONE;\n\n\tvar EPS = 0.000001;\n\n\t// current position in spherical coordinates\n\tvar spherical = new THREE.Spherical();\n\tvar sphericalDelta = new THREE.Spherical();\n\n\tvar scale = 1;\n\tvar panOffset = new THREE.Vector3();\n\tvar zoomChanged = false;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow(0.95, scope.zoomSpeed);\n\t}\n\n\tfunction rotateLeft(angle) {\n\n\t\tsphericalDelta.theta -= angle;\n\t}\n\n\tfunction rotateUp(angle) {\n\n\t\tsphericalDelta.phi -= angle;\n\t}\n\n\tvar panLeft = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panLeft(distance, objectMatrix) {\n\n\t\t\tv.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\t\t\tv.multiplyScalar(-distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t}();\n\n\tvar panUp = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panUp(distance, objectMatrix) {\n\n\t\t\tif (scope.screenSpacePanning === true) {\n\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 1);\n\t\t\t} else {\n\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 0);\n\t\t\t\tv.crossVectors(scope.object.up, v);\n\t\t\t}\n\n\t\t\tv.multiplyScalar(distance);\n\n\t\t\tpanOffset.add(v);\n\t\t};\n\t}();\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tvar pan = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\treturn function pan(deltaX, deltaY) {\n\n\t\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\toffset.copy(position).sub(scope.target);\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0);\n\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\tpanLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n\t\t\t\tpanUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n\t\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n\t\t\t\tpanUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\t\t\t\tscope.enablePan = false;\n\t\t\t}\n\t\t};\n\t}();\n\n\tfunction dollyIn(dollyScale) {\n\n\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\tscale /= dollyScale;\n\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\tfunction dollyOut(dollyScale) {\n\n\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\tscale *= dollyScale;\n\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\t\t}\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\tfunction handleMouseDownRotate(event) {\n\n\t\t//console.log( 'handleMouseDownRotate' );\n\n\t\trotateStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownDolly(event) {\n\n\t\t//console.log( 'handleMouseDownDolly' );\n\n\t\tdollyStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseDownPan(event) {\n\n\t\t//console.log( 'handleMouseDownPan' );\n\n\t\tpanStart.set(event.clientX, event.clientY);\n\t}\n\n\tfunction handleMouseMoveRotate(event) {\n\n\t\t//console.log( 'handleMouseMoveRotate' );\n\n\t\trotateEnd.set(event.clientX, event.clientY);\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMoveDolly(event) {\n\n\t\t//console.log( 'handleMouseMoveDolly' );\n\n\t\tdollyEnd.set(event.clientX, event.clientY);\n\n\t\tdollyDelta.subVectors(dollyEnd, dollyStart);\n\n\t\tif (dollyDelta.y > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\t\t} else if (dollyDelta.y < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\t\t}\n\n\t\tdollyStart.copy(dollyEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseMovePan(event) {\n\n\t\t//console.log( 'handleMouseMovePan' );\n\n\t\tpanEnd.set(event.clientX, event.clientY);\n\n\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleMouseUp(event) {\n\n\t\t// console.log( 'handleMouseUp' );\n\n\t}\n\n\tfunction handleMouseWheel(event) {\n\n\t\t// console.log( 'handleMouseWheel' );\n\n\t\tif (event.deltaY < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\t\t} else if (event.deltaY > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\t\t}\n\n\t\tscope.update();\n\t}\n\n\tfunction handleKeyDown(event) {\n\n\t\t//console.log( 'handleKeyDown' );\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tpan(0, scope.keyPanSpeed);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tpan(0, -scope.keyPanSpeed);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tpan(scope.keyPanSpeed, 0);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tpan(-scope.keyPanSpeed, 0);\n\t\t\t\tscope.update();\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tfunction handleTouchStartRotate(event) {\n\n\t\t//console.log( 'handleTouchStartRotate' );\n\n\t\trotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\t}\n\n\tfunction handleTouchStartDollyPan(event) {\n\n\t\t//console.log( 'handleTouchStartDollyPan' );\n\n\t\tif (scope.enableZoom) {\n\n\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\tdollyStart.set(0, distance);\n\t\t}\n\n\t\tif (scope.enablePan) {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanStart.set(x, y);\n\t\t}\n\t}\n\n\tfunction handleTouchMoveRotate(event) {\n\n\t\t//console.log( 'handleTouchMoveRotate' );\n\n\t\trotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\n\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\t}\n\n\tfunction handleTouchMoveDollyPan(event) {\n\n\t\t//console.log( 'handleTouchMoveDollyPan' );\n\n\t\tif (scope.enableZoom) {\n\n\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\tdollyEnd.set(0, distance);\n\n\t\t\tdollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n\t\t\tdollyIn(dollyDelta.y);\n\n\t\t\tdollyStart.copy(dollyEnd);\n\t\t}\n\n\t\tif (scope.enablePan) {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanEnd.set(x, y);\n\n\t\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\t\tpan(panDelta.x, panDelta.y);\n\n\t\t\tpanStart.copy(panEnd);\n\t\t}\n\n\t\tscope.update();\n\t}\n\n\tfunction handleTouchEnd(event) {}\n\n\t//console.log( 'handleTouchEnd' );\n\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\n\tfunction onMouseDown(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (event.button) {\n\n\t\t\tcase scope.mouseButtons.ORBIT:\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleMouseDownRotate(event);\n\n\t\t\t\tstate = STATE.ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.ZOOM:\n\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleMouseDownDolly(event);\n\n\t\t\t\tstate = STATE.DOLLY;\n\n\t\t\t\tbreak;\n\n\t\t\tcase scope.mouseButtons.PAN:\n\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleMouseDownPan(event);\n\n\t\t\t\tstate = STATE.PAN;\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tdocument.addEventListener('mousemove', onMouseMove, false);\n\t\t\tdocument.addEventListener('mouseup', onMouseUp, false);\n\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (state) {\n\n\t\t\tcase STATE.ROTATE:\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleMouseMoveRotate(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.DOLLY:\n\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleMouseMoveDolly(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.PAN:\n\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleMouseMovePan(event);\n\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tfunction onMouseUp(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleMouseUp(event);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onMouseWheel(event) {\n\n\t\tif (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tscope.dispatchEvent(startEvent);\n\n\t\thandleMouseWheel(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\t}\n\n\tfunction onKeyDown(event) {\n\n\t\tif (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n\t\thandleKeyDown(event);\n\t}\n\n\tfunction onTouchStart(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t// one-fingered touch: rotate\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleTouchStartRotate(event);\n\n\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t// two-fingered touch: dolly-pan\n\n\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\n\t\t\t\thandleTouchStartDollyPan(event);\n\n\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tscope.dispatchEvent(startEvent);\n\t\t}\n\t}\n\n\tfunction onTouchMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t// one-fingered touch: rotate\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\t\t\t\tif (state !== STATE.TOUCH_ROTATE) return; // is this needed?\n\n\t\t\t\thandleTouchMoveRotate(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t// two-fingered touch: dolly-pan\n\n\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\t\t\t\tif (state !== STATE.TOUCH_DOLLY_PAN) return; // is this needed?\n\n\t\t\t\thandleTouchMoveDollyPan(event);\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\t}\n\n\tfunction onTouchEnd(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleTouchEnd(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\t}\n\n\tfunction onContextMenu(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t}\n\n\t//\n\n\tscope.domElement.addEventListener('contextmenu', onContextMenu, false);\n\n\tscope.domElement.addEventListener('mousedown', onMouseDown, false);\n\tscope.domElement.addEventListener('wheel', onMouseWheel, false);\n\n\tscope.domElement.addEventListener('touchstart', onTouchStart, false);\n\tscope.domElement.addEventListener('touchend', onTouchEnd, false);\n\tscope.domElement.addEventListener('touchmove', onTouchMove, false);\n\n\twindow.addEventListener('keydown', onKeyDown, false);\n\n\t// force an update at start\n\n\tthis.update();\n};\n\nOrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nOrbitControls.prototype.constructor = OrbitControls;\n\nObject.defineProperties(OrbitControls.prototype, {\n\n\tcenter: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .center has been renamed to .target');\n\t\t\treturn this.target;\n\t\t}\n\n\t},\n\n\t// backward compatibility\n\n\tnoZoom: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n\t\t\treturn !this.enableZoom;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');\n\t\t\tthis.enableZoom = !value;\n\t\t}\n\n\t},\n\n\tnoRotate: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n\t\t\treturn !this.enableRotate;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');\n\t\t\tthis.enableRotate = !value;\n\t\t}\n\n\t},\n\n\tnoPan: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n\t\t\treturn !this.enablePan;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');\n\t\t\tthis.enablePan = !value;\n\t\t}\n\n\t},\n\n\tnoKeys: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n\t\t\treturn !this.enableKeys;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');\n\t\t\tthis.enableKeys = !value;\n\t\t}\n\n\t},\n\n\tstaticMoving: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n\t\t\treturn !this.enableDamping;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');\n\t\t\tthis.enableDamping = !value;\n\t\t}\n\n\t},\n\n\tdynamicDampingFactor: {\n\n\t\tget: function get() {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n\t\t\treturn this.dampingFactor;\n\t\t},\n\n\t\tset: function set(value) {\n\n\t\t\tconsole.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');\n\t\t\tthis.dampingFactor = value;\n\t\t}\n\n\t}\n\n});\n\nexports.default = OrbitControls;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n * @author Patrick Fuller / http://patrick-fuller.com\n * @author Max Smolens / https://github.com/msmolens\n */\n\nvar OrthographicTrackballControls = function OrthographicTrackballControls(object, domElement) {\n\n\tvar _this = this;\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\n\n\tthis.object = object;\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\n\n\tthis.radius = 0;\n\n\tthis.rotateSpeed = 1.0;\n\tthis.zoomSpeed = 1.2;\n\n\tthis.noRotate = false;\n\tthis.noZoom = false;\n\tthis.noPan = false;\n\tthis.noRoll = false;\n\n\tthis.staticMoving = false;\n\tthis.dynamicDampingFactor = 0.2;\n\n\tthis.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n\n\t// internals\n\n\tthis.target = new THREE.Vector3();\n\n\tvar EPS = 0.000001;\n\n\tvar _changed = true;\n\n\tvar _state = STATE.NONE,\n\t    _prevState = STATE.NONE,\n\t    _eye = new THREE.Vector3(),\n\t    _rotateStart = new THREE.Vector3(),\n\t    _rotateEnd = new THREE.Vector3(),\n\t    _zoomStart = new THREE.Vector2(),\n\t    _zoomEnd = new THREE.Vector2(),\n\t    _touchZoomDistanceStart = 0,\n\t    _touchZoomDistanceEnd = 0,\n\t    _panStart = new THREE.Vector2(),\n\t    _panEnd = new THREE.Vector2();\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.up0 = this.object.up.clone();\n\n\tthis.left0 = this.object.left;\n\tthis.right0 = this.object.right;\n\tthis.top0 = this.object.top;\n\tthis.bottom0 = this.object.bottom;\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\t// methods\n\n\tthis.handleResize = function () {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.screen.left = 0;\n\t\t\tthis.screen.top = 0;\n\t\t\tthis.screen.width = window.innerWidth;\n\t\t\tthis.screen.height = window.innerHeight;\n\t\t} else {\n\n\t\t\tvar box = this.domElement.getBoundingClientRect();\n\t\t\t// adjustments come from similar code in the jquery offset() function\n\t\t\tvar d = this.domElement.ownerDocument.documentElement;\n\t\t\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\n\t\t\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\n\t\t\tthis.screen.width = box.width;\n\t\t\tthis.screen.height = box.height;\n\t\t}\n\n\t\tthis.radius = 0.5 * Math.min(this.screen.width, this.screen.height);\n\n\t\tthis.left0 = this.object.left;\n\t\tthis.right0 = this.object.right;\n\t\tthis.top0 = this.object.top;\n\t\tthis.bottom0 = this.object.bottom;\n\t};\n\n\tthis.handleEvent = function (event) {\n\n\t\tif (typeof this[event.type] == 'function') {\n\n\t\t\tthis[event.type](event);\n\t\t}\n\t};\n\n\tvar getMouseOnScreen = function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnScreen(pageX, pageY) {\n\n\t\t\tvector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tvar getMouseProjectionOnBall = function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar objectUp = new THREE.Vector3();\n\t\tvar mouseOnBall = new THREE.Vector3();\n\n\t\treturn function getMouseProjectionOnBall(pageX, pageY) {\n\n\t\t\tmouseOnBall.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / _this.radius, (_this.screen.height * 0.5 + _this.screen.top - pageY) / _this.radius, 0.0);\n\n\t\t\tvar length = mouseOnBall.length();\n\n\t\t\tif (_this.noRoll) {\n\n\t\t\t\tif (length < Math.SQRT1_2) {\n\n\t\t\t\t\tmouseOnBall.z = Math.sqrt(1.0 - length * length);\n\t\t\t\t} else {\n\n\t\t\t\t\tmouseOnBall.z = .5 / length;\n\t\t\t\t}\n\t\t\t} else if (length > 1.0) {\n\n\t\t\t\tmouseOnBall.normalize();\n\t\t\t} else {\n\n\t\t\t\tmouseOnBall.z = Math.sqrt(1.0 - length * length);\n\t\t\t}\n\n\t\t\t_eye.copy(_this.object.position).sub(_this.target);\n\n\t\t\tvector.copy(_this.object.up).setLength(mouseOnBall.y);\n\t\t\tvector.add(objectUp.copy(_this.object.up).cross(_eye).setLength(mouseOnBall.x));\n\t\t\tvector.add(_eye.setLength(mouseOnBall.z));\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tthis.rotateCamera = function () {\n\n\t\tvar axis = new THREE.Vector3(),\n\t\t    quaternion = new THREE.Quaternion();\n\n\t\treturn function rotateCamera() {\n\n\t\t\tvar angle = Math.acos(_rotateStart.dot(_rotateEnd) / _rotateStart.length() / _rotateEnd.length());\n\n\t\t\tif (angle) {\n\n\t\t\t\taxis.crossVectors(_rotateStart, _rotateEnd).normalize();\n\n\t\t\t\tangle *= _this.rotateSpeed;\n\n\t\t\t\tquaternion.setFromAxisAngle(axis, -angle);\n\n\t\t\t\t_eye.applyQuaternion(quaternion);\n\t\t\t\t_this.object.up.applyQuaternion(quaternion);\n\n\t\t\t\t_rotateEnd.applyQuaternion(quaternion);\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_rotateStart.copy(_rotateEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\tquaternion.setFromAxisAngle(axis, angle * (_this.dynamicDampingFactor - 1.0));\n\t\t\t\t\t_rotateStart.applyQuaternion(quaternion);\n\t\t\t\t}\n\n\t\t\t\t_changed = true;\n\t\t\t}\n\t\t};\n\t}();\n\n\tthis.zoomCamera = function () {\n\n\t\tif (_state === STATE.TOUCH_ZOOM_PAN) {\n\n\t\t\tvar factor = _touchZoomDistanceEnd / _touchZoomDistanceStart;\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\n\n\t\t\t_this.object.zoom *= factor;\n\n\t\t\t_changed = true;\n\t\t} else {\n\n\t\t\tvar factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;\n\n\t\t\tif (Math.abs(factor - 1.0) > EPS && factor > 0.0) {\n\n\t\t\t\t_this.object.zoom /= factor;\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\t_zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;\n\t\t\t\t}\n\n\t\t\t\t_changed = true;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.panCamera = function () {\n\n\t\tvar mouseChange = new THREE.Vector2(),\n\t\t    objectUp = new THREE.Vector3(),\n\t\t    pan = new THREE.Vector3();\n\n\t\treturn function panCamera() {\n\n\t\t\tmouseChange.copy(_panEnd).sub(_panStart);\n\n\t\t\tif (mouseChange.lengthSq()) {\n\n\t\t\t\t// Scale movement to keep clicked/dragged position under cursor\n\t\t\t\tvar scale_x = (_this.object.right - _this.object.left) / _this.object.zoom;\n\t\t\t\tvar scale_y = (_this.object.top - _this.object.bottom) / _this.object.zoom;\n\t\t\t\tmouseChange.x *= scale_x;\n\t\t\t\tmouseChange.y *= scale_y;\n\n\t\t\t\tpan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);\n\t\t\t\tpan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));\n\n\t\t\t\t_this.object.position.add(pan);\n\t\t\t\t_this.target.add(pan);\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_panStart.copy(_panEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\t_panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));\n\t\t\t\t}\n\n\t\t\t\t_changed = true;\n\t\t\t}\n\t\t};\n\t}();\n\n\tthis.update = function () {\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\tif (!_this.noRotate) {\n\n\t\t\t_this.rotateCamera();\n\t\t}\n\n\t\tif (!_this.noZoom) {\n\n\t\t\t_this.zoomCamera();\n\n\t\t\tif (_changed) {\n\n\t\t\t\t_this.object.updateProjectionMatrix();\n\t\t\t}\n\t\t}\n\n\t\tif (!_this.noPan) {\n\n\t\t\t_this.panCamera();\n\t\t}\n\n\t\t_this.object.position.addVectors(_this.target, _eye);\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\tif (_changed) {\n\n\t\t\t_this.dispatchEvent(changeEvent);\n\n\t\t\t_changed = false;\n\t\t}\n\t};\n\n\tthis.reset = function () {\n\n\t\t_state = STATE.NONE;\n\t\t_prevState = STATE.NONE;\n\n\t\t_this.target.copy(_this.target0);\n\t\t_this.object.position.copy(_this.position0);\n\t\t_this.object.up.copy(_this.up0);\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\t_this.object.left = _this.left0;\n\t\t_this.object.right = _this.right0;\n\t\t_this.object.top = _this.top0;\n\t\t_this.object.bottom = _this.bottom0;\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\t_this.dispatchEvent(changeEvent);\n\n\t\t_changed = false;\n\t};\n\n\t// listeners\n\n\tfunction keydown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\twindow.removeEventListener('keydown', keydown);\n\n\t\t_prevState = _state;\n\n\t\tif (_state !== STATE.NONE) {\n\n\t\t\treturn;\n\t\t} else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {\n\n\t\t\t_state = STATE.ROTATE;\n\t\t} else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {\n\n\t\t\t_state = STATE.ZOOM;\n\t\t} else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {\n\n\t\t\t_state = STATE.PAN;\n\t\t}\n\t}\n\n\tfunction keyup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\t_state = _prevState;\n\n\t\twindow.addEventListener('keydown', keydown, false);\n\t}\n\n\tfunction mousedown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.NONE) {\n\n\t\t\t_state = event.button;\n\t\t}\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_rotateStart.copy(getMouseProjectionOnBall(event.pageX, event.pageY));\n\t\t\t_rotateEnd.copy(_rotateStart);\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_zoomEnd.copy(_zoomStart);\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_panEnd.copy(_panStart);\n\t\t}\n\n\t\tdocument.addEventListener('mousemove', mousemove, false);\n\t\tdocument.addEventListener('mouseup', mouseup, false);\n\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction mousemove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_rotateEnd.copy(getMouseProjectionOnBall(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t}\n\t}\n\n\tfunction mouseup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_state = STATE.NONE;\n\n\t\tdocument.removeEventListener('mousemove', mousemove);\n\t\tdocument.removeEventListener('mouseup', mouseup);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction mousewheel(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_zoomStart.y += event.deltaY * 0.01;\n\t\t_this.dispatchEvent(startEvent);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction touchstart(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_rotateStart.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_rotateEnd.copy(_rotateStart);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_state = STATE.TOUCH_ZOOM_PAN;\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panStart.copy(getMouseOnScreen(x, y));\n\t\t\t\t_panEnd.copy(_panStart);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction touchmove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panEnd.copy(getMouseOnScreen(x, y));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\t}\n\n\tfunction touchend(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_rotateEnd.copy(getMouseProjectionOnBall(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_rotateStart.copy(_rotateEnd);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panEnd.copy(getMouseOnScreen(x, y));\n\t\t\t\t_panStart.copy(_panEnd);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_state = STATE.NONE;\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', mousedown, false);\n\t\tthis.domElement.removeEventListener('wheel', mousewheel, false);\n\n\t\tthis.domElement.removeEventListener('touchstart', touchstart, false);\n\t\tthis.domElement.removeEventListener('touchend', touchend, false);\n\t\tthis.domElement.removeEventListener('touchmove', touchmove, false);\n\n\t\tdocument.removeEventListener('mousemove', mousemove, false);\n\t\tdocument.removeEventListener('mouseup', mouseup, false);\n\n\t\twindow.removeEventListener('keydown', keydown, false);\n\t\twindow.removeEventListener('keyup', keyup, false);\n\t};\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\tthis.domElement.addEventListener('mousedown', mousedown, false);\n\tthis.domElement.addEventListener('wheel', mousewheel, false);\n\n\tthis.domElement.addEventListener('touchstart', touchstart, false);\n\tthis.domElement.addEventListener('touchend', touchend, false);\n\tthis.domElement.addEventListener('touchmove', touchmove, false);\n\n\twindow.addEventListener('keydown', keydown, false);\n\twindow.addEventListener('keyup', keyup, false);\n\n\tthis.handleResize();\n\n\t// force an update at start\n\tthis.update();\n};\n\nOrthographicTrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nOrthographicTrackballControls.prototype.constructor = OrthographicTrackballControls;\n\nexports.default = OrthographicTrackballControls;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar PointerLockControls = function PointerLockControls(camera) {\n\n\tvar scope = this;\n\n\tcamera.rotation.set(0, 0, 0);\n\n\tvar pitchObject = new THREE.Object3D();\n\tpitchObject.add(camera);\n\n\tvar yawObject = new THREE.Object3D();\n\tyawObject.position.y = 10;\n\tyawObject.add(pitchObject);\n\n\tvar PI_2 = Math.PI / 2;\n\n\tvar onMouseMove = function onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tvar movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\n\t\tvar movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n\n\t\tyawObject.rotation.y -= movementX * 0.002;\n\t\tpitchObject.rotation.x -= movementY * 0.002;\n\n\t\tpitchObject.rotation.x = Math.max(-PI_2, Math.min(PI_2, pitchObject.rotation.x));\n\t};\n\n\tthis.dispose = function () {\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t};\n\n\tdocument.addEventListener('mousemove', onMouseMove, false);\n\n\tthis.enabled = false;\n\n\tthis.getObject = function () {\n\n\t\treturn yawObject;\n\t};\n\n\tthis.getDirection = function () {\n\n\t\t// assumes the camera itself is not rotated\n\n\t\tvar direction = new THREE.Vector3(0, 0, -1);\n\t\tvar rotation = new THREE.Euler(0, 0, 0, 'YXZ');\n\n\t\treturn function (v) {\n\n\t\t\trotation.set(pitchObject.rotation.x, yawObject.rotation.y, 0);\n\n\t\t\tv.copy(direction).applyEuler(rotation);\n\n\t\t\treturn v;\n\t\t};\n\t}();\n};\n\nexports.default = PointerLockControls;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n * @author Simone Manini / http://daron1337.github.io\n * @author Luca Antiga \t/ http://lantiga.github.io\n */\n\nvar TrackballControls = function TrackballControls(object, domElement) {\n\n\tvar _this = this;\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\n\n\tthis.object = object;\n\tthis.domElement = domElement !== undefined ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\n\n\tthis.rotateSpeed = 1.0;\n\tthis.zoomSpeed = 1.2;\n\tthis.panSpeed = 0.3;\n\n\tthis.noRotate = false;\n\tthis.noZoom = false;\n\tthis.noPan = false;\n\n\tthis.staticMoving = false;\n\tthis.dynamicDampingFactor = 0.2;\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\tthis.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n\n\t// internals\n\n\tthis.target = new THREE.Vector3();\n\n\tvar EPS = 0.000001;\n\n\tvar lastPosition = new THREE.Vector3();\n\n\tvar _state = STATE.NONE,\n\t    _prevState = STATE.NONE,\n\t    _eye = new THREE.Vector3(),\n\t    _movePrev = new THREE.Vector2(),\n\t    _moveCurr = new THREE.Vector2(),\n\t    _lastAxis = new THREE.Vector3(),\n\t    _lastAngle = 0,\n\t    _zoomStart = new THREE.Vector2(),\n\t    _zoomEnd = new THREE.Vector2(),\n\t    _touchZoomDistanceStart = 0,\n\t    _touchZoomDistanceEnd = 0,\n\t    _panStart = new THREE.Vector2(),\n\t    _panEnd = new THREE.Vector2();\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.up0 = this.object.up.clone();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\t// methods\n\n\tthis.handleResize = function () {\n\n\t\tif (this.domElement === document) {\n\n\t\t\tthis.screen.left = 0;\n\t\t\tthis.screen.top = 0;\n\t\t\tthis.screen.width = window.innerWidth;\n\t\t\tthis.screen.height = window.innerHeight;\n\t\t} else {\n\n\t\t\tvar box = this.domElement.getBoundingClientRect();\n\t\t\t// adjustments come from similar code in the jquery offset() function\n\t\t\tvar d = this.domElement.ownerDocument.documentElement;\n\t\t\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\n\t\t\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\n\t\t\tthis.screen.width = box.width;\n\t\t\tthis.screen.height = box.height;\n\t\t}\n\t};\n\n\tthis.handleEvent = function (event) {\n\n\t\tif (typeof this[event.type] == 'function') {\n\n\t\t\tthis[event.type](event);\n\t\t}\n\t};\n\n\tvar getMouseOnScreen = function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnScreen(pageX, pageY) {\n\n\t\t\tvector.set((pageX - _this.screen.left) / _this.screen.width, (pageY - _this.screen.top) / _this.screen.height);\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tvar getMouseOnCircle = function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnCircle(pageX, pageY) {\n\n\t\t\tvector.set((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5), (_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width // screen.width intentional\n\t\t\t);\n\n\t\t\treturn vector;\n\t\t};\n\t}();\n\n\tthis.rotateCamera = function () {\n\n\t\tvar axis = new THREE.Vector3(),\n\t\t    quaternion = new THREE.Quaternion(),\n\t\t    eyeDirection = new THREE.Vector3(),\n\t\t    objectUpDirection = new THREE.Vector3(),\n\t\t    objectSidewaysDirection = new THREE.Vector3(),\n\t\t    moveDirection = new THREE.Vector3(),\n\t\t    angle;\n\n\t\treturn function rotateCamera() {\n\n\t\t\tmoveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);\n\t\t\tangle = moveDirection.length();\n\n\t\t\tif (angle) {\n\n\t\t\t\t_eye.copy(_this.object.position).sub(_this.target);\n\n\t\t\t\teyeDirection.copy(_eye).normalize();\n\t\t\t\tobjectUpDirection.copy(_this.object.up).normalize();\n\t\t\t\tobjectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();\n\n\t\t\t\tobjectUpDirection.setLength(_moveCurr.y - _movePrev.y);\n\t\t\t\tobjectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);\n\n\t\t\t\tmoveDirection.copy(objectUpDirection.add(objectSidewaysDirection));\n\n\t\t\t\taxis.crossVectors(moveDirection, _eye).normalize();\n\n\t\t\t\tangle *= _this.rotateSpeed;\n\t\t\t\tquaternion.setFromAxisAngle(axis, angle);\n\n\t\t\t\t_eye.applyQuaternion(quaternion);\n\t\t\t\t_this.object.up.applyQuaternion(quaternion);\n\n\t\t\t\t_lastAxis.copy(axis);\n\t\t\t\t_lastAngle = angle;\n\t\t\t} else if (!_this.staticMoving && _lastAngle) {\n\n\t\t\t\t_lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor);\n\t\t\t\t_eye.copy(_this.object.position).sub(_this.target);\n\t\t\t\tquaternion.setFromAxisAngle(_lastAxis, _lastAngle);\n\t\t\t\t_eye.applyQuaternion(quaternion);\n\t\t\t\t_this.object.up.applyQuaternion(quaternion);\n\t\t\t}\n\n\t\t\t_movePrev.copy(_moveCurr);\n\t\t};\n\t}();\n\n\tthis.zoomCamera = function () {\n\n\t\tvar factor;\n\n\t\tif (_state === STATE.TOUCH_ZOOM_PAN) {\n\n\t\t\tfactor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\n\t\t\t_eye.multiplyScalar(factor);\n\t\t} else {\n\n\t\t\tfactor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed;\n\n\t\t\tif (factor !== 1.0 && factor > 0.0) {\n\n\t\t\t\t_eye.multiplyScalar(factor);\n\t\t\t}\n\n\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t} else {\n\n\t\t\t\t_zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.panCamera = function () {\n\n\t\tvar mouseChange = new THREE.Vector2(),\n\t\t    objectUp = new THREE.Vector3(),\n\t\t    pan = new THREE.Vector3();\n\n\t\treturn function panCamera() {\n\n\t\t\tmouseChange.copy(_panEnd).sub(_panStart);\n\n\t\t\tif (mouseChange.lengthSq()) {\n\n\t\t\t\tmouseChange.multiplyScalar(_eye.length() * _this.panSpeed);\n\n\t\t\t\tpan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x);\n\t\t\t\tpan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y));\n\n\t\t\t\t_this.object.position.add(pan);\n\t\t\t\t_this.target.add(pan);\n\n\t\t\t\tif (_this.staticMoving) {\n\n\t\t\t\t\t_panStart.copy(_panEnd);\n\t\t\t\t} else {\n\n\t\t\t\t\t_panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}();\n\n\tthis.checkDistances = function () {\n\n\t\tif (!_this.noZoom || !_this.noPan) {\n\n\t\t\tif (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {\n\n\t\t\t\t_this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance));\n\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t}\n\n\t\t\tif (_eye.lengthSq() < _this.minDistance * _this.minDistance) {\n\n\t\t\t\t_this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance));\n\t\t\t\t_zoomStart.copy(_zoomEnd);\n\t\t\t}\n\t\t}\n\t};\n\n\tthis.update = function () {\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\tif (!_this.noRotate) {\n\n\t\t\t_this.rotateCamera();\n\t\t}\n\n\t\tif (!_this.noZoom) {\n\n\t\t\t_this.zoomCamera();\n\t\t}\n\n\t\tif (!_this.noPan) {\n\n\t\t\t_this.panCamera();\n\t\t}\n\n\t\t_this.object.position.addVectors(_this.target, _eye);\n\n\t\t_this.checkDistances();\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\tif (lastPosition.distanceToSquared(_this.object.position) > EPS) {\n\n\t\t\t_this.dispatchEvent(changeEvent);\n\n\t\t\tlastPosition.copy(_this.object.position);\n\t\t}\n\t};\n\n\tthis.reset = function () {\n\n\t\t_state = STATE.NONE;\n\t\t_prevState = STATE.NONE;\n\n\t\t_this.target.copy(_this.target0);\n\t\t_this.object.position.copy(_this.position0);\n\t\t_this.object.up.copy(_this.up0);\n\n\t\t_eye.subVectors(_this.object.position, _this.target);\n\n\t\t_this.object.lookAt(_this.target);\n\n\t\t_this.dispatchEvent(changeEvent);\n\n\t\tlastPosition.copy(_this.object.position);\n\t};\n\n\t// listeners\n\n\tfunction keydown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\twindow.removeEventListener('keydown', keydown);\n\n\t\t_prevState = _state;\n\n\t\tif (_state !== STATE.NONE) {\n\n\t\t\treturn;\n\t\t} else if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {\n\n\t\t\t_state = STATE.ROTATE;\n\t\t} else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {\n\n\t\t\t_state = STATE.ZOOM;\n\t\t} else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {\n\n\t\t\t_state = STATE.PAN;\n\t\t}\n\t}\n\n\tfunction keyup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\t_state = _prevState;\n\n\t\twindow.addEventListener('keydown', keydown, false);\n\t}\n\n\tfunction mousedown(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.NONE) {\n\n\t\t\t_state = event.button;\n\t\t}\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n\t\t\t_movePrev.copy(_moveCurr);\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_zoomEnd.copy(_zoomStart);\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t\t_panEnd.copy(_panStart);\n\t\t}\n\n\t\tdocument.addEventListener('mousemove', mousemove, false);\n\t\tdocument.addEventListener('mouseup', mouseup, false);\n\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction mousemove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif (_state === STATE.ROTATE && !_this.noRotate) {\n\n\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t_moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.ZOOM && !_this.noZoom) {\n\n\t\t\t_zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t} else if (_state === STATE.PAN && !_this.noPan) {\n\n\t\t\t_panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n\t\t}\n\t}\n\n\tfunction mouseup(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_state = STATE.NONE;\n\n\t\tdocument.removeEventListener('mousemove', mousemove);\n\t\tdocument.removeEventListener('mouseup', mouseup);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction mousewheel(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tif (_this.noZoom === true) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.deltaMode) {\n\n\t\t\tcase 2:\n\t\t\t\t// Zoom in pages\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.025;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t// Zoom in lines\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.01;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// undefined, 0, assume pixels\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.00025;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent(startEvent);\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction touchstart(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// 2 or more\n\t\t\t\t_state = STATE.TOUCH_ZOOM_PAN;\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panStart.copy(getMouseOnScreen(x, y));\n\t\t\t\t_panEnd.copy(_panStart);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent(startEvent);\n\t}\n\n\tfunction touchmove(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\t\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t\t_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// 2 or more\n\t\t\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\t\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tvar x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n\t\t\t\tvar y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n\t\t\t\t_panEnd.copy(getMouseOnScreen(x, y));\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\tfunction touchend(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 0:\n\t\t\t\t_state = STATE.NONE;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n\t\t\t\t_movePrev.copy(_moveCurr);\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent(endEvent);\n\t}\n\n\tfunction contextmenu(event) {\n\n\t\tif (_this.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener('contextmenu', contextmenu, false);\n\t\tthis.domElement.removeEventListener('mousedown', mousedown, false);\n\t\tthis.domElement.removeEventListener('wheel', mousewheel, false);\n\n\t\tthis.domElement.removeEventListener('touchstart', touchstart, false);\n\t\tthis.domElement.removeEventListener('touchend', touchend, false);\n\t\tthis.domElement.removeEventListener('touchmove', touchmove, false);\n\n\t\tdocument.removeEventListener('mousemove', mousemove, false);\n\t\tdocument.removeEventListener('mouseup', mouseup, false);\n\n\t\twindow.removeEventListener('keydown', keydown, false);\n\t\twindow.removeEventListener('keyup', keyup, false);\n\t};\n\n\tthis.domElement.addEventListener('contextmenu', contextmenu, false);\n\tthis.domElement.addEventListener('mousedown', mousedown, false);\n\tthis.domElement.addEventListener('wheel', mousewheel, false);\n\n\tthis.domElement.addEventListener('touchstart', touchstart, false);\n\tthis.domElement.addEventListener('touchend', touchend, false);\n\tthis.domElement.addEventListener('touchmove', touchmove, false);\n\n\twindow.addEventListener('keydown', keydown, false);\n\twindow.addEventListener('keyup', keyup, false);\n\n\tthis.handleResize();\n\n\t// force an update at start\n\tthis.update();\n};\n\nTrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nTrackballControls.prototype.constructor = TrackballControls;\n\nexports.default = TrackballControls;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author arodic / https://github.com/arodic\n */\n\nexports.default = function () {\n\n\t'use strict';\n\n\tvar GizmoMaterial = function GizmoMaterial(parameters) {\n\n\t\tTHREE.MeshBasicMaterial.call(this);\n\n\t\tthis.depthTest = false;\n\t\tthis.depthWrite = false;\n\t\tthis.fog = false;\n\t\tthis.side = THREE.FrontSide;\n\t\tthis.transparent = true;\n\n\t\tthis.setValues(parameters);\n\n\t\tthis.oldColor = this.color.clone();\n\t\tthis.oldOpacity = this.opacity;\n\n\t\tthis.highlight = function (highlighted) {\n\n\t\t\tif (highlighted) {\n\n\t\t\t\tthis.color.setRGB(1, 1, 0);\n\t\t\t\tthis.opacity = 1;\n\t\t\t} else {\n\n\t\t\t\tthis.color.copy(this.oldColor);\n\t\t\t\tthis.opacity = this.oldOpacity;\n\t\t\t}\n\t\t};\n\t};\n\n\tGizmoMaterial.prototype = Object.create(THREE.MeshBasicMaterial.prototype);\n\tGizmoMaterial.prototype.constructor = GizmoMaterial;\n\n\tvar GizmoLineMaterial = function GizmoLineMaterial(parameters) {\n\n\t\tTHREE.LineBasicMaterial.call(this);\n\n\t\tthis.depthTest = false;\n\t\tthis.depthWrite = false;\n\t\tthis.fog = false;\n\t\tthis.transparent = true;\n\t\tthis.linewidth = 1;\n\n\t\tthis.setValues(parameters);\n\n\t\tthis.oldColor = this.color.clone();\n\t\tthis.oldOpacity = this.opacity;\n\n\t\tthis.highlight = function (highlighted) {\n\n\t\t\tif (highlighted) {\n\n\t\t\t\tthis.color.setRGB(1, 1, 0);\n\t\t\t\tthis.opacity = 1;\n\t\t\t} else {\n\n\t\t\t\tthis.color.copy(this.oldColor);\n\t\t\t\tthis.opacity = this.oldOpacity;\n\t\t\t}\n\t\t};\n\t};\n\n\tGizmoLineMaterial.prototype = Object.create(THREE.LineBasicMaterial.prototype);\n\tGizmoLineMaterial.prototype.constructor = GizmoLineMaterial;\n\n\tvar pickerMaterial = new GizmoMaterial({ visible: false, transparent: false });\n\n\tvar TransformGizmo = function TransformGizmo() {\n\n\t\tthis.init = function () {\n\n\t\t\tTHREE.Object3D.call(this);\n\n\t\t\tthis.handles = new THREE.Object3D();\n\t\t\tthis.pickers = new THREE.Object3D();\n\t\t\tthis.planes = new THREE.Object3D();\n\n\t\t\tthis.add(this.handles);\n\t\t\tthis.add(this.pickers);\n\t\t\tthis.add(this.planes);\n\n\t\t\t//// PLANES\n\n\t\t\tvar planeGeometry = new THREE.PlaneBufferGeometry(50, 50, 2, 2);\n\t\t\tvar planeMaterial = new THREE.MeshBasicMaterial({ visible: false, side: THREE.DoubleSide });\n\n\t\t\tvar planes = {\n\t\t\t\t\"XY\": new THREE.Mesh(planeGeometry, planeMaterial),\n\t\t\t\t\"YZ\": new THREE.Mesh(planeGeometry, planeMaterial),\n\t\t\t\t\"XZ\": new THREE.Mesh(planeGeometry, planeMaterial),\n\t\t\t\t\"XYZE\": new THREE.Mesh(planeGeometry, planeMaterial)\n\t\t\t};\n\n\t\t\tthis.activePlane = planes[\"XYZE\"];\n\n\t\t\tplanes[\"YZ\"].rotation.set(0, Math.PI / 2, 0);\n\t\t\tplanes[\"XZ\"].rotation.set(-Math.PI / 2, 0, 0);\n\n\t\t\tfor (var i in planes) {\n\n\t\t\t\tplanes[i].name = i;\n\t\t\t\tthis.planes.add(planes[i]);\n\t\t\t\tthis.planes[i] = planes[i];\n\t\t\t}\n\n\t\t\t//// HANDLES AND PICKERS\n\n\t\t\tvar setupGizmos = function setupGizmos(gizmoMap, parent) {\n\n\t\t\t\tfor (var name in gizmoMap) {\n\n\t\t\t\t\tfor (i = gizmoMap[name].length; i--;) {\n\n\t\t\t\t\t\tvar object = gizmoMap[name][i][0];\n\t\t\t\t\t\tvar position = gizmoMap[name][i][1];\n\t\t\t\t\t\tvar rotation = gizmoMap[name][i][2];\n\n\t\t\t\t\t\tobject.name = name;\n\n\t\t\t\t\t\tobject.renderOrder = Infinity; // avoid being hidden by other transparent objects\n\n\t\t\t\t\t\tif (position) object.position.set(position[0], position[1], position[2]);\n\t\t\t\t\t\tif (rotation) object.rotation.set(rotation[0], rotation[1], rotation[2]);\n\n\t\t\t\t\t\tparent.add(object);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tsetupGizmos(this.handleGizmos, this.handles);\n\t\t\tsetupGizmos(this.pickerGizmos, this.pickers);\n\n\t\t\t// reset Transformations\n\n\t\t\tthis.traverse(function (child) {\n\n\t\t\t\tif (child instanceof THREE.Mesh) {\n\n\t\t\t\t\tchild.updateMatrix();\n\n\t\t\t\t\tvar tempGeometry = child.geometry.clone();\n\t\t\t\t\ttempGeometry.applyMatrix(child.matrix);\n\t\t\t\t\tchild.geometry = tempGeometry;\n\n\t\t\t\t\tchild.position.set(0, 0, 0);\n\t\t\t\t\tchild.rotation.set(0, 0, 0);\n\t\t\t\t\tchild.scale.set(1, 1, 1);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tthis.highlight = function (axis) {\n\n\t\t\tthis.traverse(function (child) {\n\n\t\t\t\tif (child.material && child.material.highlight) {\n\n\t\t\t\t\tif (child.name === axis) {\n\n\t\t\t\t\t\tchild.material.highlight(true);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tchild.material.highlight(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n\n\tTransformGizmo.prototype = Object.create(THREE.Object3D.prototype);\n\tTransformGizmo.prototype.constructor = TransformGizmo;\n\n\tTransformGizmo.prototype.update = function (rotation, eye) {\n\n\t\tvar vec1 = new THREE.Vector3(0, 0, 0);\n\t\tvar vec2 = new THREE.Vector3(0, 1, 0);\n\t\tvar lookAtMatrix = new THREE.Matrix4();\n\n\t\tthis.traverse(function (child) {\n\n\t\t\tif (child.name.search(\"E\") !== -1) {\n\n\t\t\t\tchild.quaternion.setFromRotationMatrix(lookAtMatrix.lookAt(eye, vec1, vec2));\n\t\t\t} else if (child.name.search(\"X\") !== -1 || child.name.search(\"Y\") !== -1 || child.name.search(\"Z\") !== -1) {\n\n\t\t\t\tchild.quaternion.setFromEuler(rotation);\n\t\t\t}\n\t\t});\n\t};\n\n\tvar TransformGizmoTranslate = function TransformGizmoTranslate() {\n\n\t\tTransformGizmo.call(this);\n\n\t\tvar arrowGeometry = new THREE.Geometry();\n\t\tvar mesh = new THREE.Mesh(new THREE.CylinderGeometry(0, 0.05, 0.2, 12, 1, false));\n\t\tmesh.position.y = 0.5;\n\t\tmesh.updateMatrix();\n\n\t\tarrowGeometry.merge(mesh.geometry, mesh.matrix);\n\n\t\tvar lineXGeometry = new THREE.BufferGeometry();\n\t\tlineXGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));\n\n\t\tvar lineYGeometry = new THREE.BufferGeometry();\n\t\tlineYGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n\t\tvar lineZGeometry = new THREE.BufferGeometry();\n\t\tlineZGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n\n\t\tthis.handleGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n\t\t\tY: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n\t\t\tZ: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(0.1, 0), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 })), [0, 0, 0], [0, 0, 0]]],\n\n\t\t\tXY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xffff00, opacity: 0.25 })), [0.15, 0.15, 0]]],\n\n\t\t\tYZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0x00ffff, opacity: 0.25 })), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]],\n\n\t\t\tXZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.29, 0.29), new GizmoMaterial({ color: 0xff00ff, opacity: 0.25 })), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]]\n\n\t\t};\n\n\t\tthis.pickerGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n\n\t\t\tY: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],\n\n\t\t\tZ: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.OctahedronGeometry(0.2, 0), pickerMaterial)]],\n\n\t\t\tXY: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0.2, 0]]],\n\n\t\t\tYZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],\n\n\t\t\tXZ: [[new THREE.Mesh(new THREE.PlaneBufferGeometry(0.4, 0.4), pickerMaterial), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]\n\n\t\t};\n\n\t\tthis.setActivePlane = function (axis, eye) {\n\n\t\t\tvar tempMatrix = new THREE.Matrix4();\n\t\t\teye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes[\"XY\"].matrixWorld)));\n\n\t\t\tif (axis === \"X\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\n\t\t\t\tif (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes[\"XZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Y\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Z\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XZ\"];\n\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"XYZ\") this.activePlane = this.planes[\"XYZE\"];\n\n\t\t\tif (axis === \"XY\") this.activePlane = this.planes[\"XY\"];\n\n\t\t\tif (axis === \"YZ\") this.activePlane = this.planes[\"YZ\"];\n\n\t\t\tif (axis === \"XZ\") this.activePlane = this.planes[\"XZ\"];\n\t\t};\n\n\t\tthis.init();\n\t};\n\n\tTransformGizmoTranslate.prototype = Object.create(TransformGizmo.prototype);\n\tTransformGizmoTranslate.prototype.constructor = TransformGizmoTranslate;\n\n\tvar TransformGizmoRotate = function TransformGizmoRotate() {\n\n\t\tTransformGizmo.call(this);\n\n\t\tvar CircleGeometry = function CircleGeometry(radius, facing, arc) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar vertices = [];\n\t\t\tarc = arc ? arc : 1;\n\n\t\t\tfor (var i = 0; i <= 64 * arc; ++i) {\n\n\t\t\t\tif (facing === 'x') vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);\n\t\t\t\tif (facing === 'y') vertices.push(Math.cos(i / 32 * Math.PI) * radius, 0, Math.sin(i / 32 * Math.PI) * radius);\n\t\t\t\tif (facing === 'z') vertices.push(Math.sin(i / 32 * Math.PI) * radius, Math.cos(i / 32 * Math.PI) * radius, 0);\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\t\treturn geometry;\n\t\t};\n\n\t\tthis.handleGizmos = {\n\n\t\t\tX: [[new THREE.Line(new CircleGeometry(1, 'x', 0.5), new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n\t\t\tY: [[new THREE.Line(new CircleGeometry(1, 'y', 0.5), new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n\t\t\tZ: [[new THREE.Line(new CircleGeometry(1, 'z', 0.5), new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n\t\t\tE: [[new THREE.Line(new CircleGeometry(1.25, 'z', 1), new GizmoLineMaterial({ color: 0xcccc00 }))]],\n\n\t\t\tXYZE: [[new THREE.Line(new CircleGeometry(1, 'z', 1), new GizmoLineMaterial({ color: 0x787878 }))]]\n\n\t\t};\n\n\t\tthis.pickerGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],\n\n\t\t\tY: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [Math.PI / 2, 0, 0]]],\n\n\t\t\tZ: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 4, 12, Math.PI), pickerMaterial), [0, 0, 0], [0, 0, -Math.PI / 2]]],\n\n\t\t\tE: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1.25, 0.12, 2, 24), pickerMaterial)]],\n\n\t\t\tXYZE: [[new THREE.Mesh(new THREE.TorusBufferGeometry(1, 0.12, 2, 24), pickerMaterial)]]\n\n\t\t};\n\n\t\tthis.pickerGizmos.XYZE[0][0].visible = false; // disable XYZE picker gizmo\n\n\t\tthis.setActivePlane = function (axis) {\n\n\t\t\tif (axis === \"E\") this.activePlane = this.planes[\"XYZE\"];\n\n\t\t\tif (axis === \"X\") this.activePlane = this.planes[\"YZ\"];\n\n\t\t\tif (axis === \"Y\") this.activePlane = this.planes[\"XZ\"];\n\n\t\t\tif (axis === \"Z\") this.activePlane = this.planes[\"XY\"];\n\t\t};\n\n\t\tthis.update = function (rotation, eye2) {\n\n\t\t\tTransformGizmo.prototype.update.apply(this, arguments);\n\n\t\t\tvar tempMatrix = new THREE.Matrix4();\n\t\t\tvar worldRotation = new THREE.Euler(0, 0, 1);\n\t\t\tvar tempQuaternion = new THREE.Quaternion();\n\t\t\tvar unitX = new THREE.Vector3(1, 0, 0);\n\t\t\tvar unitY = new THREE.Vector3(0, 1, 0);\n\t\t\tvar unitZ = new THREE.Vector3(0, 0, 1);\n\t\t\tvar quaternionX = new THREE.Quaternion();\n\t\t\tvar quaternionY = new THREE.Quaternion();\n\t\t\tvar quaternionZ = new THREE.Quaternion();\n\t\t\tvar eye = eye2.clone();\n\n\t\t\tworldRotation.copy(this.planes[\"XY\"].rotation);\n\t\t\ttempQuaternion.setFromEuler(worldRotation);\n\n\t\t\ttempMatrix.makeRotationFromQuaternion(tempQuaternion).getInverse(tempMatrix);\n\t\t\teye.applyMatrix4(tempMatrix);\n\n\t\t\tthis.traverse(function (child) {\n\n\t\t\t\ttempQuaternion.setFromEuler(worldRotation);\n\n\t\t\t\tif (child.name === \"X\") {\n\n\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, Math.atan2(-eye.y, eye.z));\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n\t\t\t\t\tchild.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\n\t\t\t\tif (child.name === \"Y\") {\n\n\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, Math.atan2(eye.x, eye.z));\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);\n\t\t\t\t\tchild.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\n\t\t\t\tif (child.name === \"Z\") {\n\n\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, Math.atan2(eye.y, eye.x));\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);\n\t\t\t\t\tchild.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tthis.init();\n\t};\n\n\tTransformGizmoRotate.prototype = Object.create(TransformGizmo.prototype);\n\tTransformGizmoRotate.prototype.constructor = TransformGizmoRotate;\n\n\tvar TransformGizmoScale = function TransformGizmoScale() {\n\n\t\tTransformGizmo.call(this);\n\n\t\tvar arrowGeometry = new THREE.Geometry();\n\t\tvar mesh = new THREE.Mesh(new THREE.BoxGeometry(0.125, 0.125, 0.125));\n\t\tmesh.position.y = 0.5;\n\t\tmesh.updateMatrix();\n\n\t\tarrowGeometry.merge(mesh.geometry, mesh.matrix);\n\n\t\tvar lineXGeometry = new THREE.BufferGeometry();\n\t\tlineXGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));\n\n\t\tvar lineYGeometry = new THREE.BufferGeometry();\n\t\tlineYGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n\n\t\tvar lineZGeometry = new THREE.BufferGeometry();\n\t\tlineZGeometry.addAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n\n\t\tthis.handleGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0xff0000 })), [0.5, 0, 0], [0, 0, -Math.PI / 2]], [new THREE.Line(lineXGeometry, new GizmoLineMaterial({ color: 0xff0000 }))]],\n\n\t\t\tY: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x00ff00 })), [0, 0.5, 0]], [new THREE.Line(lineYGeometry, new GizmoLineMaterial({ color: 0x00ff00 }))]],\n\n\t\t\tZ: [[new THREE.Mesh(arrowGeometry, new GizmoMaterial({ color: 0x0000ff })), [0, 0, 0.5], [Math.PI / 2, 0, 0]], [new THREE.Line(lineZGeometry, new GizmoLineMaterial({ color: 0x0000ff }))]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.125, 0.125, 0.125), new GizmoMaterial({ color: 0xffffff, opacity: 0.25 }))]]\n\n\t\t};\n\n\t\tthis.pickerGizmos = {\n\n\t\t\tX: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],\n\n\t\t\tY: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0.6, 0]]],\n\n\t\t\tZ: [[new THREE.Mesh(new THREE.CylinderBufferGeometry(0.2, 0, 1, 4, 1, false), pickerMaterial), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],\n\n\t\t\tXYZ: [[new THREE.Mesh(new THREE.BoxBufferGeometry(0.4, 0.4, 0.4), pickerMaterial)]]\n\n\t\t};\n\n\t\tthis.setActivePlane = function (axis, eye) {\n\n\t\t\tvar tempMatrix = new THREE.Matrix4();\n\t\t\teye.applyMatrix4(tempMatrix.getInverse(tempMatrix.extractRotation(this.planes[\"XY\"].matrixWorld)));\n\n\t\t\tif (axis === \"X\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\t\t\t\tif (Math.abs(eye.y) > Math.abs(eye.z)) this.activePlane = this.planes[\"XZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Y\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XY\"];\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.z)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"Z\") {\n\n\t\t\t\tthis.activePlane = this.planes[\"XZ\"];\n\t\t\t\tif (Math.abs(eye.x) > Math.abs(eye.y)) this.activePlane = this.planes[\"YZ\"];\n\t\t\t}\n\n\t\t\tif (axis === \"XYZ\") this.activePlane = this.planes[\"XYZE\"];\n\t\t};\n\n\t\tthis.init();\n\t};\n\n\tTransformGizmoScale.prototype = Object.create(TransformGizmo.prototype);\n\tTransformGizmoScale.prototype.constructor = TransformGizmoScale;\n\n\tvar TransformControls = function TransformControls(camera, domElement) {\n\n\t\t// TODO: Make non-uniform scale and rotate play nice in hierarchies\n\t\t// TODO: ADD RXYZ contol\n\n\t\tTHREE.Object3D.call(this);\n\n\t\tdomElement = domElement !== undefined ? domElement : document;\n\n\t\tthis.object = undefined;\n\t\tthis.visible = false;\n\t\tthis.translationSnap = null;\n\t\tthis.rotationSnap = null;\n\t\tthis.space = \"world\";\n\t\tthis.size = 1;\n\t\tthis.axis = null;\n\n\t\tvar scope = this;\n\n\t\tvar _mode = \"translate\";\n\t\tvar _dragging = false;\n\t\tvar _gizmo = {\n\n\t\t\t\"translate\": new TransformGizmoTranslate(),\n\t\t\t\"rotate\": new TransformGizmoRotate(),\n\t\t\t\"scale\": new TransformGizmoScale()\n\t\t};\n\n\t\tfor (var type in _gizmo) {\n\n\t\t\tvar gizmoObj = _gizmo[type];\n\n\t\t\tgizmoObj.visible = type === _mode;\n\t\t\tthis.add(gizmoObj);\n\t\t}\n\n\t\tvar changeEvent = { type: \"change\" };\n\t\tvar mouseDownEvent = { type: \"mouseDown\" };\n\t\tvar mouseUpEvent = { type: \"mouseUp\", mode: _mode };\n\t\tvar objectChangeEvent = { type: \"objectChange\" };\n\n\t\tvar ray = new THREE.Raycaster();\n\t\tvar pointerVector = new THREE.Vector2();\n\n\t\tvar point = new THREE.Vector3();\n\t\tvar offset = new THREE.Vector3();\n\n\t\tvar rotation = new THREE.Vector3();\n\t\tvar offsetRotation = new THREE.Vector3();\n\t\tvar scale = 1;\n\n\t\tvar lookAtMatrix = new THREE.Matrix4();\n\t\tvar eye = new THREE.Vector3();\n\n\t\tvar tempMatrix = new THREE.Matrix4();\n\t\tvar tempVector = new THREE.Vector3();\n\t\tvar tempQuaternion = new THREE.Quaternion();\n\t\tvar unitX = new THREE.Vector3(1, 0, 0);\n\t\tvar unitY = new THREE.Vector3(0, 1, 0);\n\t\tvar unitZ = new THREE.Vector3(0, 0, 1);\n\n\t\tvar quaternionXYZ = new THREE.Quaternion();\n\t\tvar quaternionX = new THREE.Quaternion();\n\t\tvar quaternionY = new THREE.Quaternion();\n\t\tvar quaternionZ = new THREE.Quaternion();\n\t\tvar quaternionE = new THREE.Quaternion();\n\n\t\tvar oldPosition = new THREE.Vector3();\n\t\tvar oldScale = new THREE.Vector3();\n\t\tvar oldRotationMatrix = new THREE.Matrix4();\n\n\t\tvar parentRotationMatrix = new THREE.Matrix4();\n\t\tvar parentScale = new THREE.Vector3();\n\n\t\tvar worldPosition = new THREE.Vector3();\n\t\tvar worldRotation = new THREE.Euler();\n\t\tvar worldRotationMatrix = new THREE.Matrix4();\n\t\tvar camPosition = new THREE.Vector3();\n\t\tvar camRotation = new THREE.Euler();\n\n\t\tdomElement.addEventListener(\"mousedown\", onPointerDown, false);\n\t\tdomElement.addEventListener(\"touchstart\", onPointerDown, false);\n\n\t\tdomElement.addEventListener(\"mousemove\", onPointerHover, false);\n\t\tdomElement.addEventListener(\"touchmove\", onPointerHover, false);\n\n\t\tdomElement.addEventListener(\"mousemove\", onPointerMove, false);\n\t\tdomElement.addEventListener(\"touchmove\", onPointerMove, false);\n\n\t\tdomElement.addEventListener(\"mouseup\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"mouseout\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"touchend\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"touchcancel\", onPointerUp, false);\n\t\tdomElement.addEventListener(\"touchleave\", onPointerUp, false);\n\n\t\tthis.dispose = function () {\n\n\t\t\tdomElement.removeEventListener(\"mousedown\", onPointerDown);\n\t\t\tdomElement.removeEventListener(\"touchstart\", onPointerDown);\n\n\t\t\tdomElement.removeEventListener(\"mousemove\", onPointerHover);\n\t\t\tdomElement.removeEventListener(\"touchmove\", onPointerHover);\n\n\t\t\tdomElement.removeEventListener(\"mousemove\", onPointerMove);\n\t\t\tdomElement.removeEventListener(\"touchmove\", onPointerMove);\n\n\t\t\tdomElement.removeEventListener(\"mouseup\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"mouseout\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"touchend\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"touchcancel\", onPointerUp);\n\t\t\tdomElement.removeEventListener(\"touchleave\", onPointerUp);\n\t\t};\n\n\t\tthis.attach = function (object) {\n\n\t\t\tthis.object = object;\n\t\t\tthis.visible = true;\n\t\t\tthis.update();\n\t\t};\n\n\t\tthis.detach = function () {\n\n\t\t\tthis.object = undefined;\n\t\t\tthis.visible = false;\n\t\t\tthis.axis = null;\n\t\t};\n\n\t\tthis.getMode = function () {\n\n\t\t\treturn _mode;\n\t\t};\n\n\t\tthis.setMode = function (mode) {\n\n\t\t\t_mode = mode ? mode : _mode;\n\n\t\t\tif (_mode === \"scale\") scope.space = \"local\";\n\n\t\t\tfor (var type in _gizmo) {\n\t\t\t\t_gizmo[type].visible = type === _mode;\n\t\t\t}this.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t};\n\n\t\tthis.setTranslationSnap = function (translationSnap) {\n\n\t\t\tscope.translationSnap = translationSnap;\n\t\t};\n\n\t\tthis.setRotationSnap = function (rotationSnap) {\n\n\t\t\tscope.rotationSnap = rotationSnap;\n\t\t};\n\n\t\tthis.setSize = function (size) {\n\n\t\t\tscope.size = size;\n\t\t\tthis.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t};\n\n\t\tthis.setSpace = function (space) {\n\n\t\t\tscope.space = space;\n\t\t\tthis.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t};\n\n\t\tthis.update = function () {\n\n\t\t\tif (scope.object === undefined) return;\n\n\t\t\tscope.object.updateMatrixWorld();\n\t\t\tworldPosition.setFromMatrixPosition(scope.object.matrixWorld);\n\t\t\tworldRotation.setFromRotationMatrix(tempMatrix.extractRotation(scope.object.matrixWorld));\n\n\t\t\tcamera.updateMatrixWorld();\n\t\t\tcamPosition.setFromMatrixPosition(camera.matrixWorld);\n\t\t\tcamRotation.setFromRotationMatrix(tempMatrix.extractRotation(camera.matrixWorld));\n\n\t\t\tscale = worldPosition.distanceTo(camPosition) / 6 * scope.size;\n\t\t\tthis.position.copy(worldPosition);\n\t\t\tthis.scale.set(scale, scale, scale);\n\n\t\t\tif (camera instanceof THREE.PerspectiveCamera) {\n\n\t\t\t\teye.copy(camPosition).sub(worldPosition).normalize();\n\t\t\t} else if (camera instanceof THREE.OrthographicCamera) {\n\n\t\t\t\teye.copy(camPosition).normalize();\n\t\t\t}\n\n\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t_gizmo[_mode].update(worldRotation, eye);\n\t\t\t} else if (scope.space === \"world\") {\n\n\t\t\t\t_gizmo[_mode].update(new THREE.Euler(), eye);\n\t\t\t}\n\n\t\t\t_gizmo[_mode].highlight(scope.axis);\n\t\t};\n\n\t\tfunction onPointerHover(event) {\n\n\t\t\tif (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[0] : event;\n\n\t\t\tvar intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);\n\n\t\t\tvar axis = null;\n\n\t\t\tif (intersect) {\n\n\t\t\t\taxis = intersect.object.name;\n\n\t\t\t\tevent.preventDefault();\n\t\t\t}\n\n\t\t\tif (scope.axis !== axis) {\n\n\t\t\t\tscope.axis = axis;\n\t\t\t\tscope.update();\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\t\t\t}\n\t\t}\n\n\t\tfunction onPointerDown(event) {\n\n\t\t\tif (scope.object === undefined || _dragging === true || event.button !== undefined && event.button !== 0) return;\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[0] : event;\n\n\t\t\tif (pointer.button === 0 || pointer.button === undefined) {\n\n\t\t\t\tvar intersect = intersectObjects(pointer, _gizmo[_mode].pickers.children);\n\n\t\t\t\tif (intersect) {\n\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopPropagation();\n\n\t\t\t\t\tscope.axis = intersect.object.name;\n\n\t\t\t\t\tscope.dispatchEvent(mouseDownEvent);\n\n\t\t\t\t\tscope.update();\n\n\t\t\t\t\teye.copy(camPosition).sub(worldPosition).normalize();\n\n\t\t\t\t\t_gizmo[_mode].setActivePlane(scope.axis, eye);\n\n\t\t\t\t\tvar planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);\n\n\t\t\t\t\tif (planeIntersect) {\n\n\t\t\t\t\t\toldPosition.copy(scope.object.position);\n\t\t\t\t\t\toldScale.copy(scope.object.scale);\n\n\t\t\t\t\t\toldRotationMatrix.extractRotation(scope.object.matrix);\n\t\t\t\t\t\tworldRotationMatrix.extractRotation(scope.object.matrixWorld);\n\n\t\t\t\t\t\tparentRotationMatrix.extractRotation(scope.object.parent.matrixWorld);\n\t\t\t\t\t\tparentScale.setFromMatrixScale(tempMatrix.getInverse(scope.object.parent.matrixWorld));\n\n\t\t\t\t\t\toffset.copy(planeIntersect.point);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_dragging = true;\n\t\t}\n\n\t\tfunction onPointerMove(event) {\n\n\t\t\tif (scope.object === undefined || scope.axis === null || _dragging === false || event.button !== undefined && event.button !== 0) return;\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[0] : event;\n\n\t\t\tvar planeIntersect = intersectObjects(pointer, [_gizmo[_mode].activePlane]);\n\n\t\t\tif (planeIntersect === false) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tpoint.copy(planeIntersect.point);\n\n\t\t\tif (_mode === \"translate\") {\n\n\t\t\t\tpoint.sub(offset);\n\t\t\t\tpoint.multiply(parentScale);\n\n\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\tif (scope.axis.search(\"X\") === -1) point.x = 0;\n\t\t\t\t\tif (scope.axis.search(\"Y\") === -1) point.y = 0;\n\t\t\t\t\tif (scope.axis.search(\"Z\") === -1) point.z = 0;\n\n\t\t\t\t\tpoint.applyMatrix4(oldRotationMatrix);\n\n\t\t\t\t\tscope.object.position.copy(oldPosition);\n\t\t\t\t\tscope.object.position.add(point);\n\t\t\t\t}\n\n\t\t\t\tif (scope.space === \"world\" || scope.axis.search(\"XYZ\") !== -1) {\n\n\t\t\t\t\tif (scope.axis.search(\"X\") === -1) point.x = 0;\n\t\t\t\t\tif (scope.axis.search(\"Y\") === -1) point.y = 0;\n\t\t\t\t\tif (scope.axis.search(\"Z\") === -1) point.z = 0;\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(parentRotationMatrix));\n\n\t\t\t\t\tscope.object.position.copy(oldPosition);\n\t\t\t\t\tscope.object.position.add(point);\n\t\t\t\t}\n\n\t\t\t\tif (scope.translationSnap !== null) {\n\n\t\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\t\tscope.object.position.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scope.axis.search(\"X\") !== -1) scope.object.position.x = Math.round(scope.object.position.x / scope.translationSnap) * scope.translationSnap;\n\t\t\t\t\tif (scope.axis.search(\"Y\") !== -1) scope.object.position.y = Math.round(scope.object.position.y / scope.translationSnap) * scope.translationSnap;\n\t\t\t\t\tif (scope.axis.search(\"Z\") !== -1) scope.object.position.z = Math.round(scope.object.position.z / scope.translationSnap) * scope.translationSnap;\n\n\t\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\t\tscope.object.position.applyMatrix4(worldRotationMatrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (_mode === \"scale\") {\n\n\t\t\t\tpoint.sub(offset);\n\t\t\t\tpoint.multiply(parentScale);\n\n\t\t\t\tif (scope.space === \"local\") {\n\n\t\t\t\t\tif (scope.axis === \"XYZ\") {\n\n\t\t\t\t\t\tscale = 1 + point.y / Math.max(oldScale.x, oldScale.y, oldScale.z);\n\n\t\t\t\t\t\tscope.object.scale.x = oldScale.x * scale;\n\t\t\t\t\t\tscope.object.scale.y = oldScale.y * scale;\n\t\t\t\t\t\tscope.object.scale.z = oldScale.z * scale;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\t\tif (scope.axis === \"X\") scope.object.scale.x = oldScale.x * (1 + point.x / oldScale.x);\n\t\t\t\t\t\tif (scope.axis === \"Y\") scope.object.scale.y = oldScale.y * (1 + point.y / oldScale.y);\n\t\t\t\t\t\tif (scope.axis === \"Z\") scope.object.scale.z = oldScale.z * (1 + point.z / oldScale.z);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (_mode === \"rotate\") {\n\n\t\t\t\tpoint.sub(worldPosition);\n\t\t\t\tpoint.multiply(parentScale);\n\t\t\t\ttempVector.copy(offset).sub(worldPosition);\n\t\t\t\ttempVector.multiply(parentScale);\n\n\t\t\t\tif (scope.axis === \"E\") {\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));\n\t\t\t\t\ttempVector.applyMatrix4(tempMatrix.getInverse(lookAtMatrix));\n\n\t\t\t\t\trotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));\n\t\t\t\t\toffsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));\n\n\t\t\t\t\ttempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\n\t\t\t\t\tquaternionE.setFromAxisAngle(eye, rotation.z - offsetRotation.z);\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionE);\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(tempQuaternion);\n\t\t\t\t} else if (scope.axis === \"XYZE\") {\n\n\t\t\t\t\tquaternionE.setFromEuler(point.clone().cross(tempVector).normalize()); // rotation axis\n\n\t\t\t\t\ttempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\t\t\t\t\tquaternionX.setFromAxisAngle(quaternionE, -point.clone().angleTo(tempVector));\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(tempQuaternion);\n\t\t\t\t} else if (scope.space === \"local\") {\n\n\t\t\t\t\tpoint.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\ttempVector.applyMatrix4(tempMatrix.getInverse(worldRotationMatrix));\n\n\t\t\t\t\trotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));\n\t\t\t\t\toffsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));\n\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(oldRotationMatrix);\n\n\t\t\t\t\tif (scope.rotationSnap !== null) {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (scope.axis === \"X\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionX);\n\t\t\t\t\tif (scope.axis === \"Y\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionY);\n\t\t\t\t\tif (scope.axis === \"Z\") quaternionXYZ.multiplyQuaternions(quaternionXYZ, quaternionZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(quaternionXYZ);\n\t\t\t\t} else if (scope.space === \"world\") {\n\n\t\t\t\t\trotation.set(Math.atan2(point.z, point.y), Math.atan2(point.x, point.z), Math.atan2(point.y, point.x));\n\t\t\t\t\toffsetRotation.set(Math.atan2(tempVector.z, tempVector.y), Math.atan2(tempVector.x, tempVector.z), Math.atan2(tempVector.y, tempVector.x));\n\n\t\t\t\t\ttempQuaternion.setFromRotationMatrix(tempMatrix.getInverse(parentRotationMatrix));\n\n\t\t\t\t\tif (scope.rotationSnap !== null) {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, Math.round((rotation.x - offsetRotation.x) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, Math.round((rotation.y - offsetRotation.y) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, Math.round((rotation.z - offsetRotation.z) / scope.rotationSnap) * scope.rotationSnap);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tquaternionX.setFromAxisAngle(unitX, rotation.x - offsetRotation.x);\n\t\t\t\t\t\tquaternionY.setFromAxisAngle(unitY, rotation.y - offsetRotation.y);\n\t\t\t\t\t\tquaternionZ.setFromAxisAngle(unitZ, rotation.z - offsetRotation.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tquaternionXYZ.setFromRotationMatrix(worldRotationMatrix);\n\n\t\t\t\t\tif (scope.axis === \"X\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionX);\n\t\t\t\t\tif (scope.axis === \"Y\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionY);\n\t\t\t\t\tif (scope.axis === \"Z\") tempQuaternion.multiplyQuaternions(tempQuaternion, quaternionZ);\n\n\t\t\t\t\ttempQuaternion.multiplyQuaternions(tempQuaternion, quaternionXYZ);\n\n\t\t\t\t\tscope.object.quaternion.copy(tempQuaternion);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tscope.update();\n\t\t\tscope.dispatchEvent(changeEvent);\n\t\t\tscope.dispatchEvent(objectChangeEvent);\n\t\t}\n\n\t\tfunction onPointerUp(event) {\n\n\t\t\tevent.preventDefault(); // Prevent MouseEvent on mobile\n\n\t\t\tif (event.button !== undefined && event.button !== 0) return;\n\n\t\t\tif (_dragging && scope.axis !== null) {\n\n\t\t\t\tmouseUpEvent.mode = _mode;\n\t\t\t\tscope.dispatchEvent(mouseUpEvent);\n\t\t\t}\n\n\t\t\t_dragging = false;\n\n\t\t\tif ('TouchEvent' in window && event instanceof TouchEvent) {\n\n\t\t\t\t// Force \"rollover\"\n\n\t\t\t\tscope.axis = null;\n\t\t\t\tscope.update();\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\t\t\t} else {\n\n\t\t\t\tonPointerHover(event);\n\t\t\t}\n\t\t}\n\n\t\tfunction intersectObjects(pointer, objects) {\n\n\t\t\tvar rect = domElement.getBoundingClientRect();\n\t\t\tvar x = (pointer.clientX - rect.left) / rect.width;\n\t\t\tvar y = (pointer.clientY - rect.top) / rect.height;\n\n\t\t\tpointerVector.set(x * 2 - 1, -(y * 2) + 1);\n\t\t\tray.setFromCamera(pointerVector, camera);\n\n\t\t\tvar intersections = ray.intersectObjects(objects, true);\n\t\t\treturn intersections[0] ? intersections[0] : false;\n\t\t}\n\t};\n\n\tTransformControls.prototype = Object.create(THREE.Object3D.prototype);\n\tTransformControls.prototype.constructor = TransformControls;\n\n\treturn TransformControls;\n}();\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author dmarcos / https://github.com/dmarcos\n * @author mrdoob / http://mrdoob.com\n */\n\nvar VRControls = function VRControls(object, onError) {\n\n\tvar scope = this;\n\n\tvar vrDisplay, vrDisplays;\n\n\tvar standingMatrix = new THREE.Matrix4();\n\n\tvar frameData = null;\n\n\tif ('VRFrameData' in window) {\n\n\t\tframeData = new VRFrameData();\n\t}\n\n\tfunction gotVRDisplays(displays) {\n\n\t\tvrDisplays = displays;\n\n\t\tif (displays.length > 0) {\n\n\t\t\tvrDisplay = displays[0];\n\t\t} else {\n\n\t\t\tif (onError) onError('VR input not available.');\n\t\t}\n\t}\n\n\tif (navigator.getVRDisplays) {\n\n\t\tnavigator.getVRDisplays().then(gotVRDisplays).catch(function () {\n\n\t\t\tconsole.warn('THREE.VRControls: Unable to get VR Displays');\n\t\t});\n\t}\n\n\t// the Rift SDK returns the position in meters\n\t// this scale factor allows the user to define how meters\n\t// are converted to scene units.\n\n\tthis.scale = 1;\n\n\t// If true will use \"standing space\" coordinate system where y=0 is the\n\t// floor and x=0, z=0 is the center of the room.\n\tthis.standing = false;\n\n\t// Distance from the users eyes to the floor in meters. Used when\n\t// standing=true but the VRDisplay doesn't provide stageParameters.\n\tthis.userHeight = 1.6;\n\n\tthis.getVRDisplay = function () {\n\n\t\treturn vrDisplay;\n\t};\n\n\tthis.setVRDisplay = function (value) {\n\n\t\tvrDisplay = value;\n\t};\n\n\tthis.getVRDisplays = function () {\n\n\t\tconsole.warn('THREE.VRControls: getVRDisplays() is being deprecated.');\n\t\treturn vrDisplays;\n\t};\n\n\tthis.getStandingMatrix = function () {\n\n\t\treturn standingMatrix;\n\t};\n\n\tthis.update = function () {\n\n\t\tif (vrDisplay) {\n\n\t\t\tvar pose;\n\n\t\t\tif (vrDisplay.getFrameData) {\n\n\t\t\t\tvrDisplay.getFrameData(frameData);\n\t\t\t\tpose = frameData.pose;\n\t\t\t} else if (vrDisplay.getPose) {\n\n\t\t\t\tpose = vrDisplay.getPose();\n\t\t\t}\n\n\t\t\tif (pose.orientation !== null) {\n\n\t\t\t\tobject.quaternion.fromArray(pose.orientation);\n\t\t\t}\n\n\t\t\tif (pose.position !== null) {\n\n\t\t\t\tobject.position.fromArray(pose.position);\n\t\t\t} else {\n\n\t\t\t\tobject.position.set(0, 0, 0);\n\t\t\t}\n\n\t\t\tif (this.standing) {\n\n\t\t\t\tif (vrDisplay.stageParameters) {\n\n\t\t\t\t\tobject.updateMatrix();\n\n\t\t\t\t\tstandingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);\n\t\t\t\t\tobject.applyMatrix(standingMatrix);\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.position.setY(object.position.y + this.userHeight);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tobject.position.multiplyScalar(scope.scale);\n\t\t}\n\t};\n\n\tthis.dispose = function () {\n\n\t\tvrDisplay = null;\n\t};\n};\n\nexports.default = VRControls;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypedGeometryExporter = exports.STLExporter = exports.STLBinaryExporter = exports.PLYExporter = exports.OBJExporter = exports.MMDExporter = exports.GLTFExporter = undefined;\n\nvar _GLTFExporter = __webpack_require__(41);\n\nvar _GLTFExporter2 = _interopRequireDefault(_GLTFExporter);\n\nvar _MMDExporter = __webpack_require__(42);\n\nvar _MMDExporter2 = _interopRequireDefault(_MMDExporter);\n\nvar _OBJExporter = __webpack_require__(43);\n\nvar _OBJExporter2 = _interopRequireDefault(_OBJExporter);\n\nvar _PLYExporter = __webpack_require__(44);\n\nvar _PLYExporter2 = _interopRequireDefault(_PLYExporter);\n\nvar _STLBinaryExporter = __webpack_require__(45);\n\nvar _STLBinaryExporter2 = _interopRequireDefault(_STLBinaryExporter);\n\nvar _STLExporter = __webpack_require__(46);\n\nvar _STLExporter2 = _interopRequireDefault(_STLExporter);\n\nvar _TypedGeometryExporter = __webpack_require__(47);\n\nvar _TypedGeometryExporter2 = _interopRequireDefault(_TypedGeometryExporter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.GLTFExporter = _GLTFExporter2.default;\nexports.MMDExporter = _MMDExporter2.default;\nexports.OBJExporter = _OBJExporter2.default;\nexports.PLYExporter = _PLYExporter2.default;\nexports.STLBinaryExporter = _STLBinaryExporter2.default;\nexports.STLExporter = _STLExporter2.default;\nexports.TypedGeometryExporter = _TypedGeometryExporter2.default;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author fernandojsg / http://fernandojsg.com\n * @author Don McCurdy / https://www.donmccurdy.com\n * @author Takahiro / https://github.com/takahirox\n */\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\nvar WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tUNSIGNED_BYTE: 0x1401,\n\tUNSIGNED_SHORT: 0x1403,\n\tFLOAT: 0x1406,\n\tUNSIGNED_INT: 0x1405,\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703\n};\n\nvar THREE_TO_WEBGL = {\n\t// @TODO Replace with computed property name [THREE.*] when available on es6\n\t1003: WEBGL_CONSTANTS.NEAREST,\n\t1004: WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST,\n\t1005: WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR,\n\t1006: WEBGL_CONSTANTS.LINEAR,\n\t1007: WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST,\n\t1008: WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR\n};\n\nvar PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\n//------------------------------------------------------------------------------\n// GLTF Exporter\n//------------------------------------------------------------------------------\nvar GLTFExporter = function GLTFExporter() {};\n\nGLTFExporter.prototype = {\n\n\tconstructor: GLTFExporter,\n\n\t/**\n  * Parse scenes and generate GLTF output\n  * @param  {THREE.Scene or [THREE.Scenes]} input   THREE.Scene or Array of THREE.Scenes\n  * @param  {Function} onDone  Callback on completed\n  * @param  {Object} options options\n  */\n\tparse: function parse(input, onDone, options) {\n\n\t\tvar DEFAULT_OPTIONS = {\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\ttruncateDrawRange: true,\n\t\t\tembedImages: true,\n\t\t\tanimations: [],\n\t\t\tforceIndices: false,\n\t\t\tforcePowerOfTwoTextures: false\n\t\t};\n\n\t\toptions = Object.assign({}, DEFAULT_OPTIONS, options);\n\n\t\tif (options.animations.length > 0) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\toptions.trs = true;\n\t\t}\n\n\t\tvar outputJSON = {\n\n\t\t\tasset: {\n\n\t\t\t\tversion: \"2.0\",\n\t\t\t\tgenerator: \"THREE.GLTFExporter\"\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar byteOffset = 0;\n\t\tvar buffers = [];\n\t\tvar pending = [];\n\t\tvar nodeMap = new Map();\n\t\tvar skins = [];\n\t\tvar extensionsUsed = {};\n\t\tvar cachedData = {\n\n\t\t\tattributes: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map()\n\n\t\t};\n\n\t\tvar cachedCanvas;\n\n\t\t/**\n   * Compare two arrays\n   */\n\t\t/**\n   * Compare two arrays\n   * @param  {Array} array1 Array 1 to compare\n   * @param  {Array} array2 Array 2 to compare\n   * @return {Boolean}        Returns true if both arrays are equal\n   */\n\t\tfunction equalArray(array1, array2) {\n\n\t\t\treturn array1.length === array2.length && array1.every(function (element, index) {\n\n\t\t\t\treturn element === array2[index];\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Converts a string to an ArrayBuffer.\n   * @param  {string} text\n   * @return {ArrayBuffer}\n   */\n\t\tfunction stringToArrayBuffer(text) {\n\n\t\t\tif (window.TextEncoder !== undefined) {\n\n\t\t\t\treturn new TextEncoder().encode(text).buffer;\n\t\t\t}\n\n\t\t\tvar array = new Uint8Array(new ArrayBuffer(text.length));\n\n\t\t\tfor (var i = 0, il = text.length; i < il; i++) {\n\n\t\t\t\tvar value = text.charCodeAt(i);\n\n\t\t\t\t// Replacing multi-byte character with space(0x20).\n\t\t\t\tarray[i] = value > 0xFF ? 0x20 : value;\n\t\t\t}\n\n\t\t\treturn array.buffer;\n\t\t}\n\n\t\t/**\n   * Get the min and max vectors from the given attribute\n   * @param  {THREE.BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n   * @param  {Integer} start\n   * @param  {Integer} count\n   * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n   */\n\t\tfunction getMinMax(attribute, start, count) {\n\n\t\t\tvar output = {\n\n\t\t\t\tmin: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n\t\t\t\tmax: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n\n\t\t\t};\n\n\t\t\tfor (var i = start; i < start + count; i++) {\n\n\t\t\t\tfor (var a = 0; a < attribute.itemSize; a++) {\n\n\t\t\t\t\tvar value = attribute.array[i * attribute.itemSize + a];\n\t\t\t\t\toutput.min[a] = Math.min(output.min[a], value);\n\t\t\t\t\toutput.max[a] = Math.max(output.max[a], value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n   * Checks if image size is POT.\n   *\n   * @param {Image} image The image to be checked.\n   * @returns {Boolean} Returns true if image size is POT.\n   *\n   */\n\t\tfunction isPowerOfTwo(image) {\n\n\t\t\treturn THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);\n\t\t}\n\n\t\t/**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {THREE.BufferAttribute} normal\n   * @returns {Boolean}\n   *\n   */\n\t\tfunction isNormalizedNormalAttribute(normal) {\n\n\t\t\tif (cachedData.attributes.has(normal)) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\tfor (var i = 0, il = normal.count; i < il; i++) {\n\n\t\t\t\t// 0.0005 is from glTF-validator\n\t\t\t\tif (Math.abs(v.fromArray(normal.array, i * 3).length() - 1.0) > 0.0005) return false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t/**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {THREE.BufferAttribute} normal\n   * @returns {THREE.BufferAttribute}\n   *\n   */\n\t\tfunction createNormalizedNormalAttribute(normal) {\n\n\t\t\tif (cachedData.attributes.has(normal)) {\n\n\t\t\t\treturn cachedData.textures.get(normal);\n\t\t\t}\n\n\t\t\tvar attribute = normal.clone();\n\n\t\t\tvar v = new THREE.Vector3();\n\n\t\t\tfor (var i = 0, il = attribute.count; i < il; i++) {\n\n\t\t\t\tv.fromArray(attribute.array, i * 3);\n\n\t\t\t\tif (v.x === 0 && v.y === 0 && v.z === 0) {\n\n\t\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\t\tv.setX(1.0);\n\t\t\t\t} else {\n\n\t\t\t\t\tv.normalize();\n\t\t\t\t}\n\n\t\t\t\tv.toArray(attribute.array, i * 3);\n\t\t\t}\n\n\t\t\tcachedData.attributes.set(normal, attribute);\n\n\t\t\treturn attribute;\n\t\t}\n\n\t\t/**\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n   *\n   * @param {Integer} bufferSize The size the original buffer.\n   * @returns {Integer} new buffer size with required padding.\n   *\n   */\n\t\tfunction getPaddedBufferSize(bufferSize) {\n\n\t\t\treturn Math.ceil(bufferSize / 4) * 4;\n\t\t}\n\n\t\t/**\n   * Returns a buffer aligned to 4-byte boundary.\n   *\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\n   * @param {Integer} paddingByte (Optional)\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n   */\n\t\tfunction getPaddedArrayBuffer(arrayBuffer, paddingByte) {\n\n\t\t\tpaddingByte = paddingByte || 0;\n\n\t\t\tvar paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n\n\t\t\tif (paddedLength !== arrayBuffer.byteLength) {\n\n\t\t\t\tvar array = new Uint8Array(paddedLength);\n\t\t\t\tarray.set(new Uint8Array(arrayBuffer));\n\n\t\t\t\tif (paddingByte !== 0) {\n\n\t\t\t\t\tfor (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n\n\t\t\t\t\t\tarray[i] = paddingByte;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn array.buffer;\n\t\t\t}\n\n\t\t\treturn arrayBuffer;\n\t\t}\n\n\t\t/**\n   * Process a buffer to append to the default one.\n   * @param  {ArrayBuffer} buffer\n   * @return {Integer}\n   */\n\t\tfunction processBuffer(buffer) {\n\n\t\t\tif (!outputJSON.buffers) {\n\n\t\t\t\toutputJSON.buffers = [{ byteLength: 0 }];\n\t\t\t}\n\n\t\t\t// All buffers are merged before export.\n\t\t\tbuffers.push(buffer);\n\n\t\t\treturn 0;\n\t\t}\n\n\t\t/**\n   * Process and generate a BufferView\n   * @param  {THREE.BufferAttribute} attribute\n   * @param  {number} componentType\n   * @param  {number} start\n   * @param  {number} count\n   * @param  {number} target (Optional) Target usage of the BufferView\n   * @return {Object}\n   */\n\t\tfunction processBufferView(attribute, componentType, start, count, target) {\n\n\t\t\tif (!outputJSON.bufferViews) {\n\n\t\t\t\toutputJSON.bufferViews = [];\n\t\t\t}\n\n\t\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\t\tvar componentSize;\n\n\t\t\tif (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n\n\t\t\t\tcomponentSize = 1;\n\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n\n\t\t\t\tcomponentSize = 2;\n\t\t\t} else {\n\n\t\t\t\tcomponentSize = 4;\n\t\t\t}\n\n\t\t\tvar byteLength = getPaddedBufferSize(count * attribute.itemSize * componentSize);\n\t\t\tvar dataView = new DataView(new ArrayBuffer(byteLength));\n\t\t\tvar offset = 0;\n\n\t\t\tfor (var i = start; i < start + count; i++) {\n\n\t\t\t\tfor (var a = 0; a < attribute.itemSize; a++) {\n\n\t\t\t\t\t// @TODO Fails on InterleavedBufferAttribute, and could probably be\n\t\t\t\t\t// optimized for normal BufferAttribute.\n\t\t\t\t\tvar value = attribute.array[i * attribute.itemSize + a];\n\n\t\t\t\t\tif (componentType === WEBGL_CONSTANTS.FLOAT) {\n\n\t\t\t\t\t\tdataView.setFloat32(offset, value, true);\n\t\t\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n\n\t\t\t\t\t\tdataView.setUint32(offset, value, true);\n\t\t\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n\n\t\t\t\t\t\tdataView.setUint16(offset, value, true);\n\t\t\t\t\t} else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n\n\t\t\t\t\t\tdataView.setUint8(offset, value);\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += componentSize;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar gltfBufferView = {\n\n\t\t\t\tbuffer: processBuffer(dataView.buffer),\n\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\tbyteLength: byteLength\n\n\t\t\t};\n\n\t\t\tif (target !== undefined) gltfBufferView.target = target;\n\n\t\t\tif (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n\n\t\t\t\t// Only define byteStride for vertex attributes.\n\t\t\t\tgltfBufferView.byteStride = attribute.itemSize * componentSize;\n\t\t\t}\n\n\t\t\tbyteOffset += byteLength;\n\n\t\t\toutputJSON.bufferViews.push(gltfBufferView);\n\n\t\t\t// @TODO Merge bufferViews where possible.\n\t\t\tvar output = {\n\n\t\t\t\tid: outputJSON.bufferViews.length - 1,\n\t\t\t\tbyteLength: 0\n\n\t\t\t};\n\n\t\t\treturn output;\n\t\t}\n\n\t\t/**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<Integer>}\n   */\n\t\tfunction processBufferViewImage(blob) {\n\n\t\t\tif (!outputJSON.bufferViews) {\n\n\t\t\t\toutputJSON.bufferViews = [];\n\t\t\t}\n\n\t\t\treturn new Promise(function (resolve) {\n\n\t\t\t\tvar reader = new window.FileReader();\n\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tvar buffer = getPaddedArrayBuffer(reader.result);\n\n\t\t\t\t\tvar bufferView = {\n\t\t\t\t\t\tbuffer: processBuffer(buffer),\n\t\t\t\t\t\tbyteOffset: byteOffset,\n\t\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t\t};\n\n\t\t\t\t\tbyteOffset += buffer.byteLength;\n\n\t\t\t\t\toutputJSON.bufferViews.push(bufferView);\n\n\t\t\t\t\tresolve(outputJSON.bufferViews.length - 1);\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\t/**\n   * Process attribute to generate an accessor\n   * @param  {THREE.BufferAttribute} attribute Attribute to process\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n   * @param  {Integer} start (Optional)\n   * @param  {Integer} count (Optional)\n   * @return {Integer}           Index of the processed accessor on the \"accessors\" array\n   */\n\t\tfunction processAccessor(attribute, geometry, start, count) {\n\n\t\t\tvar types = {\n\n\t\t\t\t1: 'SCALAR',\n\t\t\t\t2: 'VEC2',\n\t\t\t\t3: 'VEC3',\n\t\t\t\t4: 'VEC4',\n\t\t\t\t16: 'MAT4'\n\n\t\t\t};\n\n\t\t\tvar componentType;\n\n\t\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\t\tif (attribute.array.constructor === Float32Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\t\t\t} else if (attribute.array.constructor === Uint32Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\t\t\t} else if (attribute.array.constructor === Uint16Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\t\t\t} else if (attribute.array.constructor === Uint8Array) {\n\n\t\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n\t\t\t}\n\n\t\t\tif (start === undefined) start = 0;\n\t\t\tif (count === undefined) count = attribute.count;\n\n\t\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\t\tif (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n\n\t\t\t\tvar end = start + count;\n\t\t\t\tvar end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\t\tstart = Math.max(start, geometry.drawRange.start);\n\t\t\t\tcount = Math.min(end, end2) - start;\n\n\t\t\t\tif (count < 0) count = 0;\n\t\t\t}\n\n\t\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\t\tif (count === 0) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tvar minMax = getMinMax(attribute, start, count);\n\n\t\t\tvar bufferViewTarget;\n\n\t\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t\t// animation samplers, target must not be set.\n\t\t\tif (geometry !== undefined) {\n\n\t\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\t\t\t}\n\n\t\t\tvar bufferView = processBufferView(attribute, componentType, start, count, bufferViewTarget);\n\n\t\t\tvar gltfAccessor = {\n\n\t\t\t\tbufferView: bufferView.id,\n\t\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\t\tcomponentType: componentType,\n\t\t\t\tcount: count,\n\t\t\t\tmax: minMax.max,\n\t\t\t\tmin: minMax.min,\n\t\t\t\ttype: types[attribute.itemSize]\n\n\t\t\t};\n\n\t\t\tif (!outputJSON.accessors) {\n\n\t\t\t\toutputJSON.accessors = [];\n\t\t\t}\n\n\t\t\toutputJSON.accessors.push(gltfAccessor);\n\n\t\t\treturn outputJSON.accessors.length - 1;\n\t\t}\n\n\t\t/**\n   * Process image\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"images\" array\n   */\n\t\tfunction processImage(map) {\n\n\t\t\t// @TODO Cache\n\n\t\t\tif (!outputJSON.images) {\n\n\t\t\t\toutputJSON.images = [];\n\t\t\t}\n\n\t\t\tvar mimeType = map.format === THREE.RGBAFormat ? 'image/png' : 'image/jpeg';\n\t\t\tvar gltfImage = { mimeType: mimeType };\n\n\t\t\tif (options.embedImages) {\n\n\t\t\t\tvar canvas = cachedCanvas = cachedCanvas || document.createElement('canvas');\n\n\t\t\t\tcanvas.width = map.image.width;\n\t\t\t\tcanvas.height = map.image.height;\n\n\t\t\t\tif (options.forcePowerOfTwoTextures && !isPowerOfTwo(map.image)) {\n\n\t\t\t\t\tconsole.warn('GLTFExporter: Resized non-power-of-two image.', map.image);\n\n\t\t\t\t\tcanvas.width = THREE.Math.floorPowerOfTwo(canvas.width);\n\t\t\t\t\tcanvas.height = THREE.Math.floorPowerOfTwo(canvas.height);\n\t\t\t\t}\n\n\t\t\t\tvar ctx = canvas.getContext('2d');\n\n\t\t\t\tif (map.flipY === true) {\n\n\t\t\t\t\tctx.translate(0, canvas.height);\n\t\t\t\t\tctx.scale(1, -1);\n\t\t\t\t}\n\n\t\t\t\tctx.drawImage(map.image, 0, 0, canvas.width, canvas.height);\n\n\t\t\t\tif (options.binary === true) {\n\n\t\t\t\t\tpending.push(new Promise(function (resolve) {\n\n\t\t\t\t\t\tcanvas.toBlob(function (blob) {\n\n\t\t\t\t\t\t\tprocessBufferViewImage(blob).then(function (bufferViewIndex) {\n\n\t\t\t\t\t\t\t\tgltfImage.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}, mimeType);\n\t\t\t\t\t}));\n\t\t\t\t} else {\n\n\t\t\t\t\tgltfImage.uri = canvas.toDataURL(mimeType);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tgltfImage.uri = map.image.src;\n\t\t\t}\n\n\t\t\toutputJSON.images.push(gltfImage);\n\n\t\t\treturn outputJSON.images.length - 1;\n\t\t}\n\n\t\t/**\n   * Process sampler\n   * @param  {Texture} map Texture to process\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\n   */\n\t\tfunction processSampler(map) {\n\n\t\t\tif (!outputJSON.samplers) {\n\n\t\t\t\toutputJSON.samplers = [];\n\t\t\t}\n\n\t\t\tvar gltfSampler = {\n\n\t\t\t\tmagFilter: THREE_TO_WEBGL[map.magFilter],\n\t\t\t\tminFilter: THREE_TO_WEBGL[map.minFilter],\n\t\t\t\twrapS: THREE_TO_WEBGL[map.wrapS],\n\t\t\t\twrapT: THREE_TO_WEBGL[map.wrapT]\n\n\t\t\t};\n\n\t\t\toutputJSON.samplers.push(gltfSampler);\n\n\t\t\treturn outputJSON.samplers.length - 1;\n\t\t}\n\n\t\t/**\n   * Process texture\n   * @param  {Texture} map Map to process\n   * @return {Integer}     Index of the processed texture in the \"textures\" array\n   */\n\t\tfunction processTexture(map) {\n\n\t\t\tif (cachedData.textures.has(map)) {\n\n\t\t\t\treturn cachedData.textures.get(map);\n\t\t\t}\n\n\t\t\tif (!outputJSON.textures) {\n\n\t\t\t\toutputJSON.textures = [];\n\t\t\t}\n\n\t\t\tvar gltfTexture = {\n\n\t\t\t\tsampler: processSampler(map),\n\t\t\t\tsource: processImage(map)\n\n\t\t\t};\n\n\t\t\toutputJSON.textures.push(gltfTexture);\n\n\t\t\tvar index = outputJSON.textures.length - 1;\n\t\t\tcachedData.textures.set(map, index);\n\n\t\t\treturn index;\n\t\t}\n\n\t\t/**\n   * Process material\n   * @param  {THREE.Material} material Material to process\n   * @return {Integer}      Index of the processed material in the \"materials\" array\n   */\n\t\tfunction processMaterial(material) {\n\n\t\t\tif (cachedData.materials.has(material)) {\n\n\t\t\t\treturn cachedData.materials.get(material);\n\t\t\t}\n\n\t\t\tif (!outputJSON.materials) {\n\n\t\t\t\toutputJSON.materials = [];\n\t\t\t}\n\n\t\t\tif (material.isShaderMaterial) {\n\n\t\t\t\tconsole.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\t\tvar gltfMaterial = {\n\n\t\t\t\tpbrMetallicRoughness: {}\n\n\t\t\t};\n\n\t\t\tif (material.isMeshBasicMaterial) {\n\n\t\t\t\tgltfMaterial.extensions = { KHR_materials_unlit: {} };\n\n\t\t\t\textensionsUsed['KHR_materials_unlit'] = true;\n\t\t\t} else if (!material.isMeshStandardMaterial) {\n\n\t\t\t\tconsole.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.baseColorFactor\n\t\t\tvar color = material.color.toArray().concat([material.opacity]);\n\n\t\t\tif (!equalArray(color, [1, 1, 1, 1])) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorFactor = color;\n\t\t\t}\n\n\t\t\tif (material.isMeshStandardMaterial) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\t\t\t} else if (material.isMeshBasicMaterial) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.9;\n\t\t\t} else {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.roughnessFactor = 0.5;\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\t\tif (material.metalnessMap || material.roughnessMap) {\n\n\t\t\t\tif (material.metalnessMap === material.roughnessMap) {\n\n\t\t\t\t\tgltfMaterial.pbrMetallicRoughness.metallicRoughnessTexture = {\n\n\t\t\t\t\t\tindex: processTexture(material.metalnessMap)\n\n\t\t\t\t\t};\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// pbrMetallicRoughness.baseColorTexture\n\t\t\tif (material.map) {\n\n\t\t\t\tgltfMaterial.pbrMetallicRoughness.baseColorTexture = {\n\n\t\t\t\t\tindex: processTexture(material.map)\n\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (material.isMeshBasicMaterial || material.isLineBasicMaterial || material.isPointsMaterial) {} else {\n\n\t\t\t\t// emissiveFactor\n\t\t\t\tvar emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity).toArray();\n\n\t\t\t\tif (!equalArray(emissive, [0, 0, 0])) {\n\n\t\t\t\t\tgltfMaterial.emissiveFactor = emissive;\n\t\t\t\t}\n\n\t\t\t\t// emissiveTexture\n\t\t\t\tif (material.emissiveMap) {\n\n\t\t\t\t\tgltfMaterial.emissiveTexture = {\n\n\t\t\t\t\t\tindex: processTexture(material.emissiveMap)\n\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// normalTexture\n\t\t\tif (material.normalMap) {\n\n\t\t\t\tgltfMaterial.normalTexture = {\n\n\t\t\t\t\tindex: processTexture(material.normalMap)\n\n\t\t\t\t};\n\n\t\t\t\tif (material.normalScale.x !== -1) {\n\n\t\t\t\t\tif (material.normalScale.x !== material.normalScale.y) {\n\n\t\t\t\t\t\tconsole.warn('THREE.GLTFExporter: Normal scale components are different, ignoring Y and exporting X.');\n\t\t\t\t\t}\n\n\t\t\t\t\tgltfMaterial.normalTexture.scale = material.normalScale.x;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// occlusionTexture\n\t\t\tif (material.aoMap) {\n\n\t\t\t\tgltfMaterial.occlusionTexture = {\n\n\t\t\t\t\tindex: processTexture(material.aoMap)\n\n\t\t\t\t};\n\n\t\t\t\tif (material.aoMapIntensity !== 1.0) {\n\n\t\t\t\t\tgltfMaterial.occlusionTexture.strength = material.aoMapIntensity;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// alphaMode\n\t\t\tif (material.transparent || material.alphaTest > 0.0) {\n\n\t\t\t\tgltfMaterial.alphaMode = material.opacity < 1.0 ? 'BLEND' : 'MASK';\n\n\t\t\t\t// Write alphaCutoff if it's non-zero and different from the default (0.5).\n\t\t\t\tif (material.alphaTest > 0.0 && material.alphaTest !== 0.5) {\n\n\t\t\t\t\tgltfMaterial.alphaCutoff = material.alphaTest;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// doubleSided\n\t\t\tif (material.side === THREE.DoubleSide) {\n\n\t\t\t\tgltfMaterial.doubleSided = true;\n\t\t\t}\n\n\t\t\tif (material.name !== '') {\n\n\t\t\t\tgltfMaterial.name = material.name;\n\t\t\t}\n\n\t\t\toutputJSON.materials.push(gltfMaterial);\n\n\t\t\tvar index = outputJSON.materials.length - 1;\n\t\t\tcachedData.materials.set(material, index);\n\n\t\t\treturn index;\n\t\t}\n\n\t\t/**\n   * Process mesh\n   * @param  {THREE.Mesh} mesh Mesh to process\n   * @return {Integer}      Index of the processed mesh in the \"meshes\" array\n   */\n\t\tfunction processMesh(mesh) {\n\n\t\t\tvar geometry = mesh.geometry;\n\n\t\t\tvar mode;\n\n\t\t\t// Use the correct mode\n\t\t\tif (mesh.isLineSegments) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\t\t\t} else if (mesh.isLineLoop) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\t\t\t} else if (mesh.isLine) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\t\t\t} else if (mesh.isPoints) {\n\n\t\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\t\t\t} else {\n\n\t\t\t\tif (!geometry.isBufferGeometry) {\n\n\t\t\t\t\tvar geometryTemp = new THREE.BufferGeometry();\n\t\t\t\t\tgeometryTemp.fromGeometry(geometry);\n\t\t\t\t\tgeometry = geometryTemp;\n\t\t\t\t}\n\n\t\t\t\tif (mesh.drawMode === THREE.TriangleFanDrawMode) {\n\n\t\t\t\t\tconsole.warn('GLTFExporter: TriangleFanDrawMode and wireframe incompatible.');\n\t\t\t\t\tmode = WEBGL_CONSTANTS.TRIANGLE_FAN;\n\t\t\t\t} else if (mesh.drawMode === THREE.TriangleStripDrawMode) {\n\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINE_STRIP : WEBGL_CONSTANTS.TRIANGLE_STRIP;\n\t\t\t\t} else {\n\n\t\t\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar gltfMesh = {};\n\n\t\t\tvar attributes = {};\n\t\t\tvar primitives = [];\n\t\t\tvar targets = [];\n\n\t\t\t// Conversion between attributes names in threejs and gltf spec\n\t\t\tvar nameConversion = {\n\n\t\t\t\tuv: 'TEXCOORD_0',\n\t\t\t\tuv2: 'TEXCOORD_1',\n\t\t\t\tcolor: 'COLOR_0',\n\t\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\t\tskinIndex: 'JOINTS_0'\n\n\t\t\t};\n\n\t\t\tvar originalNormal = geometry.getAttribute('normal');\n\n\t\t\tif (originalNormal !== undefined && !isNormalizedNormalAttribute(originalNormal)) {\n\n\t\t\t\tconsole.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n\n\t\t\t\tgeometry.addAttribute('normal', createNormalizedNormalAttribute(originalNormal));\n\t\t\t}\n\n\t\t\t// @QUESTION Detect if .vertexColors = THREE.VertexColors?\n\t\t\t// For every attribute create an accessor\n\t\t\tfor (var attributeName in geometry.attributes) {\n\n\t\t\t\tvar attribute = geometry.attributes[attributeName];\n\t\t\t\tattributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n\n\t\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\t\tvar array = attribute.array;\n\t\t\t\tif (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n\n\t\t\t\t\tconsole.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n\t\t\t\t\tattribute = new THREE.BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n\t\t\t\t}\n\n\t\t\t\tif (attributeName.substr(0, 5) !== 'MORPH') {\n\n\t\t\t\t\tvar accessor = processAccessor(attribute, geometry);\n\t\t\t\t\tif (accessor !== null) {\n\n\t\t\t\t\t\tattributes[attributeName] = accessor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (originalNormal !== undefined) geometry.addAttribute('normal', originalNormal);\n\n\t\t\t// Skip if no exportable attributes found\n\t\t\tif (Object.keys(attributes).length === 0) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Morph targets\n\t\t\tif (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n\n\t\t\t\tvar weights = [];\n\t\t\t\tvar targetNames = [];\n\t\t\t\tvar reverseDictionary = {};\n\n\t\t\t\tif (mesh.morphTargetDictionary !== undefined) {\n\n\t\t\t\t\tfor (var key in mesh.morphTargetDictionary) {\n\n\t\t\t\t\t\treverseDictionary[mesh.morphTargetDictionary[key]] = key;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n\n\t\t\t\t\tvar target = {};\n\n\t\t\t\t\tvar warned = false;\n\n\t\t\t\t\tfor (var attributeName in geometry.morphAttributes) {\n\n\t\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\t\tif (attributeName !== 'position' && attributeName !== 'normal') {\n\n\t\t\t\t\t\t\tif (!warned) {\n\n\t\t\t\t\t\t\t\tconsole.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n\t\t\t\t\t\t\t\twarned = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar attribute = geometry.morphAttributes[attributeName][i];\n\n\t\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t\t//\n\t\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\t\tvar baseAttribute = geometry.attributes[attributeName];\n\t\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\t\tvar relativeAttribute = attribute.clone();\n\n\t\t\t\t\t\tfor (var j = 0, jl = attribute.count; j < jl; j++) {\n\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget[attributeName.toUpperCase()] = processAccessor(relativeAttribute, geometry);\n\t\t\t\t\t}\n\n\t\t\t\t\ttargets.push(target);\n\n\t\t\t\t\tweights.push(mesh.morphTargetInfluences[i]);\n\t\t\t\t\tif (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n\t\t\t\t}\n\n\t\t\t\tgltfMesh.weights = weights;\n\n\t\t\t\tif (targetNames.length > 0) {\n\n\t\t\t\t\tgltfMesh.extras = {};\n\t\t\t\t\tgltfMesh.extras.targetNames = targetNames;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar forceIndices = options.forceIndices;\n\t\t\tvar isMultiMaterial = Array.isArray(mesh.material);\n\n\t\t\tif (isMultiMaterial && mesh.geometry.groups.length === 0) return null;\n\n\t\t\tif (!forceIndices && geometry.index === null && isMultiMaterial) {\n\n\t\t\t\t// temporal workaround.\n\t\t\t\tconsole.warn('THREE.GLTFExporter: Creating index for non-indexed multi-material mesh.');\n\t\t\t\tforceIndices = true;\n\t\t\t}\n\n\t\t\tvar didForceIndices = false;\n\n\t\t\tif (geometry.index === null && forceIndices) {\n\n\t\t\t\tvar indices = [];\n\n\t\t\t\tfor (var i = 0, il = geometry.attributes.position.count; i < il; i++) {\n\n\t\t\t\t\tindices[i] = i;\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex(indices);\n\n\t\t\t\tdidForceIndices = true;\n\t\t\t}\n\n\t\t\tvar materials = isMultiMaterial ? mesh.material : [mesh.material];\n\t\t\tvar groups = isMultiMaterial ? mesh.geometry.groups : [{ materialIndex: 0, start: undefined, count: undefined }];\n\n\t\t\tfor (var i = 0, il = groups.length; i < il; i++) {\n\n\t\t\t\tvar primitive = {\n\t\t\t\t\tmode: mode,\n\t\t\t\t\tattributes: attributes\n\t\t\t\t};\n\n\t\t\t\tif (targets.length > 0) primitive.targets = targets;\n\n\t\t\t\tif (geometry.index !== null) {\n\n\t\t\t\t\tprimitive.indices = processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n\t\t\t\t}\n\n\t\t\t\tvar material = processMaterial(materials[groups[i].materialIndex]);\n\n\t\t\t\tif (material !== null) {\n\n\t\t\t\t\tprimitive.material = material;\n\t\t\t\t}\n\n\t\t\t\tprimitives.push(primitive);\n\t\t\t}\n\n\t\t\tif (didForceIndices) {\n\n\t\t\t\tgeometry.setIndex(null);\n\t\t\t}\n\n\t\t\tgltfMesh.primitives = primitives;\n\n\t\t\tif (!outputJSON.meshes) {\n\n\t\t\t\toutputJSON.meshes = [];\n\t\t\t}\n\n\t\t\toutputJSON.meshes.push(gltfMesh);\n\n\t\t\treturn outputJSON.meshes.length - 1;\n\t\t}\n\n\t\t/**\n   * Process camera\n   * @param  {THREE.Camera} camera Camera to process\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\n   */\n\t\tfunction processCamera(camera) {\n\n\t\t\tif (!outputJSON.cameras) {\n\n\t\t\t\toutputJSON.cameras = [];\n\t\t\t}\n\n\t\t\tvar isOrtho = camera.isOrthographicCamera;\n\n\t\t\tvar gltfCamera = {\n\n\t\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\n\t\t\t};\n\n\t\t\tif (isOrtho) {\n\n\t\t\t\tgltfCamera.orthographic = {\n\n\t\t\t\t\txmag: camera.right * 2,\n\t\t\t\t\tymag: camera.top * 2,\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t};\n\t\t\t} else {\n\n\t\t\t\tgltfCamera.perspective = {\n\n\t\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\t\tyfov: THREE.Math.degToRad(camera.fov) / camera.aspect,\n\t\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (camera.name !== '') {\n\n\t\t\t\tgltfCamera.name = camera.type;\n\t\t\t}\n\n\t\t\toutputJSON.cameras.push(gltfCamera);\n\n\t\t\treturn outputJSON.cameras.length - 1;\n\t\t}\n\n\t\t/**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {number}\n   */\n\t\tfunction processAnimation(clip, root) {\n\n\t\t\tif (!outputJSON.animations) {\n\n\t\t\t\toutputJSON.animations = [];\n\t\t\t}\n\n\t\t\tvar channels = [];\n\t\t\tvar samplers = [];\n\n\t\t\tfor (var i = 0; i < clip.tracks.length; ++i) {\n\n\t\t\t\tvar track = clip.tracks[i];\n\t\t\t\tvar trackBinding = THREE.PropertyBinding.parseTrackName(track.name);\n\t\t\t\tvar trackNode = THREE.PropertyBinding.findNode(root, trackBinding.nodeName);\n\t\t\t\tvar trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n\t\t\t\tif (trackBinding.objectName === 'bones') {\n\n\t\t\t\t\tif (trackNode.isSkinnedMesh === true) {\n\n\t\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttrackNode = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!trackNode || !trackProperty) {\n\n\t\t\t\t\tconsole.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tvar inputItemSize = 1;\n\t\t\t\tvar outputItemSize = track.values.length / track.times.length;\n\n\t\t\t\tif (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n\n\t\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\t\t\t\t}\n\n\t\t\t\tvar interpolation;\n\n\t\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t\t// valid value from .getInterpolation().\n\t\t\t\tif (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n\n\t\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\t\toutputItemSize /= 3;\n\t\t\t\t} else if (track.getInterpolation() === THREE.InterpolateDiscrete) {\n\n\t\t\t\t\tinterpolation = 'STEP';\n\t\t\t\t} else {\n\n\t\t\t\t\tinterpolation = 'LINEAR';\n\t\t\t\t}\n\n\t\t\t\tsamplers.push({\n\n\t\t\t\t\tinput: processAccessor(new THREE.BufferAttribute(track.times, inputItemSize)),\n\t\t\t\t\toutput: processAccessor(new THREE.BufferAttribute(track.values, outputItemSize)),\n\t\t\t\t\tinterpolation: interpolation\n\n\t\t\t\t});\n\n\t\t\t\tchannels.push({\n\n\t\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\t\ttarget: {\n\t\t\t\t\t\tnode: nodeMap.get(trackNode),\n\t\t\t\t\t\tpath: trackProperty\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\n\t\t\toutputJSON.animations.push({\n\n\t\t\t\tname: clip.name || 'clip_' + outputJSON.animations.length,\n\t\t\t\tsamplers: samplers,\n\t\t\t\tchannels: channels\n\n\t\t\t});\n\n\t\t\treturn outputJSON.animations.length - 1;\n\t\t}\n\n\t\tfunction processSkin(object) {\n\n\t\t\tvar node = outputJSON.nodes[nodeMap.get(object)];\n\n\t\t\tvar skeleton = object.skeleton;\n\t\t\tvar rootJoint = object.skeleton.bones[0];\n\n\t\t\tif (rootJoint === undefined) return null;\n\n\t\t\tvar joints = [];\n\t\t\tvar inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n\n\t\t\tfor (var i = 0; i < skeleton.bones.length; ++i) {\n\n\t\t\t\tjoints.push(nodeMap.get(skeleton.bones[i]));\n\n\t\t\t\tskeleton.boneInverses[i].toArray(inverseBindMatrices, i * 16);\n\t\t\t}\n\n\t\t\tif (outputJSON.skins === undefined) {\n\n\t\t\t\toutputJSON.skins = [];\n\t\t\t}\n\n\t\t\toutputJSON.skins.push({\n\n\t\t\t\tinverseBindMatrices: processAccessor(new THREE.BufferAttribute(inverseBindMatrices, 16)),\n\t\t\t\tjoints: joints,\n\t\t\t\tskeleton: nodeMap.get(rootJoint)\n\n\t\t\t});\n\n\t\t\tvar skinIndex = node.skin = outputJSON.skins.length - 1;\n\n\t\t\treturn skinIndex;\n\t\t}\n\n\t\t/**\n   * Process Object3D node\n   * @param  {THREE.Object3D} node Object3D to processNode\n   * @return {Integer}      Index of the node in the nodes list\n   */\n\t\tfunction processNode(object) {\n\n\t\t\tif (object.isLight) {\n\n\t\t\t\tconsole.warn('GLTFExporter: Unsupported node type:', object.constructor.name);\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (!outputJSON.nodes) {\n\n\t\t\t\toutputJSON.nodes = [];\n\t\t\t}\n\n\t\t\tvar gltfNode = {};\n\n\t\t\tif (options.trs) {\n\n\t\t\t\tvar rotation = object.quaternion.toArray();\n\t\t\t\tvar position = object.position.toArray();\n\t\t\t\tvar scale = object.scale.toArray();\n\n\t\t\t\tif (!equalArray(rotation, [0, 0, 0, 1])) {\n\n\t\t\t\t\tgltfNode.rotation = rotation;\n\t\t\t\t}\n\n\t\t\t\tif (!equalArray(position, [0, 0, 0])) {\n\n\t\t\t\t\tgltfNode.translation = position;\n\t\t\t\t}\n\n\t\t\t\tif (!equalArray(scale, [1, 1, 1])) {\n\n\t\t\t\t\tgltfNode.scale = scale;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tobject.updateMatrix();\n\t\t\t\tif (!equalArray(object.matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])) {\n\n\t\t\t\t\tgltfNode.matrix = object.matrix.elements;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\t\tif (object.name !== '') {\n\n\t\t\t\tgltfNode.name = String(object.name);\n\t\t\t}\n\n\t\t\tif (object.userData && Object.keys(object.userData).length > 0) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tgltfNode.extras = JSON.parse(JSON.stringify(object.userData));\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tthrow new Error('THREE.GLTFExporter: userData can\\'t be serialized');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (object.isMesh || object.isLine || object.isPoints) {\n\n\t\t\t\tvar mesh = processMesh(object);\n\n\t\t\t\tif (mesh !== null) {\n\n\t\t\t\t\tgltfNode.mesh = mesh;\n\t\t\t\t}\n\t\t\t} else if (object.isCamera) {\n\n\t\t\t\tgltfNode.camera = processCamera(object);\n\t\t\t}\n\n\t\t\tif (object.isSkinnedMesh) {\n\n\t\t\t\tskins.push(object);\n\t\t\t}\n\n\t\t\tif (object.children.length > 0) {\n\n\t\t\t\tvar children = [];\n\n\t\t\t\tfor (var i = 0, l = object.children.length; i < l; i++) {\n\n\t\t\t\t\tvar child = object.children[i];\n\n\t\t\t\t\tif (child.visible || options.onlyVisible === false) {\n\n\t\t\t\t\t\tvar node = processNode(child);\n\n\t\t\t\t\t\tif (node !== null) {\n\n\t\t\t\t\t\t\tchildren.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (children.length > 0) {\n\n\t\t\t\t\tgltfNode.children = children;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutputJSON.nodes.push(gltfNode);\n\n\t\t\tvar nodeIndex = outputJSON.nodes.length - 1;\n\t\t\tnodeMap.set(object, nodeIndex);\n\n\t\t\treturn nodeIndex;\n\t\t}\n\n\t\t/**\n   * Process Scene\n   * @param  {THREE.Scene} node Scene to process\n   */\n\t\tfunction processScene(scene) {\n\n\t\t\tif (!outputJSON.scenes) {\n\n\t\t\t\toutputJSON.scenes = [];\n\t\t\t\toutputJSON.scene = 0;\n\t\t\t}\n\n\t\t\tvar gltfScene = {\n\n\t\t\t\tnodes: []\n\n\t\t\t};\n\n\t\t\tif (scene.name !== '') {\n\n\t\t\t\tgltfScene.name = scene.name;\n\t\t\t}\n\n\t\t\toutputJSON.scenes.push(gltfScene);\n\n\t\t\tvar nodes = [];\n\n\t\t\tfor (var i = 0, l = scene.children.length; i < l; i++) {\n\n\t\t\t\tvar child = scene.children[i];\n\n\t\t\t\tif (child.visible || options.onlyVisible === false) {\n\n\t\t\t\t\tvar node = processNode(child);\n\n\t\t\t\t\tif (node !== null) {\n\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nodes.length > 0) {\n\n\t\t\t\tgltfScene.nodes = nodes;\n\t\t\t}\n\t\t}\n\n\t\t/**\n   * Creates a THREE.Scene to hold a list of objects and parse it\n   * @param  {Array} objects List of objects to process\n   */\n\t\tfunction processObjects(objects) {\n\n\t\t\tvar scene = new THREE.Scene();\n\t\t\tscene.name = 'AuxScene';\n\n\t\t\tfor (var i = 0; i < objects.length; i++) {\n\n\t\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\t\tscene.children.push(objects[i]);\n\t\t\t}\n\n\t\t\tprocessScene(scene);\n\t\t}\n\n\t\tfunction processInput(input) {\n\n\t\t\tinput = input instanceof Array ? input : [input];\n\n\t\t\tvar objectsWithoutScene = [];\n\n\t\t\tfor (var i = 0; i < input.length; i++) {\n\n\t\t\t\tif (input[i] instanceof THREE.Scene) {\n\n\t\t\t\t\tprocessScene(input[i]);\n\t\t\t\t} else {\n\n\t\t\t\t\tobjectsWithoutScene.push(input[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (objectsWithoutScene.length > 0) {\n\n\t\t\t\tprocessObjects(objectsWithoutScene);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < skins.length; ++i) {\n\n\t\t\t\tprocessSkin(skins[i]);\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < options.animations.length; ++i) {\n\n\t\t\t\tprocessAnimation(options.animations[i], input[0]);\n\t\t\t}\n\t\t}\n\n\t\tprocessInput(input);\n\n\t\tPromise.all(pending).then(function () {\n\n\t\t\t// Merge buffers.\n\t\t\tvar blob = new Blob(buffers, { type: 'application/octet-stream' });\n\n\t\t\t// Declare extensions.\n\t\t\tvar extensionsUsedList = Object.keys(extensionsUsed);\n\t\t\tif (extensionsUsedList.length > 0) outputJSON.extensionsUsed = extensionsUsedList;\n\n\t\t\tif (outputJSON.buffers && outputJSON.buffers.length > 0) {\n\n\t\t\t\t// Update bytelength of the single buffer.\n\t\t\t\toutputJSON.buffers[0].byteLength = blob.size;\n\n\t\t\t\tvar reader = new window.FileReader();\n\n\t\t\t\tif (options.binary === true) {\n\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\t\t\tvar GLB_HEADER_BYTES = 12;\n\t\t\t\t\tvar GLB_HEADER_MAGIC = 0x46546C67;\n\t\t\t\t\tvar GLB_VERSION = 2;\n\n\t\t\t\t\tvar GLB_CHUNK_PREFIX_BYTES = 8;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\n\t\t\t\t\tvar GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n\t\t\t\t\treader.readAsArrayBuffer(blob);\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\t// Binary chunk.\n\t\t\t\t\t\tvar binaryChunk = getPaddedArrayBuffer(reader.result);\n\t\t\t\t\t\tvar binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n\t\t\t\t\t\tbinaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n\n\t\t\t\t\t\t// JSON chunk.\n\t\t\t\t\t\tvar jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(outputJSON)), 0x20);\n\t\t\t\t\t\tvar jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n\t\t\t\t\t\tjsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n\t\t\t\t\t\tjsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n\n\t\t\t\t\t\t// GLB header.\n\t\t\t\t\t\tvar header = new ArrayBuffer(GLB_HEADER_BYTES);\n\t\t\t\t\t\tvar headerView = new DataView(header);\n\t\t\t\t\t\theaderView.setUint32(0, GLB_HEADER_MAGIC, true);\n\t\t\t\t\t\theaderView.setUint32(4, GLB_VERSION, true);\n\t\t\t\t\t\tvar totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\t\t\theaderView.setUint32(8, totalByteLength, true);\n\n\t\t\t\t\t\tvar glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], { type: 'application/octet-stream' });\n\n\t\t\t\t\t\tvar glbReader = new window.FileReader();\n\t\t\t\t\t\tglbReader.readAsArrayBuffer(glbBlob);\n\t\t\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\t\t\tonDone(glbReader.result);\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\t\t\t\t} else {\n\n\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\t\tvar base64data = reader.result;\n\t\t\t\t\t\toutputJSON.buffers[0].uri = base64data;\n\t\t\t\t\t\tonDone(outputJSON);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tonDone(outputJSON);\n\t\t\t}\n\t\t});\n\t}\n\n};\n\nexports.default = GLTFExporter;\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _mmdParser = __webpack_require__(4);\n\nvar MMDParser = _interopRequireWildcard(_mmdParser);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author takahiro / http://github.com/takahirox\n *\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n */\n\nvar MMDExporter = function MMDExporter() {\n\n\t// Unicode to Shift_JIS table\n\tvar u2sTable;\n\n\tfunction unicodeToShiftjis(str) {\n\n\t\tif (u2sTable === undefined) {\n\n\t\t\tvar encoder = new MMDParser.CharsetEncoder();\n\t\t\tvar table = encoder.s2uTable;\n\t\t\tu2sTable = {};\n\n\t\t\tvar keys = Object.keys(table);\n\n\t\t\tfor (var i = 0, il = keys.length; i < il; i++) {\n\n\t\t\t\tvar key = keys[i];\n\n\t\t\t\tvar value = table[key];\n\t\t\t\tkey = parseInt(key);\n\n\t\t\t\tu2sTable[value] = key;\n\t\t\t}\n\t\t}\n\n\t\tvar array = [];\n\n\t\tfor (var i = 0, il = str.length; i < il; i++) {\n\n\t\t\tvar code = str.charCodeAt(i);\n\n\t\t\tvar value = u2sTable[code];\n\n\t\t\tif (value === undefined) {\n\n\t\t\t\tthrow 'cannot convert charcode 0x' + code.toString(16);\n\t\t\t} else if (value > 0xff) {\n\n\t\t\t\tarray.push(value >> 8 & 0xff);\n\t\t\t\tarray.push(value & 0xff);\n\t\t\t} else {\n\n\t\t\t\tarray.push(value & 0xff);\n\t\t\t}\n\t\t}\n\n\t\treturn new Uint8Array(array);\n\t}\n\n\tfunction getBindBones(skin) {\n\n\t\t// any more efficient ways?\n\t\tvar poseSkin = skin.clone();\n\t\tposeSkin.pose();\n\t\treturn poseSkin.skeleton.bones;\n\t}\n\n\t/* TODO: implement\n // mesh -> pmd\n this.parsePmd = function ( object ) {\n \t};\n */\n\n\t/* TODO: implement\n // mesh -> pmx\n this.parsePmx = function ( object ) {\n \t};\n */\n\n\t/*\n  * skeleton -> vpd\n  * Returns Shift_JIS encoded Uint8Array. Otherwise return strings.\n  */\n\tthis.parseVpd = function (skin, outputShiftJis, useOriginalBones) {\n\n\t\tif (skin.isSkinnedMesh !== true) {\n\n\t\t\tconsole.warn('THREE.MMDExporter: parseVpd() requires SkinnedMesh instance.');\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction toStringsFromNumber(num) {\n\n\t\t\tif (Math.abs(num) < 1e-6) num = 0;\n\n\t\t\tvar a = num.toString();\n\n\t\t\tif (a.indexOf('.') === -1) {\n\n\t\t\t\ta += '.';\n\t\t\t}\n\n\t\t\ta += '000000';\n\n\t\t\tvar index = a.indexOf('.');\n\n\t\t\tvar d = a.slice(0, index);\n\t\t\tvar p = a.slice(index + 1, index + 7);\n\n\t\t\treturn d + '.' + p;\n\t\t}\n\n\t\tfunction toStringsFromArray(array) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0, il = array.length; i < il; i++) {\n\n\t\t\t\ta.push(toStringsFromNumber(array[i]));\n\t\t\t}\n\n\t\t\treturn a.join(',');\n\t\t}\n\n\t\tskin.updateMatrixWorld(true);\n\n\t\tvar bones = skin.skeleton.bones;\n\t\tvar bones2 = getBindBones(skin);\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar quaternion2 = new THREE.Quaternion();\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\tvar array = [];\n\t\tarray.push('Vocaloid Pose Data file');\n\t\tarray.push('');\n\t\tarray.push((skin.name !== '' ? skin.name.replace(/\\s/g, '_') : 'skin') + '.osm;');\n\t\tarray.push(bones.length + ';');\n\t\tarray.push('');\n\n\t\tfor (var i = 0, il = bones.length; i < il; i++) {\n\n\t\t\tvar bone = bones[i];\n\t\t\tvar bone2 = bones2[i];\n\n\t\t\t/*\n    * use the bone matrix saved before solving IK.\n    * see CCDIKSolver for the detail.\n    */\n\t\t\tif (useOriginalBones === true && bone.userData.ik !== undefined && bone.userData.ik.originalMatrix !== undefined) {\n\n\t\t\t\tmatrix.fromArray(bone.userData.ik.originalMatrix);\n\t\t\t} else {\n\n\t\t\t\tmatrix.copy(bone.matrix);\n\t\t\t}\n\n\t\t\tposition.setFromMatrixPosition(matrix);\n\t\t\tquaternion.setFromRotationMatrix(matrix);\n\n\t\t\tvar pArray = position.sub(bone2.position).toArray();\n\t\t\tvar qArray = quaternion2.copy(bone2.quaternion).conjugate().multiply(quaternion).toArray();\n\n\t\t\t// right to left\n\t\t\tpArray[2] = -pArray[2];\n\t\t\tqArray[0] = -qArray[0];\n\t\t\tqArray[1] = -qArray[1];\n\n\t\t\tarray.push('Bone' + i + '{' + bone.name);\n\t\t\tarray.push('  ' + toStringsFromArray(pArray) + ';');\n\t\t\tarray.push('  ' + toStringsFromArray(qArray) + ';');\n\t\t\tarray.push('}');\n\t\t\tarray.push('');\n\t\t}\n\n\t\tarray.push('');\n\n\t\tvar lines = array.join('\\n');\n\n\t\treturn outputShiftJis === true ? unicodeToShiftjis(lines) : lines;\n\t};\n\n\t/* TODO: implement\n // animation + skeleton -> vmd\n this.parseVmd = function ( object ) {\n \t};\n */\n};\n\nexports.default = MMDExporter;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar OBJExporter = function OBJExporter() {};\n\nOBJExporter.prototype = {\n\n\tconstructor: OBJExporter,\n\n\tparse: function parse(object) {\n\n\t\tvar output = '';\n\n\t\tvar indexVertex = 0;\n\t\tvar indexVertexUvs = 0;\n\t\tvar indexNormals = 0;\n\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\t\tvar uv = new THREE.Vector2();\n\n\t\tvar i,\n\t\t    j,\n\t\t    k,\n\t\t    l,\n\t\t    m,\n\t\t    face = [];\n\n\t\tvar parseMesh = function parseMesh(mesh) {\n\n\t\t\tvar nbVertex = 0;\n\t\t\tvar nbNormals = 0;\n\t\t\tvar nbVertexUvs = 0;\n\n\t\t\tvar geometry = mesh.geometry;\n\n\t\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject(mesh);\n\t\t\t}\n\n\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t// shortcuts\n\t\t\t\tvar vertices = geometry.getAttribute('position');\n\t\t\t\tvar normals = geometry.getAttribute('normal');\n\t\t\t\tvar uvs = geometry.getAttribute('uv');\n\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t// name of the mesh object\n\t\t\t\toutput += 'o ' + mesh.name + '\\n';\n\n\t\t\t\t// name of the mesh material\n\t\t\t\tif (mesh.material && mesh.material.name) {\n\n\t\t\t\t\toutput += 'usemtl ' + mesh.material.name + '\\n';\n\t\t\t\t}\n\n\t\t\t\t// vertices\n\n\t\t\t\tif (vertices !== undefined) {\n\n\t\t\t\t\tfor (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX(i);\n\t\t\t\t\t\tvertex.y = vertices.getY(i);\n\t\t\t\t\t\tvertex.z = vertices.getZ(i);\n\n\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\tvertex.applyMatrix4(mesh.matrixWorld);\n\n\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// uvs\n\n\t\t\t\tif (uvs !== undefined) {\n\n\t\t\t\t\tfor (i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n\n\t\t\t\t\t\tuv.x = uvs.getX(i);\n\t\t\t\t\t\tuv.y = uvs.getY(i);\n\n\t\t\t\t\t\t// transform the uv to export format\n\t\t\t\t\t\toutput += 'vt ' + uv.x + ' ' + uv.y + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// normals\n\n\t\t\t\tif (normals !== undefined) {\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n\t\t\t\t\tfor (i = 0, l = normals.count; i < l; i++, nbNormals++) {\n\n\t\t\t\t\t\tnormal.x = normals.getX(i);\n\t\t\t\t\t\tnormal.y = normals.getY(i);\n\t\t\t\t\t\tnormal.z = normals.getZ(i);\n\n\t\t\t\t\t\t// transfrom the normal to world space\n\t\t\t\t\t\tnormal.applyMatrix3(normalMatrixWorld);\n\n\t\t\t\t\t\t// transform the normal to export format\n\t\t\t\t\t\toutput += 'vn ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// faces\n\n\t\t\t\tif (indices !== null) {\n\n\t\t\t\t\tfor (i = 0, l = indices.count; i < l; i += 3) {\n\n\t\t\t\t\t\tfor (m = 0; m < 3; m++) {\n\n\t\t\t\t\t\t\tj = indices.getX(i + m) + 1;\n\n\t\t\t\t\t\t\tface[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\toutput += 'f ' + face.join(' ') + \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tfor (i = 0, l = vertices.count; i < l; i += 3) {\n\n\t\t\t\t\t\tfor (m = 0; m < 3; m++) {\n\n\t\t\t\t\t\t\tj = i + m + 1;\n\n\t\t\t\t\t\t\tface[m] = indexVertex + j + (normals || uvs ? '/' + (uvs ? indexVertexUvs + j : '') + (normals ? '/' + (indexNormals + j) : '') : '');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// transform the face to export format\n\t\t\t\t\t\toutput += 'f ' + face.join(' ') + \"\\n\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('THREE.OBJExporter.parseMesh(): geometry type unsupported', geometry);\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t\tindexVertexUvs += nbVertexUvs;\n\t\t\tindexNormals += nbNormals;\n\t\t};\n\n\t\tvar parseLine = function parseLine(line) {\n\n\t\t\tvar nbVertex = 0;\n\n\t\t\tvar geometry = line.geometry;\n\t\t\tvar type = line.type;\n\n\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject(line);\n\t\t\t}\n\n\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t// shortcuts\n\t\t\t\tvar vertices = geometry.getAttribute('position');\n\n\t\t\t\t// name of the line object\n\t\t\t\toutput += 'o ' + line.name + '\\n';\n\n\t\t\t\tif (vertices !== undefined) {\n\n\t\t\t\t\tfor (i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX(i);\n\t\t\t\t\t\tvertex.y = vertices.getY(i);\n\t\t\t\t\t\tvertex.z = vertices.getZ(i);\n\n\t\t\t\t\t\t// transfrom the vertex to world space\n\t\t\t\t\t\tvertex.applyMatrix4(line.matrixWorld);\n\n\t\t\t\t\t\t// transform the vertex to export format\n\t\t\t\t\t\toutput += 'v ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (type === 'Line') {\n\n\t\t\t\t\toutput += 'l ';\n\n\t\t\t\t\tfor (j = 1, l = vertices.count; j <= l; j++) {\n\n\t\t\t\t\t\toutput += indexVertex + j + ' ';\n\t\t\t\t\t}\n\n\t\t\t\t\toutput += '\\n';\n\t\t\t\t}\n\n\t\t\t\tif (type === 'LineSegments') {\n\n\t\t\t\t\tfor (j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n\n\t\t\t\t\t\toutput += 'l ' + (indexVertex + j) + ' ' + (indexVertex + k) + '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tconsole.warn('THREE.OBJExporter.parseLine(): geometry type unsupported', geometry);\n\t\t\t}\n\n\t\t\t// update index\n\t\t\tindexVertex += nbVertex;\n\t\t};\n\n\t\tobject.traverse(function (child) {\n\n\t\t\tif (child instanceof THREE.Mesh) {\n\n\t\t\t\tparseMesh(child);\n\t\t\t}\n\n\t\t\tif (child instanceof THREE.Line) {\n\n\t\t\t\tparseLine(child);\n\t\t\t}\n\t\t});\n\n\t\treturn output;\n\t}\n\n};\n\nexports.default = OBJExporter;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Garrett Johnson / http://gkjohnson.github.io/\n * https://github.com/gkjohnson/ply-exporter-js\n *\n * Usage:\n *  var exporter = new THREE.PLYExporter();\n *\n *  // second argument is an array of attributes to\n *  // exclude from the format ('color', 'uv', 'normal')\n *  var data = exporter.parse(mesh, [ 'color' ]);\n *\n * Format Definition:\n *  http://paulbourke.net/dataformats/ply/\n */\n\nvar PLYExporter = function PLYExporter() {};\n\nPLYExporter.prototype = {\n\n\tconstructor: PLYExporter,\n\n\tparse: function parse(object, excludeProperties) {\n\n\t\tif (Array.isArray(excludeProperties) !== true) {\n\n\t\t\texcludeProperties = [];\n\t\t}\n\n\t\tvar includeNormals = excludeProperties.indexOf('normal') === -1;\n\t\tvar includeColors = excludeProperties.indexOf('color') === -1;\n\t\tvar includeUVs = excludeProperties.indexOf('uv') === -1;\n\n\t\t// count the number of vertices\n\t\tvar vertexCount = 0;\n\t\tvar faceCount = 0;\n\t\tvar vertexList = '';\n\t\tvar faceList = '';\n\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\t\tobject.traverse(function (child) {\n\n\t\t\tif (child instanceof THREE.Mesh) {\n\n\t\t\t\tvar mesh = child;\n\t\t\t\tvar geometry = mesh.geometry;\n\n\t\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\t\tgeometry = new THREE.BufferGeometry().setFromObject(mesh);\n\t\t\t\t}\n\n\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\tvar vertices = geometry.getAttribute('position');\n\t\t\t\t\tvar normals = geometry.getAttribute('normal');\n\t\t\t\t\tvar uvs = geometry.getAttribute('uv');\n\t\t\t\t\tvar colors = geometry.getAttribute('color');\n\t\t\t\t\tvar indices = geometry.getIndex();\n\n\t\t\t\t\tnormalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n\n\t\t\t\t\tif (vertices === undefined) {\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// form each line\n\t\t\t\t\tfor (var i = 0, l = vertices.count; i < l; i++) {\n\n\t\t\t\t\t\tvertex.x = vertices.getX(i);\n\t\t\t\t\t\tvertex.y = vertices.getY(i);\n\t\t\t\t\t\tvertex.z = vertices.getZ(i);\n\n\t\t\t\t\t\tvertex.applyMatrix4(mesh.matrixWorld);\n\n\t\t\t\t\t\t// Position information\n\t\t\t\t\t\tvar line = vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\n\t\t\t\t\t\t// Normal information\n\t\t\t\t\t\tif (includeNormals === true) {\n\n\t\t\t\t\t\t\tif (normals !== undefined) {\n\n\t\t\t\t\t\t\t\tvertex.x = normals.getX(i);\n\t\t\t\t\t\t\t\tvertex.y = normals.getY(i);\n\t\t\t\t\t\t\t\tvertex.z = normals.getZ(i);\n\n\t\t\t\t\t\t\t\tvertex.applyMatrix3(normalMatrixWorld);\n\n\t\t\t\t\t\t\t\tline += ' ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z;\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 0 0 0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// UV information\n\t\t\t\t\t\tif (includeUVs === true) {\n\n\t\t\t\t\t\t\tif (uvs !== undefined) {\n\n\t\t\t\t\t\t\t\tline += ' ' + uvs.getX(i) + ' ' + uvs.getY(i);\n\t\t\t\t\t\t\t} else if (includeUVs !== false) {\n\n\t\t\t\t\t\t\t\tline += ' 0 0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Color information\n\t\t\t\t\t\tif (includeColors === true) {\n\n\t\t\t\t\t\t\tif (colors !== undefined) {\n\n\t\t\t\t\t\t\t\tline += ' ' + Math.floor(colors.getX(i)) + ' ' + Math.floor(colors.getY(i)) + ' ' + Math.floor(colors.getZ(i));\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tline += ' 255 255 255';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvertexList += line + '\\n';\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create the face list\n\t\t\t\t\tif (indices !== null) {\n\n\t\t\t\t\t\tfor (i = 0, l = indices.count; i < l; i += 3) {\n\n\t\t\t\t\t\t\tfaceList += '3 ' + (indices.getX(i + 0) + vertexCount);\n\t\t\t\t\t\t\tfaceList += ' ' + (indices.getX(i + 1) + vertexCount);\n\t\t\t\t\t\t\tfaceList += ' ' + (indices.getX(i + 2) + vertexCount) + '\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor (var i = 0, l = vertices.count; i < l; i += 3) {\n\n\t\t\t\t\t\t\tfaceList += '3 ' + (vertexCount + i) + ' ' + (vertexCount + i + 1) + ' ' + (vertexCount + i + 2) + '\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tvertexCount += vertices.count;\n\t\t\t\t\tfaceCount += indices ? indices.count / 3 : vertices.count / 3;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tvar output = 'ply\\n' + 'format ascii 1.0\\n' + ('element vertex ' + vertexCount + '\\n') +\n\n\t\t// position\n\t\t'property float x\\n' + 'property float y\\n' + 'property float z\\n';\n\n\t\tif (includeNormals === true) {\n\n\t\t\t// normal\n\t\t\toutput += 'property float nx\\n' + 'property float ny\\n' + 'property float nz\\n';\n\t\t}\n\n\t\tif (includeUVs === true) {\n\n\t\t\t// uvs\n\t\t\toutput += 'property float s\\n' + 'property float t\\n';\n\t\t}\n\n\t\tif (includeColors === true) {\n\n\t\t\t// colors\n\t\t\toutput += 'property uchar red\\n' + 'property uchar green\\n' + 'property uchar blue\\n';\n\t\t}\n\n\t\t// faces\n\t\toutput += 'element face ' + faceCount + '\\n' + 'property list uchar int vertex_index\\n' + 'end_header\\n' + (vertexList + '\\n') + (faceList + '\\n');\n\n\t\treturn output;\n\t}\n\n};\n\nexports.default = PLYExporter;\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author kovacsv / http://kovacsv.hu/\n * @author mrdoob / http://mrdoob.com/\n * @author mudcube / http://mudcu.be/\n */\n\nvar STLBinaryExporter = function STLBinaryExporter() {};\n\nSTLBinaryExporter.prototype = {\n\n\tconstructor: STLBinaryExporter,\n\n\tparse: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\treturn function parse(scene) {\n\n\t\t\t// We collect objects first, as we may need to convert from BufferGeometry to Geometry\n\t\t\tvar objects = [];\n\t\t\tvar triangles = 0;\n\t\t\tscene.traverse(function (object) {\n\n\t\t\t\tif (!(object instanceof THREE.Mesh)) return;\n\n\t\t\t\tvar geometry = object.geometry;\n\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry(geometry);\n\t\t\t\t}\n\n\t\t\t\tif (!(geometry instanceof THREE.Geometry)) return;\n\t\t\t\ttriangles += geometry.faces.length;\n\n\t\t\t\tobjects.push({\n\n\t\t\t\t\tgeometry: geometry,\n\t\t\t\t\tmatrix: object.matrixWorld\n\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tvar offset = 80; // skip header\n\t\t\tvar bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n\t\t\tvar arrayBuffer = new ArrayBuffer(bufferLength);\n\t\t\tvar output = new DataView(arrayBuffer);\n\t\t\toutput.setUint32(offset, triangles, true);offset += 4;\n\n\t\t\t// Traversing our collected objects\n\t\t\tobjects.forEach(function (object) {\n\n\t\t\t\tvar vertices = object.geometry.vertices;\n\t\t\t\tvar faces = object.geometry.faces;\n\n\t\t\t\tnormalMatrixWorld.getNormalMatrix(object.matrix);\n\n\t\t\t\tfor (var i = 0, l = faces.length; i < l; i++) {\n\n\t\t\t\t\tvar face = faces[i];\n\n\t\t\t\t\tvector.copy(face.normal).applyMatrix3(normalMatrixWorld).normalize();\n\n\t\t\t\t\toutput.setFloat32(offset, vector.x, true);offset += 4; // normal\n\t\t\t\t\toutput.setFloat32(offset, vector.y, true);offset += 4;\n\t\t\t\t\toutput.setFloat32(offset, vector.z, true);offset += 4;\n\n\t\t\t\t\tvar indices = [face.a, face.b, face.c];\n\n\t\t\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\t\t\tvector.copy(vertices[indices[j]]).applyMatrix4(object.matrix);\n\n\t\t\t\t\t\toutput.setFloat32(offset, vector.x, true);offset += 4; // vertices\n\t\t\t\t\t\toutput.setFloat32(offset, vector.y, true);offset += 4;\n\t\t\t\t\t\toutput.setFloat32(offset, vector.z, true);offset += 4;\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.setUint16(offset, 0, true);offset += 2; // attribute byte count\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn output;\n\t\t};\n\t}()\n\n};\n\nexports.default = STLBinaryExporter;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author kovacsv / http://kovacsv.hu/\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar STLExporter = function STLExporter() {};\n\nSTLExporter.prototype = {\n\n\tconstructor: STLExporter,\n\n\tparse: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar normalMatrixWorld = new THREE.Matrix3();\n\n\t\treturn function parse(scene) {\n\n\t\t\tvar output = '';\n\n\t\t\toutput += 'solid exported\\n';\n\n\t\t\tscene.traverse(function (object) {\n\n\t\t\t\tif (object instanceof THREE.Mesh) {\n\n\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\tvar matrixWorld = object.matrixWorld;\n\n\t\t\t\t\tif (geometry instanceof THREE.BufferGeometry) {\n\n\t\t\t\t\t\tgeometry = new THREE.Geometry().fromBufferGeometry(geometry);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (geometry instanceof THREE.Geometry) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\t\t\tvar faces = geometry.faces;\n\n\t\t\t\t\t\tnormalMatrixWorld.getNormalMatrix(matrixWorld);\n\n\t\t\t\t\t\tfor (var i = 0, l = faces.length; i < l; i++) {\n\n\t\t\t\t\t\t\tvar face = faces[i];\n\n\t\t\t\t\t\t\tvector.copy(face.normal).applyMatrix3(normalMatrixWorld).normalize();\n\n\t\t\t\t\t\t\toutput += '\\tfacet normal ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\t\t\t\t\t\t\toutput += '\\t\\touter loop\\n';\n\n\t\t\t\t\t\t\tvar indices = [face.a, face.b, face.c];\n\n\t\t\t\t\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\t\t\t\t\tvector.copy(vertices[indices[j]]).applyMatrix4(matrixWorld);\n\n\t\t\t\t\t\t\t\toutput += '\\t\\t\\tvertex ' + vector.x + ' ' + vector.y + ' ' + vector.z + '\\n';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\toutput += '\\t\\tendloop\\n';\n\t\t\t\t\t\t\toutput += '\\tendfacet\\n';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\toutput += 'endsolid exported\\n';\n\n\t\t\treturn output;\n\t\t};\n\t}()\n\n};\n\nexports.default = STLExporter;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar TypedGeometryExporter = function TypedGeometryExporter() {};\n\nTypedGeometryExporter.prototype = {\n\n\tconstructor: TypedGeometryExporter,\n\n\tparse: function parse(geometry) {\n\n\t\tvar output = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.0,\n\t\t\t\ttype: 'TypedGeometry',\n\t\t\t\tgenerator: 'TypedGeometryExporter'\n\t\t\t}\n\t\t};\n\n\t\tvar attributes = ['vertices', 'normals', 'uvs'];\n\n\t\tfor (var key in attributes) {\n\n\t\t\tvar attribute = attributes[key];\n\n\t\t\tvar typedArray = geometry[attribute];\n\t\t\tvar array = [];\n\n\t\t\tfor (var i = 0, l = typedArray.length; i < l; i++) {\n\n\t\t\t\tarray[i] = typedArray[i];\n\t\t\t}\n\n\t\t\toutput[attribute] = array;\n\t\t}\n\n\t\tvar boundingSphere = geometry.boundingSphere;\n\n\t\tif (boundingSphere !== null) {\n\n\t\t\toutput.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\t\t}\n\n\t\treturn output;\n\t}\n\n};\n\nexports.default = TypedGeometryExporter;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XLoader = exports.VTKLoader = exports.UTF8Loader = exports.VRMLoader = exports.VRMLLoader = exports.TTFLoader = exports.TGALoader = exports.TDSLoader = exports.SVGLoader = exports.STLLoader = exports.RGBELoader = exports.PVRLoader = exports.PRWMLoader = exports.PLYLoader = exports.PlayCanvasLoader = exports.PDBLoader = exports.PCDLoader = exports.OBJLoader2 = exports.OBJLoader = exports.NRRDLoader = exports.NodeMaterialLoader = exports.MTLLoader = exports.MMDLoader = exports.MD2Loader = exports.LoaderSupport = exports.KTXLoader = exports.KMZLoader = exports.HDRCubeTextureLoader = exports.GLTFLoader = exports.GCodeLoader = exports.FBXLoader = exports.EXRLoader = exports.EquiangularToCubeGenerator = exports.DRACOLoader = exports.DDSLoader = exports.ColladaLoader = exports.BVHLoader = exports.BinaryLoader = exports.BabylonLoader = exports.AWDLoader = exports.AssimpLoader = exports.AssimpJSONLoader = exports.AMFLoader = exports.ThreeMFLoader = undefined;\n\nvar _MFLoader = __webpack_require__(49);\n\nvar _MFLoader2 = _interopRequireDefault(_MFLoader);\n\nvar _AMFLoader = __webpack_require__(50);\n\nvar _AMFLoader2 = _interopRequireDefault(_AMFLoader);\n\nvar _AssimpJSONLoader = __webpack_require__(51);\n\nvar _AssimpJSONLoader2 = _interopRequireDefault(_AssimpJSONLoader);\n\nvar _AssimpLoader = __webpack_require__(52);\n\nvar _AssimpLoader2 = _interopRequireDefault(_AssimpLoader);\n\nvar _AWDLoader = __webpack_require__(53);\n\nvar _AWDLoader2 = _interopRequireDefault(_AWDLoader);\n\nvar _BabylonLoader = __webpack_require__(54);\n\nvar _BabylonLoader2 = _interopRequireDefault(_BabylonLoader);\n\nvar _BinaryLoader = __webpack_require__(55);\n\nvar _BinaryLoader2 = _interopRequireDefault(_BinaryLoader);\n\nvar _BVHLoader = __webpack_require__(56);\n\nvar _BVHLoader2 = _interopRequireDefault(_BVHLoader);\n\nvar _ColladaLoader = __webpack_require__(57);\n\nvar _ColladaLoader2 = _interopRequireDefault(_ColladaLoader);\n\nvar _DDSLoader = __webpack_require__(58);\n\nvar _DDSLoader2 = _interopRequireDefault(_DDSLoader);\n\nvar _DRACOLoader = __webpack_require__(59);\n\nvar _DRACOLoader2 = _interopRequireDefault(_DRACOLoader);\n\nvar _EquiangularToCubeGenerator = __webpack_require__(60);\n\nvar _EquiangularToCubeGenerator2 = _interopRequireDefault(_EquiangularToCubeGenerator);\n\nvar _EXRLoader = __webpack_require__(61);\n\nvar _EXRLoader2 = _interopRequireDefault(_EXRLoader);\n\nvar _FBXLoader = __webpack_require__(62);\n\nvar _FBXLoader2 = _interopRequireDefault(_FBXLoader);\n\nvar _GCodeLoader = __webpack_require__(63);\n\nvar _GCodeLoader2 = _interopRequireDefault(_GCodeLoader);\n\nvar _GLTFLoader = __webpack_require__(5);\n\nvar _GLTFLoader2 = _interopRequireDefault(_GLTFLoader);\n\nvar _HDRCubeTextureLoader = __webpack_require__(64);\n\nvar _HDRCubeTextureLoader2 = _interopRequireDefault(_HDRCubeTextureLoader);\n\nvar _KMZLoader = __webpack_require__(65);\n\nvar _KMZLoader2 = _interopRequireDefault(_KMZLoader);\n\nvar _KTXLoader = __webpack_require__(66);\n\nvar _KTXLoader2 = _interopRequireDefault(_KTXLoader);\n\nvar _LoaderSupport = __webpack_require__(7);\n\nvar _LoaderSupport2 = _interopRequireDefault(_LoaderSupport);\n\nvar _MD2Loader = __webpack_require__(68);\n\nvar _MD2Loader2 = _interopRequireDefault(_MD2Loader);\n\nvar _MMDLoader = __webpack_require__(69);\n\nvar _MMDLoader2 = _interopRequireDefault(_MMDLoader);\n\nvar _MTLLoader = __webpack_require__(9);\n\nvar _MTLLoader2 = _interopRequireDefault(_MTLLoader);\n\nvar _NodeMaterialLoader = __webpack_require__(70);\n\nvar _NodeMaterialLoader2 = _interopRequireDefault(_NodeMaterialLoader);\n\nvar _NRRDLoader = __webpack_require__(71);\n\nvar _NRRDLoader2 = _interopRequireDefault(_NRRDLoader);\n\nvar _OBJLoader = __webpack_require__(72);\n\nvar _OBJLoader2 = _interopRequireDefault(_OBJLoader);\n\nvar _OBJLoader3 = __webpack_require__(73);\n\nvar _OBJLoader4 = _interopRequireDefault(_OBJLoader3);\n\nvar _PCDLoader = __webpack_require__(74);\n\nvar _PCDLoader2 = _interopRequireDefault(_PCDLoader);\n\nvar _PDBLoader = __webpack_require__(75);\n\nvar _PDBLoader2 = _interopRequireDefault(_PDBLoader);\n\nvar _PlayCanvasLoader = __webpack_require__(76);\n\nvar _PlayCanvasLoader2 = _interopRequireDefault(_PlayCanvasLoader);\n\nvar _PLYLoader = __webpack_require__(77);\n\nvar _PLYLoader2 = _interopRequireDefault(_PLYLoader);\n\nvar _PRWMLoader = __webpack_require__(78);\n\nvar _PRWMLoader2 = _interopRequireDefault(_PRWMLoader);\n\nvar _PVRLoader = __webpack_require__(79);\n\nvar _PVRLoader2 = _interopRequireDefault(_PVRLoader);\n\nvar _RGBELoader = __webpack_require__(6);\n\nvar _RGBELoader2 = _interopRequireDefault(_RGBELoader);\n\nvar _STLLoader = __webpack_require__(80);\n\nvar _STLLoader2 = _interopRequireDefault(_STLLoader);\n\nvar _SVGLoader = __webpack_require__(81);\n\nvar _SVGLoader2 = _interopRequireDefault(_SVGLoader);\n\nvar _TDSLoader = __webpack_require__(82);\n\nvar _TDSLoader2 = _interopRequireDefault(_TDSLoader);\n\nvar _TGALoader = __webpack_require__(83);\n\nvar _TGALoader2 = _interopRequireDefault(_TGALoader);\n\nvar _TTFLoader = __webpack_require__(84);\n\nvar _TTFLoader2 = _interopRequireDefault(_TTFLoader);\n\nvar _VRMLLoader = __webpack_require__(85);\n\nvar _VRMLLoader2 = _interopRequireDefault(_VRMLLoader);\n\nvar _VRMLoader = __webpack_require__(86);\n\nvar _VRMLoader2 = _interopRequireDefault(_VRMLoader);\n\nvar _UTF8Loader = __webpack_require__(87);\n\nvar _UTF8Loader2 = _interopRequireDefault(_UTF8Loader);\n\nvar _VTKLoader = __webpack_require__(88);\n\nvar _VTKLoader2 = _interopRequireDefault(_VTKLoader);\n\nvar _XLoader = __webpack_require__(89);\n\nvar _XLoader2 = _interopRequireDefault(_XLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.ThreeMFLoader = _MFLoader2.default;\nexports.AMFLoader = _AMFLoader2.default;\nexports.AssimpJSONLoader = _AssimpJSONLoader2.default;\nexports.AssimpLoader = _AssimpLoader2.default;\nexports.AWDLoader = _AWDLoader2.default;\nexports.BabylonLoader = _BabylonLoader2.default;\nexports.BinaryLoader = _BinaryLoader2.default;\nexports.BVHLoader = _BVHLoader2.default;\nexports.ColladaLoader = _ColladaLoader2.default;\nexports.DDSLoader = _DDSLoader2.default;\nexports.DRACOLoader = _DRACOLoader2.default;\nexports.EquiangularToCubeGenerator = _EquiangularToCubeGenerator2.default;\nexports.EXRLoader = _EXRLoader2.default;\nexports.FBXLoader = _FBXLoader2.default;\nexports.GCodeLoader = _GCodeLoader2.default;\nexports.GLTFLoader = _GLTFLoader2.default;\nexports.HDRCubeTextureLoader = _HDRCubeTextureLoader2.default;\nexports.KMZLoader = _KMZLoader2.default;\nexports.KTXLoader = _KTXLoader2.default;\nexports.LoaderSupport = _LoaderSupport2.default;\nexports.MD2Loader = _MD2Loader2.default;\nexports.MMDLoader = _MMDLoader2.default;\nexports.MTLLoader = _MTLLoader2.default;\nexports.NodeMaterialLoader = _NodeMaterialLoader2.default;\nexports.NRRDLoader = _NRRDLoader2.default;\nexports.OBJLoader = _OBJLoader2.default;\nexports.OBJLoader2 = _OBJLoader4.default;\nexports.PCDLoader = _PCDLoader2.default;\nexports.PDBLoader = _PDBLoader2.default;\nexports.PlayCanvasLoader = _PlayCanvasLoader2.default;\nexports.PLYLoader = _PLYLoader2.default;\nexports.PRWMLoader = _PRWMLoader2.default;\nexports.PVRLoader = _PVRLoader2.default;\nexports.RGBELoader = _RGBELoader2.default;\nexports.STLLoader = _STLLoader2.default;\nexports.SVGLoader = _SVGLoader2.default;\nexports.TDSLoader = _TDSLoader2.default;\nexports.TGALoader = _TGALoader2.default;\nexports.TTFLoader = _TTFLoader2.default;\nexports.VRMLLoader = _VRMLLoader2.default;\nexports.VRMLoader = _VRMLoader2.default;\nexports.UTF8Loader = _UTF8Loader2.default;\nexports.VTKLoader = _VTKLoader2.default;\nexports.XLoader = _XLoader2.default;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author technohippy / https://github.com/technohippy\n */\n\nvar ThreeMFLoader = function ThreeMFLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.availableExtensions = [];\n};\n\nThreeMFLoader.prototype = {\n\n\tconstructor: ThreeMFLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tvar scope = this;\n\n\t\tfunction loadDocument(data) {\n\n\t\t\tvar zip = null;\n\t\t\tvar file = null;\n\n\t\t\tvar relsName;\n\t\t\tvar modelPartNames = [];\n\t\t\tvar printTicketPartNames = [];\n\t\t\tvar texturesPartNames = [];\n\t\t\tvar otherPartNames = [];\n\n\t\t\tvar rels;\n\t\t\tvar modelParts = {};\n\t\t\tvar printTicketParts = {};\n\t\t\tvar texturesParts = {};\n\t\t\tvar otherParts = {};\n\n\t\t\ttry {\n\n\t\t\t\tzip = new JSZip(data); // eslint-disable-line no-undef\n\t\t\t} catch (e) {\n\n\t\t\t\tif (e instanceof ReferenceError) {\n\n\t\t\t\t\tconsole.error('THREE.ThreeMFLoader: jszip missing and file is compressed.');\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (file in zip.files) {\n\n\t\t\t\tif (file.match(/\\.rels$/)) {\n\n\t\t\t\t\trelsName = file;\n\t\t\t\t} else if (file.match(/^3D\\/.*\\.model$/)) {\n\n\t\t\t\t\tmodelPartNames.push(file);\n\t\t\t\t} else if (file.match(/^3D\\/Metadata\\/.*\\.xml$/)) {\n\n\t\t\t\t\tprintTicketPartNames.push(file);\n\t\t\t\t} else if (file.match(/^3D\\/Textures\\/.*/)) {\n\n\t\t\t\t\ttexturesPartNames.push(file);\n\t\t\t\t} else if (file.match(/^3D\\/Other\\/.*/)) {\n\n\t\t\t\t\totherPartNames.push(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar relsView = new Uint8Array(zip.file(relsName).asArrayBuffer());\n\t\t\tvar relsFileText = THREE.LoaderUtils.decodeText(relsView);\n\t\t\trels = parseRelsXml(relsFileText);\n\n\t\t\tfor (var i = 0; i < modelPartNames.length; i++) {\n\n\t\t\t\tvar modelPart = modelPartNames[i];\n\t\t\t\tvar view = new Uint8Array(zip.file(modelPart).asArrayBuffer());\n\n\t\t\t\tvar fileText = THREE.LoaderUtils.decodeText(view);\n\t\t\t\tvar xmlData = new DOMParser().parseFromString(fileText, 'application/xml');\n\n\t\t\t\tif (xmlData.documentElement.nodeName.toLowerCase() !== 'model') {\n\n\t\t\t\t\tconsole.error('THREE.ThreeMFLoader: Error loading 3MF - no 3MF document found: ', modelPart);\n\t\t\t\t}\n\n\t\t\t\tvar modelNode = xmlData.querySelector('model');\n\t\t\t\tvar extensions = {};\n\n\t\t\t\tfor (var i = 0; i < modelNode.attributes.length; i++) {\n\n\t\t\t\t\tvar attr = modelNode.attributes[i];\n\t\t\t\t\tif (attr.name.match(/^xmlns:(.+)$/)) {\n\n\t\t\t\t\t\textensions[attr.value] = RegExp.$1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar modelData = parseModelNode(modelNode);\n\t\t\t\tmodelData['xml'] = modelNode;\n\n\t\t\t\tif (0 < Object.keys(extensions).length) {\n\n\t\t\t\t\tmodelData['extensions'] = extensions;\n\t\t\t\t}\n\n\t\t\t\tmodelParts[modelPart] = modelData;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < texturesPartNames.length; i++) {\n\n\t\t\t\tvar texturesPartName = texturesPartNames[i];\n\t\t\t\ttexturesParts[texturesPartName] = zip.file(texturesPartName).asBinary();\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\trels: rels,\n\t\t\t\tmodel: modelParts,\n\t\t\t\tprintTicket: printTicketParts,\n\t\t\t\ttexture: texturesParts,\n\t\t\t\tother: otherParts\n\t\t\t};\n\t\t}\n\n\t\tfunction parseRelsXml(relsFileText) {\n\n\t\t\tvar relsXmlData = new DOMParser().parseFromString(relsFileText, 'application/xml');\n\t\t\tvar relsNode = relsXmlData.querySelector('Relationship');\n\t\t\tvar target = relsNode.getAttribute('Target');\n\t\t\tvar id = relsNode.getAttribute('Id');\n\t\t\tvar type = relsNode.getAttribute('Type');\n\n\t\t\treturn {\n\t\t\t\ttarget: target,\n\t\t\t\tid: id,\n\t\t\t\ttype: type\n\t\t\t};\n\t\t}\n\n\t\tfunction parseMetadataNodes(metadataNodes) {\n\n\t\t\tvar metadataData = {};\n\n\t\t\tfor (var i = 0; i < metadataNodes.length; i++) {\n\n\t\t\t\tvar metadataNode = metadataNodes[i];\n\t\t\t\tvar name = metadataNode.getAttribute('name');\n\t\t\t\tvar validNames = ['Title', 'Designer', 'Description', 'Copyright', 'LicenseTerms', 'Rating', 'CreationDate', 'ModificationDate'];\n\n\t\t\t\tif (0 <= validNames.indexOf(name)) {\n\n\t\t\t\t\tmetadataData[name] = metadataNode.textContent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn metadataData;\n\t\t}\n\n\t\tfunction parseBasematerialsNode(basematerialsNode) {}\n\n\t\tfunction parseMeshNode(meshNode, extensions) {\n\n\t\t\tvar meshData = {};\n\n\t\t\tvar vertices = [];\n\t\t\tvar vertexNodes = meshNode.querySelectorAll('vertices vertex');\n\n\t\t\tfor (var i = 0; i < vertexNodes.length; i++) {\n\n\t\t\t\tvar vertexNode = vertexNodes[i];\n\t\t\t\tvar x = vertexNode.getAttribute('x');\n\t\t\t\tvar y = vertexNode.getAttribute('y');\n\t\t\t\tvar z = vertexNode.getAttribute('z');\n\n\t\t\t\tvertices.push(parseFloat(x), parseFloat(y), parseFloat(z));\n\t\t\t}\n\n\t\t\tmeshData['vertices'] = new Float32Array(vertices.length);\n\n\t\t\tfor (var i = 0; i < vertices.length; i++) {\n\n\t\t\t\tmeshData['vertices'][i] = vertices[i];\n\t\t\t}\n\n\t\t\tvar triangleProperties = [];\n\t\t\tvar triangles = [];\n\t\t\tvar triangleNodes = meshNode.querySelectorAll('triangles triangle');\n\n\t\t\tfor (var i = 0; i < triangleNodes.length; i++) {\n\n\t\t\t\tvar triangleNode = triangleNodes[i];\n\t\t\t\tvar v1 = triangleNode.getAttribute('v1');\n\t\t\t\tvar v2 = triangleNode.getAttribute('v2');\n\t\t\t\tvar v3 = triangleNode.getAttribute('v3');\n\t\t\t\tvar p1 = triangleNode.getAttribute('p1');\n\t\t\t\tvar p2 = triangleNode.getAttribute('p2');\n\t\t\t\tvar p3 = triangleNode.getAttribute('p3');\n\t\t\t\tvar pid = triangleNode.getAttribute('pid');\n\n\t\t\t\ttriangles.push(parseInt(v1, 10), parseInt(v2, 10), parseInt(v3, 10));\n\n\t\t\t\tvar triangleProperty = {};\n\n\t\t\t\tif (p1) {\n\n\t\t\t\t\ttriangleProperty['p1'] = parseInt(p1, 10);\n\t\t\t\t}\n\n\t\t\t\tif (p2) {\n\n\t\t\t\t\ttriangleProperty['p2'] = parseInt(p2, 10);\n\t\t\t\t}\n\n\t\t\t\tif (p3) {\n\n\t\t\t\t\ttriangleProperty['p3'] = parseInt(p3, 10);\n\t\t\t\t}\n\n\t\t\t\tif (pid) {\n\n\t\t\t\t\ttriangleProperty['pid'] = pid;\n\t\t\t\t}\n\n\t\t\t\tif (0 < Object.keys(triangleProperty).length) {\n\n\t\t\t\t\ttriangleProperties.push(triangleProperty);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmeshData['triangleProperties'] = triangleProperties;\n\t\t\tmeshData['triangles'] = new Uint32Array(triangles.length);\n\n\t\t\tfor (var i = 0; i < triangles.length; i++) {\n\n\t\t\t\tmeshData['triangles'][i] = triangles[i];\n\t\t\t}\n\n\t\t\treturn meshData;\n\t\t}\n\n\t\tfunction parseComponentsNode(componentsNode) {}\n\n\t\tfunction parseObjectNode(objectNode) {\n\n\t\t\tvar objectData = {\n\t\t\t\ttype: objectNode.getAttribute('type')\n\t\t\t};\n\n\t\t\tvar id = objectNode.getAttribute('id');\n\n\t\t\tif (id) {\n\n\t\t\t\tobjectData['id'] = id;\n\t\t\t}\n\n\t\t\tvar pid = objectNode.getAttribute('pid');\n\n\t\t\tif (pid) {\n\n\t\t\t\tobjectData['pid'] = pid;\n\t\t\t}\n\n\t\t\tvar pindex = objectNode.getAttribute('pindex');\n\n\t\t\tif (pindex) {\n\n\t\t\t\tobjectData['pindex'] = pindex;\n\t\t\t}\n\n\t\t\tvar thumbnail = objectNode.getAttribute('thumbnail');\n\n\t\t\tif (thumbnail) {\n\n\t\t\t\tobjectData['thumbnail'] = thumbnail;\n\t\t\t}\n\n\t\t\tvar partnumber = objectNode.getAttribute('partnumber');\n\n\t\t\tif (partnumber) {\n\n\t\t\t\tobjectData['partnumber'] = partnumber;\n\t\t\t}\n\n\t\t\tvar name = objectNode.getAttribute('name');\n\n\t\t\tif (name) {\n\n\t\t\t\tobjectData['name'] = name;\n\t\t\t}\n\n\t\t\tvar meshNode = objectNode.querySelector('mesh');\n\n\t\t\tif (meshNode) {\n\n\t\t\t\tobjectData['mesh'] = parseMeshNode(meshNode);\n\t\t\t}\n\n\t\t\tvar componentsNode = objectNode.querySelector('components');\n\n\t\t\tif (componentsNode) {\n\n\t\t\t\tobjectData['components'] = parseComponentsNode(componentsNode);\n\t\t\t}\n\n\t\t\treturn objectData;\n\t\t}\n\n\t\tfunction parseResourcesNode(resourcesNode) {\n\n\t\t\tvar resourcesData = {};\n\t\t\tvar basematerialsNode = resourcesNode.querySelector('basematerials');\n\n\t\t\tif (basematerialsNode) {\n\n\t\t\t\tresourcesData['basematerial'] = parseBasematerialsNode(basematerialsNode);\n\t\t\t}\n\n\t\t\tresourcesData['object'] = {};\n\t\t\tvar objectNodes = resourcesNode.querySelectorAll('object');\n\n\t\t\tfor (var i = 0; i < objectNodes.length; i++) {\n\n\t\t\t\tvar objectNode = objectNodes[i];\n\t\t\t\tvar objectData = parseObjectNode(objectNode);\n\t\t\t\tresourcesData['object'][objectData['id']] = objectData;\n\t\t\t}\n\n\t\t\treturn resourcesData;\n\t\t}\n\n\t\tfunction parseBuildNode(buildNode) {\n\n\t\t\tvar buildData = [];\n\t\t\tvar itemNodes = buildNode.querySelectorAll('item');\n\n\t\t\tfor (var i = 0; i < itemNodes.length; i++) {\n\n\t\t\t\tvar itemNode = itemNodes[i];\n\t\t\t\tvar buildItem = {\n\t\t\t\t\tobjectid: itemNode.getAttribute('objectid')\n\t\t\t\t};\n\t\t\t\tvar transform = itemNode.getAttribute('transform');\n\n\t\t\t\tif (transform) {\n\n\t\t\t\t\tvar t = [];\n\t\t\t\t\ttransform.split(' ').forEach(function (s) {\n\n\t\t\t\t\t\tt.push(parseFloat(s));\n\t\t\t\t\t});\n\t\t\t\t\tvar mat4 = new THREE.Matrix4();\n\t\t\t\t\tbuildItem['transform'] = mat4.set(t[0], t[3], t[6], t[9], t[1], t[4], t[7], t[10], t[2], t[5], t[8], t[11], 0.0, 0.0, 0.0, 1.0);\n\t\t\t\t}\n\n\t\t\t\tbuildData.push(buildItem);\n\t\t\t}\n\n\t\t\treturn buildData;\n\t\t}\n\n\t\tfunction parseModelNode(modelNode) {\n\n\t\t\tvar modelData = { unit: modelNode.getAttribute('unit') || 'millimeter' };\n\t\t\tvar metadataNodes = modelNode.querySelectorAll('metadata');\n\n\t\t\tif (metadataNodes) {\n\n\t\t\t\tmodelData['metadata'] = parseMetadataNodes(metadataNodes);\n\t\t\t}\n\n\t\t\tvar resourcesNode = modelNode.querySelector('resources');\n\n\t\t\tif (resourcesNode) {\n\n\t\t\t\tmodelData['resources'] = parseResourcesNode(resourcesNode);\n\t\t\t}\n\n\t\t\tvar buildNode = modelNode.querySelector('build');\n\n\t\t\tif (buildNode) {\n\n\t\t\t\tmodelData['build'] = parseBuildNode(buildNode);\n\t\t\t}\n\n\t\t\treturn modelData;\n\t\t}\n\n\t\tfunction buildMesh(meshData, data3mf) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tgeometry.setIndex(new THREE.BufferAttribute(meshData['triangles'], 1));\n\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(meshData['vertices'], 3));\n\n\t\t\tif (meshData['colors']) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.BufferAttribute(meshData['colors'], 3));\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\tvar materialOpts = {\n\t\t\t\tflatShading: true\n\t\t\t};\n\n\t\t\tif (meshData['colors'] && 0 < meshData['colors'].length) {\n\n\t\t\t\tmaterialOpts['vertexColors'] = THREE.VertexColors;\n\t\t\t} else {\n\n\t\t\t\tmaterialOpts['color'] = 0xaaaaff;\n\t\t\t}\n\n\t\t\tvar material = new THREE.MeshPhongMaterial(materialOpts);\n\t\t\treturn new THREE.Mesh(geometry, material);\n\t\t}\n\n\t\tfunction applyExtensions(extensions, meshData, modelXml, data3mf) {\n\n\t\t\tif (!extensions) {\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar availableExtensions = [];\n\t\t\tvar keys = Object.keys(extensions);\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\n\t\t\t\tvar ns = keys[i];\n\n\t\t\t\tfor (var j = 0; j < scope.availableExtensions.length; j++) {\n\n\t\t\t\t\tvar extension = scope.availableExtensions[j];\n\n\t\t\t\t\tif (extension.ns === ns) {\n\n\t\t\t\t\t\tavailableExtensions.push(extension);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < availableExtensions.length; i++) {\n\n\t\t\t\tvar extension = availableExtensions[i];\n\t\t\t\textension.apply(modelXml, extensions[extension['ns']], meshData);\n\t\t\t}\n\t\t}\n\n\t\tfunction buildMeshes(data3mf) {\n\n\t\t\tvar modelsData = data3mf.model;\n\t\t\tvar meshes = {};\n\t\t\tvar modelsKeys = Object.keys(modelsData);\n\n\t\t\tfor (var i = 0; i < modelsKeys.length; i++) {\n\n\t\t\t\tvar modelsKey = modelsKeys[i];\n\t\t\t\tvar modelData = modelsData[modelsKey];\n\t\t\t\tvar modelXml = modelData['xml'];\n\t\t\t\tvar extensions = modelData['extensions'];\n\n\t\t\t\tvar objectIds = Object.keys(modelData['resources']['object']);\n\n\t\t\t\tfor (var j = 0; j < objectIds.length; j++) {\n\n\t\t\t\t\tvar objectId = objectIds[j];\n\t\t\t\t\tvar objectData = modelData['resources']['object'][objectId];\n\t\t\t\t\tvar meshData = objectData['mesh'];\n\t\t\t\t\tapplyExtensions(extensions, meshData, modelXml, data3mf);\n\t\t\t\t\tmeshes[objectId] = buildMesh(meshData, data3mf);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn meshes;\n\t\t}\n\n\t\tfunction build(meshes, refs, data3mf) {\n\n\t\t\tvar group = new THREE.Group();\n\t\t\tvar buildData = data3mf.model[refs['target'].substring(1)]['build'];\n\n\t\t\tfor (var i = 0; i < buildData.length; i++) {\n\n\t\t\t\tvar buildItem = buildData[i];\n\t\t\t\tvar mesh = meshes[buildItem['objectid']];\n\n\t\t\t\tif (buildItem['transform']) {\n\n\t\t\t\t\tmesh.geometry.applyMatrix(buildItem['transform']);\n\t\t\t\t}\n\n\t\t\t\tgroup.add(mesh);\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\n\t\tvar data3mf = loadDocument(data);\n\t\tvar meshes = buildMeshes(data3mf);\n\n\t\treturn build(meshes, data3mf['rels'], data3mf);\n\t},\n\n\taddExtension: function addExtension(extension) {\n\n\t\tthis.availableExtensions.push(extension);\n\t}\n\n};\n\nexports.default = ThreeMFLoader;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author tamarintech / https://tamarintech.com\n *\n * Description: Early release of an AMF Loader following the pattern of the\n * example loaders in the three.js project.\n *\n * More information about the AMF format: http://amf.wikispaces.com\n *\n * Usage:\n *\tvar loader = new AMFLoader();\n *\tloader.load('/path/to/project.amf', function(objecttree) {\n *\t\tscene.add(objecttree);\n *\t});\n *\n * Materials now supported, material colors supported\n * Zip support, requires jszip\n * No constellation support (yet)!\n *\n */\n\nvar AMFLoader = function AMFLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nAMFLoader.prototype = {\n\n\tconstructor: AMFLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction loadDocument(data) {\n\n\t\t\tvar view = new DataView(data);\n\t\t\tvar magic = String.fromCharCode(view.getUint8(0), view.getUint8(1));\n\n\t\t\tif (magic === 'PK') {\n\n\t\t\t\tvar zip = null;\n\t\t\t\tvar file = null;\n\n\t\t\t\tconsole.log('THREE.AMFLoader: Loading Zip');\n\n\t\t\t\ttry {\n\n\t\t\t\t\tzip = new JSZip(data); // eslint-disable-line no-undef\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tif (e instanceof ReferenceError) {\n\n\t\t\t\t\t\tconsole.log('THREE.AMFLoader: jszip missing and file is compressed.');\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (file in zip.files) {\n\n\t\t\t\t\tif (file.toLowerCase().substr(-4) === '.amf') {\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconsole.log('THREE.AMFLoader: Trying to load file asset: ' + file);\n\t\t\t\tview = new DataView(zip.file(file).asArrayBuffer());\n\t\t\t}\n\n\t\t\tvar fileText = THREE.LoaderUtils.decodeText(view);\n\t\t\tvar xmlData = new DOMParser().parseFromString(fileText, 'application/xml');\n\n\t\t\tif (xmlData.documentElement.nodeName.toLowerCase() !== 'amf') {\n\n\t\t\t\tconsole.log('THREE.AMFLoader: Error loading AMF - no AMF document found.');\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn xmlData;\n\t\t}\n\n\t\tfunction loadDocumentScale(node) {\n\n\t\t\tvar scale = 1.0;\n\t\t\tvar unit = 'millimeter';\n\n\t\t\tif (node.documentElement.attributes.unit !== undefined) {\n\n\t\t\t\tunit = node.documentElement.attributes.unit.value.toLowerCase();\n\t\t\t}\n\n\t\t\tvar scaleUnits = {\n\t\t\t\tmillimeter: 1.0,\n\t\t\t\tinch: 25.4,\n\t\t\t\tfeet: 304.8,\n\t\t\t\tmeter: 1000.0,\n\t\t\t\tmicron: 0.001\n\t\t\t};\n\n\t\t\tif (scaleUnits[unit] !== undefined) {\n\n\t\t\t\tscale = scaleUnits[unit];\n\t\t\t}\n\n\t\t\tconsole.log('THREE.AMFLoader: Unit scale: ' + scale);\n\t\t\treturn scale;\n\t\t}\n\n\t\tfunction loadMaterials(node) {\n\n\t\t\tvar matName = 'AMF Material';\n\t\t\tvar matId = node.attributes.id.textContent;\n\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\tvar loadedMaterial = null;\n\n\t\t\tfor (var i = 0; i < node.childNodes.length; i++) {\n\n\t\t\t\tvar matChildEl = node.childNodes[i];\n\n\t\t\t\tif (matChildEl.nodeName === 'metadata' && matChildEl.attributes.type !== undefined) {\n\n\t\t\t\t\tif (matChildEl.attributes.type.value === 'name') {\n\n\t\t\t\t\t\tmatName = matChildEl.textContent;\n\t\t\t\t\t}\n\t\t\t\t} else if (matChildEl.nodeName === 'color') {\n\n\t\t\t\t\tcolor = loadColor(matChildEl);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tloadedMaterial = new THREE.MeshPhongMaterial({\n\t\t\t\tflatShading: true,\n\t\t\t\tcolor: new THREE.Color(color.r, color.g, color.b),\n\t\t\t\tname: matName\n\t\t\t});\n\n\t\t\tif (color.a !== 1.0) {\n\n\t\t\t\tloadedMaterial.transparent = true;\n\t\t\t\tloadedMaterial.opacity = color.a;\n\t\t\t}\n\n\t\t\treturn { id: matId, material: loadedMaterial };\n\t\t}\n\n\t\tfunction loadColor(node) {\n\n\t\t\tvar color = { r: 1.0, g: 1.0, b: 1.0, a: 1.0 };\n\n\t\t\tfor (var i = 0; i < node.childNodes.length; i++) {\n\n\t\t\t\tvar matColor = node.childNodes[i];\n\n\t\t\t\tif (matColor.nodeName === 'r') {\n\n\t\t\t\t\tcolor.r = matColor.textContent;\n\t\t\t\t} else if (matColor.nodeName === 'g') {\n\n\t\t\t\t\tcolor.g = matColor.textContent;\n\t\t\t\t} else if (matColor.nodeName === 'b') {\n\n\t\t\t\t\tcolor.b = matColor.textContent;\n\t\t\t\t} else if (matColor.nodeName === 'a') {\n\n\t\t\t\t\tcolor.a = matColor.textContent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn color;\n\t\t}\n\n\t\tfunction loadMeshVolume(node) {\n\n\t\t\tvar volume = { name: '', triangles: [], materialid: null };\n\n\t\t\tvar currVolumeNode = node.firstElementChild;\n\n\t\t\tif (node.attributes.materialid !== undefined) {\n\n\t\t\t\tvolume.materialId = node.attributes.materialid.nodeValue;\n\t\t\t}\n\n\t\t\twhile (currVolumeNode) {\n\n\t\t\t\tif (currVolumeNode.nodeName === 'metadata') {\n\n\t\t\t\t\tif (currVolumeNode.attributes.type !== undefined) {\n\n\t\t\t\t\t\tif (currVolumeNode.attributes.type.value === 'name') {\n\n\t\t\t\t\t\t\tvolume.name = currVolumeNode.textContent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (currVolumeNode.nodeName === 'triangle') {\n\n\t\t\t\t\tvar v1 = currVolumeNode.getElementsByTagName('v1')[0].textContent;\n\t\t\t\t\tvar v2 = currVolumeNode.getElementsByTagName('v2')[0].textContent;\n\t\t\t\t\tvar v3 = currVolumeNode.getElementsByTagName('v3')[0].textContent;\n\n\t\t\t\t\tvolume.triangles.push(v1, v2, v3);\n\t\t\t\t}\n\n\t\t\t\tcurrVolumeNode = currVolumeNode.nextElementSibling;\n\t\t\t}\n\n\t\t\treturn volume;\n\t\t}\n\n\t\tfunction loadMeshVertices(node) {\n\n\t\t\tvar vertArray = [];\n\t\t\tvar normalArray = [];\n\t\t\tvar currVerticesNode = node.firstElementChild;\n\n\t\t\twhile (currVerticesNode) {\n\n\t\t\t\tif (currVerticesNode.nodeName === 'vertex') {\n\n\t\t\t\t\tvar vNode = currVerticesNode.firstElementChild;\n\n\t\t\t\t\twhile (vNode) {\n\n\t\t\t\t\t\tif (vNode.nodeName === 'coordinates') {\n\n\t\t\t\t\t\t\tvar x = vNode.getElementsByTagName('x')[0].textContent;\n\t\t\t\t\t\t\tvar y = vNode.getElementsByTagName('y')[0].textContent;\n\t\t\t\t\t\t\tvar z = vNode.getElementsByTagName('z')[0].textContent;\n\n\t\t\t\t\t\t\tvertArray.push(x, y, z);\n\t\t\t\t\t\t} else if (vNode.nodeName === 'normal') {\n\n\t\t\t\t\t\t\tvar nx = vNode.getElementsByTagName('nx')[0].textContent;\n\t\t\t\t\t\t\tvar ny = vNode.getElementsByTagName('ny')[0].textContent;\n\t\t\t\t\t\t\tvar nz = vNode.getElementsByTagName('nz')[0].textContent;\n\n\t\t\t\t\t\t\tnormalArray.push(nx, ny, nz);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvNode = vNode.nextElementSibling;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrVerticesNode = currVerticesNode.nextElementSibling;\n\t\t\t}\n\n\t\t\treturn { 'vertices': vertArray, 'normals': normalArray };\n\t\t}\n\n\t\tfunction loadObject(node) {\n\n\t\t\tvar objId = node.attributes.id.textContent;\n\t\t\tvar loadedObject = { name: 'amfobject', meshes: [] };\n\t\t\tvar currColor = null;\n\t\t\tvar currObjNode = node.firstElementChild;\n\n\t\t\twhile (currObjNode) {\n\n\t\t\t\tif (currObjNode.nodeName === 'metadata') {\n\n\t\t\t\t\tif (currObjNode.attributes.type !== undefined) {\n\n\t\t\t\t\t\tif (currObjNode.attributes.type.value === 'name') {\n\n\t\t\t\t\t\t\tloadedObject.name = currObjNode.textContent;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (currObjNode.nodeName === 'color') {\n\n\t\t\t\t\tcurrColor = loadColor(currObjNode);\n\t\t\t\t} else if (currObjNode.nodeName === 'mesh') {\n\n\t\t\t\t\tvar currMeshNode = currObjNode.firstElementChild;\n\t\t\t\t\tvar mesh = { vertices: [], normals: [], volumes: [], color: currColor };\n\n\t\t\t\t\twhile (currMeshNode) {\n\n\t\t\t\t\t\tif (currMeshNode.nodeName === 'vertices') {\n\n\t\t\t\t\t\t\tvar loadedVertices = loadMeshVertices(currMeshNode);\n\n\t\t\t\t\t\t\tmesh.normals = mesh.normals.concat(loadedVertices.normals);\n\t\t\t\t\t\t\tmesh.vertices = mesh.vertices.concat(loadedVertices.vertices);\n\t\t\t\t\t\t} else if (currMeshNode.nodeName === 'volume') {\n\n\t\t\t\t\t\t\tmesh.volumes.push(loadMeshVolume(currMeshNode));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrMeshNode = currMeshNode.nextElementSibling;\n\t\t\t\t\t}\n\n\t\t\t\t\tloadedObject.meshes.push(mesh);\n\t\t\t\t}\n\n\t\t\t\tcurrObjNode = currObjNode.nextElementSibling;\n\t\t\t}\n\n\t\t\treturn { 'id': objId, 'obj': loadedObject };\n\t\t}\n\n\t\tvar xmlData = loadDocument(data);\n\t\tvar amfName = '';\n\t\tvar amfAuthor = '';\n\t\tvar amfScale = loadDocumentScale(xmlData);\n\t\tvar amfMaterials = {};\n\t\tvar amfObjects = {};\n\t\tvar childNodes = xmlData.documentElement.childNodes;\n\n\t\tvar i, j;\n\n\t\tfor (i = 0; i < childNodes.length; i++) {\n\n\t\t\tvar child = childNodes[i];\n\n\t\t\tif (child.nodeName === 'metadata') {\n\n\t\t\t\tif (child.attributes.type !== undefined) {\n\n\t\t\t\t\tif (child.attributes.type.value === 'name') {\n\n\t\t\t\t\t\tamfName = child.textContent;\n\t\t\t\t\t} else if (child.attributes.type.value === 'author') {\n\n\t\t\t\t\t\tamfAuthor = child.textContent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (child.nodeName === 'material') {\n\n\t\t\t\tvar loadedMaterial = loadMaterials(child);\n\n\t\t\t\tamfMaterials[loadedMaterial.id] = loadedMaterial.material;\n\t\t\t} else if (child.nodeName === 'object') {\n\n\t\t\t\tvar loadedObject = loadObject(child);\n\n\t\t\t\tamfObjects[loadedObject.id] = loadedObject.obj;\n\t\t\t}\n\t\t}\n\n\t\tvar sceneObject = new THREE.Group();\n\t\tvar defaultMaterial = new THREE.MeshPhongMaterial({ color: 0xaaaaff, flatShading: true });\n\n\t\tsceneObject.name = amfName;\n\t\tsceneObject.userData.author = amfAuthor;\n\t\tsceneObject.userData.loader = 'AMF';\n\n\t\tfor (var id in amfObjects) {\n\n\t\t\tvar part = amfObjects[id];\n\t\t\tvar meshes = part.meshes;\n\t\t\tvar newObject = new THREE.Group();\n\t\t\tnewObject.name = part.name || '';\n\n\t\t\tfor (i = 0; i < meshes.length; i++) {\n\n\t\t\t\tvar objDefaultMaterial = defaultMaterial;\n\t\t\t\tvar mesh = meshes[i];\n\t\t\t\tvar vertices = new THREE.Float32BufferAttribute(mesh.vertices, 3);\n\t\t\t\tvar normals = null;\n\n\t\t\t\tif (mesh.normals.length) {\n\n\t\t\t\t\tnormals = new THREE.Float32BufferAttribute(mesh.normals, 3);\n\t\t\t\t}\n\n\t\t\t\tif (mesh.color) {\n\n\t\t\t\t\tvar color = mesh.color;\n\n\t\t\t\t\tobjDefaultMaterial = defaultMaterial.clone();\n\t\t\t\t\tobjDefaultMaterial.color = new THREE.Color(color.r, color.g, color.b);\n\n\t\t\t\t\tif (color.a !== 1.0) {\n\n\t\t\t\t\t\tobjDefaultMaterial.transparent = true;\n\t\t\t\t\t\tobjDefaultMaterial.opacity = color.a;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar volumes = mesh.volumes;\n\n\t\t\t\tfor (j = 0; j < volumes.length; j++) {\n\n\t\t\t\t\tvar volume = volumes[j];\n\t\t\t\t\tvar newGeometry = new THREE.BufferGeometry();\n\t\t\t\t\tvar material = objDefaultMaterial;\n\n\t\t\t\t\tnewGeometry.setIndex(volume.triangles);\n\t\t\t\t\tnewGeometry.addAttribute('position', vertices.clone());\n\n\t\t\t\t\tif (normals) {\n\n\t\t\t\t\t\tnewGeometry.addAttribute('normal', normals.clone());\n\t\t\t\t\t}\n\n\t\t\t\t\tif (amfMaterials[volume.materialId] !== undefined) {\n\n\t\t\t\t\t\tmaterial = amfMaterials[volume.materialId];\n\t\t\t\t\t}\n\n\t\t\t\t\tnewGeometry.scale(amfScale, amfScale, amfScale);\n\t\t\t\t\tnewObject.add(new THREE.Mesh(newGeometry, material.clone()));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsceneObject.add(newObject);\n\t\t}\n\n\t\treturn sceneObject;\n\t}\n\n};\n\nexports.default = AMFLoader;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Alexander Gessler / http://www.greentoken.de/\n * https://github.com/acgessler\n *\n * Loader for models imported with Open Asset Import Library (http://assimp.sf.net)\n * through assimp2json (https://github.com/acgessler/assimp2json).\n *\n * Supports any input format that assimp supports, including 3ds, obj, dae, blend,\n * fbx, x, ms3d, lwo (and many more).\n *\n * See webgl_loader_assimp2json example.\n */\n\nvar AssimpJSONLoader = function AssimpJSONLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nAssimpJSONLoader.prototype = {\n\n\tconstructor: AssimpJSONLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = THREE.LoaderUtils.extractUrlBase(url);\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tvar json = JSON.parse(text);\n\t\t\tvar metadata = json.__metadata__;\n\n\t\t\t// check if __metadata__ meta header is present\n\t\t\t// this header is used to disambiguate between different JSON-based file formats\n\n\t\t\tif (typeof metadata !== 'undefined') {\n\n\t\t\t\t// check if assimp2json at all\n\n\t\t\t\tif (metadata.format !== 'assimp2json') {\n\n\t\t\t\t\tonError('THREE.AssimpJSONLoader: Not an assimp2json scene.');\n\t\t\t\t\treturn;\n\n\t\t\t\t\t// check major format version\n\t\t\t\t} else if (metadata.version < 100 && metadata.version >= 200) {\n\n\t\t\t\t\tonError('THREE.AssimpJSONLoader: Unsupported assimp2json file format version.');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tonLoad(scope.parse(json, path));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(json, path) {\n\n\t\tfunction parseList(json, handler) {\n\n\t\t\tvar meshes = new Array(json.length);\n\n\t\t\tfor (var i = 0; i < json.length; ++i) {\n\n\t\t\t\tmeshes[i] = handler.call(this, json[i]);\n\t\t\t}\n\n\t\t\treturn meshes;\n\t\t}\n\n\t\tfunction parseMesh(json) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar i, l, face;\n\n\t\t\tvar indices = [];\n\n\t\t\tvar vertices = json.vertices || [];\n\t\t\tvar normals = json.normals || [];\n\t\t\tvar uvs = json.texturecoords || [];\n\t\t\tvar colors = json.colors || [];\n\n\t\t\tuvs = uvs[0] || []; // only support for a single set of uvs\n\n\t\t\tfor (i = 0, l = json.faces.length; i < l; i++) {\n\n\t\t\t\tface = json.faces[i];\n\t\t\t\tindices.push(face[0], face[1], face[2]);\n\t\t\t}\n\n\t\t\tgeometry.setIndex(indices);\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n\t\t\tif (normals.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n\t\t\t}\n\n\t\t\tif (uvs.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\t\t\t}\n\n\t\t\tif (colors.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseMaterial(json) {\n\n\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\tfor (var i in json.properties) {\n\n\t\t\t\tvar property = json.properties[i];\n\t\t\t\tvar key = property.key;\n\t\t\t\tvar value = property.value;\n\n\t\t\t\tswitch (key) {\n\n\t\t\t\t\tcase '$tex.file':\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tvar semantic = property.semantic;\n\n\t\t\t\t\t\t\t// prop.semantic gives the type of the texture\n\t\t\t\t\t\t\t// 1: diffuse\n\t\t\t\t\t\t\t// 2: specular mao\n\t\t\t\t\t\t\t// 5: height map (bumps)\n\t\t\t\t\t\t\t// 6: normal map\n\t\t\t\t\t\t\t// more values (i.e. emissive, environment) are known by assimp and may be relevant\n\n\t\t\t\t\t\t\tif (semantic === 1 || semantic === 2 || semantic === 5 || semantic === 6) {\n\n\t\t\t\t\t\t\t\tvar keyname;\n\n\t\t\t\t\t\t\t\tswitch (semantic) {\n\n\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'map';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'specularMap';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'bumpMap';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\t\t\t\tkeyname = 'normalMap';\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar texture = textureLoader.load(value);\n\n\t\t\t\t\t\t\t\t// TODO: read texture settings from assimp.\n\t\t\t\t\t\t\t\t// Wrapping is the default, though.\n\n\t\t\t\t\t\t\t\ttexture.wrapS = texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t\t\t\t\tmaterial[keyname] = texture;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcase '?mat.name':\n\t\t\t\t\t\tmaterial.name = value;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$clr.diffuse':\n\t\t\t\t\t\tmaterial.color.fromArray(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$clr.specular':\n\t\t\t\t\t\tmaterial.specular.fromArray(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$clr.emissive':\n\t\t\t\t\t\tmaterial.emissive.fromArray(value);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$mat.shininess':\n\t\t\t\t\t\tmaterial.shininess = value;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$mat.shadingm':\n\t\t\t\t\t\t// aiShadingMode_Flat\n\t\t\t\t\t\tmaterial.flatShading = value === 1 ? true : false;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '$mat.opacity':\n\t\t\t\t\t\tif (value < 1) {\n\t\t\t\t\t\t\tmaterial.opacity = value;\n\t\t\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction parseObject(json, node, meshes, materials) {\n\n\t\t\tvar obj = new THREE.Object3D(),\n\t\t\t    i,\n\t\t\t    idx;\n\n\t\t\tobj.name = node.name || '';\n\t\t\tobj.matrix = new THREE.Matrix4().fromArray(node.transformation).transpose();\n\t\t\tobj.matrix.decompose(obj.position, obj.quaternion, obj.scale);\n\n\t\t\tfor (i = 0; node.meshes && i < node.meshes.length; i++) {\n\n\t\t\t\tidx = node.meshes[i];\n\t\t\t\tobj.add(new THREE.Mesh(meshes[idx], materials[json.meshes[idx].materialindex]));\n\t\t\t}\n\n\t\t\tfor (i = 0; node.children && i < node.children.length; i++) {\n\n\t\t\t\tobj.add(parseObject(json, node.children[i], meshes, materials));\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}\n\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setPath(path).setCrossOrigin(this.crossOrigin);\n\n\t\tvar meshes = parseList(json.meshes, parseMesh);\n\t\tvar materials = parseList(json.materials, parseMaterial);\n\t\treturn parseObject(json, json.rootnode, meshes, materials);\n\t}\n\n};\n\nexports.default = AssimpJSONLoader;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Virtulous / https://virtulo.us/\n */\n\nvar AssimpLoader = function AssimpLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nAssimpLoader.prototype = {\n\n\tconstructor: AssimpLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = THREE.LoaderUtils.extractUrlBase(url);\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer, path));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(buffer, path) {\n\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setPath(path).setCrossOrigin(this.crossOrigin);\n\n\t\tvar Virtulous = {};\n\n\t\tVirtulous.KeyFrame = function (time, matrix) {\n\n\t\t\tthis.time = time;\n\t\t\tthis.matrix = matrix.clone();\n\t\t\tthis.position = new THREE.Vector3();\n\t\t\tthis.quaternion = new THREE.Quaternion();\n\t\t\tthis.scale = new THREE.Vector3(1, 1, 1);\n\t\t\tthis.matrix.decompose(this.position, this.quaternion, this.scale);\n\t\t\tthis.clone = function () {\n\n\t\t\t\tvar n = new Virtulous.KeyFrame(this.time, this.matrix);\n\t\t\t\treturn n;\n\t\t\t};\n\t\t\tthis.lerp = function (nextKey, time) {\n\n\t\t\t\ttime -= this.time;\n\t\t\t\tvar dist = nextKey.time - this.time;\n\t\t\t\tvar l = time / dist;\n\t\t\t\tvar l2 = 1 - l;\n\t\t\t\tvar keypos = this.position;\n\t\t\t\tvar keyrot = this.quaternion;\n\t\t\t\t//      var keyscl =  key.parentspaceScl || key.scl;\n\t\t\t\tvar key2pos = nextKey.position;\n\t\t\t\tvar key2rot = nextKey.quaternion;\n\t\t\t\t//  var key2scl =  key2.parentspaceScl || key2.scl;\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n\t\t\t\tVirtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l;\n\t\t\t\t//     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n\t\t\t\t//     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n\t\t\t\t//     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\t\t\t\tVirtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n\t\t\t\tVirtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n\t\t\t\treturn Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n\t\t\t};\n\t\t};\n\n\t\tVirtulous.KeyFrame.tempAniPos = new THREE.Vector3();\n\t\tVirtulous.KeyFrame.tempAniQuat = new THREE.Quaternion();\n\t\tVirtulous.KeyFrame.tempAniScale = new THREE.Vector3(1, 1, 1);\n\t\tVirtulous.KeyFrame.tempAniMatrix = new THREE.Matrix4();\n\t\tVirtulous.KeyFrameTrack = function () {\n\n\t\t\tthis.keys = [];\n\t\t\tthis.target = null;\n\t\t\tthis.time = 0;\n\t\t\tthis.length = 0;\n\t\t\tthis._accelTable = {};\n\t\t\tthis.fps = 20;\n\t\t\tthis.addKey = function (key) {\n\n\t\t\t\tthis.keys.push(key);\n\t\t\t};\n\t\t\tthis.init = function () {\n\n\t\t\t\tthis.sortKeys();\n\n\t\t\t\tif (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n\n\t\t\t\tif (!this.fps) return;\n\n\t\t\t\tfor (var j = 0; j < this.length * this.fps; j++) {\n\n\t\t\t\t\tfor (var i = 0; i < this.keys.length; i++) {\n\n\t\t\t\t\t\tif (this.keys[i].time == j) {\n\n\t\t\t\t\t\t\tthis._accelTable[j] = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n\n\t\t\t\t\t\t\tthis._accelTable[j] = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.parseFromThree = function (data) {\n\n\t\t\t\tvar fps = data.fps;\n\t\t\t\tthis.target = data.node;\n\t\t\t\tvar track = data.hierarchy[0].keys;\n\t\t\t\tfor (var i = 0; i < track.length; i++) {\n\n\t\t\t\t\tthis.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n\t\t\t\t}\n\t\t\t\tthis.init();\n\t\t\t};\n\n\t\t\tthis.parseFromCollada = function (data) {\n\n\t\t\t\tvar track = data.keys;\n\t\t\t\tvar fps = this.fps;\n\n\t\t\t\tfor (var i = 0; i < track.length; i++) {\n\n\t\t\t\t\tthis.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n\t\t\t\t}\n\n\t\t\t\tthis.init();\n\t\t\t};\n\n\t\t\tthis.sortKeys = function () {\n\n\t\t\t\tthis.keys.sort(this.keySortFunc);\n\t\t\t};\n\n\t\t\tthis.keySortFunc = function (a, b) {\n\n\t\t\t\treturn a.time - b.time;\n\t\t\t};\n\n\t\t\tthis.clone = function () {\n\n\t\t\t\tvar t = new Virtulous.KeyFrameTrack();\n\t\t\t\tt.target = this.target;\n\t\t\t\tt.time = this.time;\n\t\t\t\tt.length = this.length;\n\n\t\t\t\tfor (var i = 0; i < this.keys.length; i++) {\n\n\t\t\t\t\tt.addKey(this.keys[i].clone());\n\t\t\t\t}\n\n\t\t\t\tt.init();\n\t\t\t\treturn t;\n\t\t\t};\n\n\t\t\tthis.reTarget = function (root, compareitor) {\n\n\t\t\t\tif (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\tthis.target = compareitor(root, this.target);\n\t\t\t};\n\n\t\t\tthis.keySearchAccel = function (time) {\n\n\t\t\t\ttime *= this.fps;\n\t\t\t\ttime = Math.floor(time);\n\t\t\t\treturn this._accelTable[time] || 0;\n\t\t\t};\n\n\t\t\tthis.setTime = function (time) {\n\n\t\t\t\ttime = Math.abs(time);\n\t\t\t\tif (this.length) time = time % this.length + .05;\n\t\t\t\tvar key0 = null;\n\t\t\t\tvar key1 = null;\n\n\t\t\t\tfor (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\n\n\t\t\t\t\tif (this.keys[i].time == time) {\n\n\t\t\t\t\t\tkey0 = this.keys[i];\n\t\t\t\t\t\tkey1 = this.keys[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n\n\t\t\t\t\t\tkey0 = this.keys[i];\n\t\t\t\t\t\tkey1 = this.keys[i + 1];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (this.keys[i].time < time && i == this.keys.length - 1) {\n\n\t\t\t\t\t\tkey0 = this.keys[i];\n\t\t\t\t\t\tkey1 = this.keys[0].clone();\n\t\t\t\t\t\tkey1.time += this.length + .05;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (key0 && key1 && key0 !== key1) {\n\n\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\tthis.target.matrix.copy(key0.lerp(key1, time));\n\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (key0 && key1 && key0 == key1) {\n\n\t\t\t\t\tthis.target.matrixAutoUpdate = false;\n\t\t\t\t\tthis.target.matrix.copy(key0.matrix);\n\t\t\t\t\tthis.target.matrixWorldNeedsUpdate = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t\tVirtulous.TrackTargetNodeNameCompare = function (root, target) {\n\n\t\t\tfunction find(node, name) {\n\n\t\t\t\tif (node.name == name) return node;\n\n\t\t\t\tfor (var i = 0; i < node.children.length; i++) {\n\n\t\t\t\t\tvar r = find(node.children[i], name);\n\t\t\t\t\tif (r) return r;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn find(root, target.name);\n\t\t};\n\n\t\tVirtulous.Animation = function () {\n\n\t\t\tthis.tracks = [];\n\t\t\tthis.length = 0;\n\n\t\t\tthis.addTrack = function (track) {\n\n\t\t\t\tthis.tracks.push(track);\n\t\t\t\tthis.length = Math.max(track.length, this.length);\n\t\t\t};\n\n\t\t\tthis.setTime = function (time) {\n\n\t\t\t\tthis.time = time;\n\n\t\t\t\tfor (var i = 0; i < this.tracks.length; i++) {\n\t\t\t\t\tthis.tracks[i].setTime(time);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.clone = function (target, compareitor) {\n\n\t\t\t\tif (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n\t\t\t\tvar n = new Virtulous.Animation();\n\t\t\t\tn.target = target;\n\t\t\t\tfor (var i = 0; i < this.tracks.length; i++) {\n\n\t\t\t\t\tvar track = this.tracks[i].clone();\n\t\t\t\t\ttrack.reTarget(target, compareitor);\n\t\t\t\t\tn.addTrack(track);\n\t\t\t\t}\n\n\t\t\t\treturn n;\n\t\t\t};\n\t\t};\n\n\t\tvar ASSBIN_CHUNK_AICAMERA = 0x1234;\n\t\tvar ASSBIN_CHUNK_AILIGHT = 0x1235;\n\t\tvar ASSBIN_CHUNK_AITEXTURE = 0x1236;\n\t\tvar ASSBIN_CHUNK_AIMESH = 0x1237;\n\t\tvar ASSBIN_CHUNK_AINODEANIM = 0x1238;\n\t\tvar ASSBIN_CHUNK_AISCENE = 0x1239;\n\t\tvar ASSBIN_CHUNK_AIBONE = 0x123a;\n\t\tvar ASSBIN_CHUNK_AIANIMATION = 0x123b;\n\t\tvar ASSBIN_CHUNK_AINODE = 0x123c;\n\t\tvar ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n\t\tvar ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n\t\tvar ASSBIN_MESH_HAS_POSITIONS = 0x1;\n\t\tvar ASSBIN_MESH_HAS_NORMALS = 0x2;\n\t\tvar ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n\t\tvar ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n\t\tvar ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n\t\tvar AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n\t\tvar AI_MAX_NUMBER_OF_TEXTURECOORDS = 4;\n\t\tvar aiLightSource_UNDEFINED = 0x0;\n\t\t//! A directional light source has a well-defined direction\n\t\t//! but is infinitely far away. That's quite a good\n\t\t//! approximation for sun light.\n\t\tvar aiLightSource_DIRECTIONAL = 0x1;\n\t\t//! A point light source has a well-defined position\n\t\t//! in space but no direction - it emits light in all\n\t\t//! directions. A normal bulb is a point light.\n\t\tvar aiLightSource_POINT = 0x2;\n\t\t//! A spot light source emits light in a specific\n\t\t//! angle. It has a position and a direction it is pointing to.\n\t\t//! A good example for a spot light is a light spot in\n\t\t//! sport arenas.\n\t\tvar aiLightSource_SPOT = 0x3;\n\t\t//! The generic light level of the world, including the bounces\n\t\t//! of all other lightsources.\n\t\t//! Typically, there's at most one ambient light in a scene.\n\t\t//! This light type doesn't have a valid position, direction, or\n\t\t//! other properties, just a color.\n\t\tvar aiLightSource_AMBIENT = 0x4;\n\t\t/** Flat shading. Shading is done on per-face base,\n   *  diffuse only. Also known as 'faceted shading'.\n   */\n\t\tvar aiShadingMode_Flat = 0x1;\n\t\t/** Simple Gouraud shading.\n   */\n\t\tvar aiShadingMode_Gouraud = 0x2;\n\t\t/** Phong-Shading -\n   */\n\t\tvar aiShadingMode_Phong = 0x3;\n\t\t/** Phong-Blinn-Shading\n   */\n\t\tvar aiShadingMode_Blinn = 0x4;\n\t\t/** Toon-Shading per pixel\n   *\n   *  Also known as 'comic' shader.\n   */\n\t\tvar aiShadingMode_Toon = 0x5;\n\t\t/** OrenNayar-Shading per pixel\n   *\n   *  Extension to standard Lambertian shading, taking the\n   *  roughness of the material into account\n   */\n\t\tvar aiShadingMode_OrenNayar = 0x6;\n\t\t/** Minnaert-Shading per pixel\n   *\n   *  Extension to standard Lambertian shading, taking the\n   *  \"darkness\" of the material into account\n   */\n\t\tvar aiShadingMode_Minnaert = 0x7;\n\t\t/** CookTorrance-Shading per pixel\n   *\n   *  Special shader for metallic surfaces.\n   */\n\t\tvar aiShadingMode_CookTorrance = 0x8;\n\t\t/** No shading at all. Constant light influence of 1.0.\n   */\n\t\tvar aiShadingMode_NoShading = 0x9;\n\t\t/** Fresnel shading\n   */\n\t\tvar aiShadingMode_Fresnel = 0xa;\n\t\tvar aiTextureType_NONE = 0x0;\n\t\t/** The texture is combined with the result of the diffuse\n   *  lighting equation.\n   */\n\t\tvar aiTextureType_DIFFUSE = 0x1;\n\t\t/** The texture is combined with the result of the specular\n   *  lighting equation.\n   */\n\t\tvar aiTextureType_SPECULAR = 0x2;\n\t\t/** The texture is combined with the result of the ambient\n   *  lighting equation.\n   */\n\t\tvar aiTextureType_AMBIENT = 0x3;\n\t\t/** The texture is added to the result of the lighting\n   *  calculation. It isn't influenced by incoming light.\n   */\n\t\tvar aiTextureType_EMISSIVE = 0x4;\n\t\t/** The texture is a height map.\n   *\n   *  By convention, higher gray-scale values stand for\n   *  higher elevations from the base height.\n   */\n\t\tvar aiTextureType_HEIGHT = 0x5;\n\t\t/** The texture is a (tangent space) normal-map.\n   *\n   *  Again, there are several conventions for tangent-space\n   *  normal maps. Assimp does (intentionally) not\n   *  distinguish here.\n   */\n\t\tvar aiTextureType_NORMALS = 0x6;\n\t\t/** The texture defines the glossiness of the material.\n   *\n   *  The glossiness is in fact the exponent of the specular\n   *  (phong) lighting equation. Usually there is a conversion\n   *  function defined to map the linear color values in the\n   *  texture to a suitable exponent. Have fun.\n   */\n\t\tvar aiTextureType_SHININESS = 0x7;\n\t\t/** The texture defines per-pixel opacity.\n   *\n   *  Usually 'white' means opaque and 'black' means\n   *  'transparency'. Or quite the opposite. Have fun.\n   */\n\t\tvar aiTextureType_OPACITY = 0x8;\n\t\t/** Displacement texture\n   *\n   *  The exact purpose and format is application-dependent.\n   *  Higher color values stand for higher vertex displacements.\n   */\n\t\tvar aiTextureType_DISPLACEMENT = 0x9;\n\t\t/** Lightmap texture (aka Ambient Occlusion)\n   *\n   *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n   *  covered by this material property. The texture contains a\n   *  scaling value for the final color value of a pixel. Its\n   *  intensity is not affected by incoming light.\n   */\n\t\tvar aiTextureType_LIGHTMAP = 0xA;\n\t\t/** Reflection texture\n   *\n   * Contains the color of a perfect mirror reflection.\n   * Rarely used, almost never for real-time applications.\n   */\n\t\tvar aiTextureType_REFLECTION = 0xB;\n\t\t/** Unknown texture\n   *\n   *  A texture reference that does not match any of the definitions\n   *  above is considered to be 'unknown'. It is still imported,\n   *  but is excluded from any further postprocessing.\n   */\n\t\tvar aiTextureType_UNKNOWN = 0xC;\n\t\tvar BONESPERVERT = 4;\n\n\t\tfunction ASSBIN_MESH_HAS_TEXCOORD(n) {\n\n\t\t\treturn ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n\t\t}\n\n\t\tfunction ASSBIN_MESH_HAS_COLOR(n) {\n\n\t\t\treturn ASSBIN_MESH_HAS_COLOR_BASE << n;\n\t\t}\n\n\t\tfunction markBones(scene) {\n\n\t\t\tfor (var i in scene.mMeshes) {\n\n\t\t\t\tvar mesh = scene.mMeshes[i];\n\t\t\t\tfor (var k in mesh.mBones) {\n\n\t\t\t\t\tvar boneNode = scene.findNode(mesh.mBones[k].mName);\n\t\t\t\t\tif (boneNode) boneNode.isBone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfunction cloneTreeToBones(root, scene) {\n\n\t\t\tvar rootBone = new THREE.Bone();\n\t\t\trootBone.matrix.copy(root.matrix);\n\t\t\trootBone.matrixWorld.copy(root.matrixWorld);\n\t\t\trootBone.position.copy(root.position);\n\t\t\trootBone.quaternion.copy(root.quaternion);\n\t\t\trootBone.scale.copy(root.scale);\n\t\t\tscene.nodeCount++;\n\t\t\trootBone.name = \"bone_\" + root.name + scene.nodeCount.toString();\n\n\t\t\tif (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n\t\t\tscene.nodeToBoneMap[root.name].push(rootBone);\n\t\t\tfor (var i in root.children) {\n\n\t\t\t\tvar child = cloneTreeToBones(root.children[i], scene);\n\t\t\t\tif (child) rootBone.add(child);\n\t\t\t}\n\n\t\t\treturn rootBone;\n\t\t}\n\n\t\tfunction sortWeights(indexes, weights) {\n\n\t\t\tvar pairs = [];\n\n\t\t\tfor (var i = 0; i < indexes.length; i++) {\n\n\t\t\t\tpairs.push({\n\t\t\t\t\ti: indexes[i],\n\t\t\t\t\tw: weights[i]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tpairs.sort(function (a, b) {\n\n\t\t\t\treturn b.w - a.w;\n\t\t\t});\n\n\t\t\twhile (pairs.length < 4) {\n\n\t\t\t\tpairs.push({\n\t\t\t\t\ti: 0,\n\t\t\t\t\tw: 0\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (pairs.length > 4) pairs.length = 4;\n\t\t\tvar sum = 0;\n\n\t\t\tfor (var i = 0; i < 4; i++) {\n\n\t\t\t\tsum += pairs[i].w * pairs[i].w;\n\t\t\t}\n\n\t\t\tsum = Math.sqrt(sum);\n\n\t\t\tfor (var i = 0; i < 4; i++) {\n\n\t\t\t\tpairs[i].w = pairs[i].w / sum;\n\t\t\t\tindexes[i] = pairs[i].i;\n\t\t\t\tweights[i] = pairs[i].w;\n\t\t\t}\n\t\t}\n\n\t\tfunction findMatchingBone(root, name) {\n\n\t\t\tif (root.name.indexOf(\"bone_\" + name) == 0) return root;\n\n\t\t\tfor (var i in root.children) {\n\n\t\t\t\tvar ret = findMatchingBone(root.children[i], name);\n\n\t\t\t\tif (ret) return ret;\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t}\n\n\t\tfunction aiMesh() {\n\n\t\t\tthis.mPrimitiveTypes = 0;\n\t\t\tthis.mNumVertices = 0;\n\t\t\tthis.mNumFaces = 0;\n\t\t\tthis.mNumBones = 0;\n\t\t\tthis.mMaterialIndex = 0;\n\t\t\tthis.mVertices = [];\n\t\t\tthis.mNormals = [];\n\t\t\tthis.mTangents = [];\n\t\t\tthis.mBitangents = [];\n\t\t\tthis.mColors = [[]];\n\t\t\tthis.mTextureCoords = [[]];\n\t\t\tthis.mFaces = [];\n\t\t\tthis.mBones = [];\n\t\t\tthis.hookupSkeletons = function (scene, threeScene) {\n\n\t\t\t\tif (this.mBones.length == 0) return;\n\n\t\t\t\tvar allBones = [];\n\t\t\t\tvar offsetMatrix = [];\n\t\t\t\tvar skeletonRoot = scene.findNode(this.mBones[0].mName);\n\n\t\t\t\twhile (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n\n\t\t\t\t\tskeletonRoot = skeletonRoot.mParent;\n\t\t\t\t}\n\n\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n\t\t\t\tthis.threeNode.add(threeSkeletonRootBone);\n\n\t\t\t\tfor (var i = 0; i < this.mBones.length; i++) {\n\n\t\t\t\t\tvar bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\n\t\t\t\t\tif (bone) {\n\n\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\tallBones.push(tbone);\n\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\toffsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar skeletonRoot = scene.findNode(this.mBones[i].mName);\n\t\t\t\t\t\tif (!skeletonRoot) return;\n\t\t\t\t\t\tvar threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n\t\t\t\t\t\tvar threeSkeletonRootParent = threeSkeletonRoot.parent;\n\t\t\t\t\t\tvar threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n\t\t\t\t\t\tthis.threeNode.add(threeSkeletonRootBone);\n\t\t\t\t\t\tvar bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\t\t\t\t\t\tvar tbone = bone;\n\t\t\t\t\t\tallBones.push(tbone);\n\t\t\t\t\t\t//tbone.matrixAutoUpdate = false;\n\t\t\t\t\t\toffsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar skeleton = new THREE.Skeleton(allBones, offsetMatrix);\n\n\t\t\t\tthis.threeNode.bind(skeleton, new THREE.Matrix4());\n\t\t\t\tthis.threeNode.material.skinning = true;\n\t\t\t};\n\n\t\t\tthis.toTHREE = function (scene) {\n\n\t\t\t\tif (this.threeNode) return this.threeNode;\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tvar mat;\n\t\t\t\tif (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new THREE.MeshLambertMaterial();\n\t\t\t\tgeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(this.mVertexBuffer, 3));\n\t\t\t\tif (this.mNormalBuffer && this.mNormalBuffer.length > 0) geometry.addAttribute('normal', new THREE.BufferAttribute(this.mNormalBuffer, 3));\n\t\t\t\tif (this.mColorBuffer && this.mColorBuffer.length > 0) geometry.addAttribute('color', new THREE.BufferAttribute(this.mColorBuffer, 4));\n\t\t\t\tif (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n\t\t\t\tif (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) geometry.addAttribute('uv1', new THREE.BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n\t\t\t\tif (this.mTangentBuffer && this.mTangentBuffer.length > 0) geometry.addAttribute('tangents', new THREE.BufferAttribute(this.mTangentBuffer, 3));\n\t\t\t\tif (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) geometry.addAttribute('bitangents', new THREE.BufferAttribute(this.mBitangentBuffer, 3));\n\t\t\t\tif (this.mBones.length > 0) {\n\n\t\t\t\t\tvar weights = [];\n\t\t\t\t\tvar bones = [];\n\n\t\t\t\t\tfor (var i = 0; i < this.mBones.length; i++) {\n\n\t\t\t\t\t\tfor (var j = 0; j < this.mBones[i].mWeights.length; j++) {\n\n\t\t\t\t\t\t\tvar weight = this.mBones[i].mWeights[j];\n\t\t\t\t\t\t\tif (weight) {\n\n\t\t\t\t\t\t\t\tif (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n\t\t\t\t\t\t\t\tif (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n\t\t\t\t\t\t\t\tweights[weight.mVertexId].push(weight.mWeight);\n\t\t\t\t\t\t\t\tbones[weight.mVertexId].push(parseInt(i));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i in bones) {\n\n\t\t\t\t\t\tsortWeights(bones[i], weights[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar _weights = [];\n\t\t\t\t\tvar _bones = [];\n\n\t\t\t\t\tfor (var i = 0; i < weights.length; i++) {\n\n\t\t\t\t\t\tfor (var j = 0; j < 4; j++) {\n\n\t\t\t\t\t\t\tif (weights[i] && bones[i]) {\n\n\t\t\t\t\t\t\t\t_weights.push(weights[i][j]);\n\t\t\t\t\t\t\t\t_bones.push(bones[i][j]);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t_weights.push(0);\n\t\t\t\t\t\t\t\t_bones.push(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute('skinWeight', new THREE.BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n\t\t\t\t\tgeometry.addAttribute('skinIndex', new THREE.BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n\t\t\t\t}\n\n\t\t\t\tvar mesh;\n\n\t\t\t\tif (this.mBones.length == 0) mesh = new THREE.Mesh(geometry, mat);\n\n\t\t\t\tif (this.mBones.length > 0) mesh = new THREE.SkinnedMesh(geometry, mat);\n\n\t\t\t\tthis.threeNode = mesh;\n\t\t\t\t//mesh.matrixAutoUpdate = false;\n\t\t\t\treturn mesh;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiFace() {\n\n\t\t\tthis.mNumIndices = 0;\n\t\t\tthis.mIndices = [];\n\t\t}\n\n\t\tfunction aiVector3D() {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Vector3(this.x, this.y, this.z);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVector2D() {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Vector2(this.x, this.y);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVector4D() {\n\n\t\t\tthis.w = 0;\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Vector4(this.w, this.x, this.y, this.z);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiColor4D() {\n\n\t\t\tthis.r = 0;\n\t\t\tthis.g = 0;\n\t\t\tthis.b = 0;\n\t\t\tthis.a = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Color(this.r, this.g, this.b, this.a);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiColor3D() {\n\n\t\t\tthis.r = 0;\n\t\t\tthis.g = 0;\n\t\t\tthis.b = 0;\n\t\t\tthis.a = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Color(this.r, this.g, this.b, 1);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiQuaternion() {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 0;\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\treturn new THREE.Quaternion(this.x, this.y, this.z, this.w);\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVertexWeight() {\n\n\t\t\tthis.mVertexId = 0;\n\t\t\tthis.mWeight = 0;\n\t\t}\n\n\t\tfunction aiString() {\n\n\t\t\tthis.data = [];\n\t\t\tthis.toString = function () {\n\n\t\t\t\tvar str = '';\n\t\t\t\tthis.data.forEach(function (i) {\n\n\t\t\t\t\tstr += String.fromCharCode(i);\n\t\t\t\t});\n\t\t\t\treturn str.replace(/[^\\x20-\\x7E]+/g, '');\n\t\t\t};\n\t\t}\n\n\t\tfunction aiVectorKey() {\n\n\t\t\tthis.mTime = 0;\n\t\t\tthis.mValue = null;\n\t\t}\n\n\t\tfunction aiQuatKey() {\n\n\t\t\tthis.mTime = 0;\n\t\t\tthis.mValue = null;\n\t\t}\n\n\t\tfunction aiNode() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mTransformation = [];\n\t\t\tthis.mNumChildren = 0;\n\t\t\tthis.mNumMeshes = 0;\n\t\t\tthis.mMeshes = [];\n\t\t\tthis.mChildren = [];\n\t\t\tthis.toTHREE = function (scene) {\n\n\t\t\t\tif (this.threeNode) return this.threeNode;\n\t\t\t\tvar o = new THREE.Object3D();\n\t\t\t\to.name = this.mName;\n\t\t\t\to.matrix = this.mTransformation.toTHREE();\n\n\t\t\t\tfor (var i = 0; i < this.mChildren.length; i++) {\n\n\t\t\t\t\to.add(this.mChildren[i].toTHREE(scene));\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < this.mMeshes.length; i++) {\n\n\t\t\t\t\to.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n\t\t\t\t}\n\n\t\t\t\tthis.threeNode = o;\n\t\t\t\t//o.matrixAutoUpdate = false;\n\t\t\t\to.matrix.decompose(o.position, o.quaternion, o.scale);\n\t\t\t\treturn o;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiBone() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mNumWeights = 0;\n\t\t\tthis.mOffsetMatrix = 0;\n\t\t}\n\n\t\tfunction aiMaterialProperty() {\n\n\t\t\tthis.mKey = \"\";\n\t\t\tthis.mSemantic = 0;\n\t\t\tthis.mIndex = 0;\n\t\t\tthis.mData = [];\n\t\t\tthis.mDataLength = 0;\n\t\t\tthis.mType = 0;\n\t\t\tthis.dataAsColor = function () {\n\n\t\t\t\tvar array = new Uint8Array(this.mData).buffer;\n\t\t\t\tvar reader = new DataView(array);\n\t\t\t\tvar r = reader.getFloat32(0, true);\n\t\t\t\tvar g = reader.getFloat32(4, true);\n\t\t\t\tvar b = reader.getFloat32(8, true);\n\t\t\t\t//var a = reader.getFloat32(12, true);\n\t\t\t\treturn new THREE.Color(r, g, b);\n\t\t\t};\n\n\t\t\tthis.dataAsFloat = function () {\n\n\t\t\t\tvar array = new Uint8Array(this.mData).buffer;\n\t\t\t\tvar reader = new DataView(array);\n\t\t\t\tvar r = reader.getFloat32(0, true);\n\t\t\t\treturn r;\n\t\t\t};\n\n\t\t\tthis.dataAsBool = function () {\n\n\t\t\t\tvar array = new Uint8Array(this.mData).buffer;\n\t\t\t\tvar reader = new DataView(array);\n\t\t\t\tvar r = reader.getFloat32(0, true);\n\t\t\t\treturn !!r;\n\t\t\t};\n\n\t\t\tthis.dataAsString = function () {\n\n\t\t\t\tvar s = new aiString();\n\t\t\t\ts.data = this.mData;\n\t\t\t\treturn s.toString();\n\t\t\t};\n\n\t\t\tthis.dataAsMap = function () {\n\n\t\t\t\tvar s = new aiString();\n\t\t\t\ts.data = this.mData;\n\t\t\t\tvar path = s.toString();\n\t\t\t\tpath = path.replace(/\\\\/g, '/');\n\n\t\t\t\tif (path.indexOf('/') != -1) {\n\n\t\t\t\t\tpath = path.substr(path.lastIndexOf('/') + 1);\n\t\t\t\t}\n\n\t\t\t\treturn textureLoader.load(path);\n\t\t\t};\n\t\t}\n\t\tvar namePropMapping = {\n\n\t\t\t\"?mat.name\": \"name\",\n\t\t\t\"$mat.shadingm\": \"shading\",\n\t\t\t\"$mat.twosided\": \"twoSided\",\n\t\t\t\"$mat.wireframe\": \"wireframe\",\n\t\t\t\"$clr.ambient\": \"ambient\",\n\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\"$clr.specular\": \"specular\",\n\t\t\t\"$clr.emissive\": \"emissive\",\n\t\t\t\"$clr.transparent\": \"transparent\",\n\t\t\t\"$clr.reflective\": \"reflect\",\n\t\t\t\"$mat.shininess\": \"shininess\",\n\t\t\t\"$mat.reflectivity\": \"reflectivity\",\n\t\t\t\"$mat.refracti\": \"refraction\",\n\t\t\t\"$tex.file\": \"map\"\n\n\t\t};\n\n\t\tvar nameTypeMapping = {\n\n\t\t\t\"?mat.name\": \"string\",\n\t\t\t\"$mat.shadingm\": \"bool\",\n\t\t\t\"$mat.twosided\": \"bool\",\n\t\t\t\"$mat.wireframe\": \"bool\",\n\t\t\t\"$clr.ambient\": \"color\",\n\t\t\t\"$clr.diffuse\": \"color\",\n\t\t\t\"$clr.specular\": \"color\",\n\t\t\t\"$clr.emissive\": \"color\",\n\t\t\t\"$clr.transparent\": \"color\",\n\t\t\t\"$clr.reflective\": \"color\",\n\t\t\t\"$mat.shininess\": \"float\",\n\t\t\t\"$mat.reflectivity\": \"float\",\n\t\t\t\"$mat.refracti\": \"float\",\n\t\t\t\"$tex.file\": \"map\"\n\n\t\t};\n\n\t\tfunction aiMaterial() {\n\n\t\t\tthis.mNumAllocated = 0;\n\t\t\tthis.mNumProperties = 0;\n\t\t\tthis.mProperties = [];\n\t\t\tthis.toTHREE = function (scene) {\n\n\t\t\t\tvar name = this.mProperties[0].dataAsString();\n\t\t\t\tvar mat = new THREE.MeshPhongMaterial();\n\n\t\t\t\tfor (var i = 0; i < this.mProperties.length; i++) {\n\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'float') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'color') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'bool') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'string') mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n\t\t\t\t\tif (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n\n\t\t\t\t\t\tvar prop = this.mProperties[i];\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n\t\t\t\t\t\tif (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmat.ambient.r = .53;\n\t\t\t\tmat.ambient.g = .53;\n\t\t\t\tmat.ambient.b = .53;\n\t\t\t\tmat.color.r = 1;\n\t\t\t\tmat.color.g = 1;\n\t\t\t\tmat.color.b = 1;\n\t\t\t\treturn mat;\n\t\t\t};\n\t\t}\n\n\t\tfunction veclerp(v1, v2, l) {\n\n\t\t\tvar v = new THREE.Vector3();\n\t\t\tvar lm1 = 1 - l;\n\t\t\tv.x = v1.x * l + v2.x * lm1;\n\t\t\tv.y = v1.y * l + v2.y * lm1;\n\t\t\tv.z = v1.z * l + v2.z * lm1;\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction quatlerp(q1, q2, l) {\n\n\t\t\treturn q1.clone().slerp(q2, 1 - l);\n\t\t}\n\n\t\tfunction sampleTrack(keys, time, lne, lerp) {\n\n\t\t\tif (keys.length == 1) return keys[0].mValue.toTHREE();\n\n\t\t\tvar dist = Infinity;\n\t\t\tvar key = null;\n\t\t\tvar nextKey = null;\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\n\t\t\t\tvar timeDist = Math.abs(keys[i].mTime - time);\n\n\t\t\t\tif (timeDist < dist && keys[i].mTime <= time) {\n\n\t\t\t\t\tdist = timeDist;\n\t\t\t\t\tkey = keys[i];\n\t\t\t\t\tnextKey = keys[i + 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!key) {\n\n\t\t\t\treturn null;\n\t\t\t} else if (nextKey) {\n\n\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\tvar T = key.mTime - time;\n\t\t\t\tvar l = T / dT;\n\n\t\t\t\treturn lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n\t\t\t} else {\n\n\t\t\t\tnextKey = keys[0].clone();\n\t\t\t\tnextKey.mTime += lne;\n\n\t\t\t\tvar dT = nextKey.mTime - key.mTime;\n\t\t\t\tvar T = key.mTime - time;\n\t\t\t\tvar l = T / dT;\n\n\t\t\t\treturn lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n\t\t\t}\n\t\t}\n\n\t\tfunction aiNodeAnim() {\n\n\t\t\tthis.mNodeName = \"\";\n\t\t\tthis.mNumPositionKeys = 0;\n\t\t\tthis.mNumRotationKeys = 0;\n\t\t\tthis.mNumScalingKeys = 0;\n\t\t\tthis.mPositionKeys = [];\n\t\t\tthis.mRotationKeys = [];\n\t\t\tthis.mScalingKeys = [];\n\t\t\tthis.mPreState = \"\";\n\t\t\tthis.mPostState = \"\";\n\t\t\tthis.init = function (tps) {\n\n\t\t\t\tif (!tps) tps = 1;\n\n\t\t\t\tfunction t(t) {\n\n\t\t\t\t\tt.mTime /= tps;\n\t\t\t\t}\n\n\t\t\t\tthis.mPositionKeys.forEach(t);\n\t\t\t\tthis.mRotationKeys.forEach(t);\n\t\t\t\tthis.mScalingKeys.forEach(t);\n\t\t\t};\n\n\t\t\tthis.sortKeys = function () {\n\n\t\t\t\tfunction comp(a, b) {\n\n\t\t\t\t\treturn a.mTime - b.mTime;\n\t\t\t\t}\n\n\t\t\t\tthis.mPositionKeys.sort(comp);\n\t\t\t\tthis.mRotationKeys.sort(comp);\n\t\t\t\tthis.mScalingKeys.sort(comp);\n\t\t\t};\n\n\t\t\tthis.getLength = function () {\n\n\t\t\t\treturn Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n\n\t\t\t\t\treturn a.mTime;\n\t\t\t\t})), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n\n\t\t\t\t\treturn a.mTime;\n\t\t\t\t})), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n\n\t\t\t\t\treturn a.mTime;\n\t\t\t\t})));\n\t\t\t};\n\n\t\t\tthis.toTHREE = function (o, tps) {\n\n\t\t\t\tthis.sortKeys();\n\t\t\t\tvar length = this.getLength();\n\t\t\t\tvar track = new Virtulous.KeyFrameTrack();\n\n\t\t\t\tfor (var i = 0; i < length; i += .05) {\n\n\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\t\tvar time = i;\n\t\t\t\t\tvar pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n\t\t\t\t\tvar scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n\t\t\t\t\tvar rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n\t\t\t\t\tmatrix.compose(pos, rotation, scale);\n\n\t\t\t\t\tvar key = new Virtulous.KeyFrame(time, matrix);\n\t\t\t\t\ttrack.addKey(key);\n\t\t\t\t}\n\n\t\t\t\ttrack.target = o.findNode(this.mNodeName).toTHREE();\n\n\t\t\t\tvar tracks = [track];\n\n\t\t\t\tif (o.nodeToBoneMap[this.mNodeName]) {\n\n\t\t\t\t\tfor (var i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n\n\t\t\t\t\t\tvar t2 = track.clone();\n\t\t\t\t\t\tt2.target = o.nodeToBoneMap[this.mNodeName][i];\n\t\t\t\t\t\ttracks.push(t2);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiAnimation() {\n\n\t\t\tthis.mName = \"\";\n\t\t\tthis.mDuration = 0;\n\t\t\tthis.mTicksPerSecond = 0;\n\t\t\tthis.mNumChannels = 0;\n\t\t\tthis.mChannels = [];\n\t\t\tthis.toTHREE = function (root) {\n\n\t\t\t\tvar animationHandle = new Virtulous.Animation();\n\n\t\t\t\tfor (var i in this.mChannels) {\n\n\t\t\t\t\tthis.mChannels[i].init(this.mTicksPerSecond);\n\n\t\t\t\t\tvar tracks = this.mChannels[i].toTHREE(root);\n\n\t\t\t\t\tfor (var j in tracks) {\n\n\t\t\t\t\t\ttracks[j].init();\n\t\t\t\t\t\tanimationHandle.addTrack(tracks[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tanimationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n\n\t\t\t\t\treturn e.length;\n\t\t\t\t}));\n\t\t\t\treturn animationHandle;\n\t\t\t};\n\t\t}\n\n\t\tfunction aiTexture() {\n\n\t\t\tthis.mWidth = 0;\n\t\t\tthis.mHeight = 0;\n\t\t\tthis.texAchFormatHint = [];\n\t\t\tthis.pcData = [];\n\t\t}\n\n\t\tfunction aiLight() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mType = 0;\n\t\t\tthis.mAttenuationConstant = 0;\n\t\t\tthis.mAttenuationLinear = 0;\n\t\t\tthis.mAttenuationQuadratic = 0;\n\t\t\tthis.mAngleInnerCone = 0;\n\t\t\tthis.mAngleOuterCone = 0;\n\t\t\tthis.mColorDiffuse = null;\n\t\t\tthis.mColorSpecular = null;\n\t\t\tthis.mColorAmbient = null;\n\t\t}\n\n\t\tfunction aiCamera() {\n\n\t\t\tthis.mName = '';\n\t\t\tthis.mPosition = null;\n\t\t\tthis.mLookAt = null;\n\t\t\tthis.mUp = null;\n\t\t\tthis.mHorizontalFOV = 0;\n\t\t\tthis.mClipPlaneNear = 0;\n\t\t\tthis.mClipPlaneFar = 0;\n\t\t\tthis.mAspect = 0;\n\t\t}\n\n\t\tfunction aiScene() {\n\n\t\t\tthis.mFlags = 0;\n\t\t\tthis.mNumMeshes = 0;\n\t\t\tthis.mNumMaterials = 0;\n\t\t\tthis.mNumAnimations = 0;\n\t\t\tthis.mNumTextures = 0;\n\t\t\tthis.mNumLights = 0;\n\t\t\tthis.mNumCameras = 0;\n\t\t\tthis.mRootNode = null;\n\t\t\tthis.mMeshes = [];\n\t\t\tthis.mMaterials = [];\n\t\t\tthis.mAnimations = [];\n\t\t\tthis.mLights = [];\n\t\t\tthis.mCameras = [];\n\t\t\tthis.nodeToBoneMap = {};\n\t\t\tthis.findNode = function (name, root) {\n\n\t\t\t\tif (!root) {\n\n\t\t\t\t\troot = this.mRootNode;\n\t\t\t\t}\n\n\t\t\t\tif (root.mName == name) {\n\n\t\t\t\t\treturn root;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < root.mChildren.length; i++) {\n\n\t\t\t\t\tvar ret = this.findNode(name, root.mChildren[i]);\n\t\t\t\t\tif (ret) return ret;\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t};\n\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\tthis.nodeCount = 0;\n\n\t\t\t\tmarkBones(this);\n\n\t\t\t\tvar o = this.mRootNode.toTHREE(this);\n\n\t\t\t\tfor (var i in this.mMeshes) {\n\t\t\t\t\tthis.mMeshes[i].hookupSkeletons(this, o);\n\t\t\t\t}if (this.mAnimations.length > 0) {\n\n\t\t\t\t\tvar a = this.mAnimations[0].toTHREE(this);\n\t\t\t\t}\n\n\t\t\t\treturn { object: o, animation: a };\n\t\t\t};\n\t\t}\n\n\t\tfunction aiMatrix4() {\n\n\t\t\tthis.elements = [[], [], [], []];\n\t\t\tthis.toTHREE = function () {\n\n\t\t\t\tvar m = new THREE.Matrix4();\n\n\t\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\t\tfor (var i2 = 0; i2 < 4; ++i2) {\n\n\t\t\t\t\t\tm.elements[i * 4 + i2] = this.elements[i2][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn m;\n\t\t\t};\n\t\t}\n\n\t\tvar littleEndian = true;\n\n\t\tfunction readFloat(dataview) {\n\n\t\t\tvar val = dataview.getFloat32(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 4;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_double(dataview) {\n\n\t\t\tvar val = dataview.getFloat64(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 8;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_uint8_t(dataview) {\n\n\t\t\tvar val = dataview.getUint8(dataview.readOffset);\n\t\t\tdataview.readOffset += 1;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_uint16_t(dataview) {\n\n\t\t\tvar val = dataview.getUint16(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 2;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_unsigned_int(dataview) {\n\n\t\t\tvar val = dataview.getUint32(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 4;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_uint32_t(dataview) {\n\n\t\t\tvar val = dataview.getUint32(dataview.readOffset, littleEndian);\n\t\t\tdataview.readOffset += 4;\n\t\t\treturn val;\n\t\t}\n\n\t\tfunction Read_aiVector3D(stream) {\n\n\t\t\tvar v = new aiVector3D();\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\tv.z = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiVector2D(stream) {\n\n\t\t\tvar v = new aiVector2D();\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiVector4D(stream) {\n\n\t\t\tvar v = new aiVector4D();\n\t\t\tv.w = readFloat(stream);\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\tv.z = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiColor3D(stream) {\n\n\t\t\tvar c = new aiColor3D();\n\t\t\tc.r = readFloat(stream);\n\t\t\tc.g = readFloat(stream);\n\t\t\tc.b = readFloat(stream);\n\t\t\treturn c;\n\t\t}\n\n\t\tfunction Read_aiColor4D(stream) {\n\n\t\t\tvar c = new aiColor4D();\n\t\t\tc.r = readFloat(stream);\n\t\t\tc.g = readFloat(stream);\n\t\t\tc.b = readFloat(stream);\n\t\t\tc.a = readFloat(stream);\n\t\t\treturn c;\n\t\t}\n\n\t\tfunction Read_aiQuaternion(stream) {\n\n\t\t\tvar v = new aiQuaternion();\n\t\t\tv.w = readFloat(stream);\n\t\t\tv.x = readFloat(stream);\n\t\t\tv.y = readFloat(stream);\n\t\t\tv.z = readFloat(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiString(stream) {\n\n\t\t\tvar s = new aiString();\n\t\t\tvar stringlengthbytes = Read_unsigned_int(stream);\n\t\t\tstream.ReadBytes(s.data, 1, stringlengthbytes);\n\t\t\treturn s.toString();\n\t\t}\n\n\t\tfunction Read_aiVertexWeight(stream) {\n\n\t\t\tvar w = new aiVertexWeight();\n\t\t\tw.mVertexId = Read_unsigned_int(stream);\n\t\t\tw.mWeight = readFloat(stream);\n\t\t\treturn w;\n\t\t}\n\n\t\tfunction Read_aiMatrix4x4(stream) {\n\n\t\t\tvar m = new aiMatrix4();\n\n\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\tfor (var i2 = 0; i2 < 4; ++i2) {\n\n\t\t\t\t\tm.elements[i][i2] = readFloat(stream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn m;\n\t\t}\n\n\t\tfunction Read_aiVectorKey(stream) {\n\n\t\t\tvar v = new aiVectorKey();\n\t\t\tv.mTime = Read_double(stream);\n\t\t\tv.mValue = Read_aiVector3D(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction Read_aiQuatKey(stream) {\n\n\t\t\tvar v = new aiQuatKey();\n\t\t\tv.mTime = Read_double(stream);\n\t\t\tv.mValue = Read_aiQuaternion(stream);\n\t\t\treturn v;\n\t\t}\n\n\t\tfunction ReadArray(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVector2D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVector2D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVector3D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVector3D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVector4D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVector4D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVertexWeight(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVertexWeight(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiColor4D(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiColor4D(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiVectorKey(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiVectorKey(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadArray_aiQuatKey(stream, data, size) {\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\t\t\t\tdata[i] = Read_aiQuatKey(stream);\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadBounds(stream, T /*p*/, n) {\n\n\t\t\t// not sure what to do here, the data isn't really useful.\n\t\t\treturn stream.Seek(sizeof(T) * n, aiOrigin_CUR);\n\t\t}\n\n\t\tfunction ai_assert(bool) {\n\n\t\t\tif (!bool) throw \"asset failed\";\n\t\t}\n\n\t\tfunction ReadBinaryNode(stream, parent, depth) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tvar node = new aiNode();\n\t\t\tnode.mParent = parent;\n\t\t\tnode.mDepth = depth;\n\t\t\tnode.mName = Read_aiString(stream);\n\t\t\tnode.mTransformation = Read_aiMatrix4x4(stream);\n\t\t\tnode.mNumChildren = Read_unsigned_int(stream);\n\t\t\tnode.mNumMeshes = Read_unsigned_int(stream);\n\n\t\t\tif (node.mNumMeshes) {\n\n\t\t\t\tnode.mMeshes = [];\n\n\t\t\t\tfor (var i = 0; i < node.mNumMeshes; ++i) {\n\n\t\t\t\t\tnode.mMeshes[i] = Read_unsigned_int(stream);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node.mNumChildren) {\n\n\t\t\t\tnode.mChildren = [];\n\n\t\t\t\tfor (var i = 0; i < node.mNumChildren; ++i) {\n\n\t\t\t\t\tvar node2 = ReadBinaryNode(stream, node, depth++);\n\t\t\t\t\tnode.mChildren[i] = node2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn node;\n\t\t}\n\n\t\t// -----------------------------------------------------------------------------------\n\n\t\tfunction ReadBinaryBone(stream, b) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tb.mName = Read_aiString(stream);\n\t\t\tb.mNumWeights = Read_unsigned_int(stream);\n\t\t\tb.mOffsetMatrix = Read_aiMatrix4x4(stream);\n\t\t\t// for the moment we write dumb min/max values for the bones, too.\n\t\t\t// maybe I'll add a better, hash-like solution later\n\t\t\tif (shortened) {\n\n\t\t\t\tReadBounds(stream, b.mWeights, b.mNumWeights);\n\t\t\t} else {\n\n\t\t\t\t// else write as usual\n\n\t\t\t\tb.mWeights = [];\n\t\t\t\tReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n\t\t\t}\n\n\t\t\treturn b;\n\t\t}\n\n\t\tfunction ReadBinaryMesh(stream, mesh) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tmesh.mPrimitiveTypes = Read_unsigned_int(stream);\n\t\t\tmesh.mNumVertices = Read_unsigned_int(stream);\n\t\t\tmesh.mNumFaces = Read_unsigned_int(stream);\n\t\t\tmesh.mNumBones = Read_unsigned_int(stream);\n\t\t\tmesh.mMaterialIndex = Read_unsigned_int(stream);\n\t\t\tmesh.mNumUVComponents = [];\n\t\t\t// first of all, write bits for all existent vertex components\n\t\t\tvar c = Read_unsigned_int(stream);\n\n\t\t\tif (c & ASSBIN_MESH_HAS_POSITIONS) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mVertices = [];\n\t\t\t\t\tmesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c & ASSBIN_MESH_HAS_NORMALS) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mNormals = [];\n\t\t\t\t\tmesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n\t\t\t\t\tReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mTangents = [];\n\t\t\t\t\tmesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t\tmesh.mBitangents = [];\n\t\t\t\t\tmesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n\n\t\t\t\tif (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mColors[n] = [];\n\t\t\t\t\tmesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n\t\t\t\t\tstream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmesh.mTexCoordsBuffers = [];\n\n\t\t\tfor (var n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n\n\t\t\t\tif (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break;\n\n\t\t\t\t// write number of UV components\n\t\t\t\tmesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tmesh.mTextureCoords[n] = [];\n\t\t\t\t\t//note that assbin always writes 3d texcoords\n\t\t\t\t\tmesh.mTexCoordsBuffers[n] = [];\n\n\t\t\t\t\tfor (var uv = 0; uv < mesh.mNumVertices; uv++) {\n\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[n].push(readFloat(stream));\n\t\t\t\t\t\tmesh.mTexCoordsBuffers[n].push(readFloat(stream));\n\t\t\t\t\t\treadFloat(stream);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// write faces. There are no floating-point calculations involved\n\t\t\t// in these, so we can write a simple hash over the face data\n\t\t\t// to the dump file. We generate a single 32 Bit hash for 512 faces\n\t\t\t// using Assimp's standard hashing function.\n\t\t\tif (shortened) {\n\n\t\t\t\tRead_unsigned_int(stream);\n\t\t\t} else {\n\n\t\t\t\t// else write as usual\n\n\t\t\t\t// if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n\t\t\t\tmesh.mFaces = [];\n\n\t\t\t\tvar indexCounter = 0;\n\t\t\t\tmesh.mIndexArray = [];\n\n\t\t\t\tfor (var i = 0; i < mesh.mNumFaces; ++i) {\n\n\t\t\t\t\tvar f = mesh.mFaces[i] = new aiFace();\n\t\t\t\t\t// BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\t\t\t\t\tf.mNumIndices = Read_uint16_t(stream);\n\t\t\t\t\tf.mIndices = [];\n\n\t\t\t\t\tfor (var a = 0; a < f.mNumIndices; ++a) {\n\n\t\t\t\t\t\tif (mesh.mNumVertices < 1 << 16) {\n\n\t\t\t\t\t\t\tf.mIndices[a] = Read_uint16_t(stream);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tf.mIndices[a] = Read_unsigned_int(stream);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (f.mNumIndices === 3) {\n\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[0]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[1]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[2]);\n\t\t\t\t\t} else if (f.mNumIndices === 4) {\n\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[0]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[1]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[2]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[2]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[3]);\n\t\t\t\t\t\tmesh.mIndexArray.push(f.mIndices[0]);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// write bones\n\t\t\tif (mesh.mNumBones) {\n\n\t\t\t\tmesh.mBones = [];\n\n\t\t\t\tfor (var a = 0; a < mesh.mNumBones; ++a) {\n\n\t\t\t\t\tmesh.mBones[a] = new aiBone();\n\t\t\t\t\tReadBinaryBone(stream, mesh.mBones[a]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadBinaryMaterialProperty(stream, prop) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tprop.mKey = Read_aiString(stream);\n\t\t\tprop.mSemantic = Read_unsigned_int(stream);\n\t\t\tprop.mIndex = Read_unsigned_int(stream);\n\t\t\tprop.mDataLength = Read_unsigned_int(stream);\n\t\t\tprop.mType = Read_unsigned_int(stream);\n\t\t\tprop.mData = [];\n\t\t\tstream.ReadBytes(prop.mData, 1, prop.mDataLength);\n\t\t}\n\n\t\t// -----------------------------------------------------------------------------------\n\n\t\tfunction ReadBinaryMaterial(stream, mat) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tmat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n\n\t\t\tif (mat.mNumProperties) {\n\n\t\t\t\tif (mat.mProperties) {\n\n\t\t\t\t\tdelete mat.mProperties;\n\t\t\t\t}\n\n\t\t\t\tmat.mProperties = [];\n\n\t\t\t\tfor (var i = 0; i < mat.mNumProperties; ++i) {\n\n\t\t\t\t\tmat.mProperties[i] = new aiMaterialProperty();\n\t\t\t\t\tReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryNodeAnim(stream, nd) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tnd.mNodeName = Read_aiString(stream);\n\t\t\tnd.mNumPositionKeys = Read_unsigned_int(stream);\n\t\t\tnd.mNumRotationKeys = Read_unsigned_int(stream);\n\t\t\tnd.mNumScalingKeys = Read_unsigned_int(stream);\n\t\t\tnd.mPreState = Read_unsigned_int(stream);\n\t\t\tnd.mPostState = Read_unsigned_int(stream);\n\n\t\t\tif (nd.mNumPositionKeys) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tnd.mPositionKeys = [];\n\t\t\t\t\tReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nd.mNumRotationKeys) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tnd.mRotationKeys = [];\n\t\t\t\t\tReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (nd.mNumScalingKeys) {\n\n\t\t\t\tif (shortened) {\n\n\t\t\t\t\tReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n\t\t\t\t} else {\n\n\t\t\t\t\t// else write as usual\n\n\t\t\t\t\tnd.mScalingKeys = [];\n\t\t\t\t\tReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryAnim(stream, anim) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tanim.mName = Read_aiString(stream);\n\t\t\tanim.mDuration = Read_double(stream);\n\t\t\tanim.mTicksPerSecond = Read_double(stream);\n\t\t\tanim.mNumChannels = Read_unsigned_int(stream);\n\n\t\t\tif (anim.mNumChannels) {\n\n\t\t\t\tanim.mChannels = [];\n\n\t\t\t\tfor (var a = 0; a < anim.mNumChannels; ++a) {\n\n\t\t\t\t\tanim.mChannels[a] = new aiNodeAnim();\n\t\t\t\t\tReadBinaryNodeAnim(stream, anim.mChannels[a]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction ReadBinaryTexture(stream, tex) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\ttex.mWidth = Read_unsigned_int(stream);\n\t\t\ttex.mHeight = Read_unsigned_int(stream);\n\t\t\tstream.ReadBytes(tex.achFormatHint, 1, 4);\n\n\t\t\tif (!shortened) {\n\n\t\t\t\tif (!tex.mHeight) {\n\n\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\tstream.ReadBytes(tex.pcData, 1, tex.mWidth);\n\t\t\t\t} else {\n\n\t\t\t\t\ttex.pcData = [];\n\t\t\t\t\tstream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryLight(stream, l) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tl.mName = Read_aiString(stream);\n\t\t\tl.mType = Read_unsigned_int(stream);\n\n\t\t\tif (l.mType != aiLightSource_DIRECTIONAL) {\n\n\t\t\t\tl.mAttenuationConstant = readFloat(stream);\n\t\t\t\tl.mAttenuationLinear = readFloat(stream);\n\t\t\t\tl.mAttenuationQuadratic = readFloat(stream);\n\t\t\t}\n\n\t\t\tl.mColorDiffuse = Read_aiColor3D(stream);\n\t\t\tl.mColorSpecular = Read_aiColor3D(stream);\n\t\t\tl.mColorAmbient = Read_aiColor3D(stream);\n\n\t\t\tif (l.mType == aiLightSource_SPOT) {\n\n\t\t\t\tl.mAngleInnerCone = readFloat(stream);\n\t\t\t\tl.mAngleOuterCone = readFloat(stream);\n\t\t\t}\n\t\t}\n\t\t// -----------------------------------------------------------------------------------\n\t\tfunction ReadBinaryCamera(stream, cam) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tcam.mName = Read_aiString(stream);\n\t\t\tcam.mPosition = Read_aiVector3D(stream);\n\t\t\tcam.mLookAt = Read_aiVector3D(stream);\n\t\t\tcam.mUp = Read_aiVector3D(stream);\n\t\t\tcam.mHorizontalFOV = readFloat(stream);\n\t\t\tcam.mClipPlaneNear = readFloat(stream);\n\t\t\tcam.mClipPlaneFar = readFloat(stream);\n\t\t\tcam.mAspect = readFloat(stream);\n\t\t}\n\n\t\tfunction ReadBinaryScene(stream, scene) {\n\n\t\t\tvar chunkID = Read_uint32_t(stream);\n\t\t\tai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n\t\t\t/*uint32_t size =*/\n\t\t\tRead_uint32_t(stream);\n\t\t\tscene.mFlags = Read_unsigned_int(stream);\n\t\t\tscene.mNumMeshes = Read_unsigned_int(stream);\n\t\t\tscene.mNumMaterials = Read_unsigned_int(stream);\n\t\t\tscene.mNumAnimations = Read_unsigned_int(stream);\n\t\t\tscene.mNumTextures = Read_unsigned_int(stream);\n\t\t\tscene.mNumLights = Read_unsigned_int(stream);\n\t\t\tscene.mNumCameras = Read_unsigned_int(stream);\n\t\t\t// Read node graph\n\t\t\tscene.mRootNode = new aiNode();\n\t\t\tscene.mRootNode = ReadBinaryNode(stream, null, 0);\n\t\t\t// Read all meshes\n\t\t\tif (scene.mNumMeshes) {\n\n\t\t\t\tscene.mMeshes = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumMeshes; ++i) {\n\n\t\t\t\t\tscene.mMeshes[i] = new aiMesh();\n\t\t\t\t\tReadBinaryMesh(stream, scene.mMeshes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read materials\n\t\t\tif (scene.mNumMaterials) {\n\n\t\t\t\tscene.mMaterials = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumMaterials; ++i) {\n\n\t\t\t\t\tscene.mMaterials[i] = new aiMaterial();\n\t\t\t\t\tReadBinaryMaterial(stream, scene.mMaterials[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read all animations\n\t\t\tif (scene.mNumAnimations) {\n\n\t\t\t\tscene.mAnimations = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumAnimations; ++i) {\n\n\t\t\t\t\tscene.mAnimations[i] = new aiAnimation();\n\t\t\t\t\tReadBinaryAnim(stream, scene.mAnimations[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read all textures\n\t\t\tif (scene.mNumTextures) {\n\n\t\t\t\tscene.mTextures = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumTextures; ++i) {\n\n\t\t\t\t\tscene.mTextures[i] = new aiTexture();\n\t\t\t\t\tReadBinaryTexture(stream, scene.mTextures[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read lights\n\t\t\tif (scene.mNumLights) {\n\n\t\t\t\tscene.mLights = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumLights; ++i) {\n\n\t\t\t\t\tscene.mLights[i] = new aiLight();\n\t\t\t\t\tReadBinaryLight(stream, scene.mLights[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Read cameras\n\t\t\tif (scene.mNumCameras) {\n\n\t\t\t\tscene.mCameras = [];\n\n\t\t\t\tfor (var i = 0; i < scene.mNumCameras; ++i) {\n\n\t\t\t\t\tscene.mCameras[i] = new aiCamera();\n\t\t\t\t\tReadBinaryCamera(stream, scene.mCameras[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar aiOrigin_CUR = 0;\n\t\tvar aiOrigin_BEG = 1;\n\n\t\tfunction extendStream(stream) {\n\n\t\t\tstream.readOffset = 0;\n\t\t\tstream.Seek = function (off, ori) {\n\n\t\t\t\tif (ori == aiOrigin_CUR) {\n\n\t\t\t\t\tstream.readOffset += off;\n\t\t\t\t}\n\t\t\t\tif (ori == aiOrigin_BEG) {\n\n\t\t\t\t\tstream.readOffset = off;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstream.ReadBytes = function (buff, size, n) {\n\n\t\t\t\tvar bytes = size * n;\n\t\t\t\tfor (var i = 0; i < bytes; i++) {\n\t\t\t\t\tbuff[i] = Read_uint8_t(this);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tstream.subArray32 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Float32Array(newbuff);\n\t\t\t};\n\n\t\t\tstream.subArrayUint16 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Uint16Array(newbuff);\n\t\t\t};\n\n\t\t\tstream.subArrayUint8 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Uint8Array(newbuff);\n\t\t\t};\n\n\t\t\tstream.subArrayUint32 = function (start, end) {\n\n\t\t\t\tvar buff = this.buffer;\n\t\t\t\tvar newbuff = buff.slice(start, end);\n\t\t\t\treturn new Uint32Array(newbuff);\n\t\t\t};\n\t\t}\n\n\t\tvar shortened, compressed;\n\n\t\tfunction InternReadFile(pFiledata) {\n\n\t\t\tvar pScene = new aiScene();\n\t\t\tvar stream = new DataView(pFiledata);\n\t\t\textendStream(stream);\n\t\t\tstream.Seek(44, aiOrigin_CUR); // signature\n\t\t\t/*unsigned int versionMajor =*/\n\t\t\tvar versionMajor = Read_unsigned_int(stream);\n\t\t\t/*unsigned int versionMinor =*/\n\t\t\tvar versionMinor = Read_unsigned_int(stream);\n\t\t\t/*unsigned int versionRevision =*/\n\t\t\tvar versionRevision = Read_unsigned_int(stream);\n\t\t\t/*unsigned int compileFlags =*/\n\t\t\tvar compileFlags = Read_unsigned_int(stream);\n\t\t\tshortened = Read_uint16_t(stream) > 0;\n\t\t\tcompressed = Read_uint16_t(stream) > 0;\n\t\t\tif (shortened) throw \"Shortened binaries are not supported!\";\n\t\t\tstream.Seek(256, aiOrigin_CUR); // original filename\n\t\t\tstream.Seek(128, aiOrigin_CUR); // options\n\t\t\tstream.Seek(64, aiOrigin_CUR); // padding\n\t\t\tif (compressed) {\n\n\t\t\t\tvar uncompressedSize = Read_uint32_t(stream);\n\t\t\t\tvar compressedSize = stream.FileSize() - stream.Tell();\n\t\t\t\tvar compressedData = [];\n\t\t\t\tstream.Read(compressedData, 1, compressedSize);\n\t\t\t\tvar uncompressedData = [];\n\t\t\t\tuncompress(uncompressedData, uncompressedSize, compressedData, compressedSize);\n\t\t\t\tvar buff = new ArrayBuffer(uncompressedData);\n\t\t\t\tReadBinaryScene(buff, pScene);\n\t\t\t} else {\n\n\t\t\t\tReadBinaryScene(stream, pScene);\n\t\t\t\treturn pScene.toTHREE();\n\t\t\t}\n\t\t}\n\n\t\treturn InternReadFile(buffer);\n\t}\n\n};\n\nexports.default = AssimpLoader;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Author: Pierre Lepers\n * Date: 09/12/2013 17:21\n */\n\nexports.default = function () {\n\n\tvar UNCOMPRESSED = 0,\n\t    DEFLATE = 1,\n\t    LZMA = 2,\n\t    AWD_FIELD_INT8 = 1,\n\t    AWD_FIELD_INT16 = 2,\n\t    AWD_FIELD_INT32 = 3,\n\t    AWD_FIELD_UINT8 = 4,\n\t    AWD_FIELD_UINT16 = 5,\n\t    AWD_FIELD_UINT32 = 6,\n\t    AWD_FIELD_FLOAT32 = 7,\n\t    AWD_FIELD_FLOAT64 = 8,\n\t    AWD_FIELD_BOOL = 21,\n\t    AWD_FIELD_COLOR = 22,\n\t    AWD_FIELD_BADDR = 23,\n\t    AWD_FIELD_STRING = 31,\n\t    AWD_FIELD_BYTEARRAY = 32,\n\t    AWD_FIELD_VECTOR2x1 = 41,\n\t    AWD_FIELD_VECTOR3x1 = 42,\n\t    AWD_FIELD_VECTOR4x1 = 43,\n\t    AWD_FIELD_MTX3x2 = 44,\n\t    AWD_FIELD_MTX3x3 = 45,\n\t    AWD_FIELD_MTX4x3 = 46,\n\t    AWD_FIELD_MTX4x4 = 47,\n\t    BOOL = 21,\n\t    COLOR = 22,\n\t    BADDR = 23,\n\t    INT8 = 1,\n\t    INT16 = 2,\n\t    INT32 = 3,\n\t    UINT8 = 4,\n\t    UINT16 = 5,\n\t    UINT32 = 6,\n\t    FLOAT32 = 7,\n\t    FLOAT64 = 8;\n\n\tvar littleEndian = true;\n\n\tfunction Block() {\n\n\t\tthis.id = 0;\n\t\tthis.data = null;\n\t}\n\n\tfunction AWDProperties() {}\n\n\tAWDProperties.prototype = {\n\t\tset: function set(key, value) {\n\n\t\t\tthis[key] = value;\n\t\t},\n\n\t\tget: function get(key, fallback) {\n\n\t\t\tif (this.hasOwnProperty(key)) {\n\n\t\t\t\treturn this[key];\n\t\t\t} else {\n\n\t\t\t\treturn fallback;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar AWDLoader = function AWDLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\t\tthis.trunk = new THREE.Object3D();\n\n\t\tthis.materialFactory = undefined;\n\n\t\tthis._url = '';\n\t\tthis._baseDir = '';\n\n\t\tthis._data = undefined;\n\t\tthis._ptr = 0;\n\n\t\tthis._version = [];\n\t\tthis._streaming = false;\n\t\tthis._optimized_for_accuracy = false;\n\t\tthis._compression = 0;\n\t\tthis._bodylen = 0xFFFFFFFF;\n\n\t\tthis._blocks = [new Block()];\n\n\t\tthis._accuracyMatrix = false;\n\t\tthis._accuracyGeo = false;\n\t\tthis._accuracyProps = false;\n\t};\n\n\tAWDLoader.prototype = {\n\n\t\tconstructor: AWDLoader,\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tthis._url = url;\n\t\t\tthis._baseDir = url.substr(0, url.lastIndexOf('/') + 1);\n\n\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.load(url, function (text) {\n\n\t\t\t\tonLoad(scope.parse(text));\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tparse: function parse(data) {\n\n\t\t\tvar blen = data.byteLength;\n\n\t\t\tthis._ptr = 0;\n\t\t\tthis._data = new DataView(data);\n\n\t\t\tthis._parseHeader();\n\n\t\t\tif (this._compression != 0) {\n\n\t\t\t\tconsole.error('compressed AWD not supported');\n\t\t\t}\n\n\t\t\tif (!this._streaming && this._bodylen != data.byteLength - this._ptr) {\n\n\t\t\t\tconsole.error('AWDLoader: body len does not match file length', this._bodylen, blen - this._ptr);\n\t\t\t}\n\n\t\t\twhile (this._ptr < blen) {\n\n\t\t\t\tthis.parseNextBlock();\n\t\t\t}\n\n\t\t\treturn this.trunk;\n\t\t},\n\n\t\tparseNextBlock: function parseNextBlock() {\n\n\t\t\tvar assetData,\n\t\t\t    ns,\n\t\t\t    type,\n\t\t\t    len,\n\t\t\t    block,\n\t\t\t    blockId = this.readU32(),\n\t\t\t    ns = this.readU8(),\n\t\t\t    type = this.readU8(),\n\t\t\t    flags = this.readU8(),\n\t\t\t    len = this.readU32();\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 1:\n\t\t\t\t\tassetData = this.parseMeshData(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 22:\n\t\t\t\t\tassetData = this.parseContainer(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 23:\n\t\t\t\t\tassetData = this.parseMeshInstance(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 81:\n\t\t\t\t\tassetData = this.parseMaterial(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 82:\n\t\t\t\t\tassetData = this.parseTexture(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 101:\n\t\t\t\t\tassetData = this.parseSkeleton(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\t//  case 111:\n\t\t\t\t//    assetData = this.parseMeshPoseAnimation(len, true);\n\t\t\t\t//    break;\n\n\t\t\t\tcase 112:\n\t\t\t\t\tassetData = this.parseMeshPoseAnimation(len, false);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 113:\n\t\t\t\t\tassetData = this.parseVertexAnimationSet(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 102:\n\t\t\t\t\tassetData = this.parseSkeletonPose(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 103:\n\t\t\t\t\tassetData = this.parseSkeletonAnimation(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 122:\n\t\t\t\t\tassetData = this.parseAnimatorSet(len);\n\t\t\t\t\tbreak;\n\n\t\t\t\t// case 121:\n\t\t\t\t//  assetData = parseUVAnimation(len);\n\t\t\t\t//  break;\n\n\t\t\t\tdefault:\n\t\t\t\t\t//debug('Ignoring block!',type, len);\n\t\t\t\t\tthis._ptr += len;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// Store block reference for later use\n\t\t\tthis._blocks[blockId] = block = new Block();\n\t\t\tblock.data = assetData;\n\t\t\tblock.id = blockId;\n\t\t},\n\n\t\t_parseHeader: function _parseHeader() {\n\n\t\t\tvar version = this._version,\n\t\t\t    awdmagic = this.readU8() << 16 | this.readU8() << 8 | this.readU8();\n\n\t\t\tif (awdmagic != 4282180) throw new Error(\"AWDLoader - bad magic\");\n\n\t\t\tversion[0] = this.readU8();\n\t\t\tversion[1] = this.readU8();\n\n\t\t\tvar flags = this.readU16();\n\n\t\t\tthis._streaming = (flags & 0x1) == 0x1;\n\n\t\t\tif (version[0] === 2 && version[1] === 1) {\n\n\t\t\t\tthis._accuracyMatrix = (flags & 0x2) === 0x2;\n\t\t\t\tthis._accuracyGeo = (flags & 0x4) === 0x4;\n\t\t\t\tthis._accuracyProps = (flags & 0x8) === 0x8;\n\t\t\t}\n\n\t\t\tthis._geoNrType = this._accuracyGeo ? FLOAT64 : FLOAT32;\n\t\t\tthis._matrixNrType = this._accuracyMatrix ? FLOAT64 : FLOAT32;\n\t\t\tthis._propsNrType = this._accuracyProps ? FLOAT64 : FLOAT32;\n\n\t\t\tthis._optimized_for_accuracy = (flags & 0x2) === 0x2;\n\n\t\t\tthis._compression = this.readU8();\n\t\t\tthis._bodylen = this.readU32();\n\t\t},\n\n\t\tparseContainer: function parseContainer(len) {\n\n\t\t\tvar parent,\n\t\t\t    ctr = new THREE.Object3D(),\n\t\t\t    par_id = this.readU32(),\n\t\t\t    mtx = this.parseMatrix4();\n\n\t\t\tctr.name = this.readUTF();\n\t\t\tctr.applyMatrix(mtx);\n\n\t\t\tparent = this._blocks[par_id].data || this.trunk;\n\t\t\tparent.add(ctr);\n\n\t\t\tthis.parseProperties({\n\t\t\t\t1: this._matrixNrType,\n\t\t\t\t2: this._matrixNrType,\n\t\t\t\t3: this._matrixNrType,\n\t\t\t\t4: UINT8\n\t\t\t});\n\n\t\t\tctr.extra = this.parseUserAttributes();\n\n\t\t\treturn ctr;\n\t\t},\n\n\t\tparseMeshInstance: function parseMeshInstance(len) {\n\n\t\t\tvar name, mesh, geometries, meshLen, meshes, par_id, data_id, mtx, materials, mat, mat_id, num_materials, parent, i;\n\n\t\t\tpar_id = this.readU32();\n\t\t\tmtx = this.parseMatrix4();\n\t\t\tname = this.readUTF();\n\t\t\tdata_id = this.readU32();\n\t\t\tnum_materials = this.readU16();\n\n\t\t\tgeometries = this.getBlock(data_id);\n\n\t\t\tmaterials = [];\n\n\t\t\tfor (i = 0; i < num_materials; i++) {\n\n\t\t\t\tmat_id = this.readU32();\n\t\t\t\tmat = this.getBlock(mat_id);\n\t\t\t\tmaterials.push(mat);\n\t\t\t}\n\n\t\t\tmeshLen = geometries.length;\n\t\t\tmeshes = [];\n\n\t\t\t// TODO : BufferGeometry don't support \"geometryGroups\" for now.\n\t\t\t// so we create sub meshes for each groups\n\t\t\tif (meshLen > 1) {\n\n\t\t\t\tmesh = new THREE.Object3D();\n\t\t\t\tfor (i = 0; i < meshLen; i++) {\n\n\t\t\t\t\tvar sm = new THREE.Mesh(geometries[i]);\n\t\t\t\t\tmeshes.push(sm);\n\t\t\t\t\tmesh.add(sm);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tmesh = new THREE.Mesh(geometries[0]);\n\t\t\t\tmeshes.push(mesh);\n\t\t\t}\n\n\t\t\tmesh.applyMatrix(mtx);\n\t\t\tmesh.name = name;\n\n\t\t\tparent = this.getBlock(par_id) || this.trunk;\n\t\t\tparent.add(mesh);\n\n\t\t\tvar matLen = materials.length;\n\t\t\tvar maxLen = Math.max(meshLen, matLen);\n\t\t\tfor (i = 0; i < maxLen; i++) {\n\t\t\t\tmeshes[i % meshLen].material = materials[i % matLen];\n\t\t\t} // Ignore for now\n\t\t\tthis.parseProperties(null);\n\t\t\tmesh.extra = this.parseUserAttributes();\n\n\t\t\treturn mesh;\n\t\t},\n\n\t\tparseMaterial: function parseMaterial(len) {\n\n\t\t\tvar name, type, props, mat, attributes, finalize, num_methods, methods_parsed;\n\n\t\t\tname = this.readUTF();\n\t\t\ttype = this.readU8();\n\t\t\tnum_methods = this.readU8();\n\n\t\t\t//log( \"AWDLoader parseMaterial \",name )\n\n\t\t\t// Read material numerical properties\n\t\t\t// (1=color, 2=bitmap url, 11=alpha_blending, 12=alpha_threshold, 13=repeat)\n\t\t\tprops = this.parseProperties({\n\t\t\t\t1: AWD_FIELD_INT32,\n\t\t\t\t2: AWD_FIELD_BADDR,\n\t\t\t\t11: AWD_FIELD_BOOL,\n\t\t\t\t12: AWD_FIELD_FLOAT32,\n\t\t\t\t13: AWD_FIELD_BOOL\n\t\t\t});\n\n\t\t\tmethods_parsed = 0;\n\n\t\t\twhile (methods_parsed < num_methods) {\n\n\t\t\t\tvar method_type = this.readU16();\n\t\t\t\tthis.parseProperties(null);\n\t\t\t\tthis.parseUserAttributes();\n\t\t\t}\n\n\t\t\tattributes = this.parseUserAttributes();\n\n\t\t\tif (this.materialFactory !== undefined) {\n\n\t\t\t\tmat = this.materialFactory(name);\n\t\t\t\tif (mat) return mat;\n\t\t\t}\n\n\t\t\tmat = new THREE.MeshPhongMaterial();\n\n\t\t\tif (type === 1) {\n\n\t\t\t\t// Color material\n\t\t\t\tmat.color.setHex(props.get(1, 0xcccccc));\n\t\t\t} else if (type === 2) {\n\n\t\t\t\t// Bitmap material\n\t\t\t\tvar tex_addr = props.get(2, 0);\n\t\t\t\tmat.map = this.getBlock(tex_addr);\n\t\t\t}\n\n\t\t\tmat.extra = attributes;\n\t\t\tmat.alphaThreshold = props.get(12, 0.0);\n\t\t\tmat.repeat = props.get(13, false);\n\n\t\t\treturn mat;\n\t\t},\n\n\t\tparseTexture: function parseTexture(len) {\n\n\t\t\tvar name = this.readUTF(),\n\t\t\t    type = this.readU8(),\n\t\t\t    asset,\n\t\t\t    data_len;\n\n\t\t\t// External\n\t\t\tif (type === 0) {\n\n\t\t\t\tdata_len = this.readU32();\n\t\t\t\tvar url = this.readUTFBytes(data_len);\n\t\t\t\tconsole.log(url);\n\n\t\t\t\tasset = this.loadTexture(url);\n\t\t\t} else {}\n\t\t\t// embed texture not supported\n\n\t\t\t// Ignore for now\n\t\t\tthis.parseProperties(null);\n\n\t\t\tthis.parseUserAttributes();\n\t\t\treturn asset;\n\t\t},\n\n\t\tloadTexture: function loadTexture(url) {\n\n\t\t\tvar tex = new THREE.Texture();\n\n\t\t\tvar loader = new THREE.ImageLoader(this.manager);\n\n\t\t\tloader.load(this._baseDir + url, function (image) {\n\n\t\t\t\ttex.image = image;\n\t\t\t\ttex.needsUpdate = true;\n\t\t\t});\n\n\t\t\treturn tex;\n\t\t},\n\n\t\tparseSkeleton: function parseSkeleton(len) {\n\n\t\t\t// Array<Bone>\n\t\t\tvar name = this.readUTF(),\n\t\t\t    num_joints = this.readU16(),\n\t\t\t    skeleton = [],\n\t\t\t    joints_parsed = 0;\n\n\t\t\tthis.parseProperties(null);\n\n\t\t\twhile (joints_parsed < num_joints) {\n\n\t\t\t\tvar joint, ibp;\n\n\t\t\t\t// Ignore joint id\n\t\t\t\tthis.readU16();\n\n\t\t\t\tjoint = new THREE.Bone();\n\t\t\t\tjoint.parent = this.readU16() - 1; // 0=null in AWD\n\t\t\t\tjoint.name = this.readUTF();\n\n\t\t\t\tibp = this.parseMatrix4();\n\t\t\t\tjoint.skinMatrix = ibp;\n\n\t\t\t\t// Ignore joint props/attributes for now\n\t\t\t\tthis.parseProperties(null);\n\t\t\t\tthis.parseUserAttributes();\n\n\t\t\t\tskeleton.push(joint);\n\t\t\t\tjoints_parsed++;\n\t\t\t}\n\n\t\t\t// Discard attributes for now\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn skeleton;\n\t\t},\n\n\t\tparseSkeletonPose: function parseSkeletonPose(blockID) {\n\n\t\t\tvar name = this.readUTF();\n\n\t\t\tvar num_joints = this.readU16();\n\t\t\tthis.parseProperties(null);\n\n\t\t\t// debug( 'parse Skeleton Pose. joints : ' + num_joints);\n\n\t\t\tvar pose = [];\n\n\t\t\tvar joints_parsed = 0;\n\n\t\t\twhile (joints_parsed < num_joints) {\n\n\t\t\t\tvar joint_pose;\n\n\t\t\t\tvar has_transform; //:uint;\n\t\t\t\tvar mtx_data;\n\n\t\t\t\thas_transform = this.readU8();\n\n\t\t\t\tif (has_transform === 1) {\n\n\t\t\t\t\tmtx_data = this.parseMatrix4();\n\t\t\t\t} else {\n\n\t\t\t\t\tmtx_data = new THREE.Matrix4();\n\t\t\t\t}\n\t\t\t\tpose[joints_parsed] = mtx_data;\n\t\t\t\tjoints_parsed++;\n\t\t\t}\n\n\t\t\t// Skip attributes for now\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn pose;\n\t\t},\n\n\t\tparseSkeletonAnimation: function parseSkeletonAnimation(blockID) {\n\n\t\t\tvar frame_dur;\n\t\t\tvar pose_addr;\n\t\t\tvar pose;\n\n\t\t\tvar name = this.readUTF();\n\n\t\t\tvar clip = [];\n\n\t\t\tvar num_frames = this.readU16();\n\t\t\tthis.parseProperties(null);\n\n\t\t\tvar frames_parsed = 0;\n\t\t\tvar returnedArray;\n\n\t\t\t// debug( 'parse Skeleton Animation. frames : ' + num_frames);\n\n\t\t\twhile (frames_parsed < num_frames) {\n\n\t\t\t\tpose_addr = this.readU32();\n\t\t\t\tframe_dur = this.readU16();\n\n\t\t\t\tpose = this._blocks[pose_addr].data;\n\t\t\t\t// debug( 'pose address ',pose[2].elements[12],pose[2].elements[13],pose[2].elements[14] );\n\t\t\t\tclip.push({\n\t\t\t\t\tpose: pose,\n\t\t\t\t\tduration: frame_dur\n\t\t\t\t});\n\n\t\t\t\tframes_parsed++;\n\t\t\t}\n\n\t\t\tif (clip.length === 0) {\n\n\t\t\t\t// debug(\"Could not this SkeletonClipNode, because no Frames where set.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Ignore attributes for now\n\t\t\tthis.parseUserAttributes();\n\t\t\treturn clip;\n\t\t},\n\n\t\tparseVertexAnimationSet: function parseVertexAnimationSet(len) {\n\n\t\t\tvar poseBlockAdress,\n\t\t\t    name = this.readUTF(),\n\t\t\t    num_frames = this.readU16(),\n\t\t\t    props = this.parseProperties({ 1: UINT16 }),\n\t\t\t    frames_parsed = 0,\n\t\t\t    skeletonFrames = [];\n\n\t\t\twhile (frames_parsed < num_frames) {\n\n\t\t\t\tposeBlockAdress = this.readU32();\n\t\t\t\tskeletonFrames.push(this._blocks[poseBlockAdress].data);\n\t\t\t\tframes_parsed++;\n\t\t\t}\n\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn skeletonFrames;\n\t\t},\n\n\t\tparseAnimatorSet: function parseAnimatorSet(len) {\n\n\t\t\tvar targetMesh;\n\n\t\t\tvar animSetBlockAdress; //:int\n\n\t\t\tvar targetAnimationSet; //:AnimationSetBase;\n\t\t\tvar outputString = \"\"; //:String = \"\";\n\t\t\tvar name = this.readUTF();\n\t\t\tvar type = this.readU16();\n\n\t\t\tvar props = this.parseProperties({ 1: BADDR });\n\n\t\t\tanimSetBlockAdress = this.readU32();\n\t\t\tvar targetMeshLength = this.readU16();\n\n\t\t\tvar meshAdresses = []; //:Vector.<uint> = new Vector.<uint>;\n\n\t\t\tfor (var i = 0; i < targetMeshLength; i++) {\n\t\t\t\tmeshAdresses.push(this.readU32());\n\t\t\t}var activeState = this.readU16();\n\t\t\tvar autoplay = Boolean(this.readU8());\n\t\t\tthis.parseUserAttributes();\n\t\t\tthis.parseUserAttributes();\n\n\t\t\tvar returnedArray;\n\t\t\tvar targetMeshes = []; //:Vector.<Mesh> = new Vector.<Mesh>;\n\n\t\t\tfor (i = 0; i < meshAdresses.length; i++) {\n\n\t\t\t\t//      returnedArray = getAssetByID(meshAdresses[i], [AssetType.MESH]);\n\t\t\t\t//      if (returnedArray[0])\n\t\t\t\ttargetMeshes.push(this._blocks[meshAdresses[i]].data);\n\t\t\t}\n\n\t\t\ttargetAnimationSet = this._blocks[animSetBlockAdress].data;\n\t\t\tvar thisAnimator;\n\n\t\t\tif (type == 1) {\n\n\t\t\t\tthisAnimator = {\n\t\t\t\t\tanimationSet: targetAnimationSet,\n\t\t\t\t\tskeleton: this._blocks[props.get(1, 0)].data\n\t\t\t\t};\n\t\t\t} else if (type == 2) {\n\t\t\t\t// debug( \"vertex Anim???\");\n\t\t\t}\n\n\t\t\tfor (i = 0; i < targetMeshes.length; i++) {\n\n\t\t\t\ttargetMeshes[i].animator = thisAnimator;\n\t\t\t}\n\t\t\t// debug(\"Parsed a Animator: Name = \" + name);\n\n\t\t\treturn thisAnimator;\n\t\t},\n\n\t\tparseMeshData: function parseMeshData(len) {\n\n\t\t\tvar name = this.readUTF(),\n\t\t\t    num_subs = this.readU16(),\n\t\t\t    geom,\n\t\t\t    subs_parsed = 0,\n\t\t\t    buffer,\n\t\t\t    skinW,\n\t\t\t    skinI,\n\t\t\t    geometries = [];\n\n\t\t\t// Ignore for now\n\t\t\tthis.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });\n\n\t\t\t// Loop through sub meshes\n\t\t\twhile (subs_parsed < num_subs) {\n\n\t\t\t\tvar sm_len, sm_end, attrib;\n\n\t\t\t\tgeom = new THREE.BufferGeometry();\n\t\t\t\tgeom.name = name;\n\t\t\t\tgeometries.push(geom);\n\n\t\t\t\tsm_len = this.readU32();\n\t\t\t\tsm_end = this._ptr + sm_len;\n\n\t\t\t\t// Ignore for now\n\t\t\t\tthis.parseProperties({ 1: this._geoNrType, 2: this._geoNrType });\n\n\t\t\t\t// Loop through data streams\n\t\t\t\twhile (this._ptr < sm_end) {\n\n\t\t\t\t\tvar idx = 0,\n\t\t\t\t\t    str_type = this.readU8(),\n\t\t\t\t\t    str_ftype = this.readU8(),\n\t\t\t\t\t    str_len = this.readU32(),\n\t\t\t\t\t    str_end = str_len + this._ptr;\n\n\t\t\t\t\tif (str_type === 1) {\n\n\t\t\t\t\t\t// VERTICES\n\n\t\t\t\t\t\tbuffer = new Float32Array(str_len / 12 * 3);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 3);\n\n\t\t\t\t\t\tgeom.addAttribute('position', attrib);\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx] = -this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 1] = this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 2] = this.readF32();\n\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (str_type === 2) {\n\n\t\t\t\t\t\t// INDICES\n\n\t\t\t\t\t\tbuffer = new Uint16Array(str_len / 2);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 1);\n\t\t\t\t\t\tgeom.setIndex(attrib);\n\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx + 1] = this.readU16();\n\t\t\t\t\t\t\tbuffer[idx] = this.readU16();\n\t\t\t\t\t\t\tbuffer[idx + 2] = this.readU16();\n\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (str_type === 3) {\n\n\t\t\t\t\t\t// UVS\n\n\t\t\t\t\t\tbuffer = new Float32Array(str_len / 8 * 2);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 2);\n\n\t\t\t\t\t\tgeom.addAttribute('uv', attrib);\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx] = this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 1] = 1.0 - this.readF32();\n\t\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (str_type === 4) {\n\n\t\t\t\t\t\t// NORMALS\n\n\t\t\t\t\t\tbuffer = new Float32Array(str_len / 12 * 3);\n\t\t\t\t\t\tattrib = new THREE.BufferAttribute(buffer, 3);\n\t\t\t\t\t\tgeom.addAttribute('normal', attrib);\n\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\tbuffer[idx] = -this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 1] = this.readF32();\n\t\t\t\t\t\t\tbuffer[idx + 2] = this.readF32();\n\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._ptr = str_end;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.parseUserAttributes();\n\n\t\t\t\tgeom.computeBoundingSphere();\n\t\t\t\tsubs_parsed++;\n\t\t\t}\n\n\t\t\t//geom.computeFaceNormals();\n\n\t\t\tthis.parseUserAttributes();\n\t\t\t//finalizeAsset(geom, name);\n\n\t\t\treturn geometries;\n\t\t},\n\n\t\tparseMeshPoseAnimation: function parseMeshPoseAnimation(len, poseOnly) {\n\n\t\t\tvar num_frames = 1,\n\t\t\t    num_submeshes,\n\t\t\t    frames_parsed,\n\t\t\t    subMeshParsed,\n\t\t\t    frame_dur,\n\t\t\t    x,\n\t\t\t    y,\n\t\t\t    z,\n\t\t\t    str_len,\n\t\t\t    str_end,\n\t\t\t    geom,\n\t\t\t    subGeom,\n\t\t\t    idx = 0,\n\t\t\t    clip = {},\n\t\t\t    indices,\n\t\t\t    verts,\n\t\t\t    num_Streams,\n\t\t\t    streamsParsed,\n\t\t\t    streamtypes = [],\n\t\t\t    props,\n\t\t\t    thisGeo,\n\t\t\t    name = this.readUTF(),\n\t\t\t    geoAdress = this.readU32();\n\n\t\t\tvar mesh = this.getBlock(geoAdress);\n\n\t\t\tif (mesh === null) {\n\n\t\t\t\tconsole.log(\"parseMeshPoseAnimation target mesh not found at:\", geoAdress);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tgeom = mesh.geometry;\n\t\t\tgeom.morphTargets = [];\n\n\t\t\tif (!poseOnly) num_frames = this.readU16();\n\n\t\t\tnum_submeshes = this.readU16();\n\t\t\tnum_Streams = this.readU16();\n\n\t\t\t// debug(\"VA num_frames : \", num_frames );\n\t\t\t// debug(\"VA num_submeshes : \", num_submeshes );\n\t\t\t// debug(\"VA numstreams : \", num_Streams );\n\n\t\t\tstreamsParsed = 0;\n\t\t\twhile (streamsParsed < num_Streams) {\n\n\t\t\t\tstreamtypes.push(this.readU16());\n\t\t\t\tstreamsParsed++;\n\t\t\t}\n\t\t\tprops = this.parseProperties({ 1: BOOL, 2: BOOL });\n\n\t\t\tclip.looping = props.get(1, true);\n\t\t\tclip.stitchFinalFrame = props.get(2, false);\n\n\t\t\tframes_parsed = 0;\n\n\t\t\twhile (frames_parsed < num_frames) {\n\n\t\t\t\tframe_dur = this.readU16();\n\t\t\t\tsubMeshParsed = 0;\n\n\t\t\t\twhile (subMeshParsed < num_submeshes) {\n\n\t\t\t\t\tstreamsParsed = 0;\n\t\t\t\t\tstr_len = this.readU32();\n\t\t\t\t\tstr_end = this._ptr + str_len;\n\n\t\t\t\t\twhile (streamsParsed < num_Streams) {\n\n\t\t\t\t\t\tif (streamtypes[streamsParsed] === 1) {\n\n\t\t\t\t\t\t\t//geom.addAttribute( 'morphTarget'+frames_parsed, Float32Array, str_len/12, 3 );\n\t\t\t\t\t\t\tvar buffer = new Float32Array(str_len / 4);\n\t\t\t\t\t\t\tgeom.morphTargets.push({\n\t\t\t\t\t\t\t\tarray: buffer\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t//buffer = geom.attributes['morphTarget'+frames_parsed].array\n\t\t\t\t\t\t\tidx = 0;\n\n\t\t\t\t\t\t\twhile (this._ptr < str_end) {\n\n\t\t\t\t\t\t\t\tbuffer[idx] = this.readF32();\n\t\t\t\t\t\t\t\tbuffer[idx + 1] = this.readF32();\n\t\t\t\t\t\t\t\tbuffer[idx + 2] = this.readF32();\n\t\t\t\t\t\t\t\tidx += 3;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsubMeshParsed++;\n\t\t\t\t\t\t} else this._ptr = str_end;\n\t\t\t\t\t\tstreamsParsed++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tframes_parsed++;\n\t\t\t}\n\n\t\t\tthis.parseUserAttributes();\n\n\t\t\treturn null;\n\t\t},\n\n\t\tgetBlock: function getBlock(id) {\n\n\t\t\treturn this._blocks[id].data;\n\t\t},\n\n\t\tparseMatrix4: function parseMatrix4() {\n\n\t\t\tvar mtx = new THREE.Matrix4();\n\t\t\tvar e = mtx.elements;\n\n\t\t\te[0] = this.readF32();\n\t\t\te[1] = this.readF32();\n\t\t\te[2] = this.readF32();\n\t\t\te[3] = 0.0;\n\t\t\t//e[3] = 0.0;\n\n\t\t\te[4] = this.readF32();\n\t\t\te[5] = this.readF32();\n\t\t\te[6] = this.readF32();\n\t\t\t//e[7] = this.readF32();\n\t\t\te[7] = 0.0;\n\n\t\t\te[8] = this.readF32();\n\t\t\te[9] = this.readF32();\n\t\t\te[10] = this.readF32();\n\t\t\t//e[11] = this.readF32();\n\t\t\te[11] = 0.0;\n\n\t\t\te[12] = -this.readF32();\n\t\t\te[13] = this.readF32();\n\t\t\te[14] = this.readF32();\n\t\t\t//e[15] = this.readF32();\n\t\t\te[15] = 1.0;\n\t\t\treturn mtx;\n\t\t},\n\n\t\tparseProperties: function parseProperties(expected) {\n\n\t\t\tvar list_len = this.readU32();\n\t\t\tvar list_end = this._ptr + list_len;\n\n\t\t\tvar props = new AWDProperties();\n\n\t\t\tif (expected) {\n\n\t\t\t\twhile (this._ptr < list_end) {\n\n\t\t\t\t\tvar key = this.readU16();\n\t\t\t\t\tvar len = this.readU32();\n\t\t\t\t\tvar type;\n\n\t\t\t\t\tif (expected.hasOwnProperty(key)) {\n\n\t\t\t\t\t\ttype = expected[key];\n\t\t\t\t\t\tprops.set(key, this.parseAttrValue(type, len));\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis._ptr += len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn props;\n\t\t},\n\n\t\tparseUserAttributes: function parseUserAttributes() {\n\n\t\t\t// skip for now\n\t\t\tthis._ptr = this.readU32() + this._ptr;\n\t\t\treturn null;\n\t\t},\n\n\t\tparseAttrValue: function parseAttrValue(type, len) {\n\n\t\t\tvar elem_len;\n\t\t\tvar read_func;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase AWD_FIELD_INT8:\n\t\t\t\t\telem_len = 1;\n\t\t\t\t\tread_func = this.readI8;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_INT16:\n\t\t\t\t\telem_len = 2;\n\t\t\t\t\tread_func = this.readI16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_INT32:\n\t\t\t\t\telem_len = 4;\n\t\t\t\t\tread_func = this.readI32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_BOOL:\n\t\t\t\tcase AWD_FIELD_UINT8:\n\t\t\t\t\telem_len = 1;\n\t\t\t\t\tread_func = this.readU8;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_UINT16:\n\t\t\t\t\telem_len = 2;\n\t\t\t\t\tread_func = this.readU16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_UINT32:\n\t\t\t\tcase AWD_FIELD_BADDR:\n\t\t\t\t\telem_len = 4;\n\t\t\t\t\tread_func = this.readU32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_FLOAT32:\n\t\t\t\t\telem_len = 4;\n\t\t\t\t\tread_func = this.readF32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_FLOAT64:\n\t\t\t\t\telem_len = 8;\n\t\t\t\t\tread_func = this.readF64;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase AWD_FIELD_VECTOR2x1:\n\t\t\t\tcase AWD_FIELD_VECTOR3x1:\n\t\t\t\tcase AWD_FIELD_VECTOR4x1:\n\t\t\t\tcase AWD_FIELD_MTX3x2:\n\t\t\t\tcase AWD_FIELD_MTX3x3:\n\t\t\t\tcase AWD_FIELD_MTX4x3:\n\t\t\t\tcase AWD_FIELD_MTX4x4:\n\t\t\t\t\telem_len = 8;\n\t\t\t\t\tread_func = this.readF64;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (elem_len < len) {\n\n\t\t\t\tvar list;\n\t\t\t\tvar num_read;\n\t\t\t\tvar num_elems;\n\n\t\t\t\tlist = [];\n\t\t\t\tnum_read = 0;\n\t\t\t\tnum_elems = len / elem_len;\n\n\t\t\t\twhile (num_read < num_elems) {\n\n\t\t\t\t\tlist.push(read_func.call(this));\n\t\t\t\t\tnum_read++;\n\t\t\t\t}\n\n\t\t\t\treturn list;\n\t\t\t} else {\n\n\t\t\t\treturn read_func.call(this);\n\t\t\t}\n\t\t},\n\n\t\treadU8: function readU8() {\n\n\t\t\treturn this._data.getUint8(this._ptr++);\n\t\t},\n\t\treadI8: function readI8() {\n\n\t\t\treturn this._data.getInt8(this._ptr++);\n\t\t},\n\t\treadU16: function readU16() {\n\n\t\t\tvar a = this._data.getUint16(this._ptr, littleEndian);\n\t\t\tthis._ptr += 2;\n\t\t\treturn a;\n\t\t},\n\t\treadI16: function readI16() {\n\n\t\t\tvar a = this._data.getInt16(this._ptr, littleEndian);\n\t\t\tthis._ptr += 2;\n\t\t\treturn a;\n\t\t},\n\t\treadU32: function readU32() {\n\n\t\t\tvar a = this._data.getUint32(this._ptr, littleEndian);\n\t\t\tthis._ptr += 4;\n\t\t\treturn a;\n\t\t},\n\t\treadI32: function readI32() {\n\n\t\t\tvar a = this._data.getInt32(this._ptr, littleEndian);\n\t\t\tthis._ptr += 4;\n\t\t\treturn a;\n\t\t},\n\t\treadF32: function readF32() {\n\n\t\t\tvar a = this._data.getFloat32(this._ptr, littleEndian);\n\t\t\tthis._ptr += 4;\n\t\t\treturn a;\n\t\t},\n\t\treadF64: function readF64() {\n\n\t\t\tvar a = this._data.getFloat64(this._ptr, littleEndian);\n\t\t\tthis._ptr += 8;\n\t\t\treturn a;\n\t\t},\n\n\t\t/**\n  * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.\n  * @param {Array.<number>} bytes UTF-8 byte array.\n  * @return {string} 16-bit Unicode string.\n  */\n\t\treadUTF: function readUTF() {\n\n\t\t\tvar len = this.readU16();\n\t\t\treturn this.readUTFBytes(len);\n\t\t},\n\n\t\t/**\n   * Converts a UTF-8 byte array to JavaScript's 16-bit Unicode.\n   * @param {Array.<number>} bytes UTF-8 byte array.\n   * @return {string} 16-bit Unicode string.\n   */\n\t\treadUTFBytes: function readUTFBytes(len) {\n\n\t\t\t// TODO(user): Use native implementations if/when available\n\t\t\tvar out = [],\n\t\t\t    c = 0;\n\n\t\t\twhile (out.length < len) {\n\n\t\t\t\tvar c1 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\tif (c1 < 128) {\n\n\t\t\t\t\tout[c++] = String.fromCharCode(c1);\n\t\t\t\t} else if (c1 > 191 && c1 < 224) {\n\n\t\t\t\t\tvar c2 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\t\tout[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);\n\t\t\t\t} else {\n\n\t\t\t\t\tvar c2 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\t\tvar c3 = this._data.getUint8(this._ptr++, littleEndian);\n\t\t\t\t\tout[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out.join('');\n\t\t}\n\n\t};\n\n\treturn AWDLoader;\n}();\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar BabylonLoader = function BabylonLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nBabylonLoader.prototype = {\n\n\tconstructor: BabylonLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(json) {\n\n\t\tfunction parseMaterials(json) {\n\n\t\t\tvar materials = {};\n\n\t\t\tfor (var i = 0, l = json.materials.length; i < l; i++) {\n\n\t\t\t\tvar data = json.materials[i];\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial();\n\t\t\t\tmaterial.name = data.name;\n\t\t\t\tmaterial.color.fromArray(data.diffuse);\n\t\t\t\tmaterial.emissive.fromArray(data.emissive);\n\t\t\t\tmaterial.specular.fromArray(data.specular);\n\t\t\t\tmaterial.shininess = data.specularPower;\n\t\t\t\tmaterial.opacity = data.alpha;\n\n\t\t\t\tmaterials[data.id] = material;\n\t\t\t}\n\n\t\t\tif (json.multiMaterials) {\n\n\t\t\t\tfor (var i = 0, l = json.multiMaterials.length; i < l; i++) {\n\n\t\t\t\t\tvar data = json.multiMaterials[i];\n\n\t\t\t\t\tconsole.warn('THREE.BabylonLoader: Multi materials not yet supported.');\n\n\t\t\t\t\tmaterials[data.id] = new THREE.MeshPhongMaterial();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn materials;\n\t\t}\n\n\t\tfunction parseGeometry(json) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar indices = json.indices;\n\t\t\tvar positions = json.positions;\n\t\t\tvar normals = json.normals;\n\t\t\tvar uvs = json.uvs;\n\n\t\t\t// indices\n\n\t\t\tgeometry.setIndex(indices);\n\n\t\t\t// positions\n\n\t\t\tfor (var j = 2, jl = positions.length; j < jl; j += 3) {\n\n\t\t\t\tpositions[j] = -positions[j];\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n\n\t\t\t// normals\n\n\t\t\tif (normals) {\n\n\t\t\t\tfor (var j = 2, jl = normals.length; j < jl; j += 3) {\n\n\t\t\t\t\tnormals[j] = -normals[j];\n\t\t\t\t}\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif (uvs) {\n\n\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\t\t\t}\n\n\t\t\t// offsets\n\n\t\t\tvar subMeshes = json.subMeshes;\n\n\t\t\tif (subMeshes) {\n\n\t\t\t\tfor (var j = 0, jl = subMeshes.length; j < jl; j++) {\n\n\t\t\t\t\tvar subMesh = subMeshes[j];\n\n\t\t\t\t\tgeometry.addGroup(subMesh.indexStart, subMesh.indexCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseObjects(json, materials) {\n\n\t\t\tvar objects = {};\n\t\t\tvar scene = new THREE.Scene();\n\n\t\t\tvar cameras = json.cameras;\n\n\t\t\tfor (var i = 0, l = cameras.length; i < l; i++) {\n\n\t\t\t\tvar data = cameras[i];\n\n\t\t\t\tvar camera = new THREE.PerspectiveCamera(data.fov / Math.PI * 180, 1.33, data.minZ, data.maxZ);\n\n\t\t\t\tcamera.name = data.name;\n\t\t\t\tcamera.position.fromArray(data.position);\n\t\t\t\tif (data.rotation) camera.rotation.fromArray(data.rotation);\n\n\t\t\t\tobjects[data.id] = camera;\n\t\t\t}\n\n\t\t\tvar lights = json.lights;\n\n\t\t\tfor (var i = 0, l = lights.length; i < l; i++) {\n\n\t\t\t\tvar data = lights[i];\n\n\t\t\t\tvar light;\n\n\t\t\t\tswitch (data.type) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tlight = new THREE.DirectionalLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tlight = new THREE.SpotLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\tlight = new THREE.HemisphereLight();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tlight.name = data.name;\n\t\t\t\tif (data.position) light.position.set(data.position[0], data.position[1], -data.position[2]);\n\t\t\t\tlight.color.fromArray(data.diffuse);\n\t\t\t\tif (data.groundColor) light.groundColor.fromArray(data.groundColor);\n\t\t\t\tif (data.intensity) light.intensity = data.intensity;\n\n\t\t\t\tobjects[data.id] = light;\n\n\t\t\t\tscene.add(light);\n\t\t\t}\n\n\t\t\tvar meshes = json.meshes;\n\n\t\t\tfor (var i = 0, l = meshes.length; i < l; i++) {\n\n\t\t\t\tvar data = meshes[i];\n\n\t\t\t\tvar object;\n\n\t\t\t\tif (data.indices) {\n\n\t\t\t\t\tvar geometry = parseGeometry(data);\n\n\t\t\t\t\tobject = new THREE.Mesh(geometry, materials[data.materialId]);\n\t\t\t\t} else {\n\n\t\t\t\t\tobject = new THREE.Group();\n\t\t\t\t}\n\n\t\t\t\tobject.name = data.name;\n\t\t\t\tobject.position.set(data.position[0], data.position[1], -data.position[2]);\n\t\t\t\tobject.rotation.fromArray(data.rotation);\n\t\t\t\tif (data.rotationQuaternion) object.quaternion.fromArray(data.rotationQuaternion);\n\t\t\t\tobject.scale.fromArray(data.scaling);\n\t\t\t\t// object.visible = data.isVisible;\n\n\t\t\t\tif (data.parentId) {\n\n\t\t\t\t\tobjects[data.parentId].add(object);\n\t\t\t\t} else {\n\n\t\t\t\t\tscene.add(object);\n\t\t\t\t}\n\n\t\t\t\tobjects[data.id] = object;\n\t\t\t}\n\n\t\t\treturn scene;\n\t\t}\n\n\t\tvar materials = parseMaterials(json);\n\t\tvar scene = parseObjects(json, materials);\n\n\t\treturn scene;\n\t}\n\n};\n\nexports.default = BabylonLoader;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar BinaryLoader = function BinaryLoader(manager) {\n\n\tif (typeof manager === 'boolean') {\n\n\t\tconsole.warn('THREE.BinaryLoader: showStatus parameter has been removed from constructor.');\n\t\tmanager = undefined;\n\t}\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nBinaryLoader.prototype = {\n\n\tconstructor: BinaryLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\t// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)\n\t//  - binary models consist of two files: JS and BIN\n\t//  - parameters\n\t//\t\t- url (required)\n\t//\t\t- callback (required)\n\t//\t\t- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)\n\t//\t\t- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t// todo: unify load API to for easier SceneLoader use\n\n\t\tvar texturePath = this.texturePath || THREE.LoaderUtils.extractUrlBase(url);\n\t\tvar binaryPath = this.binaryPath || THREE.LoaderUtils.extractUrlBase(url);\n\n\t\t// #1 load JS part via web worker\n\n\t\tvar scope = this;\n\n\t\tvar jsonloader = new THREE.FileLoader(this.manager);\n\t\tjsonloader.load(url, function (data) {\n\n\t\t\tvar json = JSON.parse(data);\n\n\t\t\tvar bufferUrl = binaryPath + json.buffers;\n\n\t\t\tvar bufferLoader = new THREE.FileLoader(scope.manager);\n\t\t\tbufferLoader.setResponseType('arraybuffer');\n\t\t\tbufferLoader.load(bufferUrl, function (bufData) {\n\n\t\t\t\t// IEWEBGL needs this ???\n\t\t\t\t//buffer = ( new Uint8Array( xhr.responseBody ) ).buffer;\n\n\t\t\t\t//// iOS and other XMLHttpRequest level 1 ???\n\n\t\t\t\tscope.parse(bufData, onLoad, texturePath, json.materials);\n\t\t\t}, onProgress, onError);\n\t\t}, onProgress, onError);\n\t},\n\n\tsetBinaryPath: function setBinaryPath(value) {\n\n\t\tthis.binaryPath = value;\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tsetTexturePath: function setTexturePath(value) {\n\n\t\tthis.texturePath = value;\n\t},\n\n\tparse: function parse(data, callback, texturePath, jsonMaterials) {\n\n\t\tvar Model = function Model() {\n\n\t\t\tvar scope = this,\n\t\t\t    currentOffset = 0,\n\t\t\t    md,\n\t\t\t    normals = [],\n\t\t\t    uvs = [],\n\t\t\t    start_tri_flat,\n\t\t\t    start_tri_smooth,\n\t\t\t    start_tri_flat_uv,\n\t\t\t    start_tri_smooth_uv,\n\t\t\t    start_quad_flat,\n\t\t\t    start_quad_smooth,\n\t\t\t    start_quad_flat_uv,\n\t\t\t    start_quad_smooth_uv,\n\t\t\t    tri_size,\n\t\t\t    quad_size,\n\t\t\t    len_tri_flat,\n\t\t\t    len_tri_smooth,\n\t\t\t    len_tri_flat_uv,\n\t\t\t    len_tri_smooth_uv,\n\t\t\t    len_quad_flat,\n\t\t\t    len_quad_smooth,\n\t\t\t    len_quad_flat_uv;\n\n\t\t\tTHREE.Geometry.call(this);\n\n\t\t\tmd = parseMetaData(data, currentOffset);\n\n\t\t\tcurrentOffset += md.header_bytes;\n\t\t\t/*\n   \t\tmd.vertex_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n   \t\tmd.material_index_bytes = Uint16Array.BYTES_PER_ELEMENT;\n   \t\tmd.normal_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n   \t\tmd.uv_index_bytes = Uint32Array.BYTES_PER_ELEMENT;\n   */\n\t\t\t// buffers sizes\n\n\t\t\ttri_size = md.vertex_index_bytes * 3 + md.material_index_bytes;\n\t\t\tquad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;\n\n\t\t\tlen_tri_flat = md.ntri_flat * tri_size;\n\t\t\tlen_tri_smooth = md.ntri_smooth * (tri_size + md.normal_index_bytes * 3);\n\t\t\tlen_tri_flat_uv = md.ntri_flat_uv * (tri_size + md.uv_index_bytes * 3);\n\t\t\tlen_tri_smooth_uv = md.ntri_smooth_uv * (tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3);\n\n\t\t\tlen_quad_flat = md.nquad_flat * quad_size;\n\t\t\tlen_quad_smooth = md.nquad_smooth * (quad_size + md.normal_index_bytes * 4);\n\t\t\tlen_quad_flat_uv = md.nquad_flat_uv * (quad_size + md.uv_index_bytes * 4);\n\n\t\t\t// read buffers\n\n\t\t\tcurrentOffset += init_vertices(currentOffset);\n\n\t\t\tcurrentOffset += init_normals(currentOffset);\n\t\t\tcurrentOffset += handlePadding(md.nnormals * 3);\n\n\t\t\tcurrentOffset += init_uvs(currentOffset);\n\n\t\t\tstart_tri_flat = currentOffset;\n\t\t\tstart_tri_smooth = start_tri_flat + len_tri_flat + handlePadding(md.ntri_flat * 2);\n\t\t\tstart_tri_flat_uv = start_tri_smooth + len_tri_smooth + handlePadding(md.ntri_smooth * 2);\n\t\t\tstart_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding(md.ntri_flat_uv * 2);\n\n\t\t\tstart_quad_flat = start_tri_smooth_uv + len_tri_smooth_uv + handlePadding(md.ntri_smooth_uv * 2);\n\t\t\tstart_quad_smooth = start_quad_flat + len_quad_flat + handlePadding(md.nquad_flat * 2);\n\t\t\tstart_quad_flat_uv = start_quad_smooth + len_quad_smooth + handlePadding(md.nquad_smooth * 2);\n\t\t\tstart_quad_smooth_uv = start_quad_flat_uv + len_quad_flat_uv + handlePadding(md.nquad_flat_uv * 2);\n\n\t\t\t// have to first process faces with uvs\n\t\t\t// so that face and uv indices match\n\n\t\t\tinit_triangles_flat_uv(start_tri_flat_uv);\n\t\t\tinit_triangles_smooth_uv(start_tri_smooth_uv);\n\n\t\t\tinit_quads_flat_uv(start_quad_flat_uv);\n\t\t\tinit_quads_smooth_uv(start_quad_smooth_uv);\n\n\t\t\t// now we can process untextured faces\n\n\t\t\tinit_triangles_flat(start_tri_flat);\n\t\t\tinit_triangles_smooth(start_tri_smooth);\n\n\t\t\tinit_quads_flat(start_quad_flat);\n\t\t\tinit_quads_smooth(start_quad_smooth);\n\n\t\t\tthis.computeFaceNormals();\n\n\t\t\tfunction handlePadding(n) {\n\n\t\t\t\treturn n % 4 ? 4 - n % 4 : 0;\n\t\t\t}\n\n\t\t\tfunction parseMetaData(data, offset) {\n\n\t\t\t\tvar metaData = {\n\n\t\t\t\t\t'signature': parseString(data, offset, 12),\n\t\t\t\t\t'header_bytes': parseUChar8(data, offset + 12),\n\n\t\t\t\t\t'vertex_coordinate_bytes': parseUChar8(data, offset + 13),\n\t\t\t\t\t'normal_coordinate_bytes': parseUChar8(data, offset + 14),\n\t\t\t\t\t'uv_coordinate_bytes': parseUChar8(data, offset + 15),\n\n\t\t\t\t\t'vertex_index_bytes': parseUChar8(data, offset + 16),\n\t\t\t\t\t'normal_index_bytes': parseUChar8(data, offset + 17),\n\t\t\t\t\t'uv_index_bytes': parseUChar8(data, offset + 18),\n\t\t\t\t\t'material_index_bytes': parseUChar8(data, offset + 19),\n\n\t\t\t\t\t'nvertices': parseUInt32(data, offset + 20),\n\t\t\t\t\t'nnormals': parseUInt32(data, offset + 20 + 4 * 1),\n\t\t\t\t\t'nuvs': parseUInt32(data, offset + 20 + 4 * 2),\n\n\t\t\t\t\t'ntri_flat': parseUInt32(data, offset + 20 + 4 * 3),\n\t\t\t\t\t'ntri_smooth': parseUInt32(data, offset + 20 + 4 * 4),\n\t\t\t\t\t'ntri_flat_uv': parseUInt32(data, offset + 20 + 4 * 5),\n\t\t\t\t\t'ntri_smooth_uv': parseUInt32(data, offset + 20 + 4 * 6),\n\n\t\t\t\t\t'nquad_flat': parseUInt32(data, offset + 20 + 4 * 7),\n\t\t\t\t\t'nquad_smooth': parseUInt32(data, offset + 20 + 4 * 8),\n\t\t\t\t\t'nquad_flat_uv': parseUInt32(data, offset + 20 + 4 * 9),\n\t\t\t\t\t'nquad_smooth_uv': parseUInt32(data, offset + 20 + 4 * 10)\n\n\t\t\t\t};\n\t\t\t\t/*\n    \t\t\tconsole.log( \"signature: \" + metaData.signature );\n    \t\t\t\tconsole.log( \"header_bytes: \" + metaData.header_bytes );\n    \t\t\tconsole.log( \"vertex_coordinate_bytes: \" + metaData.vertex_coordinate_bytes );\n    \t\t\tconsole.log( \"normal_coordinate_bytes: \" + metaData.normal_coordinate_bytes );\n    \t\t\tconsole.log( \"uv_coordinate_bytes: \" + metaData.uv_coordinate_bytes );\n    \t\t\t\tconsole.log( \"vertex_index_bytes: \" + metaData.vertex_index_bytes );\n    \t\t\tconsole.log( \"normal_index_bytes: \" + metaData.normal_index_bytes );\n    \t\t\tconsole.log( \"uv_index_bytes: \" + metaData.uv_index_bytes );\n    \t\t\tconsole.log( \"material_index_bytes: \" + metaData.material_index_bytes );\n    \t\t\t\tconsole.log( \"nvertices: \" + metaData.nvertices );\n    \t\t\tconsole.log( \"nnormals: \" + metaData.nnormals );\n    \t\t\tconsole.log( \"nuvs: \" + metaData.nuvs );\n    \t\t\t\tconsole.log( \"ntri_flat: \" + metaData.ntri_flat );\n    \t\t\tconsole.log( \"ntri_smooth: \" + metaData.ntri_smooth );\n    \t\t\tconsole.log( \"ntri_flat_uv: \" + metaData.ntri_flat_uv );\n    \t\t\tconsole.log( \"ntri_smooth_uv: \" + metaData.ntri_smooth_uv );\n    \t\t\t\tconsole.log( \"nquad_flat: \" + metaData.nquad_flat );\n    \t\t\tconsole.log( \"nquad_smooth: \" + metaData.nquad_smooth );\n    \t\t\tconsole.log( \"nquad_flat_uv: \" + metaData.nquad_flat_uv );\n    \t\t\tconsole.log( \"nquad_smooth_uv: \" + metaData.nquad_smooth_uv );\n    \t\t\t\tvar total = metaData.header_bytes\n    \t\t\t\t\t  + metaData.nvertices * metaData.vertex_coordinate_bytes * 3\n    \t\t\t\t\t  + metaData.nnormals * metaData.normal_coordinate_bytes * 3\n    \t\t\t\t\t  + metaData.nuvs * metaData.uv_coordinate_bytes * 2\n    \t\t\t\t\t  + metaData.ntri_flat * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes )\n    \t\t\t\t\t  + metaData.ntri_smooth * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 )\n    \t\t\t\t\t  + metaData.ntri_flat_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.uv_index_bytes*3 )\n    \t\t\t\t\t  + metaData.ntri_smooth_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 + metaData.uv_index_bytes*3 )\n    \t\t\t\t\t  + metaData.nquad_flat * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes )\n    \t\t\t\t\t  + metaData.nquad_smooth * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 )\n    \t\t\t\t\t  + metaData.nquad_flat_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.uv_index_bytes*4 )\n    \t\t\t\t\t  + metaData.nquad_smooth_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 + metaData.uv_index_bytes*4 );\n    \t\t\tconsole.log( \"total bytes: \" + total );\n    */\n\n\t\t\t\treturn metaData;\n\t\t\t}\n\n\t\t\tfunction parseString(data, offset, length) {\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(data, offset, length));\n\t\t\t}\n\n\t\t\tfunction parseUChar8(data, offset) {\n\n\t\t\t\tvar charArray = new Uint8Array(data, offset, 1);\n\n\t\t\t\treturn charArray[0];\n\t\t\t}\n\n\t\t\tfunction parseUInt32(data, offset) {\n\n\t\t\t\tvar intArray = new Uint32Array(data, offset, 1);\n\n\t\t\t\treturn intArray[0];\n\t\t\t}\n\n\t\t\tfunction init_vertices(start) {\n\n\t\t\t\tvar nElements = md.nvertices;\n\n\t\t\t\tvar coordArray = new Float32Array(data, start, nElements * 3);\n\n\t\t\t\tvar i, x, y, z;\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\tx = coordArray[i * 3];\n\t\t\t\t\ty = coordArray[i * 3 + 1];\n\t\t\t\t\tz = coordArray[i * 3 + 2];\n\n\t\t\t\t\tscope.vertices.push(new THREE.Vector3(x, y, z));\n\t\t\t\t}\n\n\t\t\t\treturn nElements * 3 * Float32Array.BYTES_PER_ELEMENT;\n\t\t\t}\n\n\t\t\tfunction init_normals(start) {\n\n\t\t\t\tvar nElements = md.nnormals;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar normalArray = new Int8Array(data, start, nElements * 3);\n\n\t\t\t\t\tvar i, x, y, z;\n\n\t\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\t\tx = normalArray[i * 3];\n\t\t\t\t\t\ty = normalArray[i * 3 + 1];\n\t\t\t\t\t\tz = normalArray[i * 3 + 2];\n\n\t\t\t\t\t\tnormals.push(x / 127, y / 127, z / 127);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nElements * 3 * Int8Array.BYTES_PER_ELEMENT;\n\t\t\t}\n\n\t\t\tfunction init_uvs(start) {\n\n\t\t\t\tvar nElements = md.nuvs;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar uvArray = new Float32Array(data, start, nElements * 2);\n\n\t\t\t\t\tvar i, u, v;\n\n\t\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\t\tu = uvArray[i * 2];\n\t\t\t\t\t\tv = uvArray[i * 2 + 1];\n\n\t\t\t\t\t\tuvs.push(u, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn nElements * 2 * Float32Array.BYTES_PER_ELEMENT;\n\t\t\t}\n\n\t\t\tfunction init_uvs3(nElements, offset) {\n\n\t\t\t\tvar i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;\n\n\t\t\t\tvar uvIndexBuffer = new Uint32Array(data, offset, 3 * nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\tuva = uvIndexBuffer[i * 3];\n\t\t\t\t\tuvb = uvIndexBuffer[i * 3 + 1];\n\t\t\t\t\tuvc = uvIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tu1 = uvs[uva * 2];\n\t\t\t\t\tv1 = uvs[uva * 2 + 1];\n\n\t\t\t\t\tu2 = uvs[uvb * 2];\n\t\t\t\t\tv2 = uvs[uvb * 2 + 1];\n\n\t\t\t\t\tu3 = uvs[uvc * 2];\n\t\t\t\t\tv3 = uvs[uvc * 2 + 1];\n\n\t\t\t\t\tscope.faceVertexUvs[0].push([new THREE.Vector2(u1, v1), new THREE.Vector2(u2, v2), new THREE.Vector2(u3, v3)]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_uvs4(nElements, offset) {\n\n\t\t\t\tvar i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;\n\n\t\t\t\tvar uvIndexBuffer = new Uint32Array(data, offset, 4 * nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\tuva = uvIndexBuffer[i * 4];\n\t\t\t\t\tuvb = uvIndexBuffer[i * 4 + 1];\n\t\t\t\t\tuvc = uvIndexBuffer[i * 4 + 2];\n\t\t\t\t\tuvd = uvIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tu1 = uvs[uva * 2];\n\t\t\t\t\tv1 = uvs[uva * 2 + 1];\n\n\t\t\t\t\tu2 = uvs[uvb * 2];\n\t\t\t\t\tv2 = uvs[uvb * 2 + 1];\n\n\t\t\t\t\tu3 = uvs[uvc * 2];\n\t\t\t\t\tv3 = uvs[uvc * 2 + 1];\n\n\t\t\t\t\tu4 = uvs[uvd * 2];\n\t\t\t\t\tv4 = uvs[uvd * 2 + 1];\n\n\t\t\t\t\tscope.faceVertexUvs[0].push([new THREE.Vector2(u1, v1), new THREE.Vector2(u2, v2), new THREE.Vector2(u4, v4)]);\n\n\t\t\t\t\tscope.faceVertexUvs[0].push([new THREE.Vector2(u2, v2), new THREE.Vector2(u3, v3), new THREE.Vector2(u4, v4)]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces3_flat(nElements, offsetVertices, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, m;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 3 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 3];\n\t\t\t\t\tb = vertexIndexBuffer[i * 3 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, c, null, null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces4_flat(nElements, offsetVertices, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, d, m;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 4 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 4];\n\t\t\t\t\tb = vertexIndexBuffer[i * 4 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 4 + 2];\n\t\t\t\t\td = vertexIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, d, null, null, m));\n\t\t\t\t\tscope.faces.push(new THREE.Face3(b, c, d, null, null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces3_smooth(nElements, offsetVertices, offsetNormals, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, m;\n\t\t\t\tvar na, nb, nc;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 3 * nElements);\n\t\t\t\tvar normalIndexBuffer = new Uint32Array(data, offsetNormals, 3 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 3];\n\t\t\t\t\tb = vertexIndexBuffer[i * 3 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tna = normalIndexBuffer[i * 3];\n\t\t\t\t\tnb = normalIndexBuffer[i * 3 + 1];\n\t\t\t\t\tnc = normalIndexBuffer[i * 3 + 2];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tvar nax = normals[na * 3],\n\t\t\t\t\t    nay = normals[na * 3 + 1],\n\t\t\t\t\t    naz = normals[na * 3 + 2],\n\t\t\t\t\t    nbx = normals[nb * 3],\n\t\t\t\t\t    nby = normals[nb * 3 + 1],\n\t\t\t\t\t    nbz = normals[nb * 3 + 2],\n\t\t\t\t\t    ncx = normals[nc * 3],\n\t\t\t\t\t    ncy = normals[nc * 3 + 1],\n\t\t\t\t\t    ncz = normals[nc * 3 + 2];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, c, [new THREE.Vector3(nax, nay, naz), new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ncx, ncy, ncz)], null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_faces4_smooth(nElements, offsetVertices, offsetNormals, offsetMaterials) {\n\n\t\t\t\tvar i, a, b, c, d, m;\n\t\t\t\tvar na, nb, nc, nd;\n\n\t\t\t\tvar vertexIndexBuffer = new Uint32Array(data, offsetVertices, 4 * nElements);\n\t\t\t\tvar normalIndexBuffer = new Uint32Array(data, offsetNormals, 4 * nElements);\n\t\t\t\tvar materialIndexBuffer = new Uint16Array(data, offsetMaterials, nElements);\n\n\t\t\t\tfor (i = 0; i < nElements; i++) {\n\n\t\t\t\t\ta = vertexIndexBuffer[i * 4];\n\t\t\t\t\tb = vertexIndexBuffer[i * 4 + 1];\n\t\t\t\t\tc = vertexIndexBuffer[i * 4 + 2];\n\t\t\t\t\td = vertexIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tna = normalIndexBuffer[i * 4];\n\t\t\t\t\tnb = normalIndexBuffer[i * 4 + 1];\n\t\t\t\t\tnc = normalIndexBuffer[i * 4 + 2];\n\t\t\t\t\tnd = normalIndexBuffer[i * 4 + 3];\n\n\t\t\t\t\tm = materialIndexBuffer[i];\n\n\t\t\t\t\tvar nax = normals[na * 3],\n\t\t\t\t\t    nay = normals[na * 3 + 1],\n\t\t\t\t\t    naz = normals[na * 3 + 2],\n\t\t\t\t\t    nbx = normals[nb * 3],\n\t\t\t\t\t    nby = normals[nb * 3 + 1],\n\t\t\t\t\t    nbz = normals[nb * 3 + 2],\n\t\t\t\t\t    ncx = normals[nc * 3],\n\t\t\t\t\t    ncy = normals[nc * 3 + 1],\n\t\t\t\t\t    ncz = normals[nc * 3 + 2],\n\t\t\t\t\t    ndx = normals[nd * 3],\n\t\t\t\t\t    ndy = normals[nd * 3 + 1],\n\t\t\t\t\t    ndz = normals[nd * 3 + 2];\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(a, b, d, [new THREE.Vector3(nax, nay, naz), new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ndx, ndy, ndz)], null, m));\n\n\t\t\t\t\tscope.faces.push(new THREE.Face3(b, c, d, [new THREE.Vector3(nbx, nby, nbz), new THREE.Vector3(ncx, ncy, ncz), new THREE.Vector3(ndx, ndy, ndz)], null, m));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_flat(start) {\n\n\t\t\t\tvar nElements = md.ntri_flat;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tinit_faces3_flat(nElements, start, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_flat_uv(start) {\n\n\t\t\t\tvar nElements = md.ntri_flat_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\t\tinit_faces3_flat(nElements, start, offsetMaterials);\n\t\t\t\t\tinit_uvs3(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_smooth(start) {\n\n\t\t\t\tvar nElements = md.ntri_smooth;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\t\tinit_faces3_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_triangles_smooth_uv(start) {\n\n\t\t\t\tvar nElements = md.ntri_smooth_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;\n\n\t\t\t\t\tinit_faces3_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t\tinit_uvs3(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_flat(start) {\n\n\t\t\t\tvar nElements = md.nquad_flat;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tinit_faces4_flat(nElements, start, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_flat_uv(start) {\n\n\t\t\t\tvar nElements = md.nquad_flat_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\t\tinit_faces4_flat(nElements, start, offsetMaterials);\n\t\t\t\t\tinit_uvs4(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_smooth(start) {\n\n\t\t\t\tvar nElements = md.nquad_smooth;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\t\tinit_faces4_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction init_quads_smooth_uv(start) {\n\n\t\t\t\tvar nElements = md.nquad_smooth_uv;\n\n\t\t\t\tif (nElements) {\n\n\t\t\t\t\tvar offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\t\t\t\t\tvar offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;\n\n\t\t\t\t\tinit_faces4_smooth(nElements, start, offsetNormals, offsetMaterials);\n\t\t\t\t\tinit_uvs4(nElements, offsetUvs);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tModel.prototype = Object.create(THREE.Geometry.prototype);\n\t\tModel.prototype.constructor = Model;\n\n\t\tvar geometry = new Model();\n\t\tvar materials = THREE.Loader.prototype.initMaterials(jsonMaterials, texturePath, this.crossOrigin);\n\n\t\tcallback(geometry, materials);\n\t}\n\n};\n\nexports.default = BinaryLoader;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author herzig / http://github.com/herzig\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: reads BVH files and outputs a single THREE.Skeleton and an THREE.AnimationClip\n *\n * Currently only supports bvh files containing a single root.\n *\n */\n\nvar BVHLoader = function BVHLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.animateBonePositions = true;\n\tthis.animateBoneRotations = true;\n};\n\nBVHLoader.prototype = {\n\n\tconstructor: BVHLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(text) {\n\n\t\t/*\n  \treads a string array (lines) from a BVH file\n  \tand outputs a skeleton structure including motion data\n  \t\treturns thee root node:\n  \t{ name: '', channels: [], children: [] }\n  */\n\t\tfunction readBvh(lines) {\n\n\t\t\t// read model structure\n\n\t\t\tif (nextLine(lines) !== 'HIERARCHY') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: HIERARCHY expected.');\n\t\t\t}\n\n\t\t\tvar list = []; // collects flat array of all bones\n\t\t\tvar root = readNode(lines, nextLine(lines), list);\n\n\t\t\t// read motion data\n\n\t\t\tif (nextLine(lines) !== 'MOTION') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: MOTION expected.');\n\t\t\t}\n\n\t\t\t// number of frames\n\n\t\t\tvar tokens = nextLine(lines).split(/[\\s]+/);\n\t\t\tvar numFrames = parseInt(tokens[1]);\n\n\t\t\tif (isNaN(numFrames)) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Failed to read number of frames.');\n\t\t\t}\n\n\t\t\t// frame time\n\n\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\t\t\tvar frameTime = parseFloat(tokens[2]);\n\n\t\t\tif (isNaN(frameTime)) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Failed to read frame time.');\n\t\t\t}\n\n\t\t\t// read frame data line by line\n\n\t\t\tfor (var i = 0; i < numFrames; i++) {\n\n\t\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\t\t\t\treadFrameData(tokens, i * frameTime, root);\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\t/*\n  \tRecursively reads data from a single frame into the bone hierarchy.\n  \tThe passed bone hierarchy has to be structured in the same order as the BVH file.\n  \tkeyframe data is stored in bone.frames.\n  \t\t- data: splitted string array (frame values), values are shift()ed so\n  \tthis should be empty after parsing the whole hierarchy.\n  \t- frameTime: playback time for this keyframe.\n  \t- bone: the bone to read frame data from.\n  */\n\t\tfunction readFrameData(data, frameTime, bone) {\n\n\t\t\t// end sites have no motion data\n\n\t\t\tif (bone.type === 'ENDSITE') return;\n\n\t\t\t// add keyframe\n\n\t\t\tvar keyframe = {\n\t\t\t\ttime: frameTime,\n\t\t\t\tposition: new THREE.Vector3(),\n\t\t\t\trotation: new THREE.Quaternion()\n\t\t\t};\n\n\t\t\tbone.frames.push(keyframe);\n\n\t\t\tvar quat = new THREE.Quaternion();\n\n\t\t\tvar vx = new THREE.Vector3(1, 0, 0);\n\t\t\tvar vy = new THREE.Vector3(0, 1, 0);\n\t\t\tvar vz = new THREE.Vector3(0, 0, 1);\n\n\t\t\t// parse values for each channel in node\n\n\t\t\tfor (var i = 0; i < bone.channels.length; i++) {\n\n\t\t\t\tswitch (bone.channels[i]) {\n\n\t\t\t\t\tcase 'Xposition':\n\t\t\t\t\t\tkeyframe.position.x = parseFloat(data.shift().trim());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yposition':\n\t\t\t\t\t\tkeyframe.position.y = parseFloat(data.shift().trim());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zposition':\n\t\t\t\t\t\tkeyframe.position.z = parseFloat(data.shift().trim());\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Xrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle(vx, parseFloat(data.shift().trim()) * Math.PI / 180);\n\t\t\t\t\t\tkeyframe.rotation.multiply(quat);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Yrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle(vy, parseFloat(data.shift().trim()) * Math.PI / 180);\n\t\t\t\t\t\tkeyframe.rotation.multiply(quat);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Zrotation':\n\t\t\t\t\t\tquat.setFromAxisAngle(vz, parseFloat(data.shift().trim()) * Math.PI / 180);\n\t\t\t\t\t\tkeyframe.rotation.multiply(quat);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn('THREE.BVHLoader: Invalid channel type.');\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// parse child nodes\n\n\t\t\tfor (var i = 0; i < bone.children.length; i++) {\n\n\t\t\t\treadFrameData(data, frameTime, bone.children[i]);\n\t\t\t}\n\t\t}\n\n\t\t/*\n   Recursively parses the HIERACHY section of the BVH file\n  \t - lines: all lines of the file. lines are consumed as we go along.\n   - firstline: line containing the node type and name e.g. 'JOINT hip'\n   - list: collects a flat list of nodes\n  \t returns: a BVH node including children\n  */\n\t\tfunction readNode(lines, firstline, list) {\n\n\t\t\tvar node = { name: '', type: '', frames: [] };\n\t\t\tlist.push(node);\n\n\t\t\t// parse node type and name\n\n\t\t\tvar tokens = firstline.split(/[\\s]+/);\n\n\t\t\tif (tokens[0].toUpperCase() === 'END' && tokens[1].toUpperCase() === 'SITE') {\n\n\t\t\t\tnode.type = 'ENDSITE';\n\t\t\t\tnode.name = 'ENDSITE'; // bvh end sites have no name\n\t\t\t} else {\n\n\t\t\t\tnode.name = tokens[1];\n\t\t\t\tnode.type = tokens[0].toUpperCase();\n\t\t\t}\n\n\t\t\tif (nextLine(lines) !== '{') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Expected opening { after type & name');\n\t\t\t}\n\n\t\t\t// parse OFFSET\n\n\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\n\t\t\tif (tokens[0] !== 'OFFSET') {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Expected OFFSET but got: ' + tokens[0]);\n\t\t\t}\n\n\t\t\tif (tokens.length !== 4) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Invalid number of values for OFFSET.');\n\t\t\t}\n\n\t\t\tvar offset = new THREE.Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n\n\t\t\tif (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n\n\t\t\t\tconsole.error('THREE.BVHLoader: Invalid values of OFFSET.');\n\t\t\t}\n\n\t\t\tnode.offset = offset;\n\n\t\t\t// parse CHANNELS definitions\n\n\t\t\tif (node.type !== 'ENDSITE') {\n\n\t\t\t\ttokens = nextLine(lines).split(/[\\s]+/);\n\n\t\t\t\tif (tokens[0] !== 'CHANNELS') {\n\n\t\t\t\t\tconsole.error('THREE.BVHLoader: Expected CHANNELS definition.');\n\t\t\t\t}\n\n\t\t\t\tvar numChannels = parseInt(tokens[1]);\n\t\t\t\tnode.channels = tokens.splice(2, numChannels);\n\t\t\t\tnode.children = [];\n\t\t\t}\n\n\t\t\t// read children\n\n\t\t\twhile (true) {\n\n\t\t\t\tvar line = nextLine(lines);\n\n\t\t\t\tif (line === '}') {\n\n\t\t\t\t\treturn node;\n\t\t\t\t} else {\n\n\t\t\t\t\tnode.children.push(readNode(lines, line, list));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n  \trecursively converts the internal bvh node structure to a THREE.Bone hierarchy\n  \t\tsource: the bvh root node\n  \tlist: pass an empty array, collects a flat list of all converted THREE.Bones\n  \t\treturns the root THREE.Bone\n  */\n\t\tfunction toTHREEBone(source, list) {\n\n\t\t\tvar bone = new THREE.Bone();\n\t\t\tlist.push(bone);\n\n\t\t\tbone.position.add(source.offset);\n\t\t\tbone.name = source.name;\n\n\t\t\tif (source.type !== 'ENDSITE') {\n\n\t\t\t\tfor (var i = 0; i < source.children.length; i++) {\n\n\t\t\t\t\tbone.add(toTHREEBone(source.children[i], list));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn bone;\n\t\t}\n\n\t\t/*\n  \tbuilds a THREE.AnimationClip from the keyframe data saved in each bone.\n  \t\tbone: bvh root node\n  \t\treturns: a THREE.AnimationClip containing position and quaternion tracks\n  */\n\t\tfunction toTHREEAnimation(bones) {\n\n\t\t\tvar tracks = [];\n\n\t\t\t// create a position and quaternion animation track for each node\n\n\t\t\tfor (var i = 0; i < bones.length; i++) {\n\n\t\t\t\tvar bone = bones[i];\n\n\t\t\t\tif (bone.type === 'ENDSITE') continue;\n\n\t\t\t\t// track data\n\n\t\t\t\tvar times = [];\n\t\t\t\tvar positions = [];\n\t\t\t\tvar rotations = [];\n\n\t\t\t\tfor (var j = 0; j < bone.frames.length; j++) {\n\n\t\t\t\t\tvar frame = bone.frames[j];\n\n\t\t\t\t\ttimes.push(frame.time);\n\n\t\t\t\t\t// the animation system animates the position property,\n\t\t\t\t\t// so we have to add the joint offset to all values\n\n\t\t\t\t\tpositions.push(frame.position.x + bone.offset.x);\n\t\t\t\t\tpositions.push(frame.position.y + bone.offset.y);\n\t\t\t\t\tpositions.push(frame.position.z + bone.offset.z);\n\n\t\t\t\t\trotations.push(frame.rotation.x);\n\t\t\t\t\trotations.push(frame.rotation.y);\n\t\t\t\t\trotations.push(frame.rotation.z);\n\t\t\t\t\trotations.push(frame.rotation.w);\n\t\t\t\t}\n\n\t\t\t\tif (scope.animateBonePositions) {\n\n\t\t\t\t\ttracks.push(new THREE.VectorKeyframeTrack('.bones[' + bone.name + '].position', times, positions));\n\t\t\t\t}\n\n\t\t\t\tif (scope.animateBoneRotations) {\n\n\t\t\t\t\ttracks.push(new THREE.QuaternionKeyframeTrack('.bones[' + bone.name + '].quaternion', times, rotations));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new THREE.AnimationClip('animation', -1, tracks);\n\t\t}\n\n\t\t/*\n  \treturns the next non-empty line in lines\n  */\n\t\tfunction nextLine(lines) {\n\n\t\t\tvar line;\n\t\t\t// skip empty lines\n\t\t\twhile ((line = lines.shift().trim()).length === 0) {}\n\t\t\treturn line;\n\t\t}\n\n\t\tvar scope = this;\n\n\t\tvar lines = text.split(/[\\r\\n]+/g);\n\n\t\tvar bones = readBvh(lines);\n\n\t\tvar threeBones = [];\n\t\ttoTHREEBone(bones[0], threeBones);\n\n\t\tvar threeClip = toTHREEAnimation(bones);\n\n\t\treturn {\n\t\t\tskeleton: new THREE.Skeleton(threeBones),\n\t\t\tclip: threeClip\n\t\t};\n\t}\n\n};\n\nexports.default = BVHLoader;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar ColladaLoader = function ColladaLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nColladaLoader.prototype = {\n\n\tconstructor: ColladaLoader,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = scope.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : scope.path;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text, path));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetPath: function setPath(value) {\n\n\t\tthis.path = value;\n\t},\n\n\toptions: {\n\n\t\tset convertUpAxis(value) {\n\n\t\t\tconsole.warn('THREE.ColladaLoader: options.convertUpAxis() has been removed. Up axis is converted automatically.');\n\t\t}\n\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(text, path) {\n\n\t\tfunction getElementsByTagName(xml, name) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tvar array = [];\n\t\t\tvar childNodes = xml.childNodes;\n\n\t\t\tfor (var i = 0, l = childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = childNodes[i];\n\n\t\t\t\tif (child.nodeName === name) {\n\n\t\t\t\t\tarray.push(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseStrings(text) {\n\n\t\t\tif (text.length === 0) return [];\n\n\t\t\tvar parts = text.trim().split(/\\s+/);\n\t\t\tvar array = new Array(parts.length);\n\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++) {\n\n\t\t\t\tarray[i] = parts[i];\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseFloats(text) {\n\n\t\t\tif (text.length === 0) return [];\n\n\t\t\tvar parts = text.trim().split(/\\s+/);\n\t\t\tvar array = new Array(parts.length);\n\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++) {\n\n\t\t\t\tarray[i] = parseFloat(parts[i]);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseInts(text) {\n\n\t\t\tif (text.length === 0) return [];\n\n\t\t\tvar parts = text.trim().split(/\\s+/);\n\t\t\tvar array = new Array(parts.length);\n\n\t\t\tfor (var i = 0, l = parts.length; i < l; i++) {\n\n\t\t\t\tarray[i] = parseInt(parts[i]);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseId(text) {\n\n\t\t\treturn text.substring(1);\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + count++;\n\t\t}\n\n\t\tfunction isEmpty(object) {\n\n\t\t\treturn Object.keys(object).length === 0;\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset(xml) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n\t\t\t\tupAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n\t\t\t};\n\t\t}\n\n\t\tfunction parseAssetUnit(xml) {\n\n\t\t\tif (xml !== undefined && xml.hasAttribute('meter') === true) {\n\n\t\t\t\treturn parseFloat(xml.getAttribute('meter'));\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\t\t\t}\n\t\t}\n\n\t\tfunction parseAssetUpAxis(xml) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary(xml, libraryName, nodeName, parser) {\n\n\t\t\tvar library = getElementsByTagName(xml, libraryName)[0];\n\n\t\t\tif (library !== undefined) {\n\n\t\t\t\tvar elements = getElementsByTagName(library, nodeName);\n\n\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\t\tparser(elements[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction buildLibrary(data, builder) {\n\n\t\t\tfor (var name in data) {\n\n\t\t\t\tvar object = data[name];\n\t\t\t\tobject.build = builder(data[name]);\n\t\t\t}\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild(data, builder) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\tdata.build = builder(data);\n\n\t\t\treturn data.build;\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tvar id;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute('id');\n\t\t\t\t\t\tdata.sources[id] = parseSource(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute('id');\n\t\t\t\t\t\tdata.samplers[id] = parseAnimationSampler(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute('target');\n\t\t\t\t\t\tdata.channels[id] = parseAnimationChannel(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.animations[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseAnimationSampler(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tdata.inputs[semantic] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseAnimationChannel(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tvar target = xml.getAttribute('target');\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tvar parts = target.split('/');\n\n\t\t\tvar id = parts.shift();\n\t\t\tvar sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tvar arraySyntax = sid.indexOf('(') !== -1;\n\t\t\tvar memberSyntax = sid.indexOf('.') !== -1;\n\n\t\t\tif (memberSyntax) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split('.');\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\t\t\t} else if (arraySyntax) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tvar indices = sid.split('(');\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor (var i = 0; i < indices.length; i++) {\n\n\t\t\t\t\tindices[i] = parseInt(indices[i].replace(/\\)/, ''));\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId(xml.getAttribute('source'));\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildAnimation(data) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar channels = data.channels;\n\t\t\tvar samplers = data.samplers;\n\t\t\tvar sources = data.sources;\n\n\t\t\tfor (var target in channels) {\n\n\t\t\t\tif (channels.hasOwnProperty(target)) {\n\n\t\t\t\t\tvar channel = channels[target];\n\t\t\t\t\tvar sampler = samplers[channel.sampler];\n\n\t\t\t\t\tvar inputId = sampler.inputs.INPUT;\n\t\t\t\t\tvar outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tvar inputSource = sources[inputId];\n\t\t\t\t\tvar outputSource = sources[outputId];\n\n\t\t\t\t\tvar animation = buildAnimationChannel(channel, inputSource, outputSource);\n\n\t\t\t\t\tcreateKeyframeTracks(animation, tracks);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tracks;\n\t\t}\n\n\t\tfunction getAnimation(id) {\n\n\t\t\treturn getBuild(library.animations[id], buildAnimation);\n\t\t}\n\n\t\tfunction buildAnimationChannel(channel, inputSource, outputSource) {\n\n\t\t\tvar node = library.nodes[channel.id];\n\t\t\tvar object3D = getNode(node.id);\n\n\t\t\tvar transform = node.transforms[channel.sid];\n\t\t\tvar defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tvar time, stride;\n\t\t\tvar i, il, j, jl;\n\n\t\t\tvar data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch (transform) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor (i = 0, il = inputSource.array.length; i < il; i++) {\n\n\t\t\t\t\t\ttime = inputSource.array[i];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif (data[time] === undefined) data[time] = {};\n\n\t\t\t\t\t\tif (channel.arraySyntax === true) {\n\n\t\t\t\t\t\t\tvar value = outputSource.array[stride];\n\t\t\t\t\t\t\tvar index = channel.indices[0] + 4 * channel.indices[1];\n\n\t\t\t\t\t\t\tdata[time][index] = value;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor (j = 0, jl = outputSource.stride; j < jl; j++) {\n\n\t\t\t\t\t\t\t\tdata[time][j] = outputSource.array[stride + j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tvar keyframes = prepareAnimationData(data, defaultMatrix);\n\n\t\t\tvar animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\t\t}\n\n\t\tfunction prepareAnimationData(data, defaultMatrix) {\n\n\t\t\tvar keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor (var time in data) {\n\n\t\t\t\tkeyframes.push({ time: parseFloat(time), value: data[time] });\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort(ascending);\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor (var i = 0; i < 16; i++) {\n\n\t\t\t\ttransformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending(a, b) {\n\n\t\t\t\treturn a.time - b.time;\n\t\t\t}\n\t\t}\n\n\t\tvar position = new THREE.Vector3();\n\t\tvar scale = new THREE.Vector3();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\tfunction createKeyframeTracks(animation, tracks) {\n\n\t\t\tvar keyframes = animation.keyframes;\n\t\t\tvar name = animation.name;\n\n\t\t\tvar times = [];\n\t\t\tvar positionData = [];\n\t\t\tvar quaternionData = [];\n\t\t\tvar scaleData = [];\n\n\t\t\tfor (var i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tvar time = keyframe.time;\n\t\t\t\tvar value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray(value).transpose();\n\t\t\t\tmatrix.decompose(position, quaternion, scale);\n\n\t\t\t\ttimes.push(time);\n\t\t\t\tpositionData.push(position.x, position.y, position.z);\n\t\t\t\tquaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n\t\t\t\tscaleData.push(scale.x, scale.y, scale.z);\n\t\t\t}\n\n\t\t\tif (positionData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.position', times, positionData));\n\t\t\tif (quaternionData.length > 0) tracks.push(new THREE.QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n\t\t\tif (scaleData.length > 0) tracks.push(new THREE.VectorKeyframeTrack(name + '.scale', times, scaleData));\n\n\t\t\treturn tracks;\n\t\t}\n\n\t\tfunction transformAnimationData(keyframes, property, defaultValue) {\n\n\t\t\tvar keyframe;\n\n\t\t\tvar empty = true;\n\t\t\tvar i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor (i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\tkeyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] === undefined) {\n\n\t\t\t\t\tkeyframe.value[property] = null; // mark as missing\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (empty === true) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor (i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\t\tkeyframe = keyframes[i];\n\n\t\t\t\t\tkeyframe.value[property] = defaultValue;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes(keyframes, property);\n\t\t\t}\n\t\t}\n\n\t\tfunction createMissingKeyframes(keyframes, property) {\n\n\t\t\tvar prev, next;\n\n\t\t\tfor (var i = 0, l = keyframes.length; i < l; i++) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] === null) {\n\n\t\t\t\t\tprev = getPrev(keyframes, i, property);\n\t\t\t\t\tnext = getNext(keyframes, i, property);\n\n\t\t\t\t\tif (prev === null) {\n\n\t\t\t\t\t\tkeyframe.value[property] = next.value[property];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (next === null) {\n\n\t\t\t\t\t\tkeyframe.value[property] = prev.value[property];\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate(keyframe, prev, next, property);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getPrev(keyframes, i, property) {\n\n\t\t\twhile (i >= 0) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] !== null) return keyframe;\n\n\t\t\t\ti--;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction getNext(keyframes, i, property) {\n\n\t\t\twhile (i < keyframes.length) {\n\n\t\t\t\tvar keyframe = keyframes[i];\n\n\t\t\t\tif (keyframe.value[property] !== null) return keyframe;\n\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tfunction interpolate(key, prev, next, property) {\n\n\t\t\tif (next.time - prev.time === 0) {\n\n\t\t\t\tkey.value[property] = prev.value[property];\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tkey.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('id') || 'default',\n\t\t\t\tstart: parseFloat(xml.getAttribute('start') || 0),\n\t\t\t\tend: parseFloat(xml.getAttribute('end') || 0),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.clips[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildAnimationClip(data) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tvar name = data.name;\n\t\t\tvar duration = data.end - data.start || -1;\n\t\t\tvar animations = data.animations;\n\n\t\t\tfor (var i = 0, il = animations.length; i < il; i++) {\n\n\t\t\t\tvar animationTracks = getAnimation(animations[i]);\n\n\t\t\t\tfor (var j = 0, jl = animationTracks.length; j < jl; j++) {\n\n\t\t\t\t\ttracks.push(animationTracks[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new THREE.AnimationClip(name, duration, tracks);\n\t\t}\n\n\t\tfunction getAnimationClip(id) {\n\n\t\t\treturn getBuild(library.clips[id], buildAnimationClip);\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tdata.skin = parseSkin(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.controllers[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseSkin(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tvar id = child.getAttribute('id');\n\t\t\t\t\t\tdata.sources[id] = parseSource(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseJoints(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tdata.inputs[semantic] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseVertexWeights(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tvar offset = parseInt(child.getAttribute('offset'));\n\t\t\t\t\t\tdata.inputs[semantic] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildController(data) {\n\n\t\t\tvar build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tvar geometry = library.geometries[build.id];\n\n\t\t\tif (data.skin !== undefined) {\n\n\t\t\t\tbuild.skin = buildSkin(data.skin);\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\t\t\t}\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction buildSkin(data) {\n\n\t\t\tvar BONE_LIMIT = 4;\n\n\t\t\tvar build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertexWeights = data.vertexWeights;\n\n\t\t\tvar vcount = vertexWeights.vcount;\n\t\t\tvar v = vertexWeights.v;\n\t\t\tvar jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tvar weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tvar jointSource = data.sources[data.joints.inputs.JOINT];\n\t\t\tvar inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n\n\t\t\tvar weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n\t\t\tvar stride = 0;\n\n\t\t\tvar i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor (i = 0, l = vcount.length; i < l; i++) {\n\n\t\t\t\tvar jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\t\t\t\tvar vertexSkinData = [];\n\n\t\t\t\tfor (j = 0; j < jointCount; j++) {\n\n\t\t\t\t\tvar skinIndex = v[stride + jointOffset];\n\t\t\t\t\tvar weightId = v[stride + weightOffset];\n\t\t\t\t\tvar skinWeight = weights[weightId];\n\n\t\t\t\t\tvertexSkinData.push({ index: skinIndex, weight: skinWeight });\n\n\t\t\t\t\tstride += 2;\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort(descending);\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor (j = 0; j < BONE_LIMIT; j++) {\n\n\t\t\t\t\tvar d = vertexSkinData[j];\n\n\t\t\t\t\tif (d !== undefined) {\n\n\t\t\t\t\t\tbuild.indices.array.push(d.index);\n\t\t\t\t\t\tbuild.weights.array.push(d.weight);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push(0);\n\t\t\t\t\t\tbuild.weights.array.push(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tbuild.bindMatrix = new THREE.Matrix4().fromArray(data.bindShapeMatrix).transpose();\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor (i = 0, l = jointSource.array.length; i < l; i++) {\n\n\t\t\t\tvar name = jointSource.array[i];\n\t\t\t\tvar boneInverse = new THREE.Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n\n\t\t\t\tbuild.joints.push({ name: name, boneInverse: boneInverse });\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending(a, b) {\n\n\t\t\t\treturn b.weight - a.weight;\n\t\t\t}\n\t\t}\n\n\t\tfunction getController(id) {\n\n\t\t\treturn getBuild(library.controllers[id], buildController);\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tinit_from: getElementsByTagName(xml, 'init_from')[0].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildImage(data) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\treturn data.init_from;\n\t\t}\n\n\t\tfunction getImage(id) {\n\n\t\t\tvar data = library.images[id];\n\n\t\t\tif (data !== undefined) {\n\n\t\t\t\treturn getBuild(data, buildImage);\n\t\t\t}\n\n\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.effects[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectNewparam(xml, data) {\n\n\t\t\tvar sid = xml.getAttribute('sid');\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[sid] = parseEffectSurface(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[sid] = parseEffectSampler(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEffectSurface(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectSampler(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameters(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[child.nodeName] = parseEffectParameter(child);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[child.nodeName] = {\n\t\t\t\t\t\t\topaque: child.getAttribute('opaque'),\n\t\t\t\t\t\t\tdata: parseEffectParameter(child)\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameter(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloats(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[child.nodeName] = { id: child.getAttribute('texture'), extra: parseEffectParameterTexture(child) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameterTexture(xml) {\n\n\t\t\tvar data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra(xml, data) {\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique(xml, data) {\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[child.nodeName] = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif (child.textContent.toUpperCase() === 'TRUE') {\n\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = 1;\n\t\t\t\t\t\t} else if (child.textContent.toUpperCase() === 'FALSE') {\n\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = 0;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[child.nodeName] = parseInt(child.textContent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseEffectExtra(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[child.nodeName] = parseInt(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildEffect(data) {\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction getEffect(id) {\n\n\t\t\treturn getBuild(library.effects[id], buildEffect);\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name')\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId(child.getAttribute('url'));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.materials[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildMaterial(data) {\n\n\t\t\tvar effect = getEffect(data.url);\n\t\t\tvar technique = effect.profile.technique;\n\t\t\tvar extra = effect.profile.extra;\n\n\t\t\tvar material;\n\n\t\t\tswitch (technique.type) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new THREE.MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name;\n\n\t\t\tfunction getTexture(textureObject) {\n\n\t\t\t\tvar sampler = effect.profile.samplers[textureObject.id];\n\t\t\t\tvar image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif (sampler !== undefined) {\n\n\t\t\t\t\tvar surface = effect.profile.surfaces[sampler.source];\n\t\t\t\t\timage = getImage(surface.init_from);\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n\t\t\t\t\timage = getImage(textureObject.id);\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif (image !== null) {\n\n\t\t\t\t\tvar texture = textureLoader.load(image);\n\n\t\t\t\t\tvar extra = textureObject.extra;\n\n\t\t\t\t\tif (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n\n\t\t\t\t\t\tvar technique = extra.technique;\n\n\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\t\t\ttexture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n\t\t\t\t\t\ttexture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttexture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\ttexture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn texture;\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar parameters = technique.parameters;\n\n\t\t\tfor (var key in parameters) {\n\n\t\t\t\tvar parameter = parameters[key];\n\n\t\t\t\tswitch (key) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif (parameter.color) material.color.fromArray(parameter.color);\n\t\t\t\t\t\tif (parameter.texture) material.map = getTexture(parameter.texture);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n\t\t\t\t\t\tif (parameter.texture) material.specularMap = getTexture(parameter.texture);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif (parameter.float && material.shininess) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n\t\t\t\t\t\tif (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar transparent = parameters['transparent'];\n\t\t\tvar transparency = parameters['transparency'];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif (transparency === undefined && transparent) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif (transparent === undefined && transparency) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [1, 1, 1, 1]\n\t\t\t\t\t} };\n\t\t\t}\n\n\t\t\tif (transparent && transparency) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif (transparent.data.texture) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t} else {\n\n\t\t\t\t\tvar color = transparent.data.color;\n\n\t\t\t\t\tswitch (transparent.opaque) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[3] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - color[0] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - color[3] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[0] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.opacity < 1) material.transparent = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tif (extra !== undefined && extra.technique !== undefined && extra.technique.double_sided === 1) {\n\n\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t}\n\n\t\t\treturn material;\n\t\t}\n\n\t\tfunction getMaterial(id) {\n\n\t\t\treturn getBuild(library.materials[id], buildMaterial);\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name')\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.cameras[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseCameraOptics(xml) {\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {};\n\t\t}\n\n\t\tfunction parseCameraTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters(child);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseCameraParameters(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[child.nodeName] = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildCamera(data) {\n\n\t\t\tvar camera;\n\n\t\t\tswitch (data.optics.technique) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new THREE.PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tvar ymag = data.optics.parameters.ymag;\n\t\t\t\t\tvar xmag = data.optics.parameters.xmag;\n\t\t\t\t\tvar aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = xmag === undefined ? ymag * aspectRatio : xmag;\n\t\t\t\t\tymag = ymag === undefined ? xmag / aspectRatio : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new THREE.OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n\t\t\t\t\tdata.optics.parameters.znear, data.optics.parameters.zfar);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new THREE.PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name;\n\n\t\t\treturn camera;\n\t\t}\n\n\t\tfunction getCamera(id) {\n\n\t\t\tvar data = library.cameras[id];\n\n\t\t\tif (data !== undefined) {\n\n\t\t\t\treturn getBuild(data, buildCamera);\n\t\t\t}\n\n\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.lights[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseLightTechnique(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseLightParameters(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.color = new THREE.Color().fromArray(array);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tvar f = parseFloat(child.textContent);\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt(1 / f) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildLight(data) {\n\n\t\t\tvar light;\n\n\t\t\tswitch (data.technique) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new THREE.DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new THREE.PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new THREE.SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new THREE.AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (data.parameters.color) light.color.copy(data.parameters.color);\n\t\t\tif (data.parameters.distance) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\t\t}\n\n\t\tfunction getLight(id) {\n\n\t\t\tvar data = library.lights[id];\n\n\t\t\tif (data !== undefined) {\n\n\t\t\t\treturn getBuild(data, buildLight);\n\t\t\t}\n\n\t\t\tconsole.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name'),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tvar mesh = getElementsByTagName(xml, 'mesh')[0];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif (mesh === undefined) return;\n\n\t\t\tfor (var i = 0; i < mesh.childNodes.length; i++) {\n\n\t\t\t\tvar child = mesh.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tvar id = child.getAttribute('id');\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[id] = parseSource(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push(parseGeometryPrimitive(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.geometries[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction parseSource(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tvar accessor = getElementsByTagName(child, 'accessor')[0];\n\n\t\t\t\t\t\tif (accessor !== undefined) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt(accessor.getAttribute('stride'));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseGeometryVertices(xml) {\n\n\t\t\tvar data = {};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tdata[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseGeometryPrimitive(xml) {\n\n\t\t\tvar primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute('material'),\n\t\t\t\tcount: parseInt(xml.getAttribute('count')),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor (var i = 0, l = xml.childNodes.length; i < l; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tvar id = parseId(child.getAttribute('source'));\n\t\t\t\t\t\tvar semantic = child.getAttribute('semantic');\n\t\t\t\t\t\tvar offset = parseInt(child.getAttribute('offset'));\n\t\t\t\t\t\tprimitive.inputs[semantic] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max(primitive.stride, offset + 1);\n\t\t\t\t\t\tif (semantic === 'TEXCOORD') primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts(child.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn primitive;\n\t\t}\n\n\t\tfunction groupPrimitives(primitives) {\n\n\t\t\tvar build = {};\n\n\t\t\tfor (var i = 0; i < primitives.length; i++) {\n\n\t\t\t\tvar primitive = primitives[i];\n\n\t\t\t\tif (build[primitive.type] === undefined) build[primitive.type] = [];\n\n\t\t\t\tbuild[primitive.type].push(primitive);\n\t\t\t}\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction checkUVCoordinates(primitives) {\n\n\t\t\tvar count = 0;\n\n\t\t\tfor (var i = 0, l = primitives.length; i < l; i++) {\n\n\t\t\t\tvar primitive = primitives[i];\n\n\t\t\t\tif (primitive.hasUV === true) {\n\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (count > 0 && count < primitives.length) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\t\t\t}\n\t\t}\n\n\t\tfunction buildGeometry(data) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar sources = data.sources;\n\t\t\tvar vertices = data.vertices;\n\t\t\tvar primitives = data.primitives;\n\n\t\t\tif (primitives.length === 0) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tvar groupedPrimitives = groupPrimitives(primitives);\n\n\t\t\tfor (var type in groupedPrimitives) {\n\n\t\t\t\tvar primitiveType = groupedPrimitives[type];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates(primitiveType);\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[type] = buildGeometryType(primitiveType, sources, vertices);\n\t\t\t}\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction buildGeometryType(primitives, sources, vertices) {\n\n\t\t\tvar build = {};\n\n\t\t\tvar position = { array: [], stride: 0 };\n\t\t\tvar normal = { array: [], stride: 0 };\n\t\t\tvar uv = { array: [], stride: 0 };\n\t\t\tvar color = { array: [], stride: 0 };\n\n\t\t\tvar skinIndex = { array: [], stride: 4 };\n\t\t\tvar skinWeight = { array: [], stride: 4 };\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar materialKeys = [];\n\n\t\t\tvar start = 0;\n\n\t\t\tfor (var p = 0; p < primitives.length; p++) {\n\n\t\t\t\tvar primitive = primitives[p];\n\t\t\t\tvar inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tvar count = 0;\n\n\t\t\t\tswitch (primitive.type) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor (var g = 0; g < primitive.count; g++) {\n\n\t\t\t\t\t\t\tvar vc = primitive.vcount[g];\n\n\t\t\t\t\t\t\tswitch (vc) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += (vc - 2) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup(start, count, p);\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif (primitive.material) {\n\n\t\t\t\t\tmaterialKeys.push(primitive.material);\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor (var name in inputs) {\n\n\t\t\t\t\tvar input = inputs[name];\n\n\t\t\t\t\tswitch (name) {\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor (var key in vertices) {\n\n\t\t\t\t\t\t\t\tvar id = vertices[key];\n\n\t\t\t\t\t\t\t\tswitch (key) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tvar prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, position.array);\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[id].stride;\n\n\t\t\t\t\t\t\t\t\t\tif (sources.skinWeights && sources.skinIndices) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar count = (position.array.length - prevLength) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < count; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push(0, 0);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, normal.array);\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, color.array);\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[id], input.offset, uv.array);\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[id].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n\t\t\t\t\t\t\tnormal.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, color.array);\n\t\t\t\t\t\t\tcolor.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n\t\t\t\t\t\t\tuv.stride = sources[input.id].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif (position.array.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position.array, position.stride));\n\t\t\tif (normal.array.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal.array, normal.stride));\n\t\t\tif (color.array.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color.array, color.stride));\n\t\t\tif (uv.array.length > 0) geometry.addAttribute('uv', new THREE.Float32BufferAttribute(uv.array, uv.stride));\n\n\t\t\tif (skinIndex.array.length > 0) geometry.addAttribute('skinIndex', new THREE.Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n\t\t\tif (skinWeight.array.length > 0) geometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[0].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\t\t}\n\n\t\tfunction buildGeometryData(primitive, source, offset, array) {\n\n\t\t\tvar indices = primitive.p;\n\t\t\tvar stride = primitive.stride;\n\t\t\tvar vcount = primitive.vcount;\n\n\t\t\tfunction pushVector(i) {\n\n\t\t\t\tvar index = indices[i + offset] * sourceStride;\n\t\t\t\tvar length = index + sourceStride;\n\n\t\t\t\tfor (; index < length; index++) {\n\n\t\t\t\t\tarray.push(sourceArray[index]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar sourceArray = source.array;\n\t\t\tvar sourceStride = source.stride;\n\n\t\t\tif (primitive.vcount !== undefined) {\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor (var i = 0, l = vcount.length; i < l; i++) {\n\n\t\t\t\t\tvar count = vcount[i];\n\n\t\t\t\t\tif (count === 4) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\t\t\t\t\t\tvar d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector(a);pushVector(b);pushVector(d);\n\t\t\t\t\t\tpushVector(b);pushVector(c);pushVector(d);\n\t\t\t\t\t} else if (count === 3) {\n\n\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\tvar b = index + stride * 1;\n\t\t\t\t\t\tvar c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector(a);pushVector(b);pushVector(c);\n\t\t\t\t\t} else if (count > 4) {\n\n\t\t\t\t\t\tfor (var k = 1, kl = count - 2; k <= kl; k++) {\n\n\t\t\t\t\t\t\tvar a = index + stride * 0;\n\t\t\t\t\t\t\tvar b = index + stride * k;\n\t\t\t\t\t\t\tvar c = index + stride * (k + 1);\n\n\t\t\t\t\t\t\tpushVector(a);pushVector(b);pushVector(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (var i = 0, l = indices.length; i < l; i += stride) {\n\n\t\t\t\t\tpushVector(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction getGeometry(id) {\n\n\t\t\treturn getBuild(library.geometries[id], buildGeometry);\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon(child, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildKinematicsModel(data) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction getKinematicsModel(id) {\n\n\t\t\treturn getBuild(library.kinematicsModels[id], buildKinematicsModel);\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon(xml, data) {\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push(parseKinematicsLink(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction parseKinematicsJoint(xml) {\n\n\t\t\tvar data;\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter(xml, data) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute('sid'),\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\taxis: new THREE.Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.axis.fromArray(array);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tvar max = child.getElementsByTagName('max')[0];\n\t\t\t\t\t\tvar min = child.getElementsByTagName('min')[0];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat(max.textContent);\n\t\t\t\t\t\tdata.limits.min = parseFloat(min.textContent);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif (data.limits.min >= data.limits.max) {\n\n\t\t\t\tdata.static = true;\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsLink(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tsid: xml.getAttribute('sid'),\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push(parseKinematicsAttachment(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push(parseKinematicsTransform(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsAttachment(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tjoint: xml.getAttribute('joint').split('/').pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push(parseKinematicsLink(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push(parseKinematicsTransform(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsTransform(xml) {\n\n\t\t\tvar data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tvar array = parseFloats(xml.textContent);\n\n\t\t\tswitch (data.type) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new THREE.Matrix4();\n\t\t\t\t\tdata.obj.fromArray(array).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\tdata.obj.fromArray(array);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new THREE.Vector3();\n\t\t\t\t\tdata.obj.fromArray(array);\n\t\t\t\t\tdata.angle = THREE.Math.degToRad(array[3]);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseKinematicsScene(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis(xml) {\n\n\t\t\tvar data = {\n\t\t\t\ttarget: xml.getAttribute('target').split('/').pop()\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tvar param = child.getElementsByTagName('param')[0];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tvar tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildKinematicsScene(data) {\n\n\t\t\tif (data.build !== undefined) return data.build;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction getKinematicsScene(id) {\n\n\t\t\treturn getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tvar kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n\t\t\tvar kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n\t\t\tvar visualSceneId = Object.keys(library.visualScenes)[0];\n\n\t\t\tif (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n\n\t\t\tvar kinematicsModel = getKinematicsModel(kinematicsModelId);\n\t\t\tvar kinematicsScene = getKinematicsScene(kinematicsSceneId);\n\t\t\tvar visualScene = getVisualScene(visualSceneId);\n\n\t\t\tvar bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tvar jointMap = {};\n\n\t\t\tfor (var i = 0, l = bindJointAxis.length; i < l; i++) {\n\n\t\t\t\tvar axis = bindJointAxis[i];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tvar targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n\t\t\t\tif (targetElement) {\n\n\t\t\t\t\t// get the parent of the transfrom element\n\n\t\t\t\t\tvar parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect(axis.jointIndex, parentVisualElement);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction connect(jointIndex, visualElement) {\n\n\t\t\t\tvar visualElementName = visualElement.getAttribute('name');\n\t\t\t\tvar joint = kinematicsModel.joints[jointIndex];\n\n\t\t\t\tvisualScene.traverse(function (object) {\n\n\t\t\t\t\tif (object.name === visualElementName) {\n\n\t\t\t\t\t\tjointMap[jointIndex] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList(visualElement),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tvar m0 = new THREE.Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function getJointValue(jointIndex) {\n\n\t\t\t\t\tvar jointData = jointMap[jointIndex];\n\n\t\t\t\t\tif (jointData) {\n\n\t\t\t\t\t\treturn jointData.position;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function setJointValue(jointIndex, value) {\n\n\t\t\t\t\tvar jointData = jointMap[jointIndex];\n\n\t\t\t\t\tif (jointData) {\n\n\t\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\t\tif (value > joint.limits.max || value < joint.limits.min) {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n\t\t\t\t\t\t} else if (joint.static) {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar object = jointData.object;\n\t\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor (var i = 0; i < transforms.length; i++) {\n\n\t\t\t\t\t\t\t\tvar transform = transforms[i];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n\n\t\t\t\t\t\t\t\t\tswitch (joint.type) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeRotationAxis(axis, THREE.Math.degToRad(value)));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch (transform.type) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(transform.obj);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale(transform.obj);\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy(matrix);\n\t\t\t\t\t\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\n\n\t\t\t\t\t\t\tjointMap[jointIndex].position = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t};\n\t\t}\n\n\t\tfunction buildTransformList(node) {\n\n\t\t\tvar transforms = [];\n\n\t\t\tvar xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar matrix = new THREE.Matrix4().fromArray(array).transpose();\n\t\t\t\t\t\ttransforms.push({\n\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray(array);\n\t\t\t\t\t\ttransforms.push({\n\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar vector = new THREE.Vector3().fromArray(array);\n\t\t\t\t\t\tvar angle = THREE.Math.degToRad(array[3]);\n\t\t\t\t\t\ttransforms.push({\n\t\t\t\t\t\t\tsid: child.getAttribute('sid'),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn transforms;\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes(xml) {\n\n\t\t\tvar elements = xml.getElementsByTagName('node');\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\tvar element = elements[i];\n\n\t\t\t\tif (element.hasAttribute('id') === false) {\n\n\t\t\t\t\telement.setAttribute('id', generateId());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar matrix = new THREE.Matrix4();\n\t\tvar vector = new THREE.Vector3();\n\n\t\tfunction parseNode(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name') || '',\n\t\t\t\ttype: xml.getAttribute('type'),\n\t\t\t\tid: xml.getAttribute('id'),\n\t\t\t\tsid: xml.getAttribute('sid'),\n\t\t\t\tmatrix: new THREE.Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tif (child.nodeType !== 1) continue;\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push(child.getAttribute('id'));\n\t\t\t\t\t\tparseNode(child);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push(parseNodeInstance(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push(parseNodeInstance(child));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push(parseId(child.getAttribute('url')));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.matrix.multiply(matrix.fromArray(array).transpose());\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvector.fromArray(array);\n\t\t\t\t\t\tdata.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tvar angle = THREE.Math.degToRad(array[3]);\n\t\t\t\t\t\tdata.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tvar array = parseFloats(child.textContent);\n\t\t\t\t\t\tdata.matrix.scale(vector.fromArray(array));\n\t\t\t\t\t\tdata.transforms[child.getAttribute('sid')] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log(child);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlibrary.nodes[data.id] = data;\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction parseNodeInstance(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tid: parseId(xml.getAttribute('url')),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\tvar child = xml.childNodes[i];\n\n\t\t\t\tswitch (child.nodeName) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tvar instances = child.getElementsByTagName('instance_material');\n\n\t\t\t\t\t\tfor (var j = 0; j < instances.length; j++) {\n\n\t\t\t\t\t\t\tvar instance = instances[j];\n\t\t\t\t\t\t\tvar symbol = instance.getAttribute('symbol');\n\t\t\t\t\t\t\tvar target = instance.getAttribute('target');\n\n\t\t\t\t\t\t\tdata.materials[symbol] = parseId(target);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push(parseId(child.textContent));\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction buildSkeleton(skeletons, joints) {\n\n\t\t\tvar boneData = [];\n\t\t\tvar sortedBoneData = [];\n\n\t\t\tvar i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor (i = 0; i < skeletons.length; i++) {\n\n\t\t\t\tvar skeleton = skeletons[i];\n\n\t\t\t\tvar root;\n\n\t\t\t\tif (hasNode(skeleton)) {\n\n\t\t\t\t\troot = getNode(skeleton);\n\t\t\t\t\tbuildBoneHierarchy(root, joints, boneData);\n\t\t\t\t} else if (hasVisualScene(skeleton)) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tvar visualScene = library.visualScenes[skeleton];\n\t\t\t\t\tvar children = visualScene.children;\n\n\t\t\t\t\tfor (var j = 0; j < children.length; j++) {\n\n\t\t\t\t\t\tvar child = children[j];\n\n\t\t\t\t\t\tif (child.type === 'JOINT') {\n\n\t\t\t\t\t\t\tvar root = getNode(child.id);\n\t\t\t\t\t\t\tbuildBoneHierarchy(root, joints, boneData);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor (i = 0; i < joints.length; i++) {\n\n\t\t\t\tfor (j = 0; j < boneData.length; j++) {\n\n\t\t\t\t\tdata = boneData[j];\n\n\t\t\t\t\tif (data.bone.name === joints[i].name) {\n\n\t\t\t\t\t\tsortedBoneData[i] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor (i = 0; i < boneData.length; i++) {\n\n\t\t\t\tdata = boneData[i];\n\n\t\t\t\tif (data.processed === false) {\n\n\t\t\t\t\tsortedBoneData.push(data);\n\t\t\t\t\tdata.processed = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tvar bones = [];\n\t\t\tvar boneInverses = [];\n\n\t\t\tfor (i = 0; i < sortedBoneData.length; i++) {\n\n\t\t\t\tdata = sortedBoneData[i];\n\n\t\t\t\tbones.push(data.bone);\n\t\t\t\tboneInverses.push(data.boneInverse);\n\t\t\t}\n\n\t\t\treturn new THREE.Skeleton(bones, boneInverses);\n\t\t}\n\n\t\tfunction buildBoneHierarchy(root, joints, boneData) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse(function (object) {\n\n\t\t\t\tif (object.isBone === true) {\n\n\t\t\t\t\tvar boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor (var i = 0; i < joints.length; i++) {\n\n\t\t\t\t\t\tvar joint = joints[i];\n\n\t\t\t\t\t\tif (joint.name === object.name) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (boneInverse === undefined) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new THREE.Matrix4();\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push({ bone: object, boneInverse: boneInverse, processed: false });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction buildNode(data) {\n\n\t\t\tvar objects = [];\n\n\t\t\tvar matrix = data.matrix;\n\t\t\tvar nodes = data.nodes;\n\t\t\tvar type = data.type;\n\t\t\tvar instanceCameras = data.instanceCameras;\n\t\t\tvar instanceControllers = data.instanceControllers;\n\t\t\tvar instanceLights = data.instanceLights;\n\t\t\tvar instanceGeometries = data.instanceGeometries;\n\t\t\tvar instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor (var i = 0, l = nodes.length; i < l; i++) {\n\n\t\t\t\tobjects.push(getNode(nodes[i]));\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor (var i = 0, l = instanceCameras.length; i < l; i++) {\n\n\t\t\t\tvar instanceCamera = getCamera(instanceCameras[i]);\n\n\t\t\t\tif (instanceCamera !== null) {\n\n\t\t\t\t\tobjects.push(instanceCamera.clone());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor (var i = 0, l = instanceControllers.length; i < l; i++) {\n\n\t\t\t\tvar instance = instanceControllers[i];\n\t\t\t\tvar controller = getController(instance.id);\n\t\t\t\tvar geometries = getGeometry(controller.id);\n\t\t\t\tvar newObjects = buildObjects(geometries, instance.materials);\n\n\t\t\t\tvar skeletons = instance.skeletons;\n\t\t\t\tvar joints = controller.skin.joints;\n\n\t\t\t\tvar skeleton = buildSkeleton(skeletons, joints);\n\n\t\t\t\tfor (var j = 0, jl = newObjects.length; j < jl; j++) {\n\n\t\t\t\t\tvar object = newObjects[j];\n\n\t\t\t\t\tif (object.isSkinnedMesh) {\n\n\t\t\t\t\t\tobject.bind(skeleton, controller.skin.bindMatrix);\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push(object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor (var i = 0, l = instanceLights.length; i < l; i++) {\n\n\t\t\t\tvar instanceLight = getLight(instanceLights[i]);\n\n\t\t\t\tif (instanceLight !== null) {\n\n\t\t\t\t\tobjects.push(instanceLight.clone());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor (var i = 0, l = instanceGeometries.length; i < l; i++) {\n\n\t\t\t\tvar instance = instanceGeometries[i];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tvar geometries = getGeometry(instance.id);\n\t\t\t\tvar newObjects = buildObjects(geometries, instance.materials);\n\n\t\t\t\tfor (var j = 0, jl = newObjects.length; j < jl; j++) {\n\n\t\t\t\t\tobjects.push(newObjects[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor (var i = 0, l = instanceNodes.length; i < l; i++) {\n\n\t\t\t\tobjects.push(getNode(instanceNodes[i]).clone());\n\t\t\t}\n\n\t\t\tvar object;\n\n\t\t\tif (nodes.length === 0 && objects.length === 1) {\n\n\t\t\t\tobject = objects[0];\n\t\t\t} else {\n\n\t\t\t\tobject = type === 'JOINT' ? new THREE.Bone() : new THREE.Group();\n\n\t\t\t\tfor (var i = 0; i < objects.length; i++) {\n\n\t\t\t\t\tobject.add(objects[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (object.name === '') {\n\n\t\t\t\tobject.name = type === 'JOINT' ? data.sid : data.name;\n\t\t\t}\n\n\t\t\tobject.matrix.copy(matrix);\n\t\t\tobject.matrix.decompose(object.position, object.quaternion, object.scale);\n\n\t\t\treturn object;\n\t\t}\n\n\t\tfunction resolveMaterialBinding(keys, instanceMaterials) {\n\n\t\t\tvar materials = [];\n\n\t\t\tfor (var i = 0, l = keys.length; i < l; i++) {\n\n\t\t\t\tvar id = instanceMaterials[keys[i]];\n\t\t\t\tmaterials.push(getMaterial(id));\n\t\t\t}\n\n\t\t\treturn materials;\n\t\t}\n\n\t\tfunction buildObjects(geometries, instanceMaterials) {\n\n\t\t\tvar objects = [];\n\n\t\t\tfor (var type in geometries) {\n\n\t\t\t\tvar geometry = geometries[type];\n\n\t\t\t\tvar materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif (materials.length === 0) {\n\n\t\t\t\t\tif (type === 'lines' || type === 'linestrips') {\n\n\t\t\t\t\t\tmaterials.push(new THREE.LineBasicMaterial());\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push(new THREE.MeshPhongMaterial());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tvar skinning = geometry.data.attributes.skinIndex !== undefined;\n\n\t\t\t\tif (skinning) {\n\n\t\t\t\t\tfor (var i = 0, l = materials.length; i < l; i++) {\n\n\t\t\t\t\t\tmaterials[i].skinning = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tvar material = materials.length === 1 ? materials[0] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tvar object;\n\n\t\t\t\tswitch (type) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new THREE.LineSegments(geometry.data, material);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new THREE.Line(geometry.data, material);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif (skinning) {\n\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh(geometry.data, material);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new THREE.Mesh(geometry.data, material);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push(object);\n\t\t\t}\n\n\t\t\treturn objects;\n\t\t}\n\n\t\tfunction hasNode(id) {\n\n\t\t\treturn library.nodes[id] !== undefined;\n\t\t}\n\n\t\tfunction getNode(id) {\n\n\t\t\treturn getBuild(library.nodes[id], buildNode);\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene(xml) {\n\n\t\t\tvar data = {\n\t\t\t\tname: xml.getAttribute('name'),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes(xml);\n\n\t\t\tvar elements = getElementsByTagName(xml, 'node');\n\n\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\tdata.children.push(parseNode(elements[i]));\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[xml.getAttribute('id')] = data;\n\t\t}\n\n\t\tfunction buildVisualScene(data) {\n\n\t\t\tvar group = new THREE.Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tvar children = data.children;\n\n\t\t\tfor (var i = 0; i < children.length; i++) {\n\n\t\t\t\tvar child = children[i];\n\n\t\t\t\tgroup.add(getNode(child.id));\n\t\t\t}\n\n\t\t\treturn group;\n\t\t}\n\n\t\tfunction hasVisualScene(id) {\n\n\t\t\treturn library.visualScenes[id] !== undefined;\n\t\t}\n\n\t\tfunction getVisualScene(id) {\n\n\t\t\treturn getBuild(library.visualScenes[id], buildVisualScene);\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene(xml) {\n\n\t\t\tvar instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n\t\t\treturn getVisualScene(parseId(instance.getAttribute('url')));\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tvar clips = library.clips;\n\n\t\t\tif (isEmpty(clips) === true) {\n\n\t\t\t\tif (isEmpty(library.animations) === false) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\tfor (var id in library.animations) {\n\n\t\t\t\t\t\tvar animationTracks = getAnimation(id);\n\n\t\t\t\t\t\tfor (var i = 0, l = animationTracks.length; i < l; i++) {\n\n\t\t\t\t\t\t\ttracks.push(animationTracks[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push(new THREE.AnimationClip('default', -1, tracks));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (var id in clips) {\n\n\t\t\t\t\tanimations.push(getAnimationClip(id));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (text.length === 0) {\n\n\t\t\treturn { scene: new THREE.Scene() };\n\t\t}\n\n\t\tvar xml = new DOMParser().parseFromString(text, 'application/xml');\n\n\t\tvar collada = getElementsByTagName(xml, 'COLLADA')[0];\n\n\t\t// metadata\n\n\t\tvar version = collada.getAttribute('version');\n\t\tconsole.log('THREE.ColladaLoader: File version', version);\n\n\t\tvar asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setPath(path).setCrossOrigin(this.crossOrigin);\n\n\t\t//\n\n\t\tvar animations = [];\n\t\tvar kinematics = {};\n\t\tvar count = 0;\n\n\t\t//\n\n\t\tvar library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n\t\tparseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n\t\tparseLibrary(collada, 'library_controllers', 'controller', parseController);\n\t\tparseLibrary(collada, 'library_images', 'image', parseImage);\n\t\tparseLibrary(collada, 'library_effects', 'effect', parseEffect);\n\t\tparseLibrary(collada, 'library_materials', 'material', parseMaterial);\n\t\tparseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n\t\tparseLibrary(collada, 'library_lights', 'light', parseLight);\n\t\tparseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n\t\tparseLibrary(collada, 'library_nodes', 'node', parseNode);\n\t\tparseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n\t\tparseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n\t\tparseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n\n\t\tbuildLibrary(library.animations, buildAnimation);\n\t\tbuildLibrary(library.clips, buildAnimationClip);\n\t\tbuildLibrary(library.controllers, buildController);\n\t\tbuildLibrary(library.images, buildImage);\n\t\tbuildLibrary(library.effects, buildEffect);\n\t\tbuildLibrary(library.materials, buildMaterial);\n\t\tbuildLibrary(library.cameras, buildCamera);\n\t\tbuildLibrary(library.lights, buildLight);\n\t\tbuildLibrary(library.geometries, buildGeometry);\n\t\tbuildLibrary(library.visualScenes, buildVisualScene);\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tvar scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n\n\t\tif (asset.upAxis === 'Z_UP') {\n\n\t\t\tscene.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n\t\t}\n\n\t\tscene.scale.multiplyScalar(asset.unit);\n\n\t\treturn {\n\t\t\tanimations: animations,\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\t}\n\n};\n\nexports.default = ColladaLoader;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar DDSLoader = function DDSLoader() {\n\n\tthis._parser = DDSLoader.parse;\n};\n\nDDSLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);\nDDSLoader.prototype.constructor = DDSLoader;\n\nDDSLoader.parse = function (buffer, loadMipmaps) {\n\n\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t// Adapted from @toji's DDS utils\n\t// https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t// All values and structures referenced from:\n\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\tvar DDS_MAGIC = 0x20534444;\n\n\tvar DDSD_CAPS = 0x1,\n\t    DDSD_HEIGHT = 0x2,\n\t    DDSD_WIDTH = 0x4,\n\t    DDSD_PITCH = 0x8,\n\t    DDSD_PIXELFORMAT = 0x1000,\n\t    DDSD_MIPMAPCOUNT = 0x20000,\n\t    DDSD_LINEARSIZE = 0x80000,\n\t    DDSD_DEPTH = 0x800000;\n\n\tvar DDSCAPS_COMPLEX = 0x8,\n\t    DDSCAPS_MIPMAP = 0x400000,\n\t    DDSCAPS_TEXTURE = 0x1000;\n\n\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t    DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t    DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t    DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t    DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t    DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t    DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t    DDSCAPS2_VOLUME = 0x200000;\n\n\tvar DDPF_ALPHAPIXELS = 0x1,\n\t    DDPF_ALPHA = 0x2,\n\t    DDPF_FOURCC = 0x4,\n\t    DDPF_RGB = 0x40,\n\t    DDPF_YUV = 0x200,\n\t    DDPF_LUMINANCE = 0x20000;\n\n\tfunction fourCCToInt32(value) {\n\n\t\treturn value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n\t}\n\n\tfunction int32ToFourCC(value) {\n\n\t\treturn String.fromCharCode(value & 0xff, value >> 8 & 0xff, value >> 16 & 0xff, value >> 24 & 0xff);\n\t}\n\n\tfunction loadARGBMip(buffer, dataOffset, width, height) {\n\n\t\tvar dataLength = width * height * 4;\n\t\tvar srcBuffer = new Uint8Array(buffer, dataOffset, dataLength);\n\t\tvar byteArray = new Uint8Array(dataLength);\n\t\tvar dst = 0;\n\t\tvar src = 0;\n\t\tfor (var y = 0; y < height; y++) {\n\n\t\t\tfor (var x = 0; x < width; x++) {\n\n\t\t\t\tvar b = srcBuffer[src];src++;\n\t\t\t\tvar g = srcBuffer[src];src++;\n\t\t\t\tvar r = srcBuffer[src];src++;\n\t\t\t\tvar a = srcBuffer[src];src++;\n\t\t\t\tbyteArray[dst] = r;dst++; //r\n\t\t\t\tbyteArray[dst] = g;dst++; //g\n\t\t\t\tbyteArray[dst] = b;dst++; //b\n\t\t\t\tbyteArray[dst] = a;dst++; //a\n\t\t\t}\n\t\t}\n\t\treturn byteArray;\n\t}\n\n\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n\tvar FOURCC_ETC1 = fourCCToInt32(\"ETC1\");\n\n\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t// Offsets into the header array\n\n\tvar off_magic = 0;\n\n\tvar off_size = 1;\n\tvar off_flags = 2;\n\tvar off_height = 3;\n\tvar off_width = 4;\n\n\tvar off_mipmapCount = 7;\n\n\tvar off_pfFlags = 20;\n\tvar off_pfFourCC = 21;\n\tvar off_RGBBitCount = 22;\n\tvar off_RBitMask = 23;\n\tvar off_GBitMask = 24;\n\tvar off_BBitMask = 25;\n\tvar off_ABitMask = 26;\n\n\tvar off_caps = 27;\n\tvar off_caps2 = 28;\n\tvar off_caps3 = 29;\n\tvar off_caps4 = 30;\n\n\t// Parse header\n\n\tvar header = new Int32Array(buffer, 0, headerLengthInt);\n\n\tif (header[off_magic] !== DDS_MAGIC) {\n\n\t\tconsole.error('THREE.DDSLoader.parse: Invalid magic number in DDS header.');\n\t\treturn dds;\n\t}\n\n\tif (!header[off_pfFlags] & DDPF_FOURCC) {\n\n\t\tconsole.error('THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code.');\n\t\treturn dds;\n\t}\n\n\tvar blockBytes;\n\n\tvar fourCC = header[off_pfFourCC];\n\n\tvar isRGBAUncompressed = false;\n\n\tswitch (fourCC) {\n\n\t\tcase FOURCC_DXT1:\n\n\t\t\tblockBytes = 8;\n\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\tbreak;\n\n\t\tcase FOURCC_DXT3:\n\n\t\t\tblockBytes = 16;\n\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\tbreak;\n\n\t\tcase FOURCC_DXT5:\n\n\t\t\tblockBytes = 16;\n\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\tbreak;\n\n\t\tcase FOURCC_ETC1:\n\n\t\t\tblockBytes = 8;\n\t\t\tdds.format = THREE.RGB_ETC1_Format;\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tif (header[off_RGBBitCount] === 32 && header[off_RBitMask] & 0xff0000 && header[off_GBitMask] & 0xff00 && header[off_BBitMask] & 0xff && header[off_ABitMask] & 0xff000000) {\n\n\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\tblockBytes = 64;\n\t\t\t\tdds.format = THREE.RGBAFormat;\n\t\t\t} else {\n\n\t\t\t\tconsole.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));\n\t\t\t\treturn dds;\n\t\t\t}\n\n\t}\n\n\tdds.mipmapCount = 1;\n\n\tif (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n\n\t\tdds.mipmapCount = Math.max(1, header[off_mipmapCount]);\n\t}\n\n\tvar caps2 = header[off_caps2];\n\tdds.isCubemap = caps2 & DDSCAPS2_CUBEMAP ? true : false;\n\tif (dds.isCubemap && (!(caps2 & DDSCAPS2_CUBEMAP_POSITIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEX) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEY) || !(caps2 & DDSCAPS2_CUBEMAP_POSITIVEZ) || !(caps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ))) {\n\n\t\tconsole.error('THREE.DDSLoader.parse: Incomplete cubemap faces');\n\t\treturn dds;\n\t}\n\n\tdds.width = header[off_width];\n\tdds.height = header[off_height];\n\n\tvar dataOffset = header[off_size] + 4;\n\n\t// Extract mipmaps buffers\n\n\tvar faces = dds.isCubemap ? 6 : 1;\n\n\tfor (var face = 0; face < faces; face++) {\n\n\t\tvar width = dds.width;\n\t\tvar height = dds.height;\n\n\t\tfor (var i = 0; i < dds.mipmapCount; i++) {\n\n\t\t\tif (isRGBAUncompressed) {\n\n\t\t\t\tvar byteArray = loadARGBMip(buffer, dataOffset, width, height);\n\t\t\t\tvar dataLength = byteArray.length;\n\t\t\t} else {\n\n\t\t\t\tvar dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;\n\t\t\t\tvar byteArray = new Uint8Array(buffer, dataOffset, dataLength);\n\t\t\t}\n\n\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\tdds.mipmaps.push(mipmap);\n\n\t\t\tdataOffset += dataLength;\n\n\t\t\twidth = Math.max(width >> 1, 1);\n\t\t\theight = Math.max(height >> 1, 1);\n\t\t}\n\t}\n\n\treturn dds;\n};\n\nexports.default = DDSLoader;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// Copyright 2016 The Draco Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n'use strict';\n\n/**\n * @param {THREE.LoadingManager} manager\n */\nvar DRACOLoader = function DRACOLoader(manager) {\n  this.timeLoaded = 0;\n  this.manager = manager || THREE.DefaultLoadingManager;\n  this.materials = null;\n  this.verbosity = 0;\n  this.attributeOptions = {};\n  this.drawMode = THREE.TrianglesDrawMode;\n  // Native Draco attribute type to Three.JS attribute type.\n  this.nativeAttributeMap = {\n    'position': 'POSITION',\n    'normal': 'NORMAL',\n    'color': 'COLOR',\n    'uv': 'TEX_COORD'\n  };\n};\n\nDRACOLoader.prototype = {\n\n  constructor: DRACOLoader,\n\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var loader = new THREE.FileLoader(scope.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    if (this.crossOrigin !== undefined) {\n      loader.crossOrigin = this.crossOrigin;\n    }\n    loader.load(url, function (blob) {\n      scope.decodeDracoFile(blob, onLoad);\n    }, onProgress, onError);\n  },\n\n  setPath: function setPath(value) {\n    this.path = value;\n  },\n\n  setCrossOrigin: function setCrossOrigin(value) {\n    this.crossOrigin = value;\n  },\n\n  setVerbosity: function setVerbosity(level) {\n    this.verbosity = level;\n  },\n\n  /**\n   *  Sets desired mode for generated geometry indices.\n   *  Can be either:\n   *      THREE.TrianglesDrawMode\n   *      THREE.TriangleStripDrawMode\n   */\n  setDrawMode: function setDrawMode(drawMode) {\n    this.drawMode = drawMode;\n  },\n\n  /**\n   * Skips dequantization for a specific attribute.\n   * |attributeName| is the THREE.js name of the given attribute type.\n   * The only currently supported |attributeName| is 'position', more may be\n   * added in future.\n   */\n  setSkipDequantization: function setSkipDequantization(attributeName, skip) {\n    var skipDequantization = true;\n    if (typeof skip !== 'undefined') skipDequantization = skip;\n    this.getAttributeOptions(attributeName).skipDequantization = skipDequantization;\n  },\n\n  /**\n   * |attributeUniqueIdMap| specifies attribute unique id for an attribute in\n   * the geometry to be decoded. The name of the attribute must be one of the\n   * supported attribute type in Three.JS, including:\n   *     'position',\n   *     'color',\n   *     'normal',\n   *     'uv',\n   *     'uv2',\n   *     'skinIndex',\n   *     'skinWeight'.\n   * The format is:\n   *     attributeUniqueIdMap[attributeName] = attributeId\n   */\n  decodeDracoFile: function decodeDracoFile(rawBuffer, callback, attributeUniqueIdMap) {\n    var scope = this;\n    DRACOLoader.getDecoderModule().then(function (module) {\n      scope.decodeDracoFileInternal(rawBuffer, module.decoder, callback, attributeUniqueIdMap || {});\n    });\n  },\n\n  decodeDracoFileInternal: function decodeDracoFileInternal(rawBuffer, dracoDecoder, callback, attributeUniqueIdMap) {\n    /*\n     * Here is how to use Draco Javascript decoder and get the geometry.\n     */\n    var buffer = new dracoDecoder.DecoderBuffer();\n    buffer.Init(new Int8Array(rawBuffer), rawBuffer.byteLength);\n    var decoder = new dracoDecoder.Decoder();\n\n    /*\n     * Determine what type is this file: mesh or point cloud.\n     */\n    var geometryType = decoder.GetEncodedGeometryType(buffer);\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      if (this.verbosity > 0) {\n        console.log('Loaded a mesh.');\n      }\n    } else if (geometryType == dracoDecoder.POINT_CLOUD) {\n      if (this.verbosity > 0) {\n        console.log('Loaded a point cloud.');\n      }\n    } else {\n      var errorMsg = 'THREE.DRACOLoader: Unknown geometry type.';\n      console.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n    callback(this.convertDracoGeometryTo3JS(dracoDecoder, decoder, geometryType, buffer, attributeUniqueIdMap));\n  },\n\n  addAttributeToGeometry: function addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer) {\n    if (attribute.ptr === 0) {\n      var errorMsg = 'THREE.DRACOLoader: No attribute ' + attributeName;\n      console.error(errorMsg);\n      throw new Error(errorMsg);\n    }\n    var numComponents = attribute.num_components();\n    var attributeData = new dracoDecoder.DracoFloat32Array();\n    decoder.GetAttributeFloatForAllPoints(dracoGeometry, attribute, attributeData);\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    // Allocate space for attribute.\n    geometryBuffer[attributeName] = new Float32Array(numValues);\n    // Copy data from decoder.\n    for (var i = 0; i < numValues; i++) {\n      geometryBuffer[attributeName][i] = attributeData.GetValue(i);\n    }\n    // Add attribute to THREEJS geometry for rendering.\n    geometry.addAttribute(attributeName, new THREE.Float32BufferAttribute(geometryBuffer[attributeName], numComponents));\n    dracoDecoder.destroy(attributeData);\n  },\n\n  convertDracoGeometryTo3JS: function convertDracoGeometryTo3JS(dracoDecoder, decoder, geometryType, buffer, attributeUniqueIdMap) {\n    if (this.getAttributeOptions('position').skipDequantization === true) {\n      decoder.SkipAttributeTransform(dracoDecoder.POSITION);\n    }\n    var dracoGeometry;\n    var decodingStatus;\n    var start_time = performance.now();\n    if (geometryType === dracoDecoder.TRIANGULAR_MESH) {\n      dracoGeometry = new dracoDecoder.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n    } else {\n      dracoGeometry = new dracoDecoder.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr == 0) {\n      var errorMsg = 'THREE.DRACOLoader: Decoding failed: ';\n      errorMsg += decodingStatus.error_msg();\n      console.error(errorMsg);\n      dracoDecoder.destroy(decoder);\n      dracoDecoder.destroy(dracoGeometry);\n      throw new Error(errorMsg);\n    }\n\n    var decode_end = performance.now();\n    dracoDecoder.destroy(buffer);\n    /*\n     * Example on how to retrieve mesh and attributes.\n     */\n    var numFaces;\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      numFaces = dracoGeometry.num_faces();\n      if (this.verbosity > 0) {\n        console.log('Number of faces loaded: ' + numFaces.toString());\n      }\n    } else {\n      numFaces = 0;\n    }\n\n    var numPoints = dracoGeometry.num_points();\n    var numAttributes = dracoGeometry.num_attributes();\n    if (this.verbosity > 0) {\n      console.log('Number of points loaded: ' + numPoints.toString());\n      console.log('Number of attributes loaded: ' + numAttributes.toString());\n    }\n\n    // Verify if there is position attribute.\n    var posAttId = decoder.GetAttributeId(dracoGeometry, dracoDecoder.POSITION);\n    if (posAttId == -1) {\n      var errorMsg = 'THREE.DRACOLoader: No position attribute found.';\n      console.error(errorMsg);\n      dracoDecoder.destroy(decoder);\n      dracoDecoder.destroy(dracoGeometry);\n      throw new Error(errorMsg);\n    }\n    var posAttribute = decoder.GetAttribute(dracoGeometry, posAttId);\n\n    // Structure for converting to THREEJS geometry later.\n    var geometryBuffer = {};\n    // Import data to Three JS geometry.\n    var geometry = new THREE.BufferGeometry();\n\n    // Add native Draco attribute type to geometry.\n    for (var attributeName in this.nativeAttributeMap) {\n      // The native attribute type is only used when no unique Id is\n      // provided. For example, loading .drc files.\n      if (attributeUniqueIdMap[attributeName] === undefined) {\n        var attId = decoder.GetAttributeId(dracoGeometry, dracoDecoder[this.nativeAttributeMap[attributeName]]);\n        if (attId !== -1) {\n          if (this.verbosity > 0) {\n            console.log('Loaded ' + attributeName + ' attribute.');\n          }\n          var attribute = decoder.GetAttribute(dracoGeometry, attId);\n          this.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer);\n        }\n      }\n    }\n\n    // Add attributes of user specified unique id. E.g. GLTF models.\n    for (var attributeName in attributeUniqueIdMap) {\n      var attributeId = attributeUniqueIdMap[attributeName];\n      var attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeId);\n      this.addAttributeToGeometry(dracoDecoder, decoder, dracoGeometry, attributeName, attribute, geometry, geometryBuffer);\n    }\n\n    // For mesh, we need to generate the faces.\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      if (this.drawMode === THREE.TriangleStripDrawMode) {\n        var stripsArray = new dracoDecoder.DracoInt32Array();\n        var numStrips = decoder.GetTriangleStripsFromMesh(dracoGeometry, stripsArray);\n        geometryBuffer.indices = new Uint32Array(stripsArray.size());\n        for (var i = 0; i < stripsArray.size(); ++i) {\n          geometryBuffer.indices[i] = stripsArray.GetValue(i);\n        }\n        dracoDecoder.destroy(stripsArray);\n      } else {\n        var numIndices = numFaces * 3;\n        geometryBuffer.indices = new Uint32Array(numIndices);\n        var ia = new dracoDecoder.DracoInt32Array();\n        for (var i = 0; i < numFaces; ++i) {\n          decoder.GetFaceFromMesh(dracoGeometry, i, ia);\n          var index = i * 3;\n          geometryBuffer.indices[index] = ia.GetValue(0);\n          geometryBuffer.indices[index + 1] = ia.GetValue(1);\n          geometryBuffer.indices[index + 2] = ia.GetValue(2);\n        }\n        dracoDecoder.destroy(ia);\n      }\n    }\n\n    geometry.drawMode = this.drawMode;\n    if (geometryType == dracoDecoder.TRIANGULAR_MESH) {\n      geometry.setIndex(new (geometryBuffer.indices.length > 65535 ? THREE.Uint32BufferAttribute : THREE.Uint16BufferAttribute)(geometryBuffer.indices, 1));\n    }\n    var posTransform = new dracoDecoder.AttributeQuantizationTransform();\n    if (posTransform.InitFromAttribute(posAttribute)) {\n      // Quantized attribute. Store the quantization parameters into the\n      // THREE.js attribute.\n      geometry.attributes['position'].isQuantized = true;\n      geometry.attributes['position'].maxRange = posTransform.range();\n      geometry.attributes['position'].numQuantizationBits = posTransform.quantization_bits();\n      geometry.attributes['position'].minValues = new Float32Array(3);\n      for (var i = 0; i < 3; ++i) {\n        geometry.attributes['position'].minValues[i] = posTransform.min_value(i);\n      }\n    }\n    dracoDecoder.destroy(posTransform);\n    dracoDecoder.destroy(decoder);\n    dracoDecoder.destroy(dracoGeometry);\n\n    this.decode_time = decode_end - start_time;\n    this.import_time = performance.now() - decode_end;\n\n    if (this.verbosity > 0) {\n      console.log('Decode time: ' + this.decode_time);\n      console.log('Import time: ' + this.import_time);\n    }\n    return geometry;\n  },\n\n  isVersionSupported: function isVersionSupported(version, callback) {\n    DRACOLoader.getDecoderModule().then(function (module) {\n      callback(module.decoder.isVersionSupported(version));\n    });\n  },\n\n  getAttributeOptions: function getAttributeOptions(attributeName) {\n    if (typeof this.attributeOptions[attributeName] === 'undefined') this.attributeOptions[attributeName] = {};\n    return this.attributeOptions[attributeName];\n  }\n};\n\nDRACOLoader.decoderPath = './';\nDRACOLoader.decoderConfig = {};\nDRACOLoader.decoderModulePromise = null;\n\n/**\n * Sets the base path for decoder source files.\n * @param {string} path\n */\nDRACOLoader.setDecoderPath = function (path) {\n  DRACOLoader.decoderPath = path;\n};\n\n/**\n * Sets decoder configuration and releases singleton decoder module. Module\n * will be recreated with the next decoding call.\n * @param {Object} config\n */\nDRACOLoader.setDecoderConfig = function (config) {\n  var wasmBinary = DRACOLoader.decoderConfig.wasmBinary;\n  DRACOLoader.decoderConfig = config || {};\n  DRACOLoader.releaseDecoderModule();\n\n  // Reuse WASM binary.\n  if (wasmBinary) DRACOLoader.decoderConfig.wasmBinary = wasmBinary;\n};\n\n/**\n * Releases the singleton DracoDecoderModule instance. Module will be recreated\n * with the next decoding call.\n */\nDRACOLoader.releaseDecoderModule = function () {\n  DRACOLoader.decoderModulePromise = null;\n};\n\n/**\n * Gets WebAssembly or asm.js singleton instance of DracoDecoderModule\n * after testing for browser support. Returns Promise that resolves when\n * module is available.\n * @return {Promise<{decoder: DracoDecoderModule}>}\n */\nDRACOLoader.getDecoderModule = function () {\n  var scope = this;\n  var path = DRACOLoader.decoderPath;\n  var config = DRACOLoader.decoderConfig;\n  var promise = DRACOLoader.decoderModulePromise;\n\n  if (promise) return promise;\n\n  // Load source files.\n  if (typeof DracoDecoderModule !== 'undefined') {\n    // Loaded externally.\n    promise = Promise.resolve();\n  } else if ((typeof WebAssembly === 'undefined' ? 'undefined' : _typeof(WebAssembly)) !== 'object' || config.type === 'js') {\n    // Load with asm.js.\n    promise = DRACOLoader._loadScript(path + 'draco_decoder.js');\n  } else {\n    // Load with WebAssembly.\n    config.wasmBinaryFile = path + 'draco_decoder.wasm';\n    promise = DRACOLoader._loadScript(path + 'draco_wasm_wrapper.js').then(function () {\n      return DRACOLoader._loadArrayBuffer(config.wasmBinaryFile);\n    }).then(function (wasmBinary) {\n      config.wasmBinary = wasmBinary;\n    });\n  }\n\n  // Wait for source files, then create and return a decoder.\n  promise = promise.then(function () {\n    return new Promise(function (resolve) {\n      config.onModuleLoaded = function (decoder) {\n        scope.timeLoaded = performance.now();\n        // Module is Promise-like. Wrap before resolving to avoid loop.\n        resolve({ decoder: decoder });\n      };\n      DracoDecoderModule(config);\n    });\n  });\n\n  DRACOLoader.decoderModulePromise = promise;\n  return promise;\n};\n\n/**\n * @param {string} src\n * @return {Promise}\n */\nDRACOLoader._loadScript = function (src) {\n  var prevScript = document.getElementById('decoder_script');\n  if (prevScript !== null) {\n    prevScript.parentNode.removeChild(prevScript);\n  }\n  var head = document.getElementsByTagName('head')[0];\n  var script = document.createElement('script');\n  script.id = 'decoder_script';\n  script.type = 'text/javascript';\n  script.src = src;\n  return new Promise(function (resolve) {\n    script.onload = resolve;\n    head.appendChild(script);\n  });\n};\n\n/**\n * @param {string} src\n * @return {Promise}\n */\nDRACOLoader._loadArrayBuffer = function (src) {\n  var loader = new THREE.FileLoader();\n  loader.setResponseType('arraybuffer');\n  return new Promise(function (resolve, reject) {\n    loader.load(src, resolve, undefined, reject);\n  });\n};\n\nexports.default = DRACOLoader;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n* @author Richard M. / https://github.com/richardmonette\n*/\n\nvar EquiangularToCubeGenerator = function EquiangularToCubeGenerator(sourceTexture, resolution) {\n\n\tthis.sourceTexture = sourceTexture;\n\tthis.resolution = resolution;\n\n\tthis.views = [{ t: [1, 0, 0], u: [0, -1, 0] }, { t: [-1, 0, 0], u: [0, -1, 0] }, { t: [0, 1, 0], u: [0, 0, 1] }, { t: [0, -1, 0], u: [0, 0, -1] }, { t: [0, 0, 1], u: [0, -1, 0] }, { t: [0, 0, -1], u: [0, -1, 0] }];\n\n\tthis.camera = new THREE.PerspectiveCamera(90, 1, 0.1, 10);\n\tthis.boxMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), this.getShader());\n\tthis.boxMesh.material.side = THREE.BackSide;\n\tthis.scene = new THREE.Scene();\n\tthis.scene.add(this.boxMesh);\n\n\tvar params = {\n\t\tformat: THREE.RGBAFormat,\n\t\tmagFilter: this.sourceTexture.magFilter,\n\t\tminFilter: this.sourceTexture.minFilter,\n\t\ttype: this.sourceTexture.type,\n\t\tgenerateMipmaps: this.sourceTexture.generateMipmaps,\n\t\tanisotropy: this.sourceTexture.anisotropy,\n\t\tencoding: this.sourceTexture.encoding\n\t};\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube(this.resolution, this.resolution, params);\n};\n\nEquiangularToCubeGenerator.prototype = {\n\n\tconstructor: EquiangularToCubeGenerator,\n\n\tupdate: function update(renderer) {\n\n\t\tfor (var i = 0; i < 6; i++) {\n\n\t\t\tthis.renderTarget.activeCubeFace = i;\n\n\t\t\tvar v = this.views[i];\n\n\t\t\tthis.camera.position.set(0, 0, 0);\n\t\t\tthis.camera.up.set(v.u[0], v.u[1], v.u[2]);\n\t\t\tthis.camera.lookAt(v.t[0], v.t[1], v.t[2]);\n\n\t\t\trenderer.render(this.scene, this.camera, this.renderTarget, true);\n\t\t}\n\n\t\treturn this.renderTarget.texture;\n\t},\n\n\tgetShader: function getShader() {\n\n\t\tvar shaderMaterial = new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"equirectangularMap\": { value: this.sourceTexture }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec3 localPosition;\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tlocalPosition = position;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\n\\\n\t\t\t\tvarying vec3 localPosition;\\n\\\n\t\t\t\tuniform sampler2D equirectangularMap;\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvec2 EquiangularSampleUV(vec3 v) {\\n\\\n\t\t\t    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\\n\\\n\t\t\t    uv *= vec2(0.1591, 0.3183); // inverse atan\\n\\\n\t\t\t    uv += 0.5;\\n\\\n\t\t\t    return uv;\\n\\\n\t\t\t\t}\\n\\\n\t\t\t\t\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 uv = EquiangularSampleUV(normalize(localPosition));\\n\\\n    \t\t\tvec3 color = texture2D(equirectangularMap, uv).rgb;\\n\\\n    \t\t\t\\n\\\n\t\t\t\t\tgl_FragColor = vec4( color, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tblending: THREE.CustomBlending,\n\t\t\tpremultipliedAlpha: false,\n\t\t\tblendSrc: THREE.OneFactor,\n\t\t\tblendDst: THREE.ZeroFactor,\n\t\t\tblendSrcAlpha: THREE.OneFactor,\n\t\t\tblendDstAlpha: THREE.ZeroFactor,\n\t\t\tblendEquation: THREE.AddEquation\n\n\t\t});\n\n\t\tshaderMaterial.type = 'EquiangularToCubeGenerator';\n\n\t\treturn shaderMaterial;\n\t},\n\n\tdispose: function dispose() {\n\n\t\tthis.boxMesh.geometry.dispose();\n\t\tthis.boxMesh.material.dispose();\n\t\tthis.renderTarget.dispose();\n\t}\n\n};\n\nexports.default = EquiangularToCubeGenerator;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Richard M. / https://github.com/richardmonette\n *\n * OpenEXR loader which, currently, supports reading 16 bit half data, in either\n * uncompressed or PIZ wavelet compressed form.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function EXRLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nEXRLoader.prototype = Object.create(THREE.DataTextureLoader.prototype);\n\nEXRLoader.prototype._parser = function (buffer) {\n\n\tvar USHORT_RANGE = 1 << 16;\n\tvar BITMAP_SIZE = USHORT_RANGE >> 3;\n\n\tvar HUF_ENCBITS = 16; // literal (value) bit length\n\tvar HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\tvar HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1; // encoding table size\n\tvar HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\tvar HUF_DECMASK = HUF_DECSIZE - 1;\n\n\tvar SHORT_ZEROCODE_RUN = 59;\n\tvar LONG_ZEROCODE_RUN = 63;\n\tvar SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\tvar LONGEST_LONG_RUN = 255 + SHORTEST_LONG_RUN;\n\n\tvar BYTES_PER_HALF = 2;\n\n\tvar ULONG_SIZE = 8;\n\tvar FLOAT32_SIZE = 4;\n\tvar INT32_SIZE = 4;\n\tvar INT16_SIZE = 2;\n\tvar INT8_SIZE = 1;\n\n\tfunction reverseLutFromBitmap(bitmap, lut) {\n\n\t\tvar k = 0;\n\n\t\tfor (var i = 0; i < USHORT_RANGE; ++i) {\n\n\t\t\tif (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n\n\t\t\t\tlut[k++] = i;\n\t\t\t}\n\t\t}\n\n\t\tvar n = k - 1;\n\n\t\twhile (k < USHORT_RANGE) {\n\t\t\tlut[k++] = 0;\n\t\t}return n;\n\t}\n\n\tfunction hufClearDecTable(hdec) {\n\n\t\tfor (var i = 0; i < HUF_DECSIZE; i++) {\n\n\t\t\thdec[i] = {};\n\t\t\thdec[i].len = 0;\n\t\t\thdec[i].lit = 0;\n\t\t\thdec[i].p = null;\n\t\t}\n\t}\n\n\tvar getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\tfunction getBits(nBits, c, lc, uInt8Array, inOffset) {\n\n\t\twhile (lc < nBits) {\n\n\t\t\tc = c << 8 | parseUint8Array(uInt8Array, inOffset);\n\t\t\tlc += 8;\n\t\t}\n\n\t\tlc -= nBits;\n\n\t\tgetBitsReturn.l = c >> lc & (1 << nBits) - 1;\n\t\tgetBitsReturn.c = c;\n\t\tgetBitsReturn.lc = lc;\n\t}\n\n\tvar hufTableBuffer = new Array(59);\n\n\tfunction hufCanonicalCodeTable(hcode) {\n\n\t\tfor (var i = 0; i <= 58; ++i) {\n\t\t\thufTableBuffer[i] = 0;\n\t\t}for (var i = 0; i < HUF_ENCSIZE; ++i) {\n\t\t\thufTableBuffer[hcode[i]] += 1;\n\t\t}var c = 0;\n\n\t\tfor (var i = 58; i > 0; --i) {\n\n\t\t\tvar nc = c + hufTableBuffer[i] >> 1;\n\t\t\thufTableBuffer[i] = c;\n\t\t\tc = nc;\n\t\t}\n\n\t\tfor (var i = 0; i < HUF_ENCSIZE; ++i) {\n\n\t\t\tvar l = hcode[i];\n\t\t\tif (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n\t\t}\n\t}\n\n\tfunction hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n\n\t\tvar p = inOffset;\n\t\tvar c = 0;\n\t\tvar lc = 0;\n\n\t\tfor (; im <= iM; im++) {\n\n\t\t\tif (p.value - inOffset.value > ni) return false;\n\n\t\t\tgetBits(6, c, lc, uInt8Array, p);\n\n\t\t\tvar l = getBitsReturn.l;\n\t\t\tc = getBitsReturn.c;\n\t\t\tlc = getBitsReturn.lc;\n\n\t\t\thcode[im] = l;\n\n\t\t\tif (l == LONG_ZEROCODE_RUN) {\n\n\t\t\t\tif (p.value - inOffset.value > ni) {\n\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\t\t\t\t}\n\n\t\t\t\tgetBits(8, c, lc, uInt8Array, p);\n\n\t\t\t\tvar zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\tc = getBitsReturn.c;\n\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\tif (im + zerun > iM + 1) {\n\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\t\t\t\t}\n\n\t\t\t\twhile (zerun--) {\n\t\t\t\t\thcode[im++] = 0;\n\t\t\t\t}im--;\n\t\t\t} else if (l >= SHORT_ZEROCODE_RUN) {\n\n\t\t\t\tvar zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\tif (im + zerun > iM + 1) {\n\n\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\t\t\t\t}\n\n\t\t\t\twhile (zerun--) {\n\t\t\t\t\thcode[im++] = 0;\n\t\t\t\t}im--;\n\t\t\t}\n\t\t}\n\n\t\thufCanonicalCodeTable(hcode);\n\t}\n\n\tfunction hufLength(code) {\n\t\treturn code & 63;\n\t}\n\n\tfunction hufCode(code) {\n\t\treturn code >> 6;\n\t}\n\n\tfunction hufBuildDecTable(hcode, im, iM, hdecod) {\n\n\t\tfor (; im <= iM; im++) {\n\n\t\t\tvar c = hufCode(hcode[im]);\n\t\t\tvar l = hufLength(hcode[im]);\n\n\t\t\tif (c >> l) {\n\n\t\t\t\tthrow 'Invalid table entry';\n\t\t\t}\n\n\t\t\tif (l > HUF_DECBITS) {\n\n\t\t\t\tvar pl = hdecod[c >> l - HUF_DECBITS];\n\n\t\t\t\tif (pl.len) {\n\n\t\t\t\t\tthrow 'Invalid table entry';\n\t\t\t\t}\n\n\t\t\t\tpl.lit++;\n\n\t\t\t\tif (pl.p) {\n\n\t\t\t\t\tvar p = pl.p;\n\t\t\t\t\tpl.p = new Array(pl.lit);\n\n\t\t\t\t\tfor (var i = 0; i < pl.lit - 1; ++i) {\n\n\t\t\t\t\t\tpl.p[i] = p[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tpl.p = new Array(1);\n\t\t\t\t}\n\n\t\t\t\tpl.p[pl.lit - 1] = im;\n\t\t\t} else if (l) {\n\n\t\t\t\tvar plOffset = 0;\n\n\t\t\t\tfor (var i = 1 << HUF_DECBITS - l; i > 0; i--) {\n\n\t\t\t\t\tvar pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n\n\t\t\t\t\tif (pl.len || pl.p) {\n\n\t\t\t\t\t\tthrow 'Invalid table entry';\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.len = l;\n\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\tplOffset++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tvar getCharReturn = { c: 0, lc: 0 };\n\n\tfunction getChar(c, lc, uInt8Array, inOffset) {\n\n\t\tc = c << 8 | parseUint8Array(uInt8Array, inOffset);\n\t\tlc += 8;\n\n\t\tgetCharReturn.c = c;\n\t\tgetCharReturn.lc = lc;\n\t}\n\n\tvar getCodeReturn = { c: 0, lc: 0 };\n\n\tfunction getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n\n\t\tif (po == rlc) {\n\n\t\t\tif (lc < 8) {\n\n\t\t\t\tgetChar(c, lc, uInt8Array, inOffset);\n\t\t\t\tc = getCharReturn.c;\n\t\t\t\tlc = getCharReturn.lc;\n\t\t\t}\n\n\t\t\tlc -= 8;\n\n\t\t\tvar cs = c >> lc;\n\n\t\t\tif (out + cs > oe) {\n\n\t\t\t\tthrow 'Issue with getCode';\n\t\t\t}\n\n\t\t\tvar s = out[-1];\n\n\t\t\twhile (cs-- > 0) {\n\n\t\t\t\toutBuffer[outBufferOffset.value++] = s;\n\t\t\t}\n\t\t} else if (outBufferOffset.value < outBufferEndOffset) {\n\n\t\t\toutBuffer[outBufferOffset.value++] = po;\n\t\t} else {\n\n\t\t\tthrow 'Issue with getCode';\n\t\t}\n\n\t\tgetCodeReturn.c = c;\n\t\tgetCodeReturn.lc = lc;\n\t}\n\n\tvar NBITS = 16;\n\tvar A_OFFSET = 1 << NBITS - 1;\n\tvar M_OFFSET = 1 << NBITS - 1;\n\tvar MOD_MASK = (1 << NBITS) - 1;\n\n\tfunction UInt16(value) {\n\n\t\treturn value & 0xFFFF;\n\t}\n\n\tfunction Int16(value) {\n\n\t\tvar ref = UInt16(value);\n\t\treturn ref > 0x7FFF ? ref - 0x10000 : ref;\n\t}\n\n\tvar wdec14Return = { a: 0, b: 0 };\n\n\tfunction wdec14(l, h) {\n\n\t\tvar ls = Int16(l);\n\t\tvar hs = Int16(h);\n\n\t\tvar hi = hs;\n\t\tvar ai = ls + (hi & 1) + (hi >> 1);\n\n\t\tvar as = ai;\n\t\tvar bs = ai - hi;\n\n\t\twdec14Return.a = as;\n\t\twdec14Return.b = bs;\n\t}\n\n\tfunction wav2Decode(j, buffer, nx, ox, ny, oy, mx) {\n\n\t\tvar n = nx > ny ? ny : nx;\n\t\tvar p = 1;\n\t\tvar p2;\n\n\t\twhile (p <= n) {\n\t\t\tp <<= 1;\n\t\t}p >>= 1;\n\t\tp2 = p;\n\t\tp >>= 1;\n\n\t\twhile (p >= 1) {\n\n\t\t\tvar py = 0;\n\t\t\tvar ey = py + oy * (ny - p2);\n\t\t\tvar oy1 = oy * p;\n\t\t\tvar oy2 = oy * p2;\n\t\t\tvar ox1 = ox * p;\n\t\t\tvar ox2 = ox * p2;\n\t\t\tvar i00, i01, i10, i11;\n\n\t\t\tfor (; py <= ey; py += oy2) {\n\n\t\t\t\tvar px = py;\n\t\t\t\tvar ex = py + ox * (nx - p2);\n\n\t\t\t\tfor (; px <= ex; px += ox2) {\n\n\t\t\t\t\tvar p01 = px + ox1;\n\t\t\t\t\tvar p10 = px + oy1;\n\t\t\t\t\tvar p11 = p10 + ox1;\n\n\t\t\t\t\twdec14(buffer[px + j], buffer[p10 + j]);\n\n\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\twdec14(buffer[p01 + j], buffer[p11 + j]);\n\n\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\twdec14(i00, i01);\n\n\t\t\t\t\tbuffer[px + j] = wdec14Return.a;\n\t\t\t\t\tbuffer[p01 + j] = wdec14Return.b;\n\n\t\t\t\t\twdec14(i10, i11);\n\n\t\t\t\t\tbuffer[p10 + j] = wdec14Return.a;\n\t\t\t\t\tbuffer[p11 + j] = wdec14Return.b;\n\t\t\t\t}\n\n\t\t\t\tif (nx & p) {\n\n\t\t\t\t\tvar p10 = px + oy1;\n\n\t\t\t\t\twdec14(buffer[px + j], buffer[p10 + j]);\n\n\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\tbuffer[p10 + j] = wdec14Return.b;\n\n\t\t\t\t\tbuffer[px + j] = i00;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ny & p) {\n\n\t\t\t\tvar px = py;\n\t\t\t\tvar ex = py + ox * (nx - p2);\n\n\t\t\t\tfor (; px <= ex; px += ox2) {\n\n\t\t\t\t\tvar p01 = px + ox1;\n\n\t\t\t\t\twdec14(buffer[px + j], buffer[p01 + j]);\n\n\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\tbuffer[p01 + j] = wdec14Return.b;\n\n\t\t\t\t\tbuffer[px + j] = i00;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tp2 = p;\n\t\t\tp >>= 1;\n\t\t}\n\n\t\treturn py;\n\t}\n\n\tfunction hufDecode(encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n\n\t\tvar c = 0;\n\t\tvar lc = 0;\n\t\tvar outBufferEndOffset = no;\n\t\tvar inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n\n\t\twhile (inOffset.value < inOffsetEnd) {\n\n\t\t\tgetChar(c, lc, uInt8Array, inOffset);\n\n\t\t\tc = getCharReturn.c;\n\t\t\tlc = getCharReturn.lc;\n\n\t\t\twhile (lc >= HUF_DECBITS) {\n\n\t\t\t\tvar index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n\t\t\t\tvar pl = decodingTable[index];\n\n\t\t\t\tif (pl.len) {\n\n\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\tgetCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n\n\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\tlc = getCodeReturn.lc;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (!pl.p) {\n\n\t\t\t\t\t\tthrow 'hufDecode issues';\n\t\t\t\t\t}\n\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tfor (j = 0; j < pl.lit; j++) {\n\n\t\t\t\t\t\tvar l = hufLength(encodingTable[pl.p[j]]);\n\n\t\t\t\t\t\twhile (lc < l && inOffset.value < inOffsetEnd) {\n\n\t\t\t\t\t\t\tgetChar(c, lc, uInt8Array, inOffset);\n\n\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (lc >= l) {\n\n\t\t\t\t\t\t\tif (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n\n\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\tgetCode(pl.p[j], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n\n\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j == pl.lit) {\n\n\t\t\t\t\t\tthrow 'hufDecode issues';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar i = 8 - ni & 7;\n\n\t\tc >>= i;\n\t\tlc -= i;\n\n\t\twhile (lc > 0) {\n\n\t\t\tvar pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n\n\t\t\tif (pl.len) {\n\n\t\t\t\tlc -= pl.len;\n\n\t\t\t\tgetCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n\n\t\t\t\tc = getCodeReturn.c;\n\t\t\t\tlc = getCodeReturn.lc;\n\t\t\t} else {\n\n\t\t\t\tthrow 'hufDecode issues';\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, outOffset, nRaw) {\n\n\t\tvar initialInOffset = inOffset.value;\n\n\t\tvar im = parseUint32(inDataView, inOffset);\n\t\tvar iM = parseUint32(inDataView, inOffset);\n\n\t\tinOffset.value += 4;\n\n\t\tvar nBits = parseUint32(inDataView, inOffset);\n\n\t\tinOffset.value += 4;\n\n\t\tif (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n\n\t\t\tthrow 'Something wrong with HUF_ENCSIZE';\n\t\t}\n\n\t\tvar freq = new Array(HUF_ENCSIZE);\n\t\tvar hdec = new Array(HUF_DECSIZE);\n\n\t\thufClearDecTable(hdec);\n\n\t\tvar ni = nCompressed - (inOffset.value - initialInOffset);\n\n\t\thufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq);\n\n\t\tif (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n\n\t\t\tthrow 'Something wrong with hufUncompress';\n\t\t}\n\n\t\thufBuildDecTable(freq, im, iM, hdec);\n\n\t\thufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n\t}\n\n\tfunction applyLut(lut, data, nData) {\n\n\t\tfor (var i = 0; i < nData; ++i) {\n\n\t\t\tdata[i] = lut[data[i]];\n\t\t}\n\t}\n\n\tfunction decompressPIZ(outBuffer, outOffset, uInt8Array, inDataView, inOffset, tmpBufSize, num_channels, exrChannelInfos, dataWidth, num_lines) {\n\n\t\tvar bitmap = new Uint8Array(BITMAP_SIZE);\n\n\t\tvar minNonZero = parseUint16(inDataView, inOffset);\n\t\tvar maxNonZero = parseUint16(inDataView, inOffset);\n\n\t\tif (maxNonZero >= BITMAP_SIZE) {\n\n\t\t\tthrow 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n\t\t}\n\n\t\tif (minNonZero <= maxNonZero) {\n\n\t\t\tfor (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n\n\t\t\t\tbitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n\t\t\t}\n\t\t}\n\n\t\tvar lut = new Uint16Array(USHORT_RANGE);\n\t\tvar maxValue = reverseLutFromBitmap(bitmap, lut);\n\n\t\tvar length = parseUint32(inDataView, inOffset);\n\n\t\thufUncompress(uInt8Array, inDataView, inOffset, length, outBuffer, outOffset, tmpBufSize);\n\n\t\tvar pizChannelData = new Array(num_channels);\n\n\t\tvar outBufferEnd = 0;\n\n\t\tfor (var i = 0; i < num_channels; i++) {\n\n\t\t\tvar exrChannelInfo = exrChannelInfos[i];\n\n\t\t\tvar pixelSize = 2; // assumes HALF_FLOAT\n\n\t\t\tpizChannelData[i] = {};\n\t\t\tpizChannelData[i]['start'] = outBufferEnd;\n\t\t\tpizChannelData[i]['end'] = pizChannelData[i]['start'];\n\t\t\tpizChannelData[i]['nx'] = dataWidth;\n\t\t\tpizChannelData[i]['ny'] = num_lines;\n\t\t\tpizChannelData[i]['size'] = 1;\n\n\t\t\toutBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n\t\t}\n\n\t\tvar fooOffset = 0;\n\n\t\tfor (var i = 0; i < num_channels; i++) {\n\n\t\t\tfor (var j = 0; j < pizChannelData[i].size; ++j) {\n\n\t\t\t\tfooOffset += wav2Decode(j + fooOffset, outBuffer, pizChannelData[i].nx, pizChannelData[i].size, pizChannelData[i].ny, pizChannelData[i].nx * pizChannelData[i].size, maxValue);\n\t\t\t}\n\t\t}\n\n\t\tapplyLut(lut, outBuffer, outBufferEnd);\n\n\t\treturn true;\n\t}\n\n\tfunction parseNullTerminatedString(buffer, offset) {\n\n\t\tvar uintBuffer = new Uint8Array(buffer);\n\t\tvar endOffset = 0;\n\n\t\twhile (uintBuffer[offset.value + endOffset] != 0) {\n\n\t\t\tendOffset += 1;\n\t\t}\n\n\t\tvar stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset));\n\n\t\toffset.value = offset.value + endOffset + 1;\n\n\t\treturn stringValue;\n\t}\n\n\tfunction parseFixedLengthString(buffer, offset, size) {\n\n\t\tvar stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size));\n\n\t\toffset.value = offset.value + size;\n\n\t\treturn stringValue;\n\t}\n\n\tfunction parseUlong(dataView, offset) {\n\n\t\tvar uLong = dataView.getUint32(0, true);\n\n\t\toffset.value = offset.value + ULONG_SIZE;\n\n\t\treturn uLong;\n\t}\n\n\tfunction parseUint32(dataView, offset) {\n\n\t\tvar Uint32 = dataView.getUint32(offset.value, true);\n\n\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\treturn Uint32;\n\t}\n\n\tfunction parseUint8Array(uInt8Array, offset) {\n\n\t\tvar Uint8 = uInt8Array[offset.value];\n\n\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\treturn Uint8;\n\t}\n\n\tfunction parseUint8(dataView, offset) {\n\n\t\tvar Uint8 = dataView.getUint8(offset.value);\n\n\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\treturn Uint8;\n\t}\n\n\tfunction parseFloat32(dataView, offset) {\n\n\t\tvar float = dataView.getFloat32(offset.value, true);\n\n\t\toffset.value += FLOAT32_SIZE;\n\n\t\treturn float;\n\t}\n\n\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\tfunction decodeFloat16(binary) {\n\n\t\tvar exponent = (binary & 0x7C00) >> 10,\n\t\t    fraction = binary & 0x03FF;\n\n\t\treturn (binary >> 15 ? -1 : 1) * (exponent ? exponent === 0x1F ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 0x400) : 6.103515625e-5 * (fraction / 0x400));\n\t}\n\n\tfunction parseUint16(dataView, offset) {\n\n\t\tvar Uint16 = dataView.getUint16(offset.value, true);\n\n\t\toffset.value += INT16_SIZE;\n\n\t\treturn Uint16;\n\t}\n\n\tfunction parseFloat16(buffer, offset) {\n\n\t\treturn decodeFloat16(parseUint16(buffer, offset));\n\t}\n\n\tfunction parseChlist(dataView, buffer, offset, size) {\n\n\t\tvar startOffset = offset.value;\n\t\tvar channels = [];\n\n\t\twhile (offset.value < startOffset + size - 1) {\n\n\t\t\tvar name = parseNullTerminatedString(buffer, offset);\n\t\t\tvar pixelType = parseUint32(dataView, offset); // TODO: Cast this to UINT, HALF or FLOAT\n\t\t\tvar pLinear = parseUint8(dataView, offset);\n\t\t\toffset.value += 3; // reserved, three chars\n\t\t\tvar xSampling = parseUint32(dataView, offset);\n\t\t\tvar ySampling = parseUint32(dataView, offset);\n\n\t\t\tchannels.push({\n\t\t\t\tname: name,\n\t\t\t\tpixelType: pixelType,\n\t\t\t\tpLinear: pLinear,\n\t\t\t\txSampling: xSampling,\n\t\t\t\tySampling: ySampling\n\t\t\t});\n\t\t}\n\n\t\toffset.value += 1;\n\n\t\treturn channels;\n\t}\n\n\tfunction parseChromaticities(dataView, offset) {\n\n\t\tvar redX = parseFloat32(dataView, offset);\n\t\tvar redY = parseFloat32(dataView, offset);\n\t\tvar greenX = parseFloat32(dataView, offset);\n\t\tvar greenY = parseFloat32(dataView, offset);\n\t\tvar blueX = parseFloat32(dataView, offset);\n\t\tvar blueY = parseFloat32(dataView, offset);\n\t\tvar whiteX = parseFloat32(dataView, offset);\n\t\tvar whiteY = parseFloat32(dataView, offset);\n\n\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\t}\n\n\tfunction parseCompression(dataView, offset) {\n\n\t\tvar compressionCodes = ['NO_COMPRESSION', 'RLE_COMPRESSION', 'ZIPS_COMPRESSION', 'ZIP_COMPRESSION', 'PIZ_COMPRESSION'];\n\n\t\tvar compression = parseUint8(dataView, offset);\n\n\t\treturn compressionCodes[compression];\n\t}\n\n\tfunction parseBox2i(dataView, offset) {\n\n\t\tvar xMin = parseUint32(dataView, offset);\n\t\tvar yMin = parseUint32(dataView, offset);\n\t\tvar xMax = parseUint32(dataView, offset);\n\t\tvar yMax = parseUint32(dataView, offset);\n\n\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\t}\n\n\tfunction parseLineOrder(dataView, offset) {\n\n\t\tvar lineOrders = ['INCREASING_Y'];\n\n\t\tvar lineOrder = parseUint8(dataView, offset);\n\n\t\treturn lineOrders[lineOrder];\n\t}\n\n\tfunction parseV2f(dataView, offset) {\n\n\t\tvar x = parseFloat32(dataView, offset);\n\t\tvar y = parseFloat32(dataView, offset);\n\n\t\treturn [x, y];\n\t}\n\n\tfunction parseValue(dataView, buffer, offset, type, size) {\n\n\t\tif (type === 'string' || type === 'iccProfile') {\n\n\t\t\treturn parseFixedLengthString(buffer, offset, size);\n\t\t} else if (type === 'chlist') {\n\n\t\t\treturn parseChlist(dataView, buffer, offset, size);\n\t\t} else if (type === 'chromaticities') {\n\n\t\t\treturn parseChromaticities(dataView, offset);\n\t\t} else if (type === 'compression') {\n\n\t\t\treturn parseCompression(dataView, offset);\n\t\t} else if (type === 'box2i') {\n\n\t\t\treturn parseBox2i(dataView, offset);\n\t\t} else if (type === 'lineOrder') {\n\n\t\t\treturn parseLineOrder(dataView, offset);\n\t\t} else if (type === 'float') {\n\n\t\t\treturn parseFloat32(dataView, offset);\n\t\t} else if (type === 'v2f') {\n\n\t\t\treturn parseV2f(dataView, offset);\n\t\t} else if (type === 'int') {\n\n\t\t\treturn parseUint32(dataView, offset);\n\t\t} else {\n\n\t\t\tthrow 'Cannot parse value for unsupported type: ' + type;\n\t\t}\n\t}\n\n\tvar bufferDataView = new DataView(buffer);\n\tvar uInt8Array = new Uint8Array(buffer);\n\n\tvar EXRHeader = {};\n\n\tvar magic = bufferDataView.getUint32(0, true);\n\tvar versionByteZero = bufferDataView.getUint8(4, true);\n\tvar fullMask = bufferDataView.getUint8(5, true);\n\n\t// start of header\n\n\tvar offset = { value: 8 }; // start at 8, after magic stuff\n\n\tvar keepReading = true;\n\n\twhile (keepReading) {\n\n\t\tvar attributeName = parseNullTerminatedString(buffer, offset);\n\n\t\tif (attributeName == 0) {\n\n\t\t\tkeepReading = false;\n\t\t} else {\n\n\t\t\tvar attributeType = parseNullTerminatedString(buffer, offset);\n\t\t\tvar attributeSize = parseUint32(bufferDataView, offset);\n\t\t\tvar attributeValue = parseValue(bufferDataView, buffer, offset, attributeType, attributeSize);\n\n\t\t\tEXRHeader[attributeName] = attributeValue;\n\t\t}\n\t}\n\n\t// offsets\n\n\tvar dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n\tvar scanlineBlockSize = 1; // 1 for NO_COMPRESSION\n\n\tif (EXRHeader.compression === 'PIZ_COMPRESSION') {\n\n\t\tscanlineBlockSize = 32;\n\t}\n\n\tvar numBlocks = dataWindowHeight / scanlineBlockSize;\n\n\tfor (var i = 0; i < numBlocks; i++) {\n\n\t\tvar scanlineOffset = parseUlong(bufferDataView, offset);\n\t}\n\n\t// we should be passed the scanline offset table, start reading pixel data\n\n\tvar width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n\tvar height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;\n\tvar numChannels = EXRHeader.channels.length;\n\n\tvar byteArray = new Float32Array(width * height * numChannels);\n\n\tvar channelOffsets = {\n\t\tR: 0,\n\t\tG: 1,\n\t\tB: 2,\n\t\tA: 3\n\t};\n\n\tif (EXRHeader.compression === 'NO_COMPRESSION') {\n\n\t\tfor (var y = 0; y < height; y++) {\n\n\t\t\tvar y_scanline = parseUint32(bufferDataView, offset);\n\t\t\tvar dataSize = parseUint32(bufferDataView, offset);\n\n\t\t\tfor (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n\n\t\t\t\tvar cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n\t\t\t\tif (EXRHeader.channels[channelID].pixelType === 1) {\n\n\t\t\t\t\t// HALF\n\t\t\t\t\tfor (var x = 0; x < width; x++) {\n\n\t\t\t\t\t\tvar val = parseFloat16(bufferDataView, offset);\n\n\t\t\t\t\t\tbyteArray[(height - y_scanline) * (width * numChannels) + x * numChannels + cOff] = val;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'Only supported pixel format is HALF';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (EXRHeader.compression === 'PIZ_COMPRESSION') {\n\n\t\tfor (var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx++) {\n\n\t\t\tvar line_no = parseUint32(bufferDataView, offset);\n\t\t\tvar data_len = parseUint32(bufferDataView, offset);\n\n\t\t\tvar tmpBufferSize = width * scanlineBlockSize * (EXRHeader.channels.length * BYTES_PER_HALF);\n\t\t\tvar tmpBuffer = new Uint16Array(tmpBufferSize);\n\t\t\tvar tmpOffset = { value: 0 };\n\n\t\t\tdecompressPIZ(tmpBuffer, tmpOffset, uInt8Array, bufferDataView, offset, tmpBufferSize, numChannels, EXRHeader.channels, width, scanlineBlockSize);\n\n\t\t\tfor (var line_y = 0; line_y < scanlineBlockSize; line_y++) {\n\n\t\t\t\tfor (var channelID = 0; channelID < EXRHeader.channels.length; channelID++) {\n\n\t\t\t\t\tvar cOff = channelOffsets[EXRHeader.channels[channelID].name];\n\n\t\t\t\t\tif (EXRHeader.channels[channelID].pixelType === 1) {\n\n\t\t\t\t\t\t// HALF\n\t\t\t\t\t\tfor (var x = 0; x < width; x++) {\n\n\t\t\t\t\t\t\tvar val = decodeFloat16(tmpBuffer[channelID * (scanlineBlockSize * width) + line_y * width + x]);\n\n\t\t\t\t\t\t\tvar true_y = line_y + scanlineBlockIdx * scanlineBlockSize;\n\n\t\t\t\t\t\t\tbyteArray[(height - true_y) * (width * numChannels) + x * numChannels + cOff] = val;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow 'Only supported pixel format is HALF';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\n\t\tthrow 'Cannot decompress unsupported compression';\n\t}\n\n\treturn {\n\t\theader: EXRHeader,\n\t\twidth: width,\n\t\theight: height,\n\t\tdata: byteArray,\n\t\tformat: THREE.RGBFormat,\n\t\ttype: THREE.FloatType\n\t};\n};\n\nexports.default = EXRLoader;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Kyle-Larson https://github.com/Kyle-Larson\n * @author Takahiro https://github.com/takahirox\n * @author Lewy Blue https://github.com/looeee\n *\n * Loader loads FBX file and generates Group representing FBX scene.\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\n * Versions lower than this may load but will probably have errors\n *\n * Needs Support:\n *  Morph normals / blend shape normals\n *  Animation tracks for morph targets\n *\n *\tEuler rotation order\n *\n * FBX format references:\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\n *\n * \tBinary format specification:\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\n */\n\nexports.default = function () {\n\n\tvar FBXLoader = function FBXLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t};\n\n\tObject.assign(FBXLoader.prototype, {\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar resourceDirectory = THREE.LoaderUtils.extractUrlBase(url);\n\n\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.load(url, function (buffer) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tvar scene = self.parse(buffer, resourceDirectory);\n\t\t\t\t\tonLoad(scene);\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\twindow.setTimeout(function () {\n\n\t\t\t\t\t\tif (onError) onError(error);\n\n\t\t\t\t\t\tself.manager.itemError(url);\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tparse: function parse(FBXBuffer, resourceDirectory) {\n\n\t\t\tvar FBXTree;\n\n\t\t\tif (isFbxFormatBinary(FBXBuffer)) {\n\n\t\t\t\tFBXTree = new BinaryParser().parse(FBXBuffer);\n\t\t\t} else {\n\n\t\t\t\tvar FBXText = convertArrayBufferToString(FBXBuffer);\n\n\t\t\t\tif (!isFbxFormatASCII(FBXText)) {\n\n\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown format.');\n\t\t\t\t}\n\n\t\t\t\tif (getFbxVersion(FBXText) < 7000) {\n\n\t\t\t\t\tthrow new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n\t\t\t\t}\n\n\t\t\t\tFBXTree = new TextParser().parse(FBXText);\n\t\t\t}\n\n\t\t\t// console.log( FBXTree );\n\n\t\t\tvar connections = parseConnections(FBXTree);\n\t\t\tvar images = parseImages(FBXTree);\n\t\t\tvar textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n\t\t\tvar materials = parseMaterials(FBXTree, textures, connections);\n\t\t\tvar deformers = parseDeformers(FBXTree, connections);\n\t\t\tvar geometryMap = parseGeometries(FBXTree, connections, deformers);\n\t\t\tvar sceneGraph = parseScene(FBXTree, connections, deformers.skeletons, geometryMap, materials);\n\n\t\t\treturn sceneGraph;\n\t\t}\n\n\t});\n\n\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t// and details the connection type\n\tfunction parseConnections(FBXTree) {\n\n\t\tvar connectionMap = new Map();\n\n\t\tif ('Connections' in FBXTree) {\n\n\t\t\tvar rawConnections = FBXTree.Connections.connections;\n\n\t\t\trawConnections.forEach(function (rawConnection) {\n\n\t\t\t\tvar fromID = rawConnection[0];\n\t\t\t\tvar toID = rawConnection[1];\n\t\t\t\tvar relationship = rawConnection[2];\n\n\t\t\t\tif (!connectionMap.has(fromID)) {\n\n\t\t\t\t\tconnectionMap.set(fromID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\tconnectionMap.get(fromID).parents.push(parentRelationship);\n\n\t\t\t\tif (!connectionMap.has(toID)) {\n\n\t\t\t\t\tconnectionMap.set(toID, {\n\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\tchildren: []\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\tconnectionMap.get(toID).children.push(childRelationship);\n\t\t\t});\n\t\t}\n\n\t\treturn connectionMap;\n\t}\n\n\t// Parse FBXTree.Objects.Video for embedded image data\n\t// These images are connected to textures in FBXTree.Objects.Textures\n\t// via FBXTree.Connections.\n\tfunction parseImages(FBXTree) {\n\n\t\tvar images = {};\n\t\tvar blobs = {};\n\n\t\tif ('Video' in FBXTree.Objects) {\n\n\t\t\tvar videoNodes = FBXTree.Objects.Video;\n\n\t\t\tfor (var nodeID in videoNodes) {\n\n\t\t\t\tvar videoNode = videoNodes[nodeID];\n\n\t\t\t\tvar id = parseInt(nodeID);\n\n\t\t\t\timages[id] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\tif ('Content' in videoNode) {\n\n\t\t\t\t\tvar arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n\t\t\t\t\tvar base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n\n\t\t\t\t\tif (arrayBufferContent || base64Content) {\n\n\t\t\t\t\t\tvar image = parseImage(videoNodes[nodeID]);\n\n\t\t\t\t\t\tblobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var id in images) {\n\n\t\t\tvar filename = images[id];\n\n\t\t\tif (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\n\t\t}\n\n\t\treturn images;\n\t}\n\n\t// Parse embedded image data in FBXTree.Video.Content\n\tfunction parseImage(videoNode) {\n\n\t\tvar content = videoNode.Content;\n\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\tvar extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n\t\tvar type;\n\n\t\tswitch (extension) {\n\n\t\t\tcase 'bmp':\n\n\t\t\t\ttype = 'image/bmp';\n\t\t\t\tbreak;\n\n\t\t\tcase 'jpg':\n\t\t\tcase 'jpeg':\n\n\t\t\t\ttype = 'image/jpeg';\n\t\t\t\tbreak;\n\n\t\t\tcase 'png':\n\n\t\t\t\ttype = 'image/png';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tif':\n\n\t\t\t\ttype = 'image/tiff';\n\t\t\t\tbreak;\n\n\t\t\tcase 'tga':\n\n\t\t\t\tif (typeof THREE.TGALoader !== 'function') {\n\n\t\t\t\t\tconsole.warn('FBXLoader: THREE.TGALoader is required to load TGA textures');\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (THREE.Loader.Handlers.get('.tga') === null) {\n\n\t\t\t\t\t\tTHREE.Loader.Handlers.add(/\\.tga$/i, new THREE.TGALoader());\n\t\t\t\t\t}\n\n\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif (typeof content === 'string') {\n\t\t\t// ASCII format\n\n\t\t\treturn 'data:' + type + ';base64,' + content;\n\t\t} else {\n\t\t\t// Binary Format\n\n\t\t\tvar array = new Uint8Array(content);\n\t\t\treturn window.URL.createObjectURL(new Blob([array], { type: type }));\n\t\t}\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Texture\n\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t// to images in FBXTree.Objects.Video\n\tfunction parseTextures(FBXTree, loader, images, connections) {\n\n\t\tvar textureMap = new Map();\n\n\t\tif ('Texture' in FBXTree.Objects) {\n\n\t\t\tvar textureNodes = FBXTree.Objects.Texture;\n\t\t\tfor (var nodeID in textureNodes) {\n\n\t\t\t\tvar texture = parseTexture(textureNodes[nodeID], loader, images, connections);\n\t\t\t\ttextureMap.set(parseInt(nodeID), texture);\n\t\t\t}\n\t\t}\n\n\t\treturn textureMap;\n\t}\n\n\t// Parse individual node in FBXTree.Objects.Texture\n\tfunction parseTexture(textureNode, loader, images, connections) {\n\n\t\tvar texture = loadTexture(textureNode, loader, images, connections);\n\n\t\ttexture.ID = textureNode.id;\n\n\t\ttexture.name = textureNode.attrName;\n\n\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\tvar wrapModeV = textureNode.WrapModeV;\n\n\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t// 0: repeat(default), 1: clamp\n\n\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\tif ('Scaling' in textureNode) {\n\n\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\ttexture.repeat.x = values[0];\n\t\t\ttexture.repeat.y = values[1];\n\t\t}\n\n\t\treturn texture;\n\t}\n\n\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\tfunction loadTexture(textureNode, loader, images, connections) {\n\n\t\tvar fileName;\n\n\t\tvar currentPath = loader.path;\n\n\t\tvar children = connections.get(textureNode.id).children;\n\n\t\tif (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n\n\t\t\tfileName = images[children[0].ID];\n\n\t\t\tif (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n\n\t\t\t\tloader.setPath(undefined);\n\t\t\t}\n\t\t}\n\n\t\tvar texture;\n\n\t\tif (textureNode.FileName.slice(-3).toLowerCase() === 'tga') {\n\n\t\t\ttexture = THREE.Loader.Handlers.get('.tga').load(fileName);\n\t\t} else {\n\n\t\t\ttexture = loader.load(fileName);\n\t\t}\n\n\t\tloader.setPath(currentPath);\n\n\t\treturn texture;\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Material\n\tfunction parseMaterials(FBXTree, textureMap, connections) {\n\n\t\tvar materialMap = new Map();\n\n\t\tif ('Material' in FBXTree.Objects) {\n\n\t\t\tvar materialNodes = FBXTree.Objects.Material;\n\n\t\t\tfor (var nodeID in materialNodes) {\n\n\t\t\t\tvar material = parseMaterial(FBXTree, materialNodes[nodeID], textureMap, connections);\n\n\t\t\t\tif (material !== null) materialMap.set(parseInt(nodeID), material);\n\t\t\t}\n\t\t}\n\n\t\treturn materialMap;\n\t}\n\n\t// Parse single node in FBXTree.Objects.Material\n\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t// FBX format currently only supports Lambert and Phong shading models\n\tfunction parseMaterial(FBXTree, materialNode, textureMap, connections) {\n\n\t\tvar ID = materialNode.id;\n\t\tvar name = materialNode.attrName;\n\t\tvar type = materialNode.ShadingModel;\n\n\t\t//Case where FBX wraps shading model in property object.\n\t\tif ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object') {\n\n\t\t\ttype = type.value;\n\t\t}\n\n\t\t// Ignore unused materials which don't have any connections.\n\t\tif (!connections.has(ID)) return null;\n\n\t\tvar parameters = parseParameters(FBXTree, materialNode, textureMap, ID, connections);\n\n\t\tvar material;\n\n\t\tswitch (type.toLowerCase()) {\n\n\t\t\tcase 'phong':\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\tbreak;\n\t\t\tcase 'lambert':\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n\t\t\t\tmaterial = new THREE.MeshPhongMaterial({ color: 0x3300ff });\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.setValues(parameters);\n\t\tmaterial.name = name;\n\n\t\treturn material;\n\t}\n\n\t// Parse FBX material and return parameters suitable for a three.js material\n\t// Also parse the texture map and return any textures associated with the material\n\tfunction parseParameters(FBXTree, properties, textureMap, ID, connections) {\n\n\t\tvar parameters = {};\n\n\t\tif (properties.BumpFactor) {\n\n\t\t\tparameters.bumpScale = properties.BumpFactor.value;\n\t\t}\n\t\tif (properties.Diffuse) {\n\n\t\t\tparameters.color = new THREE.Color().fromArray(properties.Diffuse.value);\n\t\t} else if (properties.DiffuseColor && properties.DiffuseColor.type === 'Color') {\n\n\t\t\t// The blender exporter exports diffuse here instead of in properties.Diffuse\n\t\t\tparameters.color = new THREE.Color().fromArray(properties.DiffuseColor.value);\n\t\t}\n\t\tif (properties.DisplacementFactor) {\n\n\t\t\tparameters.displacementScale = properties.DisplacementFactor.value;\n\t\t}\n\t\tif (properties.Emissive) {\n\n\t\t\tparameters.emissive = new THREE.Color().fromArray(properties.Emissive.value);\n\t\t} else if (properties.EmissiveColor && properties.EmissiveColor.type === 'Color') {\n\n\t\t\t// The blender exporter exports emissive color here instead of in properties.Emissive\n\t\t\tparameters.emissive = new THREE.Color().fromArray(properties.EmissiveColor.value);\n\t\t}\n\t\tif (properties.EmissiveFactor) {\n\n\t\t\tparameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);\n\t\t}\n\t\tif (properties.Opacity) {\n\n\t\t\tparameters.opacity = parseFloat(properties.Opacity.value);\n\t\t}\n\t\tif (parameters.opacity < 1.0) {\n\n\t\t\tparameters.transparent = true;\n\t\t}\n\t\tif (properties.ReflectionFactor) {\n\n\t\t\tparameters.reflectivity = properties.ReflectionFactor.value;\n\t\t}\n\t\tif (properties.Shininess) {\n\n\t\t\tparameters.shininess = properties.Shininess.value;\n\t\t}\n\t\tif (properties.Specular) {\n\n\t\t\tparameters.specular = new THREE.Color().fromArray(properties.Specular.value);\n\t\t} else if (properties.SpecularColor && properties.SpecularColor.type === 'Color') {\n\n\t\t\t// The blender exporter exports specular color here instead of in properties.Specular\n\t\t\tparameters.specular = new THREE.Color().fromArray(properties.SpecularColor.value);\n\t\t}\n\n\t\tconnections.get(ID).children.forEach(function (child) {\n\n\t\t\tvar type = child.relationship;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'Bump':\n\t\t\t\t\tparameters.bumpMap = textureMap.get(child.ID);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\tparameters.map = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\tparameters.displacementMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\tparameters.emissiveMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'NormalMap':\n\t\t\t\t\tparameters.normalMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\tparameters.envMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\tparameters.specularMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\tparameters.alphaMap = getTexture(FBXTree, textureMap, child.ID, connections);\n\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientColor':\n\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t});\n\n\t\treturn parameters;\n\t}\n\n\t// get a texture from the textureMap for use by a material.\n\tfunction getTexture(FBXTree, textureMap, id, connections) {\n\n\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\tif ('LayeredTexture' in FBXTree.Objects && id in FBXTree.Objects.LayeredTexture) {\n\n\t\t\tconsole.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n\t\t\tid = connections.get(id).children[0].ID;\n\t\t}\n\n\t\treturn textureMap.get(id);\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Deformer\n\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\tfunction parseDeformers(FBXTree, connections) {\n\n\t\tvar skeletons = {};\n\t\tvar morphTargets = {};\n\n\t\tif ('Deformer' in FBXTree.Objects) {\n\n\t\t\tvar DeformerNodes = FBXTree.Objects.Deformer;\n\n\t\t\tfor (var nodeID in DeformerNodes) {\n\n\t\t\t\tvar deformerNode = DeformerNodes[nodeID];\n\n\t\t\t\tvar relationships = connections.get(parseInt(nodeID));\n\n\t\t\t\tif (deformerNode.attrType === 'Skin') {\n\n\t\t\t\t\tvar skeleton = parseSkeleton(relationships, DeformerNodes);\n\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\tif (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n\t\t\t\t\tskeleton.geometryID = relationships.parents[0].ID;\n\n\t\t\t\t\tskeletons[nodeID] = skeleton;\n\t\t\t\t} else if (deformerNode.attrType === 'BlendShape') {\n\n\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\tid: nodeID\n\t\t\t\t\t};\n\n\t\t\t\t\tmorphTarget.rawTargets = parseMorphTargets(relationships, deformerNode, DeformerNodes, connections, FBXTree);\n\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\tif (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n\t\t\t\t\tmorphTarget.parentGeoID = relationships.parents[0].ID;\n\n\t\t\t\t\tmorphTargets[nodeID] = morphTarget;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\n\t\t\tskeletons: skeletons,\n\t\t\tmorphTargets: morphTargets\n\n\t\t};\n\t}\n\n\t// Parse single nodes in FBXTree.Objects.Deformer\n\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t// Each skin node represents a skeleton and each cluster node represents a bone\n\tfunction parseSkeleton(connections, deformerNodes) {\n\n\t\tvar rawBones = [];\n\n\t\tconnections.children.forEach(function (child) {\n\n\t\t\tvar boneNode = deformerNodes[child.ID];\n\n\t\t\tif (boneNode.attrType !== 'Cluster') return;\n\n\t\t\tvar rawBone = {\n\n\t\t\t\tID: child.ID,\n\t\t\t\tindices: [],\n\t\t\t\tweights: [],\n\t\t\t\ttransform: new THREE.Matrix4().fromArray(boneNode.Transform.a),\n\t\t\t\ttransformLink: new THREE.Matrix4().fromArray(boneNode.TransformLink.a),\n\t\t\t\tlinkMode: boneNode.Mode\n\n\t\t\t};\n\n\t\t\tif ('Indexes' in boneNode) {\n\n\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\trawBone.weights = boneNode.Weights.a;\n\t\t\t}\n\n\t\t\trawBones.push(rawBone);\n\t\t});\n\n\t\treturn {\n\n\t\t\trawBones: rawBones,\n\t\t\tbones: []\n\n\t\t};\n\t}\n\n\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\tfunction parseMorphTargets(relationships, deformerNode, deformerNodes, connections) {\n\n\t\tvar rawMorphTargets = [];\n\n\t\tfor (var i = 0; i < relationships.children.length; i++) {\n\n\t\t\tif (i === 8) {\n\n\t\t\t\tconsole.warn('FBXLoader: maximum of 8 morph targets supported. Ignoring additional targets.');\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar child = relationships.children[i];\n\n\t\t\tvar morphTargetNode = deformerNodes[child.ID];\n\n\t\t\tvar rawMorphTarget = {\n\n\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\tid: morphTargetNode.id,\n\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t};\n\n\t\t\tif (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n\n\t\t\tvar targetRelationships = connections.get(parseInt(child.ID));\n\n\t\t\ttargetRelationships.children.forEach(function (child) {\n\n\t\t\t\tif (child.relationship === 'DeformPercent') {\n\n\t\t\t\t\t// TODO: animation of morph targets is currently unsupported\n\t\t\t\t\trawMorphTarget.weightCurveID = child.ID;\n\t\t\t\t\t// weightCurve = FBXTree.Objects.AnimationCurveNode[ weightCurveID ];\n\t\t\t\t} else {\n\n\t\t\t\t\trawMorphTarget.geoID = child.ID;\n\t\t\t\t\t// morphGeo = FBXTree.Objects.Geometry[ geoID ];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trawMorphTargets.push(rawMorphTarget);\n\t\t}\n\n\t\treturn rawMorphTargets;\n\t}\n\n\t// Parse nodes in FBXTree.Objects.Geometry\n\tfunction parseGeometries(FBXTree, connections, deformers) {\n\n\t\tvar geometryMap = new Map();\n\n\t\tif ('Geometry' in FBXTree.Objects) {\n\n\t\t\tvar geoNodes = FBXTree.Objects.Geometry;\n\n\t\t\tfor (var nodeID in geoNodes) {\n\n\t\t\t\tvar relationships = connections.get(parseInt(nodeID));\n\t\t\t\tvar geo = parseGeometry(FBXTree, relationships, geoNodes[nodeID], deformers);\n\n\t\t\t\tgeometryMap.set(parseInt(nodeID), geo);\n\t\t\t}\n\t\t}\n\n\t\treturn geometryMap;\n\t}\n\n\t// Parse single node in FBXTree.Objects.Geometry\n\tfunction parseGeometry(FBXTree, relationships, geoNode, deformers) {\n\n\t\tswitch (geoNode.attrType) {\n\n\t\t\tcase 'Mesh':\n\t\t\t\treturn parseMeshGeometry(FBXTree, relationships, geoNode, deformers);\n\t\t\t\tbreak;\n\n\t\t\tcase 'NurbsCurve':\n\t\t\t\treturn parseNurbsGeometry(geoNode);\n\t\t\t\tbreak;\n\n\t\t}\n\t}\n\n\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\tfunction parseMeshGeometry(FBXTree, relationships, geoNode, deformers) {\n\n\t\tvar skeletons = deformers.skeletons;\n\t\tvar morphTargets = deformers.morphTargets;\n\n\t\tvar modelNodes = relationships.parents.map(function (parent) {\n\n\t\t\treturn FBXTree.Objects.Model[parent.ID];\n\t\t});\n\n\t\t// don't create geometry if it is not associated with any models\n\t\tif (modelNodes.length === 0) return;\n\n\t\tvar skeleton = relationships.children.reduce(function (skeleton, child) {\n\n\t\t\tif (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n\n\t\t\treturn skeleton;\n\t\t}, null);\n\n\t\tvar morphTarget = relationships.children.reduce(function (morphTarget, child) {\n\n\t\t\tif (morphTargets[child.ID] !== undefined) morphTarget = morphTargets[child.ID];\n\n\t\t\treturn morphTarget;\n\t\t}, null);\n\n\t\tvar preTransform = new THREE.Matrix4();\n\n\t\t// TODO: if there is more than one model associated with the geometry, AND the models have\n\t\t// different geometric transforms, then this will cause problems\n\t\t// if ( modelNodes.length > 1 ) { }\n\n\t\t// For now just assume one model and get the preRotations from that\n\t\tvar modelNode = modelNodes[0];\n\n\t\tif ('GeometricRotation' in modelNode) {\n\n\t\t\tvar array = modelNode.GeometricRotation.value.map(THREE.Math.degToRad);\n\t\t\tarray[3] = 'ZYX';\n\n\t\t\tpreTransform.makeRotationFromEuler(new THREE.Euler().fromArray(array));\n\t\t}\n\n\t\tif ('GeometricTranslation' in modelNode) {\n\n\t\t\tpreTransform.setPosition(new THREE.Vector3().fromArray(modelNode.GeometricTranslation.value));\n\t\t}\n\n\t\tif ('GeometricScaling' in modelNode) {\n\n\t\t\tpreTransform.scale(new THREE.Vector3().fromArray(modelNode.GeometricScaling.value));\n\t\t}\n\n\t\treturn genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform);\n\t}\n\n\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\tfunction genGeometry(FBXTree, geoNode, skeleton, morphTarget, preTransform) {\n\n\t\tvar geo = new THREE.BufferGeometry();\n\t\tif (geoNode.attrName) geo.name = geoNode.attrName;\n\n\t\tvar geoInfo = getGeoInfo(geoNode, skeleton);\n\n\t\tvar buffers = genBuffers(geoInfo);\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute(buffers.vertex, 3);\n\n\t\tpreTransform.applyToBufferAttribute(positionAttribute);\n\n\t\tgeo.addAttribute('position', positionAttribute);\n\n\t\tif (buffers.colors.length > 0) {\n\n\t\t\tgeo.addAttribute('color', new THREE.Float32BufferAttribute(buffers.colors, 3));\n\t\t}\n\n\t\tif (skeleton) {\n\n\t\t\tgeo.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffers.weightsIndices, 4));\n\n\t\t\tgeo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffers.vertexWeights, 4));\n\n\t\t\t// used later to bind the skeleton to the model\n\t\t\tgeo.FBX_Deformer = skeleton;\n\t\t}\n\n\t\tif (buffers.normal.length > 0) {\n\n\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute(buffers.normal, 3);\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix(preTransform);\n\t\t\tnormalMatrix.applyToBufferAttribute(normalAttribute);\n\n\t\t\tgeo.addAttribute('normal', normalAttribute);\n\t\t}\n\n\t\tbuffers.uvs.forEach(function (uvBuffer, i) {\n\n\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\tvar name = 'uv' + (i + 1).toString();\n\n\t\t\t// the first uv buffer is just called 'uv'\n\t\t\tif (i === 0) {\n\n\t\t\t\tname = 'uv';\n\t\t\t}\n\n\t\t\tgeo.addAttribute(name, new THREE.Float32BufferAttribute(buffers.uvs[i], 2));\n\t\t});\n\n\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\tvar prevMaterialIndex = buffers.materialIndex[0];\n\t\t\tvar startIndex = 0;\n\n\t\t\tbuffers.materialIndex.forEach(function (currentIndex, i) {\n\n\t\t\t\tif (currentIndex !== prevMaterialIndex) {\n\n\t\t\t\t\tgeo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n\n\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\tif (geo.groups.length > 0) {\n\n\t\t\t\tvar lastGroup = geo.groups[geo.groups.length - 1];\n\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\tif (lastIndex !== buffers.materialIndex.length) {\n\n\t\t\t\t\tgeo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t// using one of them\n\t\t\tif (geo.groups.length === 0) {\n\n\t\t\t\tgeo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n\t\t\t}\n\t\t}\n\n\t\taddMorphTargets(FBXTree, geo, geoNode, morphTarget, preTransform);\n\n\t\treturn geo;\n\t}\n\n\tfunction getGeoInfo(geoNode, skeleton) {\n\n\t\tvar geoInfo = {};\n\n\t\tgeoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n\t\tgeoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n\n\t\tif (geoNode.LayerElementColor) {\n\n\t\t\tgeoInfo.color = getColors(geoNode.LayerElementColor[0]);\n\t\t}\n\n\t\tif (geoNode.LayerElementMaterial) {\n\n\t\t\tgeoInfo.material = getMaterials(geoNode.LayerElementMaterial[0]);\n\t\t}\n\n\t\tif (geoNode.LayerElementNormal) {\n\n\t\t\tgeoInfo.normal = getNormals(geoNode.LayerElementNormal[0]);\n\t\t}\n\n\t\tif (geoNode.LayerElementUV) {\n\n\t\t\tgeoInfo.uv = [];\n\n\t\t\tvar i = 0;\n\t\t\twhile (geoNode.LayerElementUV[i]) {\n\n\t\t\t\tgeoInfo.uv.push(getUVs(geoNode.LayerElementUV[i]));\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\n\t\tgeoInfo.weightTable = {};\n\n\t\tif (skeleton !== null) {\n\n\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\tskeleton.rawBones.forEach(function (rawBone, i) {\n\n\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\trawBone.indices.forEach(function (index, j) {\n\n\t\t\t\t\tif (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n\n\t\t\t\t\tgeoInfo.weightTable[index].push({\n\n\t\t\t\t\t\tid: i,\n\t\t\t\t\t\tweight: rawBone.weights[j]\n\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\treturn geoInfo;\n\t}\n\n\tfunction genBuffers(geoInfo) {\n\n\t\tvar buffers = {\n\t\t\tvertex: [],\n\t\t\tnormal: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\t\t\tmaterialIndex: [],\n\t\t\tvertexWeights: [],\n\t\t\tweightsIndices: []\n\t\t};\n\n\t\tvar polygonIndex = 0;\n\t\tvar faceLength = 0;\n\t\tvar displayedWeightsWarning = false;\n\n\t\t// these will hold data for a single face\n\t\tvar facePositionIndexes = [];\n\t\tvar faceNormals = [];\n\t\tvar faceColors = [];\n\t\tvar faceUVs = [];\n\t\tvar faceWeights = [];\n\t\tvar faceWeightIndices = [];\n\n\t\tgeoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n\n\t\t\tvar endOfFace = false;\n\n\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t// A cube with quad faces looks like this:\n\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t//  }\n\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\tif (vertexIndex < 0) {\n\n\t\t\t\tvertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\t\t\t\tendOfFace = true;\n\t\t\t}\n\n\t\t\tvar weightIndices = [];\n\t\t\tvar weights = [];\n\n\t\t\tfacePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n\t\t\tif (geoInfo.color) {\n\n\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n\n\t\t\t\tfaceColors.push(data[0], data[1], data[2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.skeleton) {\n\n\t\t\t\tif (geoInfo.weightTable[vertexIndex] !== undefined) {\n\n\t\t\t\t\tgeoInfo.weightTable[vertexIndex].forEach(function (wt) {\n\n\t\t\t\t\t\tweights.push(wt.weight);\n\t\t\t\t\t\tweightIndices.push(wt.id);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (weights.length > 4) {\n\n\t\t\t\t\tif (!displayedWeightsWarning) {\n\n\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar wIndex = [0, 0, 0, 0];\n\t\t\t\t\tvar Weight = [0, 0, 0, 0];\n\n\t\t\t\t\tweights.forEach(function (weight, weightIndex) {\n\n\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\tvar currentIndex = weightIndices[weightIndex];\n\n\t\t\t\t\t\tWeight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n\n\t\t\t\t\t\t\tif (currentWeight > comparedWeight) {\n\n\t\t\t\t\t\t\t\tcomparedWeightArray[comparedWeightIndex] = currentWeight;\n\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\tvar tmp = wIndex[comparedWeightIndex];\n\t\t\t\t\t\t\t\twIndex[comparedWeightIndex] = currentIndex;\n\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\tweights = Weight;\n\t\t\t\t}\n\n\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\twhile (weights.length < 4) {\n\n\t\t\t\t\tweights.push(0);\n\t\t\t\t\tweightIndices.push(0);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\t\tfaceWeights.push(weights[i]);\n\t\t\t\t\tfaceWeightIndices.push(weightIndices[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (geoInfo.normal) {\n\n\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n\n\t\t\t\tfaceNormals.push(data[0], data[1], data[2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t\tvar materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n\t\t\t}\n\n\t\t\tif (geoInfo.uv) {\n\n\t\t\t\tgeoInfo.uv.forEach(function (uv, i) {\n\n\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n\n\t\t\t\t\tif (faceUVs[i] === undefined) {\n\n\t\t\t\t\t\tfaceUVs[i] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tfaceUVs[i].push(data[0]);\n\t\t\t\t\tfaceUVs[i].push(data[1]);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfaceLength++;\n\n\t\t\tif (endOfFace) {\n\n\t\t\t\tgenFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n\n\t\t\t\tpolygonIndex++;\n\t\t\t\tfaceLength = 0;\n\n\t\t\t\t// reset arrays for the next face\n\t\t\t\tfacePositionIndexes = [];\n\t\t\t\tfaceNormals = [];\n\t\t\t\tfaceColors = [];\n\t\t\t\tfaceUVs = [];\n\t\t\t\tfaceWeights = [];\n\t\t\t\tfaceWeightIndices = [];\n\t\t\t}\n\t\t});\n\n\t\treturn buffers;\n\t}\n\n\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\tfunction genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n\n\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n\n\t\t\tif (geoInfo.skeleton) {\n\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[0]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[1]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[2]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[3]);\n\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[0]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[1]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[2]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[3]);\n\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n\t\t\t}\n\n\t\t\tif (geoInfo.color) {\n\n\t\t\t\tbuffers.colors.push(faceColors[0]);\n\t\t\t\tbuffers.colors.push(faceColors[1]);\n\t\t\t\tbuffers.colors.push(faceColors[2]);\n\n\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3]);\n\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n\n\t\t\t\tbuffers.colors.push(faceColors[i * 3]);\n\t\t\t\tbuffers.colors.push(faceColors[i * 3 + 1]);\n\t\t\t\tbuffers.colors.push(faceColors[i * 3 + 2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t}\n\n\t\t\tif (geoInfo.normal) {\n\n\t\t\t\tbuffers.normal.push(faceNormals[0]);\n\t\t\t\tbuffers.normal.push(faceNormals[1]);\n\t\t\t\tbuffers.normal.push(faceNormals[2]);\n\n\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3]);\n\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n\n\t\t\t\tbuffers.normal.push(faceNormals[i * 3]);\n\t\t\t\tbuffers.normal.push(faceNormals[i * 3 + 1]);\n\t\t\t\tbuffers.normal.push(faceNormals[i * 3 + 2]);\n\t\t\t}\n\n\t\t\tif (geoInfo.uv) {\n\n\t\t\t\tgeoInfo.uv.forEach(function (uv, j) {\n\n\t\t\t\t\tif (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][0]);\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][1]);\n\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][i * 2]);\n\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction addMorphTargets(FBXTree, parentGeo, parentGeoNode, morphTarget, preTransform) {\n\n\t\tif (morphTarget === null) return;\n\n\t\tparentGeo.morphAttributes.position = [];\n\t\tparentGeo.morphAttributes.normal = [];\n\n\t\tmorphTarget.rawTargets.forEach(function (rawTarget) {\n\n\t\t\tvar morphGeoNode = FBXTree.Objects.Geometry[rawTarget.geoID];\n\n\t\t\tif (morphGeoNode !== undefined) {\n\n\t\t\t\tgenMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform);\n\t\t\t}\n\t\t});\n\t}\n\n\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\tfunction genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform) {\n\n\t\tvar morphGeo = new THREE.BufferGeometry();\n\t\tif (morphGeoNode.attrName) morphGeo.name = morphGeoNode.attrName;\n\n\t\tvar vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t// make a copy of the parent's vertex positions\n\t\tvar vertexPositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a.slice() : [];\n\n\t\tvar morphPositions = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n\t\tvar indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n\n\t\tfor (var i = 0; i < indices.length; i++) {\n\n\t\t\tvar morphIndex = indices[i] * 3;\n\n\t\t\t// FBX format uses blend shapes rather than morph targets. This can be converted\n\t\t\t// by additively combining the blend shape positions with the original geometry's positions\n\t\t\tvertexPositions[morphIndex] += morphPositions[i * 3];\n\t\t\tvertexPositions[morphIndex + 1] += morphPositions[i * 3 + 1];\n\t\t\tvertexPositions[morphIndex + 2] += morphPositions[i * 3 + 2];\n\t\t}\n\n\t\t// TODO: add morph normal support\n\t\tvar morphGeoInfo = {\n\t\t\tvertexIndices: vertexIndices,\n\t\t\tvertexPositions: vertexPositions\n\t\t};\n\n\t\tvar morphBuffers = genBuffers(morphGeoInfo);\n\n\t\tvar positionAttribute = new THREE.Float32BufferAttribute(morphBuffers.vertex, 3);\n\t\tpositionAttribute.name = morphGeoNode.attrName;\n\n\t\tpreTransform.applyToBufferAttribute(positionAttribute);\n\n\t\tparentGeo.morphAttributes.position.push(positionAttribute);\n\t}\n\n\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\tfunction getNormals(NormalNode) {\n\n\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\tvar buffer = NormalNode.Normals.a;\n\t\tvar indexBuffer = [];\n\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\tif ('NormalIndex' in NormalNode) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\t\t\t} else if ('NormalsIndex' in NormalNode) {\n\n\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 3,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\tfunction getUVs(UVNode) {\n\n\t\tvar mappingType = UVNode.MappingInformationType;\n\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\tvar buffer = UVNode.UV.a;\n\t\tvar indexBuffer = [];\n\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\tindexBuffer = UVNode.UVIndex.a;\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 2,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\tfunction getColors(ColorNode) {\n\n\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\tvar buffer = ColorNode.Colors.a;\n\t\tvar indexBuffer = [];\n\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 4,\n\t\t\tbuffer: buffer,\n\t\t\tindices: indexBuffer,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\tfunction getMaterials(MaterialNode) {\n\n\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\tif (mappingType === 'NoMappingInformation') {\n\n\t\t\treturn {\n\t\t\t\tdataSize: 1,\n\t\t\t\tbuffer: [0],\n\t\t\t\tindices: [0],\n\t\t\t\tmappingType: 'AllSame',\n\t\t\t\treferenceType: referenceType\n\t\t\t};\n\t\t}\n\n\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t// for conforming with the other functions we've written for other data.\n\t\tvar materialIndices = [];\n\n\t\tfor (var i = 0; i < materialIndexBuffer.length; ++i) {\n\n\t\t\tmaterialIndices.push(i);\n\t\t}\n\n\t\treturn {\n\t\t\tdataSize: 1,\n\t\t\tbuffer: materialIndexBuffer,\n\t\t\tindices: materialIndices,\n\t\t\tmappingType: mappingType,\n\t\t\treferenceType: referenceType\n\t\t};\n\t}\n\n\tvar dataArray = [];\n\n\tfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\tvar index;\n\n\t\tswitch (infoObject.mappingType) {\n\n\t\t\tcase 'ByPolygonVertex':\n\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByPolygon':\n\t\t\t\tindex = polygonIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'ByVertice':\n\t\t\t\tindex = vertexIndex;\n\t\t\t\tbreak;\n\t\t\tcase 'AllSame':\n\t\t\t\tindex = infoObject.indices[0];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tconsole.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n\n\t\t}\n\n\t\tif (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n\n\t\tvar from = index * infoObject.dataSize;\n\t\tvar to = from + infoObject.dataSize;\n\n\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t}\n\n\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\tfunction parseNurbsGeometry(geoNode) {\n\n\t\tif (THREE.NURBSCurve === undefined) {\n\n\t\t\tconsole.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n\t\t\treturn new THREE.BufferGeometry();\n\t\t}\n\n\t\tvar order = parseInt(geoNode.Order);\n\n\t\tif (isNaN(order)) {\n\n\t\t\tconsole.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n\t\t\treturn new THREE.BufferGeometry();\n\t\t}\n\n\t\tvar degree = order - 1;\n\n\t\tvar knots = geoNode.KnotVector.a;\n\t\tvar controlPoints = [];\n\t\tvar pointsValues = geoNode.Points.a;\n\n\t\tfor (var i = 0, l = pointsValues.length; i < l; i += 4) {\n\n\t\t\tcontrolPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n\t\t}\n\n\t\tvar startKnot, endKnot;\n\n\t\tif (geoNode.Form === 'Closed') {\n\n\t\t\tcontrolPoints.push(controlPoints[0]);\n\t\t} else if (geoNode.Form === 'Periodic') {\n\n\t\t\tstartKnot = degree;\n\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\tfor (var i = 0; i < degree; ++i) {\n\n\t\t\t\tcontrolPoints.push(controlPoints[i]);\n\t\t\t}\n\t\t}\n\n\t\tvar curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n\t\tvar vertices = curve.getPoints(controlPoints.length * 7);\n\n\t\tvar positions = new Float32Array(vertices.length * 3);\n\n\t\tvertices.forEach(function (vertex, i) {\n\n\t\t\tvertex.toArray(positions, i * 3);\n\t\t});\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n\t\treturn geometry;\n\t}\n\n\t// create the main THREE.Group() to be returned by the loader\n\tfunction parseScene(FBXTree, connections, skeletons, geometryMap, materialMap) {\n\n\t\tvar sceneGraph = new THREE.Group();\n\n\t\tvar modelMap = parseModels(FBXTree, skeletons, geometryMap, materialMap, connections);\n\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tmodelMap.forEach(function (model) {\n\n\t\t\tvar modelNode = modelNodes[model.ID];\n\t\t\tsetLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph);\n\n\t\t\tvar parentConnections = connections.get(model.ID).parents;\n\n\t\t\tparentConnections.forEach(function (connection) {\n\n\t\t\t\tvar parent = modelMap.get(connection.ID);\n\t\t\t\tif (parent !== undefined) parent.add(model);\n\t\t\t});\n\n\t\t\tif (model.parent === null) {\n\n\t\t\t\tsceneGraph.add(model);\n\t\t\t}\n\t\t});\n\n\t\tbindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections);\n\n\t\taddAnimations(FBXTree, connections, sceneGraph);\n\n\t\tcreateAmbientLight(FBXTree, sceneGraph);\n\n\t\treturn sceneGraph;\n\t}\n\n\t// parse nodes in FBXTree.Objects.Model\n\tfunction parseModels(FBXTree, skeletons, geometryMap, materialMap, connections) {\n\n\t\tvar modelMap = new Map();\n\t\tvar modelNodes = FBXTree.Objects.Model;\n\n\t\tfor (var nodeID in modelNodes) {\n\n\t\t\tvar id = parseInt(nodeID);\n\t\t\tvar node = modelNodes[nodeID];\n\t\t\tvar relationships = connections.get(id);\n\n\t\t\tvar model = buildSkeleton(relationships, skeletons, id, node.attrName);\n\n\t\t\tif (!model) {\n\n\t\t\t\tswitch (node.attrType) {\n\n\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\tmodel = createCamera(FBXTree, relationships);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\tmodel = createLight(FBXTree, relationships);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\tmodel = createMesh(FBXTree, relationships, geometryMap, materialMap);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\tmodel = createCurve(relationships, geometryMap);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'LimbNode': // usually associated with a Bone, however if a Bone was not created we'll make a Group instead\n\t\t\t\t\tcase 'Null':\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tmodel.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n\t\t\t\tmodel.ID = id;\n\t\t\t}\n\n\t\t\tsetModelTransforms(FBXTree, model, node);\n\t\t\tmodelMap.set(id, model);\n\t\t}\n\n\t\treturn modelMap;\n\t}\n\n\tfunction buildSkeleton(relationships, skeletons, id, name) {\n\n\t\tvar bone = null;\n\n\t\trelationships.parents.forEach(function (parent) {\n\n\t\t\tfor (var ID in skeletons) {\n\n\t\t\t\tvar skeleton = skeletons[ID];\n\n\t\t\t\tskeleton.rawBones.forEach(function (rawBone, i) {\n\n\t\t\t\t\tif (rawBone.ID === parent.ID) {\n\n\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\tbone = new THREE.Bone();\n\t\t\t\t\t\tbone.matrixWorld.copy(rawBone.transformLink);\n\n\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\t\t\t\t\t\tbone.name = THREE.PropertyBinding.sanitizeNodeName(name);\n\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\tskeleton.bones[i] = bone;\n\n\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\tif (subBone !== null) {\n\n\t\t\t\t\t\t\tbone.add(subBone);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn bone;\n\t}\n\n\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\tfunction createCamera(FBXTree, relationships) {\n\n\t\tvar model;\n\t\tvar cameraAttribute;\n\n\t\trelationships.children.forEach(function (child) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n\t\t\tif (attr !== undefined) {\n\n\t\t\t\tcameraAttribute = attr;\n\t\t\t}\n\t\t});\n\n\t\tif (cameraAttribute === undefined) {\n\n\t\t\tmodel = new THREE.Object3D();\n\t\t} else {\n\n\t\t\tvar type = 0;\n\t\t\tif (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n\n\t\t\t\ttype = 1;\n\t\t\t}\n\n\t\t\tvar nearClippingPlane = 1;\n\t\t\tif (cameraAttribute.NearPlane !== undefined) {\n\n\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\t\t\t}\n\n\t\t\tvar farClippingPlane = 1000;\n\t\t\tif (cameraAttribute.FarPlane !== undefined) {\n\n\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\t\t\t}\n\n\t\t\tvar width = window.innerWidth;\n\t\t\tvar height = window.innerHeight;\n\n\t\t\tif (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n\n\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\t\t\t}\n\n\t\t\tvar aspect = width / height;\n\n\t\t\tvar fov = 45;\n\t\t\tif (cameraAttribute.FieldOfView !== undefined) {\n\n\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\t\t\t}\n\n\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\t// Perspective\n\t\t\t\t\tmodel = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n\t\t\t\t\tif (focalLength !== null) model.setFocalLength(focalLength);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\t// Orthographic\n\t\t\t\t\tmodel = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t}\n\n\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\tfunction createLight(FBXTree, relationships) {\n\n\t\tvar model;\n\t\tvar lightAttribute;\n\n\t\trelationships.children.forEach(function (child) {\n\n\t\t\tvar attr = FBXTree.Objects.NodeAttribute[child.ID];\n\n\t\t\tif (attr !== undefined) {\n\n\t\t\t\tlightAttribute = attr;\n\t\t\t}\n\t\t});\n\n\t\tif (lightAttribute === undefined) {\n\n\t\t\tmodel = new THREE.Object3D();\n\t\t} else {\n\n\t\t\tvar type;\n\n\t\t\t// LightType can be undefined for Point lights\n\t\t\tif (lightAttribute.LightType === undefined) {\n\n\t\t\t\ttype = 0;\n\t\t\t} else {\n\n\t\t\t\ttype = lightAttribute.LightType.value;\n\t\t\t}\n\n\t\t\tvar color = 0xffffff;\n\n\t\t\tif (lightAttribute.Color !== undefined) {\n\n\t\t\t\tcolor = new THREE.Color().fromArray(lightAttribute.Color.value);\n\t\t\t}\n\n\t\t\tvar intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t// light disabled\n\t\t\tif (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n\n\t\t\t\tintensity = 0;\n\t\t\t}\n\n\t\t\tvar distance = 0;\n\t\t\tif (lightAttribute.FarAttenuationEnd !== undefined) {\n\n\t\t\t\tif (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n\n\t\t\t\t\tdistance = 0;\n\t\t\t\t} else {\n\n\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\tvar decay = 1;\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 0:\n\t\t\t\t\t// Point\n\t\t\t\t\tmodel = new THREE.PointLight(color, intensity, distance, decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\t// Directional\n\t\t\t\t\tmodel = new THREE.DirectionalLight(color, intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\t// Spot\n\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\tif (lightAttribute.InnerAngle !== undefined) {\n\n\t\t\t\t\t\tangle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\tif (lightAttribute.OuterAngle !== undefined) {\n\n\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\tpenumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n\t\t\t\t\t\tpenumbra = Math.max(penumbra, 1);\n\t\t\t\t\t}\n\n\t\t\t\t\tmodel = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n\t\t\t\t\tmodel = new THREE.PointLight(color, intensity);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n\n\t\t\t\tmodel.castShadow = true;\n\t\t\t}\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tfunction createMesh(FBXTree, relationships, geometryMap, materialMap) {\n\n\t\tvar model;\n\t\tvar geometry = null;\n\t\tvar material = null;\n\t\tvar materials = [];\n\n\t\t// get geometry and materials(s) from connections\n\t\trelationships.children.forEach(function (child) {\n\n\t\t\tif (geometryMap.has(child.ID)) {\n\n\t\t\t\tgeometry = geometryMap.get(child.ID);\n\t\t\t}\n\n\t\t\tif (materialMap.has(child.ID)) {\n\n\t\t\t\tmaterials.push(materialMap.get(child.ID));\n\t\t\t}\n\t\t});\n\n\t\tif (materials.length > 1) {\n\n\t\t\tmaterial = materials;\n\t\t} else if (materials.length > 0) {\n\n\t\t\tmaterial = materials[0];\n\t\t} else {\n\n\t\t\tmaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });\n\t\t\tmaterials.push(material);\n\t\t}\n\n\t\tif ('color' in geometry.attributes) {\n\n\t\t\tmaterials.forEach(function (material) {\n\n\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\t\t\t});\n\t\t}\n\n\t\tif (geometry.FBX_Deformer) {\n\n\t\t\tmaterials.forEach(function (material) {\n\n\t\t\t\tmaterial.skinning = true;\n\t\t\t});\n\n\t\t\tmodel = new THREE.SkinnedMesh(geometry, material);\n\t\t} else {\n\n\t\t\tmodel = new THREE.Mesh(geometry, material);\n\t\t}\n\n\t\treturn model;\n\t}\n\n\tfunction createCurve(relationships, geometryMap) {\n\n\t\tvar geometry = relationships.children.reduce(function (geo, child) {\n\n\t\t\tif (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n\n\t\t\treturn geo;\n\t\t}, null);\n\n\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\tvar material = new THREE.LineBasicMaterial({ color: 0x3300ff, linewidth: 1 });\n\t\treturn new THREE.Line(geometry, material);\n\t}\n\n\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\tfunction createAmbientLight(FBXTree, sceneGraph) {\n\n\t\tif ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings) {\n\n\t\t\tvar ambientColor = FBXTree.GlobalSettings.AmbientColor.value;\n\t\t\tvar r = ambientColor[0];\n\t\t\tvar g = ambientColor[1];\n\t\t\tvar b = ambientColor[2];\n\n\t\t\tif (r !== 0 || g !== 0 || b !== 0) {\n\n\t\t\t\tvar color = new THREE.Color(r, g, b);\n\t\t\t\tsceneGraph.add(new THREE.AmbientLight(color, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setLookAtProperties(FBXTree, model, modelNode, connections, sceneGraph) {\n\n\t\tif ('LookAtProperty' in modelNode) {\n\n\t\t\tvar children = connections.get(model.ID).children;\n\n\t\t\tchildren.forEach(function (child) {\n\n\t\t\t\tif (child.relationship === 'LookAtProperty') {\n\n\t\t\t\t\tvar lookAtTarget = FBXTree.Objects.Model[child.ID];\n\n\t\t\t\t\tif ('Lcl_Translation' in lookAtTarget) {\n\n\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\tif (model.target !== undefined) {\n\n\t\t\t\t\t\t\tmodel.target.position.fromArray(pos);\n\t\t\t\t\t\t\tsceneGraph.add(model.target);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Cameras and other Object3Ds\n\n\t\t\t\t\t\t\tmodel.lookAt(new THREE.Vector3().fromArray(pos));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t// parse the model node for transform details and apply them to the model\n\tfunction setModelTransforms(FBXTree, model, modelNode) {\n\n\t\t// http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\tif ('RotationOrder' in modelNode) {\n\n\t\t\tvar enums = ['XYZ', // default\n\t\t\t'XZY', 'YZX', 'ZXY', 'YXZ', 'ZYX', 'SphericXYZ'];\n\n\t\t\tvar value = parseInt(modelNode.RotationOrder.value, 10);\n\n\t\t\tif (value > 0 && value < 6) {\n\n\t\t\t\t// model.rotation.order = enums[ value ];\n\n\t\t\t\t// Note: Euler order other than XYZ is currently not supported, so just display a warning for now\n\t\t\t\tconsole.warn('THREE.FBXLoader: unsupported Euler Order: %s. Currently only XYZ order is supported. Animations and rotations may be incorrect.', enums[value]);\n\t\t\t} else if (value === 6) {\n\n\t\t\t\tconsole.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n\t\t\t}\n\t\t}\n\n\t\tif ('Lcl_Translation' in modelNode) {\n\n\t\t\tmodel.position.fromArray(modelNode.Lcl_Translation.value);\n\t\t}\n\n\t\tif ('Lcl_Rotation' in modelNode) {\n\n\t\t\tvar rotation = modelNode.Lcl_Rotation.value.map(THREE.Math.degToRad);\n\t\t\trotation.push('ZYX');\n\t\t\tmodel.quaternion.setFromEuler(new THREE.Euler().fromArray(rotation));\n\t\t}\n\n\t\tif ('Lcl_Scaling' in modelNode) {\n\n\t\t\tmodel.scale.fromArray(modelNode.Lcl_Scaling.value);\n\t\t}\n\n\t\tif ('PreRotation' in modelNode) {\n\n\t\t\tvar array = modelNode.PreRotation.value.map(THREE.Math.degToRad);\n\t\t\tarray[3] = 'ZYX';\n\n\t\t\tvar preRotations = new THREE.Euler().fromArray(array);\n\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler(preRotations);\n\t\t\tmodel.quaternion.premultiply(preRotations);\n\t\t}\n\t}\n\n\tfunction bindSkeleton(FBXTree, skeletons, geometryMap, modelMap, connections) {\n\n\t\tvar bindMatrices = parsePoseNodes(FBXTree);\n\n\t\tfor (var ID in skeletons) {\n\n\t\t\tvar skeleton = skeletons[ID];\n\n\t\t\tvar parents = connections.get(parseInt(skeleton.ID)).parents;\n\n\t\t\tparents.forEach(function (parent) {\n\n\t\t\t\tif (geometryMap.has(parent.ID)) {\n\n\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\tvar geoRelationships = connections.get(geoID);\n\n\t\t\t\t\tgeoRelationships.parents.forEach(function (geoConnParent) {\n\n\t\t\t\t\t\tif (modelMap.has(geoConnParent.ID)) {\n\n\t\t\t\t\t\t\tvar model = modelMap.get(geoConnParent.ID);\n\n\t\t\t\t\t\t\tmodel.bind(new THREE.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction parsePoseNodes(FBXTree) {\n\n\t\tvar bindMatrices = {};\n\n\t\tif ('Pose' in FBXTree.Objects) {\n\n\t\t\tvar BindPoseNode = FBXTree.Objects.Pose;\n\n\t\t\tfor (var nodeID in BindPoseNode) {\n\n\t\t\t\tif (BindPoseNode[nodeID].attrType === 'BindPose') {\n\n\t\t\t\t\tvar poseNodes = BindPoseNode[nodeID].PoseNode;\n\n\t\t\t\t\tif (Array.isArray(poseNodes)) {\n\n\t\t\t\t\t\tposeNodes.forEach(function (poseNode) {\n\n\t\t\t\t\t\t\tbindMatrices[poseNode.Node] = new THREE.Matrix4().fromArray(poseNode.Matrix.a);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbindMatrices[poseNodes.Node] = new THREE.Matrix4().fromArray(poseNodes.Matrix.a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bindMatrices;\n\t}\n\n\tfunction parseAnimations(FBXTree, connections) {\n\n\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t// if this is undefined we can safely assume there are no animations\n\t\tif (FBXTree.Objects.AnimationCurve === undefined) return undefined;\n\n\t\tvar curveNodesMap = parseAnimationCurveNodes(FBXTree);\n\n\t\tparseAnimationCurves(FBXTree, connections, curveNodesMap);\n\n\t\tvar layersMap = parseAnimationLayers(FBXTree, connections, curveNodesMap);\n\t\tvar rawClips = parseAnimStacks(FBXTree, connections, layersMap);\n\n\t\treturn rawClips;\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t// and is referenced by an AnimationLayer\n\tfunction parseAnimationCurveNodes(FBXTree) {\n\n\t\tvar rawCurveNodes = FBXTree.Objects.AnimationCurveNode;\n\n\t\tvar curveNodesMap = new Map();\n\n\t\tfor (var nodeID in rawCurveNodes) {\n\n\t\t\tvar rawCurveNode = rawCurveNodes[nodeID];\n\n\t\t\tif (rawCurveNode.attrName.match(/S|R|T/) !== null) {\n\n\t\t\t\tvar curveNode = {\n\n\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\tcurves: {}\n\n\t\t\t\t};\n\n\t\t\t\tcurveNodesMap.set(curveNode.id, curveNode);\n\t\t\t}\n\t\t}\n\n\t\treturn curveNodesMap;\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t// axis ( e.g. times and values of x rotation)\n\tfunction parseAnimationCurves(FBXTree, connections, curveNodesMap) {\n\n\t\tvar rawCurves = FBXTree.Objects.AnimationCurve;\n\n\t\tfor (var nodeID in rawCurves) {\n\n\t\t\tvar animationCurve = {\n\n\t\t\t\tid: rawCurves[nodeID].id,\n\t\t\t\ttimes: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n\t\t\t\tvalues: rawCurves[nodeID].KeyValueFloat.a\n\n\t\t\t};\n\n\t\t\tvar relationships = connections.get(animationCurve.id);\n\n\t\t\tif (relationships !== undefined) {\n\n\t\t\t\tvar animationCurveID = relationships.parents[0].ID;\n\t\t\t\tvar animationCurveRelationship = relationships.parents[0].relationship;\n\n\t\t\t\tif (animationCurveRelationship.match(/X/)) {\n\n\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n\t\t\t\t} else if (animationCurveRelationship.match(/Y/)) {\n\n\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n\t\t\t\t} else if (animationCurveRelationship.match(/Z/)) {\n\n\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\tfunction parseAnimationLayers(FBXTree, connections, curveNodesMap) {\n\n\t\tvar rawLayers = FBXTree.Objects.AnimationLayer;\n\n\t\tvar layersMap = new Map();\n\n\t\tfor (var nodeID in rawLayers) {\n\n\t\t\tvar layerCurveNodes = [];\n\n\t\t\tvar connection = connections.get(parseInt(nodeID));\n\n\t\t\tif (connection !== undefined) {\n\n\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\tvar children = connection.children;\n\n\t\t\t\tchildren.forEach(function (child, i) {\n\n\t\t\t\t\tif (curveNodesMap.has(child.ID)) {\n\n\t\t\t\t\t\tvar curveNode = curveNodesMap.get(child.ID);\n\n\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\tif (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n\n\t\t\t\t\t\t\tif (layerCurveNodes[i] === undefined) {\n\n\t\t\t\t\t\t\t\tvar modelID;\n\n\t\t\t\t\t\t\t\tconnections.get(child.ID).parents.forEach(function (parent) {\n\n\t\t\t\t\t\t\t\t\tif (parent.relationship !== undefined) modelID = parent.ID;\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tvar rawModel = FBXTree.Objects.Model[modelID.toString()];\n\n\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\tmodelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),\n\t\t\t\t\t\t\t\t\tinitialPosition: [0, 0, 0],\n\t\t\t\t\t\t\t\t\tinitialRotation: [0, 0, 0],\n\t\t\t\t\t\t\t\t\tinitialScale: [1, 1, 1]\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif ('Lcl_Translation' in rawModel) node.initialPosition = rawModel.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\tif ('Lcl_Rotation' in rawModel) node.initialRotation = rawModel.Lcl_Rotation.value;\n\n\t\t\t\t\t\t\t\tif ('Lcl_Scaling' in rawModel) node.initialScale = rawModel.Lcl_Scaling.value;\n\n\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\tif ('PreRotation' in rawModel) node.preRotations = rawModel.PreRotation.value;\n\n\t\t\t\t\t\t\t\tlayerCurveNodes[i] = node;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlayerCurveNodes[i][curveNode.attr] = curveNode;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tlayersMap.set(parseInt(nodeID), layerCurveNodes);\n\t\t\t}\n\t\t}\n\n\t\treturn layersMap;\n\t}\n\n\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\tfunction parseAnimStacks(FBXTree, connections, layersMap) {\n\n\t\tvar rawStacks = FBXTree.Objects.AnimationStack;\n\n\t\t// connect the stacks (clips) up to the layers\n\t\tvar rawClips = {};\n\n\t\tfor (var nodeID in rawStacks) {\n\n\t\t\tvar children = connections.get(parseInt(nodeID)).children;\n\n\t\t\tif (children.length > 1) {\n\n\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\tconsole.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n\t\t\t}\n\n\t\t\tvar layer = layersMap.get(children[0].ID);\n\n\t\t\trawClips[nodeID] = {\n\n\t\t\t\tname: rawStacks[nodeID].attrName,\n\t\t\t\tlayer: layer\n\n\t\t\t};\n\t\t}\n\n\t\treturn rawClips;\n\t}\n\n\t// take raw animation data from parseAnimations and connect it up to the loaded models\n\tfunction addAnimations(FBXTree, connections, sceneGraph) {\n\n\t\tsceneGraph.animations = [];\n\n\t\tvar rawClips = parseAnimations(FBXTree, connections);\n\n\t\tif (rawClips === undefined) return;\n\n\t\tfor (var key in rawClips) {\n\n\t\t\tvar rawClip = rawClips[key];\n\n\t\t\tvar clip = addClip(rawClip);\n\n\t\t\tsceneGraph.animations.push(clip);\n\t\t}\n\t}\n\n\tfunction addClip(rawClip) {\n\n\t\tvar tracks = [];\n\n\t\trawClip.layer.forEach(function (rawTracks) {\n\n\t\t\ttracks = tracks.concat(generateTracks(rawTracks));\n\t\t});\n\n\t\treturn new THREE.AnimationClip(rawClip.name, -1, tracks);\n\t}\n\n\tfunction generateTracks(rawTracks) {\n\n\t\tvar tracks = [];\n\n\t\tif (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n\n\t\t\tvar positionTrack = generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, rawTracks.initialPosition, 'position');\n\t\t\tif (positionTrack !== undefined) tracks.push(positionTrack);\n\t\t}\n\n\t\tif (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n\n\t\t\tvar rotationTrack = generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, rawTracks.initialRotation, rawTracks.preRotations);\n\t\t\tif (rotationTrack !== undefined) tracks.push(rotationTrack);\n\t\t}\n\n\t\tif (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n\n\t\t\tvar scaleTrack = generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, rawTracks.initialScale, 'scale');\n\t\t\tif (scaleTrack !== undefined) tracks.push(scaleTrack);\n\t\t}\n\n\t\treturn tracks;\n\t}\n\n\tfunction generateVectorTrack(modelName, curves, initialValue, type) {\n\n\t\tvar times = getTimesForAllAxes(curves);\n\t\tvar values = getKeyframeTrackValues(times, curves, initialValue);\n\n\t\treturn new THREE.VectorKeyframeTrack(modelName + '.' + type, times, values);\n\t}\n\n\tfunction generateRotationTrack(modelName, curves, initialValue, preRotations) {\n\n\t\tif (curves.x !== undefined) {\n\n\t\t\tinterpolateRotations(curves.x);\n\t\t\tcurves.x.values = curves.x.values.map(THREE.Math.degToRad);\n\t\t}\n\t\tif (curves.y !== undefined) {\n\n\t\t\tinterpolateRotations(curves.y);\n\t\t\tcurves.y.values = curves.y.values.map(THREE.Math.degToRad);\n\t\t}\n\t\tif (curves.z !== undefined) {\n\n\t\t\tinterpolateRotations(curves.z);\n\t\t\tcurves.z.values = curves.z.values.map(THREE.Math.degToRad);\n\t\t}\n\n\t\tvar times = getTimesForAllAxes(curves);\n\t\tvar values = getKeyframeTrackValues(times, curves, initialValue);\n\n\t\tif (preRotations !== undefined) {\n\n\t\t\tpreRotations = preRotations.map(THREE.Math.degToRad);\n\t\t\tpreRotations.push('ZYX');\n\n\t\t\tpreRotations = new THREE.Euler().fromArray(preRotations);\n\t\t\tpreRotations = new THREE.Quaternion().setFromEuler(preRotations);\n\t\t}\n\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar euler = new THREE.Euler();\n\n\t\tvar quaternionValues = [];\n\n\t\tfor (var i = 0; i < values.length; i += 3) {\n\n\t\t\teuler.set(values[i], values[i + 1], values[i + 2], 'ZYX');\n\n\t\t\tquaternion.setFromEuler(euler);\n\n\t\t\tif (preRotations !== undefined) quaternion.premultiply(preRotations);\n\n\t\t\tquaternion.toArray(quaternionValues, i / 3 * 4);\n\t\t}\n\n\t\treturn new THREE.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n\t}\n\n\tfunction getKeyframeTrackValues(times, curves, initialValue) {\n\n\t\tvar prevValue = initialValue;\n\n\t\tvar values = [];\n\n\t\tvar xIndex = -1;\n\t\tvar yIndex = -1;\n\t\tvar zIndex = -1;\n\n\t\ttimes.forEach(function (time) {\n\n\t\t\tif (curves.x) xIndex = curves.x.times.indexOf(time);\n\t\t\tif (curves.y) yIndex = curves.y.times.indexOf(time);\n\t\t\tif (curves.z) zIndex = curves.z.times.indexOf(time);\n\n\t\t\t// if there is an x value defined for this frame, use that\n\t\t\tif (xIndex !== -1) {\n\n\t\t\t\tvar xValue = curves.x.values[xIndex];\n\t\t\t\tvalues.push(xValue);\n\t\t\t\tprevValue[0] = xValue;\n\t\t\t} else {\n\n\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\tvalues.push(prevValue[0]);\n\t\t\t}\n\n\t\t\tif (yIndex !== -1) {\n\n\t\t\t\tvar yValue = curves.y.values[yIndex];\n\t\t\t\tvalues.push(yValue);\n\t\t\t\tprevValue[1] = yValue;\n\t\t\t} else {\n\n\t\t\t\tvalues.push(prevValue[1]);\n\t\t\t}\n\n\t\t\tif (zIndex !== -1) {\n\n\t\t\t\tvar zValue = curves.z.values[zIndex];\n\t\t\t\tvalues.push(zValue);\n\t\t\t\tprevValue[2] = zValue;\n\t\t\t} else {\n\n\t\t\t\tvalues.push(prevValue[2]);\n\t\t\t}\n\t\t});\n\n\t\treturn values;\n\t}\n\n\t// For all animated objects, times are defined separately for each axis\n\t// Here we'll combine the times into one sorted array without duplicates\n\tfunction getTimesForAllAxes(curves) {\n\n\t\tvar times = [];\n\n\t\t// first join together the times for each axis, if defined\n\t\tif (curves.x !== undefined) times = times.concat(curves.x.times);\n\t\tif (curves.y !== undefined) times = times.concat(curves.y.times);\n\t\tif (curves.z !== undefined) times = times.concat(curves.z.times);\n\n\t\t// then sort them and remove duplicates\n\t\ttimes = times.sort(function (a, b) {\n\n\t\t\treturn a - b;\n\t\t}).filter(function (elem, index, array) {\n\n\t\t\treturn array.indexOf(elem) == index;\n\t\t});\n\n\t\treturn times;\n\t}\n\n\t// Rotations are defined as Euler angles which can have values  of any size\n\t// These will be converted to quaternions which don't support values greater than\n\t// PI, so we'll interpolate large rotations\n\tfunction interpolateRotations(curve) {\n\n\t\tfor (var i = 1; i < curve.values.length; i++) {\n\n\t\t\tvar initialValue = curve.values[i - 1];\n\t\t\tvar valuesSpan = curve.values[i] - initialValue;\n\n\t\t\tvar absoluteSpan = Math.abs(valuesSpan);\n\n\t\t\tif (absoluteSpan >= 180) {\n\n\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\tvar initialTime = curve.times[i - 1];\n\t\t\t\tvar timeSpan = curve.times[i] - initialTime;\n\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\twhile (nextTime < curve.times[i]) {\n\n\t\t\t\t\tinterpolatedTimes.push(nextTime);\n\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\tinterpolatedValues.push(nextValue);\n\t\t\t\t\tnextValue += step;\n\t\t\t\t}\n\n\t\t\t\tcurve.times = inject(curve.times, i, interpolatedTimes);\n\t\t\t\tcurve.values = inject(curve.values, i, interpolatedValues);\n\t\t\t}\n\t\t}\n\t}\n\n\t// parse an FBX file in ASCII format\n\tfunction TextParser() {}\n\n\tObject.assign(TextParser.prototype, {\n\n\t\tgetPrevNode: function getPrevNode() {\n\n\t\t\treturn this.nodeStack[this.currentIndent - 2];\n\t\t},\n\n\t\tgetCurrentNode: function getCurrentNode() {\n\n\t\t\treturn this.nodeStack[this.currentIndent - 1];\n\t\t},\n\n\t\tgetCurrentProp: function getCurrentProp() {\n\n\t\t\treturn this.currentProp;\n\t\t},\n\n\t\tpushStack: function pushStack(node) {\n\n\t\t\tthis.nodeStack.push(node);\n\t\t\tthis.currentIndent += 1;\n\t\t},\n\n\t\tpopStack: function popStack() {\n\n\t\t\tthis.nodeStack.pop();\n\t\t\tthis.currentIndent -= 1;\n\t\t},\n\n\t\tsetCurrentProp: function setCurrentProp(val, name) {\n\n\t\t\tthis.currentProp = val;\n\t\t\tthis.currentPropName = name;\n\t\t},\n\n\t\tparse: function parse(text) {\n\n\t\t\tthis.currentIndent = 0;\n\t\t\tthis.allNodes = new FBXTree();\n\t\t\tthis.nodeStack = [];\n\t\t\tthis.currentProp = [];\n\t\t\tthis.currentPropName = '';\n\n\t\t\tvar self = this;\n\n\t\t\tvar split = text.split('\\n');\n\n\t\t\tsplit.forEach(function (line, i) {\n\n\t\t\t\tvar matchComment = line.match(/^[\\s\\t]*;/);\n\t\t\t\tvar matchEmpty = line.match(/^[\\s\\t]*$/);\n\n\t\t\t\tif (matchComment || matchEmpty) return;\n\n\t\t\t\tvar matchBeginning = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '');\n\t\t\t\tvar matchProperty = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n\t\t\t\tvar matchEnd = line.match('^\\\\t{' + (self.currentIndent - 1) + '}}');\n\n\t\t\t\tif (matchBeginning) {\n\n\t\t\t\t\tself.parseNodeBegin(line, matchBeginning);\n\t\t\t\t} else if (matchProperty) {\n\n\t\t\t\t\tself.parseNodeProperty(line, matchProperty, split[++i]);\n\t\t\t\t} else if (matchEnd) {\n\n\t\t\t\t\tself.popStack();\n\t\t\t\t} else if (line.match(/^[^\\s\\t}]/)) {\n\n\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\tself.parseNodePropertyContinued(line);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn this.allNodes;\n\t\t},\n\n\t\tparseNodeBegin: function parseNodeBegin(line, property) {\n\n\t\t\tvar nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n\n\t\t\tvar nodeAttrs = property[2].split(',').map(function (attr) {\n\n\t\t\t\treturn attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n\t\t\t});\n\n\t\t\tvar node = { name: nodeName };\n\t\t\tvar attrs = this.parseNodeAttr(nodeAttrs);\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t// a top node\n\t\t\tif (this.currentIndent === 0) {\n\n\t\t\t\tthis.allNodes.add(nodeName, node);\n\t\t\t} else {\n\t\t\t\t// a subnode\n\n\t\t\t\t// if the subnode already exists, append it\n\t\t\t\tif (nodeName in currentNode) {\n\n\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\tif (nodeName === 'PoseNode') {\n\n\t\t\t\t\t\tcurrentNode.PoseNode.push(node);\n\t\t\t\t\t} else if (currentNode[nodeName].id !== undefined) {\n\n\t\t\t\t\t\tcurrentNode[nodeName] = {};\n\t\t\t\t\t\tcurrentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n\t\t\t\t} else if (typeof attrs.id === 'number') {\n\n\t\t\t\t\tcurrentNode[nodeName] = {};\n\t\t\t\t\tcurrentNode[nodeName][attrs.id] = node;\n\t\t\t\t} else if (nodeName !== 'Properties70') {\n\n\t\t\t\t\tif (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof attrs.id === 'number') node.id = attrs.id;\n\t\t\tif (attrs.name !== '') node.attrName = attrs.name;\n\t\t\tif (attrs.type !== '') node.attrType = attrs.type;\n\n\t\t\tthis.pushStack(node);\n\t\t},\n\n\t\tparseNodeAttr: function parseNodeAttr(attrs) {\n\n\t\t\tvar id = attrs[0];\n\n\t\t\tif (attrs[0] !== '') {\n\n\t\t\t\tid = parseInt(attrs[0]);\n\n\t\t\t\tif (isNaN(id)) {\n\n\t\t\t\t\tid = attrs[0];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar name = '',\n\t\t\t    type = '';\n\n\t\t\tif (attrs.length > 1) {\n\n\t\t\t\tname = attrs[1].replace(/^(\\w+)::/, '');\n\t\t\t\ttype = attrs[2];\n\t\t\t}\n\n\t\t\treturn { id: id, name: name, type: type };\n\t\t},\n\n\t\tparseNodeProperty: function parseNodeProperty(line, property, contentLine) {\n\n\t\t\tvar propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n\t\t\tvar propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim();\n\n\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t//\tContent: ,\n\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\tif (propName === 'Content' && propValue === ',') {\n\n\t\t\t\tpropValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n\t\t\t}\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\tvar parentName = currentNode.name;\n\n\t\t\tif (parentName === 'Properties70') {\n\n\t\t\t\tthis.parseNodeSpecialProperty(line, propName, propValue);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Connections\n\t\t\tif (propName === 'C') {\n\n\t\t\t\tvar connProps = propValue.split(',').slice(1);\n\t\t\t\tvar from = parseInt(connProps[0]);\n\t\t\t\tvar to = parseInt(connProps[1]);\n\n\t\t\t\tvar rest = propValue.split(',').slice(3);\n\n\t\t\t\trest = rest.map(function (elem) {\n\n\t\t\t\t\treturn elem.trim().replace(/^\"/, '');\n\t\t\t\t});\n\n\t\t\t\tpropName = 'connections';\n\t\t\t\tpropValue = [from, to];\n\t\t\t\tappend(propValue, rest);\n\n\t\t\t\tif (currentNode[propName] === undefined) {\n\n\t\t\t\t\tcurrentNode[propName] = [];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Node\n\t\t\tif (propName === 'Node') currentNode.id = propValue;\n\n\t\t\t// connections\n\t\t\tif (propName in currentNode && Array.isArray(currentNode[propName])) {\n\n\t\t\t\tcurrentNode[propName].push(propValue);\n\t\t\t} else {\n\n\t\t\t\tif (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n\t\t\t}\n\n\t\t\tthis.setCurrentProp(currentNode, propName);\n\n\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\tif (propName === 'a' && propValue.slice(-1) !== ',') {\n\n\t\t\t\tcurrentNode.a = parseNumberArray(propValue);\n\t\t\t}\n\t\t},\n\n\t\tparseNodePropertyContinued: function parseNodePropertyContinued(line) {\n\n\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\tcurrentNode.a += line;\n\n\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t// so convert the string to an array\n\t\t\tif (line.slice(-1) !== ',') {\n\n\t\t\t\tcurrentNode.a = parseNumberArray(currentNode.a);\n\t\t\t}\n\t\t},\n\n\t\t// parse \"Property70\"\n\t\tparseNodeSpecialProperty: function parseNodeSpecialProperty(line, propName, propValue) {\n\n\t\t\t// split this\n\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t// into array like below\n\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\tvar props = propValue.split('\",').map(function (prop) {\n\n\t\t\t\treturn prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n\t\t\t});\n\n\t\t\tvar innerPropName = props[0];\n\t\t\tvar innerPropType1 = props[1];\n\t\t\tvar innerPropType2 = props[2];\n\t\t\tvar innerPropFlag = props[3];\n\t\t\tvar innerPropValue = props[4];\n\n\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\tswitch (innerPropType1) {\n\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'enum':\n\t\t\t\tcase 'bool':\n\t\t\t\tcase 'ULongLong':\n\t\t\t\tcase 'double':\n\t\t\t\tcase 'Number':\n\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\tinnerPropValue = parseFloat(innerPropValue);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Color':\n\t\t\t\tcase 'ColorRGB':\n\t\t\t\tcase 'Vector3D':\n\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\tinnerPropValue = parseNumberArray(innerPropValue);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\tthis.getPrevNode()[innerPropName] = {\n\n\t\t\t\t'type': innerPropType1,\n\t\t\t\t'type2': innerPropType2,\n\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t'value': innerPropValue\n\n\t\t\t};\n\n\t\t\tthis.setCurrentProp(this.getPrevNode(), innerPropName);\n\t\t}\n\n\t});\n\n\t// Parse an FBX file in Binary format\n\tfunction BinaryParser() {}\n\n\tObject.assign(BinaryParser.prototype, {\n\n\t\tparse: function parse(buffer) {\n\n\t\t\tvar reader = new BinaryReader(buffer);\n\t\t\treader.skip(23); // skip magic 23 bytes\n\n\t\t\tvar version = reader.getUint32();\n\n\t\t\tconsole.log('THREE.FBXLoader: FBX binary version: ' + version);\n\n\t\t\tvar allNodes = new FBXTree();\n\n\t\t\twhile (!this.endOfContent(reader)) {\n\n\t\t\t\tvar node = this.parseNode(reader, version);\n\t\t\t\tif (node !== null) allNodes.add(node.name, node);\n\t\t\t}\n\n\t\t\treturn allNodes;\n\t\t},\n\n\t\t// Check if reader has reached the end of content.\n\t\tendOfContent: function endOfContent(reader) {\n\n\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t// - 16bytes: magic\n\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t// - 4bytes: magic\n\t\t\t// - 4bytes: version\n\t\t\t// - 120bytes: zero\n\t\t\t// - 16bytes: magic\n\t\t\tif (reader.size() % 16 === 0) {\n\n\t\t\t\treturn (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n\t\t\t} else {\n\n\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\t\t\t}\n\t\t},\n\n\t\t// recursively parse nodes until the end of the file is reached\n\t\tparseNode: function parseNode(reader, version) {\n\n\t\t\tvar node = {};\n\n\t\t\t// The first three data sizes depends on version.\n\t\t\tvar endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\t\t\tvar numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\tvar propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\tvar nameLen = reader.getUint8();\n\t\t\tvar name = reader.getString(nameLen);\n\n\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\tif (endOffset === 0) return null;\n\n\t\t\tvar propertyList = [];\n\n\t\t\tfor (var i = 0; i < numProperties; i++) {\n\n\t\t\t\tpropertyList.push(this.parseProperty(reader));\n\t\t\t}\n\n\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\tvar id = propertyList.length > 0 ? propertyList[0] : '';\n\t\t\tvar attrName = propertyList.length > 1 ? propertyList[1] : '';\n\t\t\tvar attrType = propertyList.length > 2 ? propertyList[2] : '';\n\n\t\t\t// check if this node represents just a single property\n\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\tnode.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n\n\t\t\twhile (endOffset > reader.getOffset()) {\n\n\t\t\t\tvar subNode = this.parseNode(reader, version);\n\n\t\t\t\tif (subNode !== null) this.parseSubNode(name, node, subNode);\n\t\t\t}\n\n\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\tif (typeof id === 'number') node.id = id;\n\t\t\tif (attrName !== '') node.attrName = attrName;\n\t\t\tif (attrType !== '') node.attrType = attrType;\n\t\t\tif (name !== '') node.name = name;\n\n\t\t\treturn node;\n\t\t},\n\n\t\tparseSubNode: function parseSubNode(name, node, subNode) {\n\n\t\t\t// special case: child node is single property\n\t\t\tif (subNode.singleProperty === true) {\n\n\t\t\t\tvar value = subNode.propertyList[0];\n\n\t\t\t\tif (Array.isArray(value)) {\n\n\t\t\t\t\tnode[subNode.name] = subNode;\n\n\t\t\t\t\tsubNode.a = value;\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[subNode.name] = value;\n\t\t\t\t}\n\t\t\t} else if (name === 'Connections' && subNode.name === 'C') {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tsubNode.propertyList.forEach(function (property, i) {\n\n\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\tif (i !== 0) array.push(property);\n\t\t\t\t});\n\n\t\t\t\tif (node.connections === undefined) {\n\n\t\t\t\t\tnode.connections = [];\n\t\t\t\t}\n\n\t\t\t\tnode.connections.push(array);\n\t\t\t} else if (subNode.name === 'Properties70') {\n\n\t\t\t\tvar keys = Object.keys(subNode);\n\n\t\t\t\tkeys.forEach(function (key) {\n\n\t\t\t\t\tnode[key] = subNode[key];\n\t\t\t\t});\n\t\t\t} else if (name === 'Properties70' && subNode.name === 'P') {\n\n\t\t\t\tvar innerPropName = subNode.propertyList[0];\n\t\t\t\tvar innerPropType1 = subNode.propertyList[1];\n\t\t\t\tvar innerPropType2 = subNode.propertyList[2];\n\t\t\t\tvar innerPropFlag = subNode.propertyList[3];\n\t\t\t\tvar innerPropValue;\n\n\t\t\t\tif (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n\t\t\t\tif (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n\t\t\t\tif (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n\n\t\t\t\t\tinnerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n\t\t\t\t} else {\n\n\t\t\t\t\tinnerPropValue = subNode.propertyList[4];\n\t\t\t\t}\n\n\t\t\t\t// this will be copied to parent, see above\n\t\t\t\tnode[innerPropName] = {\n\n\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t};\n\t\t\t} else if (node[subNode.name] === undefined) {\n\n\t\t\t\tif (typeof subNode.id === 'number') {\n\n\t\t\t\t\tnode[subNode.name] = {};\n\t\t\t\t\tnode[subNode.name][subNode.id] = subNode;\n\t\t\t\t} else {\n\n\t\t\t\t\tnode[subNode.name] = subNode;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (subNode.name === 'PoseNode') {\n\n\t\t\t\t\tif (!Array.isArray(node[subNode.name])) {\n\n\t\t\t\t\t\tnode[subNode.name] = [node[subNode.name]];\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[subNode.name].push(subNode);\n\t\t\t\t} else if (node[subNode.name][subNode.id] === undefined) {\n\n\t\t\t\t\tnode[subNode.name][subNode.id] = subNode;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tparseProperty: function parseProperty(reader) {\n\n\t\t\tvar type = reader.getString(1);\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'C':\n\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\tcase 'D':\n\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\tcase 'F':\n\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\tcase 'I':\n\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\tcase 'L':\n\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\tcase 'R':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getArrayBuffer(length);\n\n\t\t\t\tcase 'S':\n\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\treturn reader.getString(length);\n\n\t\t\t\tcase 'Y':\n\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\tcase 'b':\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'd':\n\t\t\t\tcase 'f':\n\t\t\t\tcase 'i':\n\t\t\t\tcase 'l':\n\n\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\tif (encoding === 0) {\n\n\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\treturn reader.getBooleanArray(arrayLength);\n\n\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\treturn reader.getFloat64Array(arrayLength);\n\n\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\treturn reader.getFloat32Array(arrayLength);\n\n\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\treturn reader.getInt32Array(arrayLength);\n\n\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\treturn reader.getInt64Array(arrayLength);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (window.Zlib === undefined) {\n\n\t\t\t\t\t\tconsole.error('THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js');\n\t\t\t\t\t}\n\n\t\t\t\t\tvar inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\t\t\t\t\tvar reader2 = new BinaryReader(inflate.decompress().buffer);\n\n\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\treturn reader2.getBooleanArray(arrayLength);\n\n\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\treturn reader2.getFloat64Array(arrayLength);\n\n\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\treturn reader2.getFloat32Array(arrayLength);\n\n\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\treturn reader2.getInt32Array(arrayLength);\n\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\treturn reader2.getInt64Array(arrayLength);\n\n\t\t\t\t\t}\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown property type ' + type);\n\n\t\t\t}\n\t\t}\n\n\t});\n\n\tfunction BinaryReader(buffer, littleEndian) {\n\n\t\tthis.dv = new DataView(buffer);\n\t\tthis.offset = 0;\n\t\tthis.littleEndian = littleEndian !== undefined ? littleEndian : true;\n\t}\n\n\tObject.assign(BinaryReader.prototype, {\n\n\t\tgetOffset: function getOffset() {\n\n\t\t\treturn this.offset;\n\t\t},\n\n\t\tsize: function size() {\n\n\t\t\treturn this.dv.buffer.byteLength;\n\t\t},\n\n\t\tskip: function skip(length) {\n\n\t\t\tthis.offset += length;\n\t\t},\n\n\t\t// seems like true/false representation depends on exporter.\n\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t// then sees LSB.\n\t\tgetBoolean: function getBoolean() {\n\n\t\t\treturn (this.getUint8() & 1) === 1;\n\t\t},\n\n\t\tgetBooleanArray: function getBooleanArray(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getBoolean());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetUint8: function getUint8() {\n\n\t\t\tvar value = this.dv.getUint8(this.offset);\n\t\t\tthis.offset += 1;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetInt16: function getInt16() {\n\n\t\t\tvar value = this.dv.getInt16(this.offset, this.littleEndian);\n\t\t\tthis.offset += 2;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetInt32: function getInt32() {\n\n\t\t\tvar value = this.dv.getInt32(this.offset, this.littleEndian);\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetInt32Array: function getInt32Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getInt32());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetUint32: function getUint32() {\n\n\t\t\tvar value = this.dv.getUint32(this.offset, this.littleEndian);\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\t\t},\n\n\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t// There's a possibility that this method returns wrong value if the value\n\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t// TODO: safely handle 64-bit integer\n\t\tgetInt64: function getInt64() {\n\n\t\t\tvar low, high;\n\n\t\t\tif (this.littleEndian) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\t\t\t}\n\n\t\t\t// calculate negative value\n\t\t\tif (high & 0x80000000) {\n\n\t\t\t\thigh = ~high & 0xFFFFFFFF;\n\t\t\t\tlow = ~low & 0xFFFFFFFF;\n\n\t\t\t\tif (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n\n\t\t\t\tlow = low + 1 & 0xFFFFFFFF;\n\n\t\t\t\treturn -(high * 0x100000000 + low);\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\t\t},\n\n\t\tgetInt64Array: function getInt64Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getInt64());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\t// Note: see getInt64() comment\n\t\tgetUint64: function getUint64() {\n\n\t\t\tvar low, high;\n\n\t\t\tif (this.littleEndian) {\n\n\t\t\t\tlow = this.getUint32();\n\t\t\t\thigh = this.getUint32();\n\t\t\t} else {\n\n\t\t\t\thigh = this.getUint32();\n\t\t\t\tlow = this.getUint32();\n\t\t\t}\n\n\t\t\treturn high * 0x100000000 + low;\n\t\t},\n\n\t\tgetFloat32: function getFloat32() {\n\n\t\t\tvar value = this.dv.getFloat32(this.offset, this.littleEndian);\n\t\t\tthis.offset += 4;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetFloat32Array: function getFloat32Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getFloat32());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetFloat64: function getFloat64() {\n\n\t\t\tvar value = this.dv.getFloat64(this.offset, this.littleEndian);\n\t\t\tthis.offset += 8;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetFloat64Array: function getFloat64Array(size) {\n\n\t\t\tvar a = [];\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta.push(this.getFloat64());\n\t\t\t}\n\n\t\t\treturn a;\n\t\t},\n\n\t\tgetArrayBuffer: function getArrayBuffer(size) {\n\n\t\t\tvar value = this.dv.buffer.slice(this.offset, this.offset + size);\n\t\t\tthis.offset += size;\n\t\t\treturn value;\n\t\t},\n\n\t\tgetString: function getString(size) {\n\n\t\t\tvar a = new Uint8Array(size);\n\n\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\ta[i] = this.getUint8();\n\t\t\t}\n\n\t\t\tvar nullByte = a.indexOf(0);\n\t\t\tif (nullByte >= 0) a = a.slice(0, nullByte);\n\n\t\t\treturn THREE.LoaderUtils.decodeText(a);\n\t\t}\n\n\t});\n\n\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t// and BinaryParser( FBX Binary format)\n\tfunction FBXTree() {}\n\n\tObject.assign(FBXTree.prototype, {\n\n\t\tadd: function add(key, val) {\n\n\t\t\tthis[key] = val;\n\t\t}\n\n\t});\n\n\tfunction isFbxFormatBinary(buffer) {\n\n\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n\t}\n\n\tfunction isFbxFormatASCII(text) {\n\n\t\tvar CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n\n\t\tvar cursor = 0;\n\n\t\tfunction read(offset) {\n\n\t\t\tvar result = text[offset - 1];\n\t\t\ttext = text.slice(cursor + offset);\n\t\t\tcursor++;\n\t\t\treturn result;\n\t\t}\n\n\t\tfor (var i = 0; i < CORRECT.length; ++i) {\n\n\t\t\tvar num = read(1);\n\t\t\tif (num === CORRECT[i]) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfunction getFbxVersion(text) {\n\n\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\tvar match = text.match(versionRegExp);\n\t\tif (match) {\n\n\t\t\tvar version = parseInt(match[1]);\n\t\t\treturn version;\n\t\t}\n\t\tthrow new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n\t}\n\n\t// Converts FBX ticks into real time seconds.\n\tfunction convertFBXTimeToSeconds(time) {\n\n\t\treturn time / 46186158000;\n\t}\n\n\t// Parses comma separated list of numbers and returns them an array.\n\t// Used internally by the TextParser\n\tfunction parseNumberArray(value) {\n\n\t\tvar array = value.split(',').map(function (val) {\n\n\t\t\treturn parseFloat(val);\n\t\t});\n\n\t\treturn array;\n\t}\n\n\tfunction convertArrayBufferToString(buffer, from, to) {\n\n\t\tif (from === undefined) from = 0;\n\t\tif (to === undefined) to = buffer.byteLength;\n\n\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n\t}\n\n\tfunction append(a, b) {\n\n\t\tfor (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n\n\t\t\ta[j] = b[i];\n\t\t}\n\t}\n\n\tfunction slice(a, b, from, to) {\n\n\t\tfor (var i = from, j = 0; i < to; i++, j++) {\n\n\t\t\ta[j] = b[i];\n\t\t}\n\n\t\treturn a;\n\t}\n\n\t// inject array a2 into array a1 at index\n\tfunction inject(a1, index, a2) {\n\n\t\treturn a1.slice(0, index).concat(a2).concat(a1.slice(index));\n\t}\n\n\treturn FBXLoader;\n}();\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n'use strict';\n\n/**\n * THREE.GCodeLoader is used to load gcode files usually used for 3D printing or CNC applications.\n *\n * Gcode files are composed by commands used by machines to create objects.\n *\n * @class THREE.GCodeLoader\n * @param {Manager} manager Loading manager.\n * @author tentone\n * @author joewalnes\n */\nvar GCodeLoader = function GCodeLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.splitLayer = false;\n};\n\nGCodeLoader.prototype.load = function (url, onLoad, onProgress, onError) {\n\n\tvar self = this;\n\n\tvar loader = new THREE.FileLoader(self.manager);\n\tloader.load(url, function (text) {\n\n\t\tonLoad(self.parse(text));\n\t}, onProgress, onError);\n};\n\nGCodeLoader.prototype.parse = function (data) {\n\n\tvar state = { x: 0, y: 0, z: 0, e: 0, f: 0, extruding: false, relative: false };\n\tvar layers = [];\n\n\tvar currentLayer = undefined;\n\n\tvar pathMaterial = new THREE.LineBasicMaterial({ color: 0xFF0000 });\n\tpathMaterial.name = 'path';\n\n\tvar extrudingMaterial = new THREE.LineBasicMaterial({ color: 0x00FF00 });\n\textrudingMaterial.name = 'extruded';\n\n\tfunction newLayer(line) {\n\n\t\tcurrentLayer = { vertex: [], pathVertex: [], z: line.z };\n\t\tlayers.push(currentLayer);\n\t}\n\n\t//Create lie segment between p1 and p2\n\tfunction addSegment(p1, p2) {\n\n\t\tif (currentLayer === undefined) {\n\n\t\t\tnewLayer(p1);\n\t\t}\n\n\t\tif (line.extruding) {\n\n\t\t\tcurrentLayer.vertex.push(p1.x, p1.y, p1.z);\n\t\t\tcurrentLayer.vertex.push(p2.x, p2.y, p2.z);\n\t\t} else {\n\n\t\t\tcurrentLayer.pathVertex.push(p1.x, p1.y, p1.z);\n\t\t\tcurrentLayer.pathVertex.push(p2.x, p2.y, p2.z);\n\t\t}\n\t}\n\n\tfunction delta(v1, v2) {\n\n\t\treturn state.relative ? v2 : v2 - v1;\n\t}\n\n\tfunction absolute(v1, v2) {\n\n\t\treturn state.relative ? v1 + v2 : v2;\n\t}\n\n\tvar lines = data.replace(/;.+/g, '').split('\\n');\n\n\tfor (var i = 0; i < lines.length; i++) {\n\n\t\tvar tokens = lines[i].split(' ');\n\t\tvar cmd = tokens[0].toUpperCase();\n\n\t\t//Argumments\n\t\tvar args = {};\n\t\ttokens.splice(1).forEach(function (token) {\n\n\t\t\tif (token[0] !== undefined) {\n\n\t\t\t\tvar key = token[0].toLowerCase();\n\t\t\t\tvar value = parseFloat(token.substring(1));\n\t\t\t\targs[key] = value;\n\t\t\t}\n\t\t});\n\n\t\t//Process commands\n\t\t//G0/G1 ‚Äì Linear Movement\n\t\tif (cmd === 'G0' || cmd === 'G1') {\n\n\t\t\tvar line = {\n\t\t\t\tx: args.x !== undefined ? absolute(state.x, args.x) : state.x,\n\t\t\t\ty: args.y !== undefined ? absolute(state.y, args.y) : state.y,\n\t\t\t\tz: args.z !== undefined ? absolute(state.z, args.z) : state.z,\n\t\t\t\te: args.e !== undefined ? absolute(state.e, args.e) : state.e,\n\t\t\t\tf: args.f !== undefined ? absolute(state.f, args.f) : state.f\n\t\t\t};\n\n\t\t\t//Layer change detection is or made by watching Z, it's made by watching when we extrude at a new Z position\n\t\t\tif (delta(state.e, line.e) > 0) {\n\n\t\t\t\tline.extruding = delta(state.e, line.e) > 0;\n\n\t\t\t\tif (currentLayer == undefined || line.z != currentLayer.z) {\n\n\t\t\t\t\tnewLayer(line);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taddSegment(state, line);\n\t\t\tstate = line;\n\t\t} else if (cmd === 'G2' || cmd === 'G3') {\n\n\t\t\t//G2/G3 - Arc Movement ( G2 clock wise and G3 counter clock wise )\n\t\t\tconsole.warn('THREE.GCodeLoader: Arc command not supported');\n\t\t} else if (cmd === 'G90') {\n\n\t\t\t//G90: Set to Absolute Positioning\n\t\t\tstate.relative = false;\n\t\t} else if (cmd === 'G91') {\n\n\t\t\t//G91: Set to state.relative Positioning\n\t\t\tstate.relative = true;\n\t\t} else if (cmd === 'G92') {\n\n\t\t\t//G92: Set Position\n\t\t\tvar line = state;\n\t\t\tline.x = args.x !== undefined ? args.x : line.x;\n\t\t\tline.y = args.y !== undefined ? args.y : line.y;\n\t\t\tline.z = args.z !== undefined ? args.z : line.z;\n\t\t\tline.e = args.e !== undefined ? args.e : line.e;\n\t\t\tstate = line;\n\t\t} else {\n\n\t\t\tconsole.warn('THREE.GCodeLoader: Command not supported:' + cmd);\n\t\t}\n\t}\n\n\tfunction addObject(vertex, extruding) {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertex, 3));\n\n\t\tvar segments = new THREE.LineSegments(geometry, extruding ? extrudingMaterial : pathMaterial);\n\t\tsegments.name = 'layer' + i;\n\t\tobject.add(segments);\n\t}\n\n\tvar object = new THREE.Group();\n\tobject.name = 'gcode';\n\n\tif (this.splitLayer) {\n\n\t\tfor (var i = 0; i < layers.length; i++) {\n\n\t\t\tvar layer = layers[i];\n\t\t\taddObject(layer.vertex, true);\n\t\t\taddObject(layer.pathVertex, false);\n\t\t}\n\t} else {\n\n\t\tvar vertex = [],\n\t\t    pathVertex = [];\n\n\t\tfor (var i = 0; i < layers.length; i++) {\n\n\t\t\tvar layer = layers[i];\n\n\t\t\tvertex = vertex.concat(layer.vertex);\n\t\t\tpathVertex = pathVertex.concat(layer.pathVertex);\n\t\t}\n\n\t\taddObject(vertex, true);\n\t\taddObject(pathVertex, false);\n\t}\n\n\tobject.quaternion.setFromEuler(new THREE.Euler(-Math.PI / 2, 0, 0));\n\n\treturn object;\n};\n\nexports.default = GCodeLoader;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _RGBELoader = __webpack_require__(6);\n\nvar _RGBELoader2 = _interopRequireDefault(_RGBELoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n* @author Prashant Sharma / spidersharma03\n* @author Ben Houston / http://clara.io / bhouston\n*/\n\nvar HDRCubeTextureLoader = function HDRCubeTextureLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t// override in sub classes\n\tthis.hdrLoader = new _RGBELoader2.default();\n};\n\nHDRCubeTextureLoader.prototype.load = function (type, urls, onLoad, onProgress, onError) {\n\n\tvar RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n\n\t\tvar e = sourceArray[sourceOffset + 3];\n\t\tvar scale = Math.pow(2.0, e - 128.0) / 255.0;\n\n\t\tdestArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n\t\tdestArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n\t\tdestArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n\t};\n\n\tvar RGBEByteToRGBHalf = function () {\n\n\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\tvar floatView = new Float32Array(1);\n\t\tvar int32View = new Int32Array(floatView.buffer);\n\n\t\t/* This method is faster than the OpenEXR implementation (very often\n   * used, eg. in Ogre), with the additional benefit of rounding, inspired\n   * by James Tursa?s half-precision code. */\n\t\tfunction toHalf(val) {\n\n\t\t\tfloatView[0] = val;\n\t\t\tvar x = int32View[0];\n\n\t\t\tvar bits = x >> 16 & 0x8000; /* Get the sign */\n\t\t\tvar m = x >> 12 & 0x07ff; /* Keep one extra bit for rounding */\n\t\t\tvar e = x >> 23 & 0xff; /* Using int is faster here */\n\n\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n    * half, return signed zero. */\n\t\t\tif (e < 103) return bits;\n\n\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\t\t\tif (e > 142) {\n\n\t\t\t\tbits |= 0x7c00;\n\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n    \t\t * not Inf, so make sure we set one mantissa bit too. */\n\t\t\t\tbits |= (e == 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\t\treturn bits;\n\t\t\t}\n\n\t\t\t/* If exponent underflows but not too much, return a denormal */\n\t\t\tif (e < 113) {\n\n\t\t\t\tm |= 0x0800;\n\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n     * to 1, which is OK. */\n\t\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\t\treturn bits;\n\t\t\t}\n\n\t\t\tbits |= e - 112 << 10 | m >> 1;\n\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n    * the exponent, which is OK. */\n\t\t\tbits += m & 1;\n\t\t\treturn bits;\n\t\t}\n\n\t\treturn function (sourceArray, sourceOffset, destArray, destOffset) {\n\n\t\t\tvar e = sourceArray[sourceOffset + 3];\n\t\t\tvar scale = Math.pow(2.0, e - 128.0) / 255.0;\n\n\t\t\tdestArray[destOffset + 0] = toHalf(sourceArray[sourceOffset + 0] * scale);\n\t\t\tdestArray[destOffset + 1] = toHalf(sourceArray[sourceOffset + 1] * scale);\n\t\t\tdestArray[destOffset + 2] = toHalf(sourceArray[sourceOffset + 2] * scale);\n\t\t};\n\t}();\n\n\t//\n\n\tvar texture = new THREE.CubeTexture();\n\n\ttexture.type = type;\n\ttexture.encoding = type === THREE.UnsignedByteType ? THREE.RGBEEncoding : THREE.LinearEncoding;\n\ttexture.format = type === THREE.UnsignedByteType ? THREE.RGBAFormat : THREE.RGBFormat;\n\ttexture.minFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;\n\ttexture.magFilter = texture.encoding === THREE.RGBEEncoding ? THREE.NearestFilter : THREE.LinearFilter;\n\ttexture.generateMipmaps = texture.encoding !== THREE.RGBEEncoding;\n\ttexture.anisotropy = 0;\n\n\tvar scope = this.hdrLoader;\n\n\tvar loaded = 0;\n\n\tfunction loadHDRData(i, onLoad, onProgress, onError) {\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(urls[i], function (buffer) {\n\n\t\t\tloaded++;\n\n\t\t\tvar texData = scope._parser(buffer);\n\n\t\t\tif (!texData) return;\n\n\t\t\tif (type === THREE.FloatType) {\n\n\t\t\t\tvar numElements = texData.data.length / 4 * 3;\n\t\t\t\tvar floatdata = new Float32Array(numElements);\n\n\t\t\t\tfor (var j = 0; j < numElements; j++) {\n\n\t\t\t\t\tRGBEByteToRGBFloat(texData.data, j * 4, floatdata, j * 3);\n\t\t\t\t}\n\n\t\t\t\ttexData.data = floatdata;\n\t\t\t} else if (type === THREE.HalfFloatType) {\n\n\t\t\t\tvar numElements = texData.data.length / 4 * 3;\n\t\t\t\tvar halfdata = new Uint16Array(numElements);\n\n\t\t\t\tfor (var j = 0; j < numElements; j++) {\n\n\t\t\t\t\tRGBEByteToRGBHalf(texData.data, j * 4, halfdata, j * 3);\n\t\t\t\t}\n\n\t\t\t\ttexData.data = halfdata;\n\t\t\t}\n\n\t\t\tif (undefined !== texData.image) {\n\n\t\t\t\ttexture[i].images = texData.image;\n\t\t\t} else if (undefined !== texData.data) {\n\n\t\t\t\tvar dataTexture = new THREE.DataTexture(texData.data, texData.width, texData.height);\n\t\t\t\tdataTexture.format = texture.format;\n\t\t\t\tdataTexture.type = texture.type;\n\t\t\t\tdataTexture.encoding = texture.encoding;\n\t\t\t\tdataTexture.minFilter = texture.minFilter;\n\t\t\t\tdataTexture.magFilter = texture.magFilter;\n\t\t\t\tdataTexture.generateMipmaps = texture.generateMipmaps;\n\n\t\t\t\ttexture.images[i] = dataTexture;\n\t\t\t}\n\n\t\t\tif (loaded === 6) {\n\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif (onLoad) onLoad(texture);\n\t\t\t}\n\t\t}, onProgress, onError);\n\t}\n\n\tfor (var i = 0; i < urls.length; i++) {\n\n\t\tloadHDRData(i, onLoad, onProgress, onError);\n\t}\n\n\treturn texture;\n};\n\nexports.default = HDRCubeTextureLoader;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar KMZLoader = function KMZLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nKMZLoader.prototype = {\n\n\tconstructor: KMZLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tvar zip = new JSZip(data); // eslint-disable-line no-undef\n\n\t\t// console.log( zip );\n\n\t\t// var xml = new DOMParser().parseFromString( zip.file( 'doc.kml' ).asText(), 'application/xml' );\n\n\t\tfunction loadImage(image) {\n\n\t\t\tvar path = decodeURI(image.init_from);\n\n\t\t\t// Hack to support relative paths\n\t\t\tpath = path.replace('../', '');\n\n\t\t\tvar regex = new RegExp(path + '$');\n\t\t\tvar files = zip.file(regex);\n\n\t\t\t// console.log( image, files );\n\n\t\t\tif (files.length) {\n\n\t\t\t\tvar file = files[0];\n\t\t\t\tvar blob = new Blob([file.asArrayBuffer()], { type: 'application/octet-binary' });\n\t\t\t\timage.build.src = URL.createObjectURL(blob);\n\t\t\t}\n\t\t}\n\n\t\t// load collada\n\n\t\tvar files = zip.file(/dae$/i);\n\n\t\tif (files.length) {\n\n\t\t\tvar file = files[0];\n\n\t\t\tvar collada = new THREE.ColladaLoader().parse(file.asText());\n\n\t\t\t// fix images\n\n\t\t\tvar images = collada.library.images;\n\n\t\t\tfor (var name in images) {\n\n\t\t\t\tloadImage(images[name]);\n\t\t\t}\n\n\t\t\treturn collada;\n\t\t}\n\n\t\tconsole.error('KMZLoader: Couldn\\'t find .dae file.');\n\n\t\treturn {\n\t\t\tscene: new THREE.Group()\n\t\t};\n\t}\n\n};\n\nexports.default = KMZLoader;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author amakaseev / https://github.com/amakaseev\n *\n * for description see https://www.khronos.org/opengles/sdk/tools/KTX/\n * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/\n *\n * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Tools/babylon.khronosTextureContainer.ts\n */\n\nvar KTXLoader = function KTXLoader() {\n\n\tthis._parser = KTXLoader.parse;\n};\n\nKTXLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);\nKTXLoader.prototype.constructor = KTXLoader;\n\nKTXLoader.parse = function (buffer, loadMipmaps) {\n\n\tvar ktx = new KhronosTextureContainer(buffer, 1);\n\n\treturn {\n\t\tmipmaps: ktx.mipmaps(loadMipmaps),\n\t\twidth: ktx.pixelWidth,\n\t\theight: ktx.pixelHeight,\n\t\tformat: ktx.glInternalFormat,\n\t\tisCubemap: ktx.numberOfFaces === 6,\n\t\tmipmapCount: ktx.numberOfMipmapLevels\n\t};\n};\n\nvar KhronosTextureContainer = function () {\n\n\t/**\n  * @param {ArrayBuffer} arrayBuffer- contents of the KTX container file\n  * @param {number} facesExpected- should be either 1 or 6, based whether a cube texture or or\n  * @param {boolean} threeDExpected- provision for indicating that data should be a 3D texture, not implemented\n  * @param {boolean} textureArrayExpected- provision for indicating that data should be a texture array, not implemented\n  */\n\tfunction KhronosTextureContainer(arrayBuffer, facesExpected, threeDExpected, textureArrayExpected) {\n\n\t\tthis.arrayBuffer = arrayBuffer;\n\n\t\t// Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:\n\t\t// '¬¥', 'K', 'T', 'X', ' ', '1', '1', '¬™', '\\r', '\\n', '\\x1A', '\\n'\n\t\t// 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n\t\tvar identifier = new Uint8Array(this.arrayBuffer, 0, 12);\n\t\tif (identifier[0] !== 0xAB || identifier[1] !== 0x4B || identifier[2] !== 0x54 || identifier[3] !== 0x58 || identifier[4] !== 0x20 || identifier[5] !== 0x31 || identifier[6] !== 0x31 || identifier[7] !== 0xBB || identifier[8] !== 0x0D || identifier[9] !== 0x0A || identifier[10] !== 0x1A || identifier[11] !== 0x0A) {\n\n\t\t\tconsole.error('texture missing KTX identifier');\n\t\t\treturn;\n\t\t}\n\n\t\t// load the reset of the header in native 32 bit int\n\t\tvar header = new Int32Array(this.arrayBuffer, 12, 13);\n\t\t// determine of the remaining header values are recorded in the opposite endianness & require conversion\n\t\tvar oppositeEndianess = header[0] === 0x01020304;\n\t\t// read all the header elements in order they exist in the file, without modification (sans endainness)\n\t\tthis.glType = oppositeEndianess ? this.switchEndainness(header[1]) : header[1]; // must be 0 for compressed textures\n\t\tthis.glTypeSize = oppositeEndianess ? this.switchEndainness(header[2]) : header[2]; // must be 1 for compressed textures\n\t\tthis.glFormat = oppositeEndianess ? this.switchEndainness(header[3]) : header[3]; // must be 0 for compressed textures\n\t\tthis.glInternalFormat = oppositeEndianess ? this.switchEndainness(header[4]) : header[4]; // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)\n\t\tthis.glBaseInternalFormat = oppositeEndianess ? this.switchEndainness(header[5]) : header[5]; // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)\n\t\tthis.pixelWidth = oppositeEndianess ? this.switchEndainness(header[6]) : header[6]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)\n\t\tthis.pixelHeight = oppositeEndianess ? this.switchEndainness(header[7]) : header[7]; // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)\n\t\tthis.pixelDepth = oppositeEndianess ? this.switchEndainness(header[8]) : header[8]; // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)\n\t\tthis.numberOfArrayElements = oppositeEndianess ? this.switchEndainness(header[9]) : header[9]; // used for texture arrays\n\t\tthis.numberOfFaces = oppositeEndianess ? this.switchEndainness(header[10]) : header[10]; // used for cubemap textures, should either be 1 or 6\n\t\tthis.numberOfMipmapLevels = oppositeEndianess ? this.switchEndainness(header[11]) : header[11]; // number of levels; disregard possibility of 0 for compressed textures\n\t\tthis.bytesOfKeyValueData = oppositeEndianess ? this.switchEndainness(header[12]) : header[12]; // the amount of space after the header for meta-data\n\n\t\t// Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.\n\t\tif (this.glType !== 0) {\n\n\t\t\tconsole.warn('only compressed formats currently supported');\n\t\t\treturn;\n\t\t} else {\n\n\t\t\t// value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.\n\t\t\tthis.numberOfMipmapLevels = Math.max(1, this.numberOfMipmapLevels);\n\t\t}\n\t\tif (this.pixelHeight === 0 || this.pixelDepth !== 0) {\n\n\t\t\tconsole.warn('only 2D textures currently supported');\n\t\t\treturn;\n\t\t}\n\t\tif (this.numberOfArrayElements !== 0) {\n\n\t\t\tconsole.warn('texture arrays not currently supported');\n\t\t\treturn;\n\t\t}\n\t\tif (this.numberOfFaces !== facesExpected) {\n\n\t\t\tconsole.warn('number of faces expected' + facesExpected + ', but found ' + this.numberOfFaces);\n\t\t\treturn;\n\t\t}\n\t\t// we now have a completely validated file, so could use existence of loadType as success\n\t\t// would need to make this more elaborate & adjust checks above to support more than one load type\n\t\tthis.loadType = KhronosTextureContainer.COMPRESSED_2D;\n\t}\n\n\t// not as fast hardware based, but will probably never need to use\n\tKhronosTextureContainer.prototype.switchEndainness = function (val) {\n\n\t\treturn (val & 0xFF) << 24 | (val & 0xFF00) << 8 | val >> 8 & 0xFF00 | val >> 24 & 0xFF;\n\t};\n\n\t// return mipmaps for THREE.js\n\tKhronosTextureContainer.prototype.mipmaps = function (loadMipmaps) {\n\n\t\tvar mipmaps = [];\n\n\t\t// initialize width & height for level 1\n\t\tvar dataOffset = KhronosTextureContainer.HEADER_LEN + this.bytesOfKeyValueData;\n\t\tvar width = this.pixelWidth;\n\t\tvar height = this.pixelHeight;\n\t\tvar mipmapCount = loadMipmaps ? this.numberOfMipmapLevels : 1;\n\n\t\tfor (var level = 0; level < mipmapCount; level++) {\n\n\t\t\tvar imageSize = new Int32Array(this.arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps\n\t\t\tfor (var face = 0; face < this.numberOfFaces; face++) {\n\n\t\t\t\tvar byteArray = new Uint8Array(this.arrayBuffer, dataOffset + 4, imageSize);\n\n\t\t\t\tmipmaps.push({ \"data\": byteArray, \"width\": width, \"height\": height });\n\n\t\t\t\tdataOffset += imageSize + 4; // size of the image + 4 for the imageSize field\n\t\t\t\tdataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image\n\t\t\t}\n\t\t\twidth = Math.max(1.0, width * 0.5);\n\t\t\theight = Math.max(1.0, height * 0.5);\n\t\t}\n\n\t\treturn mipmaps;\n\t};\n\n\tKhronosTextureContainer.HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)\n\t// load types\n\tKhronosTextureContainer.COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()\n\tKhronosTextureContainer.COMPRESSED_3D = 1; // uses a gl.compressedTexImage3D()\n\tKhronosTextureContainer.TEX_2D = 2; // uses a gl.texImage2D()\n\tKhronosTextureContainer.TEX_3D = 3; // uses a gl.texImage3D()\n\n\treturn KhronosTextureContainer;\n}();\n\nexports.default = KTXLoader;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar MD2Loader = function MD2Loader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nMD2Loader.prototype = {\n\n\tconstructor: MD2Loader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function () {\n\n\t\tvar normals = [[-0.525731, 0.000000, 0.850651], [-0.442863, 0.238856, 0.864188], [-0.295242, 0.000000, 0.955423], [-0.309017, 0.500000, 0.809017], [-0.162460, 0.262866, 0.951056], [0.000000, 0.000000, 1.000000], [0.000000, 0.850651, 0.525731], [-0.147621, 0.716567, 0.681718], [0.147621, 0.716567, 0.681718], [0.000000, 0.525731, 0.850651], [0.309017, 0.500000, 0.809017], [0.525731, 0.000000, 0.850651], [0.295242, 0.000000, 0.955423], [0.442863, 0.238856, 0.864188], [0.162460, 0.262866, 0.951056], [-0.681718, 0.147621, 0.716567], [-0.809017, 0.309017, 0.500000], [-0.587785, 0.425325, 0.688191], [-0.850651, 0.525731, 0.000000], [-0.864188, 0.442863, 0.238856], [-0.716567, 0.681718, 0.147621], [-0.688191, 0.587785, 0.425325], [-0.500000, 0.809017, 0.309017], [-0.238856, 0.864188, 0.442863], [-0.425325, 0.688191, 0.587785], [-0.716567, 0.681718, -0.147621], [-0.500000, 0.809017, -0.309017], [-0.525731, 0.850651, 0.000000], [0.000000, 0.850651, -0.525731], [-0.238856, 0.864188, -0.442863], [0.000000, 0.955423, -0.295242], [-0.262866, 0.951056, -0.162460], [0.000000, 1.000000, 0.000000], [0.000000, 0.955423, 0.295242], [-0.262866, 0.951056, 0.162460], [0.238856, 0.864188, 0.442863], [0.262866, 0.951056, 0.162460], [0.500000, 0.809017, 0.309017], [0.238856, 0.864188, -0.442863], [0.262866, 0.951056, -0.162460], [0.500000, 0.809017, -0.309017], [0.850651, 0.525731, 0.000000], [0.716567, 0.681718, 0.147621], [0.716567, 0.681718, -0.147621], [0.525731, 0.850651, 0.000000], [0.425325, 0.688191, 0.587785], [0.864188, 0.442863, 0.238856], [0.688191, 0.587785, 0.425325], [0.809017, 0.309017, 0.500000], [0.681718, 0.147621, 0.716567], [0.587785, 0.425325, 0.688191], [0.955423, 0.295242, 0.000000], [1.000000, 0.000000, 0.000000], [0.951056, 0.162460, 0.262866], [0.850651, -0.525731, 0.000000], [0.955423, -0.295242, 0.000000], [0.864188, -0.442863, 0.238856], [0.951056, -0.162460, 0.262866], [0.809017, -0.309017, 0.500000], [0.681718, -0.147621, 0.716567], [0.850651, 0.000000, 0.525731], [0.864188, 0.442863, -0.238856], [0.809017, 0.309017, -0.500000], [0.951056, 0.162460, -0.262866], [0.525731, 0.000000, -0.850651], [0.681718, 0.147621, -0.716567], [0.681718, -0.147621, -0.716567], [0.850651, 0.000000, -0.525731], [0.809017, -0.309017, -0.500000], [0.864188, -0.442863, -0.238856], [0.951056, -0.162460, -0.262866], [0.147621, 0.716567, -0.681718], [0.309017, 0.500000, -0.809017], [0.425325, 0.688191, -0.587785], [0.442863, 0.238856, -0.864188], [0.587785, 0.425325, -0.688191], [0.688191, 0.587785, -0.425325], [-0.147621, 0.716567, -0.681718], [-0.309017, 0.500000, -0.809017], [0.000000, 0.525731, -0.850651], [-0.525731, 0.000000, -0.850651], [-0.442863, 0.238856, -0.864188], [-0.295242, 0.000000, -0.955423], [-0.162460, 0.262866, -0.951056], [0.000000, 0.000000, -1.000000], [0.295242, 0.000000, -0.955423], [0.162460, 0.262866, -0.951056], [-0.442863, -0.238856, -0.864188], [-0.309017, -0.500000, -0.809017], [-0.162460, -0.262866, -0.951056], [0.000000, -0.850651, -0.525731], [-0.147621, -0.716567, -0.681718], [0.147621, -0.716567, -0.681718], [0.000000, -0.525731, -0.850651], [0.309017, -0.500000, -0.809017], [0.442863, -0.238856, -0.864188], [0.162460, -0.262866, -0.951056], [0.238856, -0.864188, -0.442863], [0.500000, -0.809017, -0.309017], [0.425325, -0.688191, -0.587785], [0.716567, -0.681718, -0.147621], [0.688191, -0.587785, -0.425325], [0.587785, -0.425325, -0.688191], [0.000000, -0.955423, -0.295242], [0.000000, -1.000000, 0.000000], [0.262866, -0.951056, -0.162460], [0.000000, -0.850651, 0.525731], [0.000000, -0.955423, 0.295242], [0.238856, -0.864188, 0.442863], [0.262866, -0.951056, 0.162460], [0.500000, -0.809017, 0.309017], [0.716567, -0.681718, 0.147621], [0.525731, -0.850651, 0.000000], [-0.238856, -0.864188, -0.442863], [-0.500000, -0.809017, -0.309017], [-0.262866, -0.951056, -0.162460], [-0.850651, -0.525731, 0.000000], [-0.716567, -0.681718, -0.147621], [-0.716567, -0.681718, 0.147621], [-0.525731, -0.850651, 0.000000], [-0.500000, -0.809017, 0.309017], [-0.238856, -0.864188, 0.442863], [-0.262866, -0.951056, 0.162460], [-0.864188, -0.442863, 0.238856], [-0.809017, -0.309017, 0.500000], [-0.688191, -0.587785, 0.425325], [-0.681718, -0.147621, 0.716567], [-0.442863, -0.238856, 0.864188], [-0.587785, -0.425325, 0.688191], [-0.309017, -0.500000, 0.809017], [-0.147621, -0.716567, 0.681718], [-0.425325, -0.688191, 0.587785], [-0.162460, -0.262866, 0.951056], [0.442863, -0.238856, 0.864188], [0.162460, -0.262866, 0.951056], [0.309017, -0.500000, 0.809017], [0.147621, -0.716567, 0.681718], [0.000000, -0.525731, 0.850651], [0.425325, -0.688191, 0.587785], [0.587785, -0.425325, 0.688191], [0.688191, -0.587785, 0.425325], [-0.955423, 0.295242, 0.000000], [-0.951056, 0.162460, 0.262866], [-1.000000, 0.000000, 0.000000], [-0.850651, 0.000000, 0.525731], [-0.955423, -0.295242, 0.000000], [-0.951056, -0.162460, 0.262866], [-0.864188, 0.442863, -0.238856], [-0.951056, 0.162460, -0.262866], [-0.809017, 0.309017, -0.500000], [-0.864188, -0.442863, -0.238856], [-0.951056, -0.162460, -0.262866], [-0.809017, -0.309017, -0.500000], [-0.681718, 0.147621, -0.716567], [-0.681718, -0.147621, -0.716567], [-0.850651, 0.000000, -0.525731], [-0.688191, 0.587785, -0.425325], [-0.587785, 0.425325, -0.688191], [-0.425325, 0.688191, -0.587785], [-0.425325, -0.688191, -0.587785], [-0.587785, -0.425325, -0.688191], [-0.688191, -0.587785, -0.425325]];\n\n\t\treturn function (buffer) {\n\n\t\t\tconsole.time('MD2Loader');\n\n\t\t\tvar data = new DataView(buffer);\n\n\t\t\t// http://tfc.duke.free.fr/coding/md2-specs-en.html\n\n\t\t\tvar header = {};\n\t\t\tvar headerNames = ['ident', 'version', 'skinwidth', 'skinheight', 'framesize', 'num_skins', 'num_vertices', 'num_st', 'num_tris', 'num_glcmds', 'num_frames', 'offset_skins', 'offset_st', 'offset_tris', 'offset_frames', 'offset_glcmds', 'offset_end'];\n\n\t\t\tfor (var i = 0; i < headerNames.length; i++) {\n\n\t\t\t\theader[headerNames[i]] = data.getInt32(i * 4, true);\n\t\t\t}\n\n\t\t\tif (header.ident !== 844121161 || header.version !== 8) {\n\n\t\t\t\tconsole.error('Not a valid MD2 file');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (header.offset_end !== data.byteLength) {\n\n\t\t\t\tconsole.error('Corrupted MD2 file');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tvar geometry = new THREE.Geometry();\n\n\t\t\t// uvs\n\n\t\t\tvar uvs = [];\n\t\t\tvar offset = header.offset_st;\n\n\t\t\tfor (var i = 0, l = header.num_st; i < l; i++) {\n\n\t\t\t\tvar u = data.getInt16(offset + 0, true);\n\t\t\t\tvar v = data.getInt16(offset + 2, true);\n\n\t\t\t\tuvs.push(new THREE.Vector2(u / header.skinwidth, 1 - v / header.skinheight));\n\n\t\t\t\toffset += 4;\n\t\t\t}\n\n\t\t\t// triangles\n\n\t\t\tvar offset = header.offset_tris;\n\n\t\t\tfor (var i = 0, l = header.num_tris; i < l; i++) {\n\n\t\t\t\tvar a = data.getUint16(offset + 0, true);\n\t\t\t\tvar b = data.getUint16(offset + 2, true);\n\t\t\t\tvar c = data.getUint16(offset + 4, true);\n\n\t\t\t\tgeometry.faces.push(new THREE.Face3(a, b, c));\n\n\t\t\t\tgeometry.faceVertexUvs[0].push([uvs[data.getUint16(offset + 6, true)], uvs[data.getUint16(offset + 8, true)], uvs[data.getUint16(offset + 10, true)]]);\n\n\t\t\t\toffset += 12;\n\t\t\t}\n\n\t\t\t// frames\n\n\t\t\tvar translation = new THREE.Vector3();\n\t\t\tvar scale = new THREE.Vector3();\n\t\t\tvar string = [];\n\n\t\t\tvar offset = header.offset_frames;\n\n\t\t\tfor (var i = 0, l = header.num_frames; i < l; i++) {\n\n\t\t\t\tscale.set(data.getFloat32(offset + 0, true), data.getFloat32(offset + 4, true), data.getFloat32(offset + 8, true));\n\n\t\t\t\ttranslation.set(data.getFloat32(offset + 12, true), data.getFloat32(offset + 16, true), data.getFloat32(offset + 20, true));\n\n\t\t\t\toffset += 24;\n\n\t\t\t\tfor (var j = 0; j < 16; j++) {\n\n\t\t\t\t\tvar character = data.getUint8(offset + j, true);\n\t\t\t\t\tif (character === 0) break;\n\n\t\t\t\t\tstring[j] = character;\n\t\t\t\t}\n\n\t\t\t\tvar frame = {\n\t\t\t\t\tname: String.fromCharCode.apply(null, string),\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tnormals: []\n\t\t\t\t};\n\n\t\t\t\toffset += 16;\n\n\t\t\t\tfor (var j = 0; j < header.num_vertices; j++) {\n\n\t\t\t\t\tvar x = data.getUint8(offset++, true);\n\t\t\t\t\tvar y = data.getUint8(offset++, true);\n\t\t\t\t\tvar z = data.getUint8(offset++, true);\n\t\t\t\t\tvar n = normals[data.getUint8(offset++, true)];\n\n\t\t\t\t\tvar vertex = new THREE.Vector3(x * scale.x + translation.x, z * scale.z + translation.z, y * scale.y + translation.y);\n\n\t\t\t\t\tvar normal = new THREE.Vector3(n[0], n[2], n[1]);\n\n\t\t\t\t\tframe.vertices.push(vertex);\n\t\t\t\t\tframe.normals.push(normal);\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphTargets.push(frame);\n\t\t\t}\n\n\t\t\t// Static\n\n\t\t\tgeometry.vertices = geometry.morphTargets[0].vertices;\n\n\t\t\tvar morphTarget = geometry.morphTargets[0];\n\n\t\t\tfor (var j = 0, jl = geometry.faces.length; j < jl; j++) {\n\n\t\t\t\tvar face = geometry.faces[j];\n\n\t\t\t\tface.vertexNormals = [morphTarget.normals[face.a], morphTarget.normals[face.b], morphTarget.normals[face.c]];\n\t\t\t}\n\n\t\t\t// Convert to geometry.morphNormals\n\n\t\t\tfor (var i = 0, l = geometry.morphTargets.length; i < l; i++) {\n\n\t\t\t\tvar morphTarget = geometry.morphTargets[i];\n\t\t\t\tvar vertexNormals = [];\n\n\t\t\t\tfor (var j = 0, jl = geometry.faces.length; j < jl; j++) {\n\n\t\t\t\t\tvar face = geometry.faces[j];\n\n\t\t\t\t\tvertexNormals.push({\n\t\t\t\t\t\ta: morphTarget.normals[face.a],\n\t\t\t\t\t\tb: morphTarget.normals[face.b],\n\t\t\t\t\t\tc: morphTarget.normals[face.c]\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tgeometry.morphNormals.push({ vertexNormals: vertexNormals });\n\t\t\t}\n\n\t\t\tgeometry.animations = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);\n\n\t\t\tconsole.timeEnd('MD2Loader');\n\n\t\t\treturn geometry;\n\t\t};\n\t}()\n\n};\n\nexports.default = MD2Loader;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _mmdParser = __webpack_require__(4);\n\nvar MMDParser = _interopRequireWildcard(_mmdParser);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author takahiro / https://github.com/takahirox\n *\n * Dependencies\n *  - mmd-parser https://github.com/takahirox/mmd-parser\n *  - ammo.js https://github.com/kripken/ammo.js\n *  - THREE.TGALoader\n *  - THREE.MMDPhysics\n *  - THREE.CCDIKSolver\n *  - THREE.OutlineEffect\n *\n *\n * This loader loads and parses PMD/PMX and VMD binary files\n * then creates mesh for Three.js.\n *\n * PMD/PMX is a model data format and VMD is a motion data format\n * used in MMD(Miku Miku Dance).\n *\n * MMD is a 3D CG animation tool which is popular in Japan.\n *\n *\n * MMD official site\n *  http://www.geocities.jp/higuchuu4/index_e.htm\n *\n * PMD, VMD format\n *  http://blog.goo.ne.jp/torisu_tetosuki/e/209ad341d3ece2b1b4df24abf619d6e4\n *\n * PMX format\n *  http://gulshan-i-raz.geo.jp/labs/2012/10/17/pmx-format1/\n *\n *\n * TODO\n *  - light motion in vmd support.\n *  - SDEF support.\n *  - uv/material/bone morphing support.\n *  - more precise grant skinning support.\n *  - shadow support.\n */\n\nvar MMDLoader = function MMDLoader(manager) {\n\n\tTHREE.Loader.call(this);\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.parser = new MMDParser.Parser();\n\tthis.textureCrossOrigin = null;\n};\n\nMMDLoader.prototype = Object.create(THREE.Loader.prototype);\nMMDLoader.prototype.constructor = MMDLoader;\n\n/*\n * base64 encoded defalut toon textures toon00.bmp - toon10.bmp\n * Users don't need to prepare default texture files.\n *\n * This idea is from http://www20.atpages.jp/katwat/three.js_r58/examples/mytest37/mmd.three.js\n */\nMMDLoader.prototype.defaultToonTextures = ['data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/bWiiMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh8aBHZBl14e8wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOUlEQVRYR+3WMREAMAwDsYY/yoDI7MLwIiP40+RJklfcCCBAgAABAgTqArfb/QMCCBAgQIAAgbbAB3z/e0F3js2cAAAAAElFTkSuQmCC', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAN0lEQVRYR+3WQREAMBACsZ5/B5ilMvgEBTt5cW37hjsBBAgQIECAwFwgyfYPCCBAgAABAgTWAh81dWyx0gFwKAAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAOklEQVRYR+3WoREAMAwDsWb/UQtCy9wxTOQJ/oQ8SXKKGwEECBAgQIBAXeDt7f4BAQQIECBAgEBb4AOz8Hzx7WLY4wAAAABJRU5ErkJggg==', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+1XwW7CMAy1+f9fZOMysSEOEweEOPRNdm3HbdOyIhAcklPrOs/PLy9RygBALxzcCDQFmgJNgaZAU6Ap0BR4PwX8gsRMVLssMRH5HcpzJEaWL7EVg9F1IHRlyqQohgVr4FGUlUcMJSjcUlDw0zvjeun70cLWmneoyf7NgBTQSniBTQQSuJAZsOnnaczjIMb5hCiuHKxokCrJfVnrctyZL0PkJAJe1HMil4nxeyi3Ypfn1kX51jpPvo/JeCNC4PhVdHdJw2XjBR8brF8PEIhNVn12AgP7uHsTBguBn53MUZCqv7Lp07Pn5k1Ro+uWmUNn7D+M57rtk7aG0Vo73xyF/fbFf0bPJjDXngnGocDTdFhygZjwUQrMNrDcmZlQT50VJ/g/UwNyHpu778+yW+/ksOz/BFo54P4AsUXMfRq7XWsAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACMElEQVRYR+2Xv4pTQRTGf2dubhLdICiii2KnYKHVolhauKWPoGAnNr6BD6CvIVaihYuI2i1ia0BY0MZGRHQXjZj/mSPnnskfNWiWZUlzJ5k7M2cm833nO5Mziej2DWWJRUoCpQKlAntSQCqgw39/iUWAGmh37jrRnVsKlgpiqmkoGVABA7E57fvY+pJDdgKqF6HzFCSADkDq+F6AHABtQ+UMVE5D7zXod7fFNhTEckTbj5XQgHzNN+5tQvc5NG7C6BNkp6D3EmpXHDR+dQAjFLchW3VS9rlw3JBh+B7ys5Cf9z0GW1C/7P32AyBAOAz1q4jGliIH3YPuBnSfQX4OGreTIgEYQb/pBDtPnEQ4CivXYPAWBk13oHrB54yA9QuSn2H4AcKRpEILDt0BUzj+RLR1V5EqjD66NPRBVpLcQwjHoHYJOhsQv6U4mnzmrIXJCFr4LDwm/xBUoboG9XX4cc9VKdYoSA2yk5NQLJaKDUjTBoveG3Z2TElTxwjNK4M3LEZgUdDdruvcXzKBpStgp2NPiWi3ks9ZXxIoFVi+AvHLdc9TqtjL3/aYjpPlrzOcEnK62Szhimdd7xX232zFDTgtxezOu3WNMRLjiKgjtOhHVMd1loynVHvOgjuIIJMaELEqhJAV/RCSLbWTcfPFakFgFlALTRRvx+ok6Hlp/Q+v3fmx90bMyUzaEAhmM3KvHlXTL5DxnbGf/1M8RNNACLL5MNtPxP/mypJAqcDSFfgFhpYqWUzhTEAAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII=', 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAL0lEQVRYR+3QQREAAAzCsOFfNJPBJ1XQS9r2hsUAAQIECBAgQIAAAQIECBAgsBZ4MUx/ofm2I/kAAAAASUVORK5CYII='];\n\n/*\n * Set 'anonymous' for the the texture image file in other domain\n * even if server responds with \"Access-Control-Allow-Origin: *\"\n * because some image operation fails in MMDLoader.\n */\nMMDLoader.prototype.setTextureCrossOrigin = function (value) {\n\n\tthis.textureCrossOrigin = value;\n};\n\nMMDLoader.prototype.load = function (modelUrl, vmdUrls, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tthis.loadModel(modelUrl, function (mesh) {\n\n\t\tscope.loadVmds(vmdUrls, function (vmd) {\n\n\t\t\tscope.pourVmdIntoModel(mesh, vmd);\n\t\t\tcallback(mesh);\n\t\t}, onProgress, onError);\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.loadModel = function (url, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tvar texturePath = THREE.LoaderUtils.extractUrlBase(url);\n\tvar modelExtension = this.extractExtension(url);\n\n\tthis.loadFileAsBuffer(url, function (buffer) {\n\n\t\tcallback(scope.createModel(buffer, modelExtension, texturePath, onProgress, onError));\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.createModel = function (buffer, modelExtension, texturePath, onProgress, onError) {\n\n\treturn this.createMesh(this.parseModel(buffer, modelExtension), texturePath, onProgress, onError);\n};\n\nMMDLoader.prototype.loadVmd = function (url, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tthis.loadFileAsBuffer(url, function (buffer) {\n\n\t\tcallback(scope.parseVmd(buffer));\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.loadVmds = function (urls, callback, onProgress, onError) {\n\n\tvar scope = this;\n\n\tvar vmds = [];\n\turls = urls.slice();\n\n\tfunction run() {\n\n\t\tvar url = urls.shift();\n\n\t\tscope.loadVmd(url, function (vmd) {\n\n\t\t\tvmds.push(vmd);\n\n\t\t\tif (urls.length > 0) {\n\n\t\t\t\trun();\n\t\t\t} else {\n\n\t\t\t\tcallback(scope.mergeVmds(vmds));\n\t\t\t}\n\t\t}, onProgress, onError);\n\t}\n\n\trun();\n};\n\nMMDLoader.prototype.loadAudio = function (url, callback, onProgress, onError) {\n\n\tvar listener = new THREE.AudioListener();\n\tvar audio = new THREE.Audio(listener);\n\tvar loader = new THREE.AudioLoader(this.manager);\n\n\tloader.load(url, function (buffer) {\n\n\t\taudio.setBuffer(buffer);\n\t\tcallback(audio, listener);\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.loadVpd = function (url, callback, onProgress, onError, params) {\n\n\tvar scope = this;\n\n\tvar func = (params && params.charcode === 'unicode' ? this.loadFileAsText : this.loadFileAsShiftJISText).bind(this);\n\n\tfunc(url, function (text) {\n\n\t\tcallback(scope.parseVpd(text));\n\t}, onProgress, onError);\n};\n\nMMDLoader.prototype.parseModel = function (buffer, modelExtension) {\n\n\t// Should I judge from model data header?\n\tswitch (modelExtension.toLowerCase()) {\n\n\t\tcase 'pmd':\n\t\t\treturn this.parsePmd(buffer);\n\n\t\tcase 'pmx':\n\t\t\treturn this.parsePmx(buffer);\n\n\t\tdefault:\n\t\t\tthrow 'extension ' + modelExtension + ' is not supported.';\n\n\t}\n};\n\nMMDLoader.prototype.parsePmd = function (buffer) {\n\n\treturn this.parser.parsePmd(buffer, true);\n};\n\nMMDLoader.prototype.parsePmx = function (buffer) {\n\n\treturn this.parser.parsePmx(buffer, true);\n};\n\nMMDLoader.prototype.parseVmd = function (buffer) {\n\n\treturn this.parser.parseVmd(buffer, true);\n};\n\nMMDLoader.prototype.parseVpd = function (text) {\n\n\treturn this.parser.parseVpd(text, true);\n};\n\nMMDLoader.prototype.mergeVmds = function (vmds) {\n\n\treturn this.parser.mergeVmds(vmds);\n};\n\nMMDLoader.prototype.pourVmdIntoModel = function (mesh, vmd, name) {\n\n\tthis.createAnimation(mesh, vmd, name);\n};\n\nMMDLoader.prototype.pourVmdIntoCamera = function (camera, vmd, name) {\n\n\tvar helper = new MMDLoader.DataCreationHelper();\n\n\tvar initAnimation = function initAnimation() {\n\n\t\tvar orderedMotions = helper.createOrderedMotionArray(vmd.cameras);\n\n\t\tvar times = [];\n\t\tvar centers = [];\n\t\tvar quaternions = [];\n\t\tvar positions = [];\n\t\tvar fovs = [];\n\n\t\tvar cInterpolations = [];\n\t\tvar qInterpolations = [];\n\t\tvar pInterpolations = [];\n\t\tvar fInterpolations = [];\n\n\t\tvar quaternion = new THREE.Quaternion();\n\t\tvar euler = new THREE.Euler();\n\t\tvar position = new THREE.Vector3();\n\t\tvar center = new THREE.Vector3();\n\n\t\tvar pushVector3 = function pushVector3(array, vec) {\n\n\t\t\tarray.push(vec.x);\n\t\t\tarray.push(vec.y);\n\t\t\tarray.push(vec.z);\n\t\t};\n\n\t\tvar pushQuaternion = function pushQuaternion(array, q) {\n\n\t\t\tarray.push(q.x);\n\t\t\tarray.push(q.y);\n\t\t\tarray.push(q.z);\n\t\t\tarray.push(q.w);\n\t\t};\n\n\t\tvar pushInterpolation = function pushInterpolation(array, interpolation, index) {\n\n\t\t\tarray.push(interpolation[index * 4 + 0] / 127); // x1\n\t\t\tarray.push(interpolation[index * 4 + 1] / 127); // x2\n\t\t\tarray.push(interpolation[index * 4 + 2] / 127); // y1\n\t\t\tarray.push(interpolation[index * 4 + 3] / 127); // y2\n\t\t};\n\n\t\tvar createTrack = function createTrack(node, type, times, values, interpolations) {\n\n\t\t\t/*\n    * optimizes here not to let KeyframeTrackPrototype optimize\n    * because KeyframeTrackPrototype optimizes times and values but\n    * doesn't optimize interpolations.\n    */\n\t\t\tif (times.length > 2) {\n\n\t\t\t\ttimes = times.slice();\n\t\t\t\tvalues = values.slice();\n\t\t\t\tinterpolations = interpolations.slice();\n\n\t\t\t\tvar stride = values.length / times.length;\n\t\t\t\tvar interpolateStride = stride === 3 ? 12 : 4; // 3: Vector3, others: Quaternion or Number\n\n\t\t\t\tvar index = 1;\n\n\t\t\t\tfor (var aheadIndex = 2, endIndex = times.length; aheadIndex < endIndex; aheadIndex++) {\n\n\t\t\t\t\tfor (var i = 0; i < stride; i++) {\n\n\t\t\t\t\t\tif (values[index * stride + i] !== values[(index - 1) * stride + i] || values[index * stride + i] !== values[aheadIndex * stride + i]) {\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (aheadIndex > index) {\n\n\t\t\t\t\t\ttimes[index] = times[aheadIndex];\n\n\t\t\t\t\t\tfor (var i = 0; i < stride; i++) {\n\n\t\t\t\t\t\t\tvalues[index * stride + i] = values[aheadIndex * stride + i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var i = 0; i < interpolateStride; i++) {\n\n\t\t\t\t\t\t\tinterpolations[index * interpolateStride + i] = interpolations[aheadIndex * interpolateStride + i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttimes.length = index + 1;\n\t\t\t\tvalues.length = (index + 1) * stride;\n\t\t\t\tinterpolations.length = (index + 1) * interpolateStride;\n\t\t\t}\n\n\t\t\tvar track = new THREE[type](node, times, values);\n\n\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n\n\t\t\t\treturn new MMDLoader.CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n\t\t\t};\n\n\t\t\treturn track;\n\t\t};\n\n\t\tfor (var i = 0; i < orderedMotions.length; i++) {\n\n\t\t\tvar m = orderedMotions[i];\n\n\t\t\tvar time = m.frameNum / 30;\n\t\t\tvar pos = m.position;\n\t\t\tvar rot = m.rotation;\n\t\t\tvar distance = m.distance;\n\t\t\tvar fov = m.fov;\n\t\t\tvar interpolation = m.interpolation;\n\n\t\t\tposition.set(0, 0, -distance);\n\t\t\tcenter.set(pos[0], pos[1], pos[2]);\n\n\t\t\teuler.set(-rot[0], -rot[1], -rot[2]);\n\t\t\tquaternion.setFromEuler(euler);\n\n\t\t\tposition.add(center);\n\t\t\tposition.applyQuaternion(quaternion);\n\n\t\t\ttimes.push(time);\n\n\t\t\tpushVector3(centers, center);\n\t\t\tpushQuaternion(quaternions, quaternion);\n\t\t\tpushVector3(positions, position);\n\n\t\t\tfovs.push(fov);\n\n\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\tpushInterpolation(cInterpolations, interpolation, j);\n\t\t\t}\n\n\t\t\tpushInterpolation(qInterpolations, interpolation, 3);\n\n\t\t\t// use same one parameter for x, y, z axis.\n\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\tpushInterpolation(pInterpolations, interpolation, 4);\n\t\t\t}\n\n\t\t\tpushInterpolation(fInterpolations, interpolation, 5);\n\t\t}\n\n\t\tif (times.length === 0) return;\n\n\t\tvar tracks = [];\n\n\t\ttracks.push(createTrack('.center', 'VectorKeyframeTrack', times, centers, cInterpolations));\n\t\ttracks.push(createTrack('.quaternion', 'QuaternionKeyframeTrack', times, quaternions, qInterpolations));\n\t\ttracks.push(createTrack('.position', 'VectorKeyframeTrack', times, positions, pInterpolations));\n\t\ttracks.push(createTrack('.fov', 'NumberKeyframeTrack', times, fovs, fInterpolations));\n\n\t\tvar clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name, -1, tracks);\n\n\t\tif (camera.center === undefined) camera.center = new THREE.Vector3(0, 0, 0);\n\t\tif (camera.animations === undefined) camera.animations = [];\n\t\tcamera.animations.push(clip);\n\t};\n\n\tinitAnimation();\n};\n\nMMDLoader.prototype.extractExtension = function (url) {\n\n\tvar index = url.lastIndexOf('.');\n\n\tif (index < 0) {\n\n\t\treturn null;\n\t}\n\n\treturn url.slice(index + 1);\n};\n\nMMDLoader.prototype.loadFile = function (url, onLoad, onProgress, onError, responseType, mimeType) {\n\n\tvar loader = new THREE.FileLoader(this.manager);\n\n\tif (mimeType !== undefined) loader.setMimeType(mimeType);\n\n\tloader.setResponseType(responseType);\n\n\tvar request = loader.load(url, function (result) {\n\n\t\tonLoad(result);\n\t}, onProgress, onError);\n\n\treturn request;\n};\n\nMMDLoader.prototype.loadFileAsBuffer = function (url, onLoad, onProgress, onError) {\n\n\tthis.loadFile(url, onLoad, onProgress, onError, 'arraybuffer');\n};\n\nMMDLoader.prototype.loadFileAsText = function (url, onLoad, onProgress, onError) {\n\n\tthis.loadFile(url, onLoad, onProgress, onError, 'text');\n};\n\nMMDLoader.prototype.loadFileAsShiftJISText = function (url, onLoad, onProgress, onError) {\n\n\tthis.loadFile(url, onLoad, onProgress, onError, 'text', 'text/plain; charset=shift_jis');\n};\n\nMMDLoader.prototype.createMesh = function (model, texturePath, onProgress, onError) {\n\n\tvar scope = this;\n\tvar geometry = new THREE.BufferGeometry();\n\tvar materials = [];\n\n\tvar buffer = {};\n\n\tbuffer.vertices = [];\n\tbuffer.uvs = [];\n\tbuffer.normals = [];\n\tbuffer.skinIndices = [];\n\tbuffer.skinWeights = [];\n\tbuffer.indices = [];\n\n\tvar initVartices = function initVartices() {\n\n\t\tfor (var i = 0; i < model.metadata.vertexCount; i++) {\n\n\t\t\tvar v = model.vertices[i];\n\n\t\t\tfor (var j = 0, jl = v.position.length; j < jl; j++) {\n\n\t\t\t\tbuffer.vertices.push(v.position[j]);\n\t\t\t}\n\n\t\t\tfor (var j = 0, jl = v.normal.length; j < jl; j++) {\n\n\t\t\t\tbuffer.normals.push(v.normal[j]);\n\t\t\t}\n\n\t\t\tfor (var j = 0, jl = v.uv.length; j < jl; j++) {\n\n\t\t\t\tbuffer.uvs.push(v.uv[j]);\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < 4; j++) {\n\n\t\t\t\tbuffer.skinIndices.push(v.skinIndices.length - 1 >= j ? v.skinIndices[j] : 0.0);\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < 4; j++) {\n\n\t\t\t\tbuffer.skinWeights.push(v.skinWeights.length - 1 >= j ? v.skinWeights[j] : 0.0);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar initFaces = function initFaces() {\n\n\t\tfor (var i = 0; i < model.metadata.faceCount; i++) {\n\n\t\t\tvar f = model.faces[i];\n\n\t\t\tfor (var j = 0, jl = f.indices.length; j < jl; j++) {\n\n\t\t\t\tbuffer.indices.push(f.indices[j]);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar initBones = function initBones() {\n\n\t\tvar bones = [];\n\n\t\tvar rigidBodies = model.rigidBodies;\n\t\tvar dictionary = {};\n\n\t\tfor (var i = 0, il = rigidBodies.length; i < il; i++) {\n\n\t\t\tvar body = rigidBodies[i];\n\t\t\tvar value = dictionary[body.boneIndex];\n\n\t\t\t// keeps greater number if already value is set without any special reasons\n\t\t\tvalue = value === undefined ? body.type : Math.max(body.type, value);\n\n\t\t\tdictionary[body.boneIndex] = value;\n\t\t}\n\n\t\tfor (var i = 0; i < model.metadata.boneCount; i++) {\n\n\t\t\tvar bone = {};\n\t\t\tvar b = model.bones[i];\n\n\t\t\tbone.parent = b.parentIndex;\n\t\t\tbone.name = b.name;\n\t\t\tbone.pos = [b.position[0], b.position[1], b.position[2]];\n\t\t\tbone.rotq = [0, 0, 0, 1];\n\t\t\tbone.scl = [1, 1, 1];\n\n\t\t\tif (bone.parent !== -1) {\n\n\t\t\t\tbone.pos[0] -= model.bones[bone.parent].position[0];\n\t\t\t\tbone.pos[1] -= model.bones[bone.parent].position[1];\n\t\t\t\tbone.pos[2] -= model.bones[bone.parent].position[2];\n\t\t\t}\n\n\t\t\tbone.rigidBodyType = dictionary[i] !== undefined ? dictionary[i] : -1;\n\n\t\t\tbones.push(bone);\n\t\t}\n\n\t\tgeometry.bones = bones;\n\t};\n\n\tvar initIKs = function initIKs() {\n\n\t\tvar iks = [];\n\n\t\t// TODO: remove duplicated codes between PMD and PMX\n\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\tfor (var i = 0; i < model.metadata.ikCount; i++) {\n\n\t\t\t\tvar ik = model.iks[i];\n\t\t\t\tvar param = {};\n\n\t\t\t\tparam.target = ik.target;\n\t\t\t\tparam.effector = ik.effector;\n\t\t\t\tparam.iteration = ik.iteration;\n\t\t\t\tparam.maxAngle = ik.maxAngle * 4;\n\t\t\t\tparam.links = [];\n\n\t\t\t\tfor (var j = 0; j < ik.links.length; j++) {\n\n\t\t\t\t\tvar link = {};\n\t\t\t\t\tlink.index = ik.links[j].index;\n\n\t\t\t\t\tif (model.bones[link.index].name.indexOf('„Å≤„Åñ') >= 0) {\n\n\t\t\t\t\t\tlink.limitation = new THREE.Vector3(1.0, 0.0, 0.0);\n\t\t\t\t\t}\n\n\t\t\t\t\tparam.links.push(link);\n\t\t\t\t}\n\n\t\t\t\tiks.push(param);\n\t\t\t}\n\t\t} else {\n\n\t\t\tfor (var i = 0; i < model.metadata.boneCount; i++) {\n\n\t\t\t\tvar b = model.bones[i];\n\t\t\t\tvar ik = b.ik;\n\n\t\t\t\tif (ik === undefined) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar param = {};\n\n\t\t\t\tparam.target = i;\n\t\t\t\tparam.effector = ik.effector;\n\t\t\t\tparam.iteration = ik.iteration;\n\t\t\t\tparam.maxAngle = ik.maxAngle;\n\t\t\t\tparam.links = [];\n\n\t\t\t\tfor (var j = 0; j < ik.links.length; j++) {\n\n\t\t\t\t\tvar link = {};\n\t\t\t\t\tlink.index = ik.links[j].index;\n\t\t\t\t\tlink.enabled = true;\n\n\t\t\t\t\tif (ik.links[j].angleLimitation === 1) {\n\n\t\t\t\t\t\tlink.limitation = new THREE.Vector3(1.0, 0.0, 0.0);\n\t\t\t\t\t\t// TODO: use limitation angles\n\t\t\t\t\t\t// link.lowerLimitationAngle;\n\t\t\t\t\t\t// link.upperLimitationAngle;\n\t\t\t\t\t}\n\n\t\t\t\t\tparam.links.push(link);\n\t\t\t\t}\n\n\t\t\t\tiks.push(param);\n\t\t\t}\n\t\t}\n\n\t\tgeometry.iks = iks;\n\t};\n\n\tvar initGrants = function initGrants() {\n\n\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar grants = [];\n\n\t\tfor (var i = 0; i < model.metadata.boneCount; i++) {\n\n\t\t\tvar b = model.bones[i];\n\t\t\tvar grant = b.grant;\n\n\t\t\tif (grant === undefined) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar param = {};\n\n\t\t\tparam.index = i;\n\t\t\tparam.parentIndex = grant.parentIndex;\n\t\t\tparam.ratio = grant.ratio;\n\t\t\tparam.isLocal = grant.isLocal;\n\t\t\tparam.affectRotation = grant.affectRotation;\n\t\t\tparam.affectPosition = grant.affectPosition;\n\t\t\tparam.transformationClass = b.transformationClass;\n\n\t\t\tgrants.push(param);\n\t\t}\n\n\t\tgrants.sort(function (a, b) {\n\n\t\t\treturn a.transformationClass - b.transformationClass;\n\t\t});\n\n\t\tgeometry.grants = grants;\n\t};\n\n\tvar initMorphs = function initMorphs() {\n\n\t\tfunction updateVertex(attribute, index, v, ratio) {\n\n\t\t\tattribute.array[index * 3 + 0] += v.position[0] * ratio;\n\t\t\tattribute.array[index * 3 + 1] += v.position[1] * ratio;\n\t\t\tattribute.array[index * 3 + 2] += v.position[2] * ratio;\n\t\t}\n\n\t\tfunction updateVertices(attribute, m, ratio) {\n\n\t\t\tfor (var i = 0; i < m.elementCount; i++) {\n\n\t\t\t\tvar v = m.elements[i];\n\n\t\t\t\tvar index;\n\n\t\t\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\t\t\tindex = model.morphs[0].elements[v.index].index;\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = v.index;\n\t\t\t\t}\n\n\t\t\t\tupdateVertex(attribute, index, v, ratio);\n\t\t\t}\n\t\t}\n\n\t\tvar morphTargets = [];\n\t\tvar attributes = [];\n\n\t\tfor (var i = 0; i < model.metadata.morphCount; i++) {\n\n\t\t\tvar m = model.morphs[i];\n\t\t\tvar params = { name: m.name };\n\n\t\t\tvar attribute = new THREE.Float32BufferAttribute(model.metadata.vertexCount * 3, 3);\n\t\t\tattribute.name = m.name;\n\n\t\t\tfor (var j = 0; j < model.metadata.vertexCount * 3; j++) {\n\n\t\t\t\tattribute.array[j] = buffer.vertices[j];\n\t\t\t}\n\n\t\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\t\tif (i !== 0) {\n\n\t\t\t\t\tupdateVertices(attribute, m, 1.0);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (m.type === 0) {\n\t\t\t\t\t// group\n\n\t\t\t\t\tfor (var j = 0; j < m.elementCount; j++) {\n\n\t\t\t\t\t\tvar m2 = model.morphs[m.elements[j].index];\n\t\t\t\t\t\tvar ratio = m.elements[j].ratio;\n\n\t\t\t\t\t\tif (m2.type === 1) {\n\n\t\t\t\t\t\t\tupdateVertices(attribute, m2, ratio);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// TODO: implement\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (m.type === 1) {\n\t\t\t\t\t// vertex\n\n\t\t\t\t\tupdateVertices(attribute, m, 1.0);\n\t\t\t\t} else if (m.type === 2) {// bone\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 3) {// uv\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 4) {// additional uv1\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 5) {// additional uv2\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 6) {// additional uv3\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 7) {// additional uv4\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t} else if (m.type === 8) {// material\n\n\t\t\t\t\t// TODO: implement\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmorphTargets.push(params);\n\t\t\tattributes.push(attribute);\n\t\t}\n\n\t\tgeometry.morphTargets = morphTargets;\n\t\tgeometry.morphAttributes.position = attributes;\n\t};\n\n\tvar initMaterials = function initMaterials() {\n\n\t\tvar textures = {};\n\t\tvar textureLoader = new THREE.TextureLoader(scope.manager);\n\t\tvar tgaLoader = new THREE.TGALoader(scope.manager);\n\t\tvar canvas = document.createElement('canvas');\n\t\tvar context = canvas.getContext('2d');\n\t\tvar offset = 0;\n\t\tvar materialParams = [];\n\n\t\tif (scope.textureCrossOrigin !== null) textureLoader.setCrossOrigin(scope.textureCrossOrigin);\n\n\t\tfunction loadTexture(filePath, params) {\n\n\t\t\tif (params === undefined) {\n\n\t\t\t\tparams = {};\n\t\t\t}\n\n\t\t\tvar fullPath;\n\n\t\t\tif (params.defaultTexturePath === true) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tfullPath = scope.defaultToonTextures[parseInt(filePath.match('toon([0-9]{2})\\.bmp$')[1])];\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tconsole.warn('THREE.MMDLoader: ' + filePath + ' seems like not right default texture path. Using toon00.bmp instead.');\n\t\t\t\t\tfullPath = scope.defaultToonTextures[0];\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfullPath = texturePath + filePath;\n\t\t\t}\n\n\t\t\tif (textures[fullPath] !== undefined) return fullPath;\n\n\t\t\tvar loader = THREE.Loader.Handlers.get(fullPath);\n\n\t\t\tif (loader === null) {\n\n\t\t\t\tloader = filePath.indexOf('.tga') >= 0 ? tgaLoader : textureLoader;\n\t\t\t}\n\n\t\t\tvar texture = loader.load(fullPath, function (t) {\n\n\t\t\t\t// MMD toon texture is Axis-Y oriented\n\t\t\t\t// but Three.js gradient map is Axis-X oriented.\n\t\t\t\t// So here replaces the toon texture image with the rotated one.\n\t\t\t\tif (params.isToonTexture === true) {\n\n\t\t\t\t\tvar image = t.image;\n\t\t\t\t\tvar width = image.width;\n\t\t\t\t\tvar height = image.height;\n\n\t\t\t\t\tcanvas.width = width;\n\t\t\t\t\tcanvas.height = height;\n\n\t\t\t\t\tcontext.clearRect(0, 0, width, height);\n\t\t\t\t\tcontext.translate(width / 2.0, height / 2.0);\n\t\t\t\t\tcontext.rotate(0.5 * Math.PI); // 90.0 * Math.PI / 180.0\n\t\t\t\t\tcontext.translate(-width / 2.0, -height / 2.0);\n\t\t\t\t\tcontext.drawImage(image, 0, 0);\n\n\t\t\t\t\tt.image = context.getImageData(0, 0, width, height);\n\t\t\t\t}\n\n\t\t\t\tt.flipY = false;\n\t\t\t\tt.wrapS = THREE.RepeatWrapping;\n\t\t\t\tt.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\tfor (var i = 0; i < texture.readyCallbacks.length; i++) {\n\n\t\t\t\t\ttexture.readyCallbacks[i](texture);\n\t\t\t\t}\n\n\t\t\t\tdelete texture.readyCallbacks;\n\t\t\t}, onProgress, onError);\n\n\t\t\tif (params.sphericalReflectionMapping === true) {\n\n\t\t\t\ttexture.mapping = THREE.SphericalReflectionMapping;\n\t\t\t}\n\n\t\t\ttexture.readyCallbacks = [];\n\n\t\t\ttextures[fullPath] = texture;\n\n\t\t\treturn fullPath;\n\t\t}\n\n\t\tfunction getTexture(name, textures) {\n\n\t\t\tif (textures[name] === undefined) {\n\n\t\t\t\tconsole.warn('THREE.MMDLoader: Undefined texture', name);\n\t\t\t}\n\n\t\t\treturn textures[name];\n\t\t}\n\n\t\tfor (var i = 0; i < model.metadata.materialCount; i++) {\n\n\t\t\tvar m = model.materials[i];\n\t\t\tvar params = {};\n\n\t\t\tparams.faceOffset = offset;\n\t\t\tparams.faceNum = m.faceCount;\n\n\t\t\toffset += m.faceCount;\n\n\t\t\tparams.name = m.name;\n\n\t\t\t/*\n    * Color\n    *\n    * MMD         MeshToonMaterial\n    * diffuse  -  color\n    * specular -  specular\n    * ambient  -  emissive * a\n    *               (a = 1.0 without map texture or 0.2 with map texture)\n    *\n    * MeshToonMaterial doesn't have ambient. Set it to emissive instead.\n    * It'll be too bright if material has map texture so using coef 0.2.\n    */\n\t\t\tparams.color = new THREE.Color(m.diffuse[0], m.diffuse[1], m.diffuse[2]);\n\t\t\tparams.opacity = m.diffuse[3];\n\t\t\tparams.specular = new THREE.Color(m.specular[0], m.specular[1], m.specular[2]);\n\t\t\tparams.shininess = m.shininess;\n\n\t\t\tif (params.opacity === 1.0) {\n\n\t\t\t\tparams.side = THREE.FrontSide;\n\t\t\t\tparams.transparent = false;\n\t\t\t} else {\n\n\t\t\t\tparams.side = THREE.DoubleSide;\n\t\t\t\tparams.transparent = true;\n\t\t\t}\n\n\t\t\tif (model.metadata.format === 'pmd') {\n\n\t\t\t\tif (m.fileName) {\n\n\t\t\t\t\tvar fileName = m.fileName;\n\t\t\t\t\tvar fileNames = [];\n\n\t\t\t\t\tvar index = fileName.lastIndexOf('*');\n\n\t\t\t\t\tif (index >= 0) {\n\n\t\t\t\t\t\tfileNames.push(fileName.slice(0, index));\n\t\t\t\t\t\tfileNames.push(fileName.slice(index + 1));\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfileNames.push(fileName);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var j = 0; j < fileNames.length; j++) {\n\n\t\t\t\t\t\tvar n = fileNames[j];\n\n\t\t\t\t\t\tif (n.indexOf('.sph') >= 0 || n.indexOf('.spa') >= 0) {\n\n\t\t\t\t\t\t\tparams.envMap = loadTexture(n, { sphericalReflectionMapping: true });\n\n\t\t\t\t\t\t\tif (n.indexOf('.sph') >= 0) {\n\n\t\t\t\t\t\t\t\tparams.envMapType = THREE.MultiplyOperation;\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tparams.envMapType = THREE.AddOperation;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tparams.map = loadTexture(n);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tif (m.textureIndex !== -1) {\n\n\t\t\t\t\tvar n = model.textures[m.textureIndex];\n\t\t\t\t\tparams.map = loadTexture(n);\n\t\t\t\t}\n\n\t\t\t\t// TODO: support m.envFlag === 3\n\t\t\t\tif (m.envTextureIndex !== -1 && (m.envFlag === 1 || m.envFlag == 2)) {\n\n\t\t\t\t\tvar n = model.textures[m.envTextureIndex];\n\t\t\t\t\tparams.envMap = loadTexture(n, { sphericalReflectionMapping: true });\n\n\t\t\t\t\tif (m.envFlag === 1) {\n\n\t\t\t\t\t\tparams.envMapType = THREE.MultiplyOperation;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tparams.envMapType = THREE.AddOperation;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar coef = params.map === undefined ? 1.0 : 0.2;\n\t\t\tparams.emissive = new THREE.Color(m.ambient[0] * coef, m.ambient[1] * coef, m.ambient[2] * coef);\n\n\t\t\tmaterialParams.push(params);\n\t\t}\n\n\t\tfor (var i = 0; i < materialParams.length; i++) {\n\n\t\t\tvar p = materialParams[i];\n\t\t\tvar p2 = model.materials[i];\n\t\t\tvar m = new THREE.MeshToonMaterial();\n\n\t\t\tgeometry.addGroup(p.faceOffset * 3, p.faceNum * 3, i);\n\n\t\t\tif (p.name !== undefined) m.name = p.name;\n\n\t\t\tm.skinning = geometry.bones.length > 0 ? true : false;\n\t\t\tm.morphTargets = geometry.morphTargets.length > 0 ? true : false;\n\t\t\tm.lights = true;\n\t\t\tm.side = model.metadata.format === 'pmx' && (p2.flag & 0x1) === 1 ? THREE.DoubleSide : p.side;\n\t\t\tm.transparent = p.transparent;\n\t\t\tm.fog = true;\n\n\t\t\tm.blending = THREE.CustomBlending;\n\t\t\tm.blendSrc = THREE.SrcAlphaFactor;\n\t\t\tm.blendDst = THREE.OneMinusSrcAlphaFactor;\n\t\t\tm.blendSrcAlpha = THREE.SrcAlphaFactor;\n\t\t\tm.blendDstAlpha = THREE.DstAlphaFactor;\n\n\t\t\tif (p.map !== undefined) {\n\n\t\t\t\t// Check if this part of the texture image the material uses requires transparency\n\t\t\t\tvar checkTextureTransparency = function checkTextureTransparency(m) {\n\n\t\t\t\t\tm.map.readyCallbacks.push(function (t) {\n\n\t\t\t\t\t\t// Is there any efficient ways?\n\t\t\t\t\t\tfunction createImageData(image) {\n\n\t\t\t\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\t\t\t\tc.width = image.width;\n\t\t\t\t\t\t\tc.height = image.height;\n\n\t\t\t\t\t\t\tvar ctx = c.getContext('2d');\n\t\t\t\t\t\t\tctx.drawImage(image, 0, 0);\n\n\t\t\t\t\t\t\treturn ctx.getImageData(0, 0, c.width, c.height);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfunction detectTextureTransparency(image, uvs, indices) {\n\n\t\t\t\t\t\t\tvar width = image.width;\n\t\t\t\t\t\t\tvar height = image.height;\n\t\t\t\t\t\t\tvar data = image.data;\n\t\t\t\t\t\t\tvar threshold = 253;\n\n\t\t\t\t\t\t\tif (data.length / (width * height) !== 4) {\n\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (var i = 0; i < indices.length; i += 3) {\n\n\t\t\t\t\t\t\t\tvar centerUV = { x: 0.0, y: 0.0 };\n\n\t\t\t\t\t\t\t\tfor (var j = 0; j < 3; j++) {\n\n\t\t\t\t\t\t\t\t\tvar index = indices[i * 3 + j];\n\t\t\t\t\t\t\t\t\tvar uv = { x: uvs[index * 2 + 0], y: uvs[index * 2 + 1] };\n\n\t\t\t\t\t\t\t\t\tif (getAlphaByUv(image, uv) < threshold) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcenterUV.x += uv.x;\n\t\t\t\t\t\t\t\t\tcenterUV.y += uv.y;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcenterUV.x /= 3;\n\t\t\t\t\t\t\t\tcenterUV.y /= 3;\n\n\t\t\t\t\t\t\t\tif (getAlphaByUv(image, centerUV) < threshold) {\n\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/*\n       * This method expects\n       *   t.flipY = false\n       *   t.wrapS = THREE.RepeatWrapping\n       *   t.wrapT = THREE.RepeatWrapping\n       * TODO: more precise\n       */\n\t\t\t\t\t\tfunction getAlphaByUv(image, uv) {\n\n\t\t\t\t\t\t\tvar width = image.width;\n\t\t\t\t\t\t\tvar height = image.height;\n\n\t\t\t\t\t\t\tvar x = Math.round(uv.x * width) % width;\n\t\t\t\t\t\t\tvar y = Math.round(uv.y * height) % height;\n\n\t\t\t\t\t\t\tif (x < 0) {\n\n\t\t\t\t\t\t\t\tx += width;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (y < 0) {\n\n\t\t\t\t\t\t\t\ty += height;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar index = y * width + x;\n\n\t\t\t\t\t\t\treturn image.data[index * 4 + 3];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar imageData = t.image.data !== undefined ? t.image : createImageData(t.image);\n\t\t\t\t\t\tvar indices = geometry.index.array.slice(m.faceOffset * 3, m.faceOffset * 3 + m.faceNum * 3);\n\n\t\t\t\t\t\tif (detectTextureTransparency(imageData, geometry.attributes.uv.array, indices)) m.transparent = true;\n\n\t\t\t\t\t\tdelete m.faceOffset;\n\t\t\t\t\t\tdelete m.faceNum;\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tm.faceOffset = p.faceOffset;\n\t\t\t\tm.faceNum = p.faceNum;\n\n\t\t\t\tm.map = getTexture(p.map, textures);\n\t\t\t\tcheckTextureTransparency(m);\n\t\t\t}\n\n\t\t\tif (p.envMap !== undefined) {\n\n\t\t\t\tm.envMap = getTexture(p.envMap, textures);\n\t\t\t\tm.combine = p.envMapType;\n\t\t\t}\n\n\t\t\tm.opacity = p.opacity;\n\t\t\tm.color = p.color;\n\n\t\t\tif (p.emissive !== undefined) {\n\n\t\t\t\tm.emissive = p.emissive;\n\t\t\t}\n\n\t\t\tm.specular = p.specular;\n\t\t\tm.shininess = Math.max(p.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )\n\n\t\t\tif (model.metadata.format === 'pmd') {\n\t\t\t\tvar isDefaultToonTexture = function isDefaultToonTexture(n) {\n\n\t\t\t\t\tif (n.length !== 10) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn n.match(/toon(10|0[0-9]).bmp/) === null ? false : true;\n\t\t\t\t};\n\n\t\t\t\t// parameters for OutlineEffect\n\n\n\t\t\t\tm.outlineParameters = {\n\t\t\t\t\tthickness: p2.edgeFlag === 1 ? 0.003 : 0.0,\n\t\t\t\t\tcolor: new THREE.Color(0.0, 0.0, 0.0),\n\t\t\t\t\talpha: 1.0\n\t\t\t\t};\n\n\t\t\t\tif (m.outlineParameters.thickness === 0.0) m.outlineParameters.visible = false;\n\n\t\t\t\tvar toonFileName = p2.toonIndex === -1 ? 'toon00.bmp' : model.toonTextures[p2.toonIndex].fileName;\n\t\t\t\tvar uuid = loadTexture(toonFileName, { isToonTexture: true, defaultTexturePath: isDefaultToonTexture(toonFileName) });\n\t\t\t\tm.gradientMap = getTexture(uuid, textures);\n\t\t\t} else {\n\n\t\t\t\t// parameters for OutlineEffect\n\t\t\t\tm.outlineParameters = {\n\t\t\t\t\tthickness: p2.edgeSize / 300,\n\t\t\t\t\tcolor: new THREE.Color(p2.edgeColor[0], p2.edgeColor[1], p2.edgeColor[2]),\n\t\t\t\t\talpha: p2.edgeColor[3]\n\t\t\t\t};\n\n\t\t\t\tif ((p2.flag & 0x10) === 0 || m.outlineParameters.thickness === 0.0) m.outlineParameters.visible = false;\n\n\t\t\t\tvar toonFileName, isDefaultToon;\n\n\t\t\t\tif (p2.toonIndex === -1 || p2.toonFlag !== 0) {\n\n\t\t\t\t\tvar num = p2.toonIndex + 1;\n\t\t\t\t\ttoonFileName = 'toon' + (num < 10 ? '0' + num : num) + '.bmp';\n\t\t\t\t\tisDefaultToon = true;\n\t\t\t\t} else {\n\n\t\t\t\t\ttoonFileName = model.textures[p2.toonIndex];\n\t\t\t\t\tisDefaultToon = false;\n\t\t\t\t}\n\n\t\t\t\tvar uuid = loadTexture(toonFileName, { isToonTexture: true, defaultTexturePath: isDefaultToon });\n\t\t\t\tm.gradientMap = getTexture(uuid, textures);\n\t\t\t}\n\n\t\t\tmaterials.push(m);\n\t\t}\n\n\t\tif (model.metadata.format === 'pmx') {\n\t\t\tvar checkAlphaMorph = function checkAlphaMorph(morph, elements) {\n\n\t\t\t\tif (morph.type !== 8) {\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < elements.length; i++) {\n\n\t\t\t\t\tvar e = elements[i];\n\n\t\t\t\t\tif (e.index === -1) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar m = materials[e.index];\n\n\t\t\t\t\tif (m.opacity !== e.diffuse[3]) {\n\n\t\t\t\t\t\tm.transparent = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (var i = 0; i < model.morphs.length; i++) {\n\n\t\t\t\tvar morph = model.morphs[i];\n\t\t\t\tvar elements = morph.elements;\n\n\t\t\t\tif (morph.type === 0) {\n\n\t\t\t\t\tfor (var j = 0; j < elements.length; j++) {\n\n\t\t\t\t\t\tvar morph2 = model.morphs[elements[j].index];\n\t\t\t\t\t\tvar elements2 = morph2.elements;\n\n\t\t\t\t\t\tcheckAlphaMorph(morph2, elements2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tcheckAlphaMorph(morph, elements);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar initPhysics = function initPhysics() {\n\n\t\tvar rigidBodies = [];\n\t\tvar constraints = [];\n\n\t\tfor (var i = 0; i < model.metadata.rigidBodyCount; i++) {\n\n\t\t\tvar b = model.rigidBodies[i];\n\t\t\tvar keys = Object.keys(b);\n\n\t\t\tvar p = {};\n\n\t\t\tfor (var j = 0; j < keys.length; j++) {\n\n\t\t\t\tvar key = keys[j];\n\t\t\t\tp[key] = b[key];\n\t\t\t}\n\n\t\t\t/*\n    * RigidBody position parameter in PMX seems global position\n    * while the one in PMD seems offset from corresponding bone.\n    * So unify being offset.\n    */\n\t\t\tif (model.metadata.format === 'pmx') {\n\n\t\t\t\tif (p.boneIndex !== -1) {\n\n\t\t\t\t\tvar bone = model.bones[p.boneIndex];\n\t\t\t\t\tp.position[0] -= bone.position[0];\n\t\t\t\t\tp.position[1] -= bone.position[1];\n\t\t\t\t\tp.position[2] -= bone.position[2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trigidBodies.push(p);\n\t\t}\n\n\t\tfor (var i = 0; i < model.metadata.constraintCount; i++) {\n\n\t\t\tvar c = model.constraints[i];\n\t\t\tvar keys = Object.keys(c);\n\n\t\t\tvar p = {};\n\n\t\t\tfor (var j = 0; j < keys.length; j++) {\n\n\t\t\t\tvar key = keys[j];\n\t\t\t\tp[key] = c[key];\n\t\t\t}\n\n\t\t\tvar bodyA = rigidBodies[p.rigidBodyIndex1];\n\t\t\tvar bodyB = rigidBodies[p.rigidBodyIndex2];\n\n\t\t\t/*\n    * Refer to http://www20.atpages.jp/katwat/wp/?p=4135\n    */\n\t\t\tif (bodyA.type !== 0 && bodyB.type === 2) {\n\n\t\t\t\tif (bodyA.boneIndex !== -1 && bodyB.boneIndex !== -1 && model.bones[bodyB.boneIndex].parentIndex === bodyA.boneIndex) {\n\n\t\t\t\t\tbodyB.type = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconstraints.push(p);\n\t\t}\n\n\t\tgeometry.rigidBodies = rigidBodies;\n\t\tgeometry.constraints = constraints;\n\t};\n\n\tvar initGeometry = function initGeometry() {\n\n\t\tgeometry.setIndex(buffer.indices);\n\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(buffer.vertices, 3));\n\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(buffer.normals, 3));\n\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(buffer.uvs, 2));\n\t\tgeometry.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffer.skinIndices, 4));\n\t\tgeometry.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffer.skinWeights, 4));\n\n\t\tgeometry.computeBoundingSphere();\n\t\tgeometry.mmdFormat = model.metadata.format;\n\t};\n\n\tinitVartices();\n\tinitFaces();\n\tinitBones();\n\tinitIKs();\n\tinitGrants();\n\tinitMorphs();\n\tinitMaterials();\n\tinitPhysics();\n\tinitGeometry();\n\n\tvar mesh = new THREE.SkinnedMesh(geometry, materials);\n\n\t// console.log( mesh ); // for console debug\n\n\treturn mesh;\n};\n\nMMDLoader.prototype.createAnimation = function (mesh, vmd, name) {\n\n\tvar helper = new MMDLoader.DataCreationHelper();\n\n\tvar initMotionAnimations = function initMotionAnimations() {\n\n\t\tif (vmd.metadata.motionCount === 0) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar bones = mesh.geometry.bones;\n\t\tvar orderedMotions = helper.createOrderedMotionArrays(bones, vmd.motions, 'boneName');\n\n\t\tvar tracks = [];\n\n\t\tvar pushInterpolation = function pushInterpolation(array, interpolation, index) {\n\n\t\t\tarray.push(interpolation[index + 0] / 127); // x1\n\t\t\tarray.push(interpolation[index + 8] / 127); // x2\n\t\t\tarray.push(interpolation[index + 4] / 127); // y1\n\t\t\tarray.push(interpolation[index + 12] / 127); // y2\n\t\t};\n\n\t\tvar createTrack = function createTrack(node, type, times, values, interpolations) {\n\n\t\t\tvar track = new THREE[type](node, times, values);\n\n\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodCubicBezier(result) {\n\n\t\t\t\treturn new MMDLoader.CubicBezierInterpolation(this.times, this.values, this.getValueSize(), result, new Float32Array(interpolations));\n\t\t\t};\n\n\t\t\treturn track;\n\t\t};\n\n\t\tfor (var i = 0; i < orderedMotions.length; i++) {\n\n\t\t\tvar times = [];\n\t\t\tvar positions = [];\n\t\t\tvar rotations = [];\n\t\t\tvar pInterpolations = [];\n\t\t\tvar rInterpolations = [];\n\n\t\t\tvar bone = bones[i];\n\t\t\tvar array = orderedMotions[i];\n\n\t\t\tfor (var j = 0; j < array.length; j++) {\n\n\t\t\t\tvar time = array[j].frameNum / 30;\n\t\t\t\tvar pos = array[j].position;\n\t\t\t\tvar rot = array[j].rotation;\n\t\t\t\tvar interpolation = array[j].interpolation;\n\n\t\t\t\ttimes.push(time);\n\n\t\t\t\tfor (var k = 0; k < 3; k++) {\n\n\t\t\t\t\tpositions.push(bone.pos[k] + pos[k]);\n\t\t\t\t}\n\n\t\t\t\tfor (var k = 0; k < 4; k++) {\n\n\t\t\t\t\trotations.push(rot[k]);\n\t\t\t\t}\n\n\t\t\t\tfor (var k = 0; k < 3; k++) {\n\n\t\t\t\t\tpushInterpolation(pInterpolations, interpolation, k);\n\t\t\t\t}\n\n\t\t\t\tpushInterpolation(rInterpolations, interpolation, 3);\n\t\t\t}\n\n\t\t\tif (times.length === 0) continue;\n\n\t\t\tvar boneName = '.bones[' + bone.name + ']';\n\n\t\t\ttracks.push(createTrack(boneName + '.position', 'VectorKeyframeTrack', times, positions, pInterpolations));\n\t\t\ttracks.push(createTrack(boneName + '.quaternion', 'QuaternionKeyframeTrack', times, rotations, rInterpolations));\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name, -1, tracks);\n\n\t\tif (mesh.geometry.animations === undefined) mesh.geometry.animations = [];\n\t\tmesh.geometry.animations.push(clip);\n\t};\n\n\tvar initMorphAnimations = function initMorphAnimations() {\n\n\t\tif (vmd.metadata.morphCount === 0) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar orderedMorphs = helper.createOrderedMotionArrays(mesh.geometry.morphTargets, vmd.morphs, 'morphName');\n\n\t\tvar tracks = [];\n\n\t\tfor (var i = 0; i < orderedMorphs.length; i++) {\n\n\t\t\tvar times = [];\n\t\t\tvar values = [];\n\t\t\tvar array = orderedMorphs[i];\n\n\t\t\tfor (var j = 0; j < array.length; j++) {\n\n\t\t\t\ttimes.push(array[j].frameNum / 30);\n\t\t\t\tvalues.push(array[j].weight);\n\t\t\t}\n\n\t\t\tif (times.length === 0) continue;\n\n\t\t\ttracks.push(new THREE.NumberKeyframeTrack('.morphTargetInfluences[' + i + ']', times, values));\n\t\t}\n\n\t\tvar clip = new THREE.AnimationClip(name === undefined ? THREE.Math.generateUUID() : name + 'Morph', -1, tracks);\n\n\t\tif (mesh.geometry.animations === undefined) mesh.geometry.animations = [];\n\t\tmesh.geometry.animations.push(clip);\n\t};\n\n\tinitMotionAnimations();\n\tinitMorphAnimations();\n};\n\nMMDLoader.DataCreationHelper = function () {};\n\nMMDLoader.DataCreationHelper.prototype = {\n\n\tconstructor: MMDLoader.DataCreationHelper,\n\n\t/*\n  * Note: Sometimes to use Japanese Unicode characters runs into problems in Three.js.\n  *       In such a case, use this method to convert it to Unicode hex charcode strings,\n  *       like '„ÅÇ„ÅÑ„ÅÜ' -> '0x30420x30440x3046'\n  */\n\n\ttoCharcodeStrings: function toCharcodeStrings(s) {\n\n\t\tvar str = '';\n\n\t\tfor (var i = 0; i < s.length; i++) {\n\n\t\t\tstr += '0x' + ('0000' + s[i].charCodeAt().toString(16)).substr(-4);\n\t\t}\n\n\t\treturn str;\n\t},\n\n\tcreateDictionary: function createDictionary(array) {\n\n\t\tvar dict = {};\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tdict[array[i].name] = i;\n\t\t}\n\n\t\treturn dict;\n\t},\n\n\tinitializeMotionArrays: function initializeMotionArrays(array) {\n\n\t\tvar result = [];\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tresult[i] = [];\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tsortMotionArray: function sortMotionArray(array) {\n\n\t\tarray.sort(function (a, b) {\n\n\t\t\treturn a.frameNum - b.frameNum;\n\t\t});\n\t},\n\n\tsortMotionArrays: function sortMotionArrays(arrays) {\n\n\t\tfor (var i = 0; i < arrays.length; i++) {\n\n\t\t\tthis.sortMotionArray(arrays[i]);\n\t\t}\n\t},\n\n\tcreateMotionArray: function createMotionArray(array) {\n\n\t\tvar result = [];\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tresult.push(array[i]);\n\t\t}\n\n\t\treturn result;\n\t},\n\n\tcreateMotionArrays: function createMotionArrays(array, result, dict, key) {\n\n\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\tvar a = array[i];\n\t\t\tvar num = dict[a[key]];\n\n\t\t\tif (num === undefined) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult[num].push(a);\n\t\t}\n\t},\n\n\tcreateOrderedMotionArray: function createOrderedMotionArray(array) {\n\n\t\tvar result = this.createMotionArray(array);\n\t\tthis.sortMotionArray(result);\n\t\treturn result;\n\t},\n\n\tcreateOrderedMotionArrays: function createOrderedMotionArrays(targetArray, motionArray, key) {\n\n\t\tvar dict = this.createDictionary(targetArray);\n\t\tvar result = this.initializeMotionArrays(targetArray);\n\t\tthis.createMotionArrays(motionArray, result, dict, key);\n\t\tthis.sortMotionArrays(result);\n\n\t\treturn result;\n\t}\n\n};\n\nMMDLoader.CubicBezierInterpolation = function (parameterPositions, sampleValues, sampleSize, resultBuffer, params) {\n\n\tTHREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);\n\n\tthis.params = params;\n};\n\nMMDLoader.CubicBezierInterpolation.prototype = Object.create(THREE.LinearInterpolant.prototype);\nMMDLoader.CubicBezierInterpolation.prototype.constructor = MMDLoader.CubicBezierInterpolation;\n\nMMDLoader.CubicBezierInterpolation.prototype.interpolate_ = function (i1, t0, t, t1) {\n\n\tvar result = this.resultBuffer;\n\tvar values = this.sampleValues;\n\tvar stride = this.valueSize;\n\n\tvar offset1 = i1 * stride;\n\tvar offset0 = offset1 - stride;\n\n\t// No interpolation if next key frame is in one frame in 30fps. This is from MMD animation spec.\n\tvar weight1 = t1 - t0 < 1 / 30 * 1.5 ? 0.0 : (t - t0) / (t1 - t0);\n\n\tif (stride === 4) {\n\t\t// Quaternion\n\n\t\tvar x1 = this.params[i1 * 4 + 0];\n\t\tvar x2 = this.params[i1 * 4 + 1];\n\t\tvar y1 = this.params[i1 * 4 + 2];\n\t\tvar y2 = this.params[i1 * 4 + 3];\n\n\t\tvar ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n\t\tTHREE.Quaternion.slerpFlat(result, 0, values, offset0, values, offset1, ratio);\n\t} else if (stride === 3) {\n\t\t// Vector3\n\n\t\tfor (var i = 0; i !== stride; ++i) {\n\n\t\t\tvar x1 = this.params[i1 * 12 + i * 4 + 0];\n\t\t\tvar x2 = this.params[i1 * 12 + i * 4 + 1];\n\t\t\tvar y1 = this.params[i1 * 12 + i * 4 + 2];\n\t\t\tvar y2 = this.params[i1 * 12 + i * 4 + 3];\n\n\t\t\tvar ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n\t\t\tresult[i] = values[offset0 + i] * (1 - ratio) + values[offset1 + i] * ratio;\n\t\t}\n\t} else {\n\t\t// Number\n\n\t\tvar x1 = this.params[i1 * 4 + 0];\n\t\tvar x2 = this.params[i1 * 4 + 1];\n\t\tvar y1 = this.params[i1 * 4 + 2];\n\t\tvar y2 = this.params[i1 * 4 + 3];\n\n\t\tvar ratio = this._calculate(x1, x2, y1, y2, weight1);\n\n\t\tresult[0] = values[offset0] * (1 - ratio) + values[offset1] * ratio;\n\t}\n\n\treturn result;\n};\n\nMMDLoader.CubicBezierInterpolation.prototype._calculate = function (x1, x2, y1, y2, x) {\n\n\t/*\n  * Cubic Bezier curves\n  *   https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Cubic_B.C3.A9zier_curves\n  *\n  * B(t) = ( 1 - t ) ^ 3 * P0\n  *      + 3 * ( 1 - t ) ^ 2 * t * P1\n  *      + 3 * ( 1 - t ) * t^2 * P2\n  *      + t ^ 3 * P3\n  *      ( 0 <= t <= 1 )\n  *\n  * MMD uses Cubic Bezier curves for bone and camera animation interpolation.\n  *   http://d.hatena.ne.jp/edvakf/20111016/1318716097\n  *\n  *    x = ( 1 - t ) ^ 3 * x0\n  *      + 3 * ( 1 - t ) ^ 2 * t * x1\n  *      + 3 * ( 1 - t ) * t^2 * x2\n  *      + t ^ 3 * x3\n  *    y = ( 1 - t ) ^ 3 * y0\n  *      + 3 * ( 1 - t ) ^ 2 * t * y1\n  *      + 3 * ( 1 - t ) * t^2 * y2\n  *      + t ^ 3 * y3\n  *      ( x0 = 0, y0 = 0 )\n  *      ( x3 = 1, y3 = 1 )\n  *      ( 0 <= t, x1, x2, y1, y2 <= 1 )\n  *\n  * Here solves this equation with Bisection method,\n  *   https://en.wikipedia.org/wiki/Bisection_method\n  * gets t, and then calculate y.\n  *\n  * f(t) = 3 * ( 1 - t ) ^ 2 * t * x1\n  *      + 3 * ( 1 - t ) * t^2 * x2\n  *      + t ^ 3 - x = 0\n  *\n  * (Another option: Newton's method\n  *    https://en.wikipedia.org/wiki/Newton%27s_method)\n  */\n\n\tvar c = 0.5;\n\tvar t = c;\n\tvar s = 1.0 - t;\n\tvar loop = 15;\n\tvar eps = 1e-5;\n\tvar math = Math;\n\n\tvar sst3, stt3, ttt;\n\n\tfor (var i = 0; i < loop; i++) {\n\n\t\tsst3 = 3.0 * s * s * t;\n\t\tstt3 = 3.0 * s * t * t;\n\t\tttt = t * t * t;\n\n\t\tvar ft = sst3 * x1 + stt3 * x2 + ttt - x;\n\n\t\tif (math.abs(ft) < eps) break;\n\n\t\tc /= 2.0;\n\n\t\tt += ft < 0 ? c : -c;\n\t\ts = 1.0 - t;\n\t}\n\n\treturn sst3 * y1 + stt3 * y2 + ttt;\n};\n\nTHREE.MMDAudioManager = function (audio, listener, p) {\n\n\tvar params = p === null || p === undefined ? {} : p;\n\n\tthis.audio = audio;\n\tthis.listener = listener;\n\n\tthis.elapsedTime = 0.0;\n\tthis.currentTime = 0.0;\n\tthis.delayTime = params.delayTime !== undefined ? params.delayTime : 0.0;\n\n\tthis.audioDuration = this.audio.buffer.duration;\n\tthis.duration = this.audioDuration + this.delayTime;\n};\n\nTHREE.MMDAudioManager.prototype = {\n\n\tconstructor: THREE.MMDAudioManager,\n\n\tcontrol: function control(delta) {\n\n\t\tthis.elapsed += delta;\n\t\tthis.currentTime += delta;\n\n\t\tif (this.checkIfStopAudio()) {\n\n\t\t\tthis.audio.stop();\n\t\t}\n\n\t\tif (this.checkIfStartAudio()) {\n\n\t\t\tthis.audio.play();\n\t\t}\n\t},\n\n\tcheckIfStartAudio: function checkIfStartAudio() {\n\n\t\tif (this.audio.isPlaying) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\twhile (this.currentTime >= this.duration) {\n\n\t\t\tthis.currentTime -= this.duration;\n\t\t}\n\n\t\tif (this.currentTime < this.delayTime) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.audio.startTime = this.currentTime - this.delayTime;\n\n\t\treturn true;\n\t},\n\n\tcheckIfStopAudio: function checkIfStopAudio() {\n\n\t\tif (!this.audio.isPlaying) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.currentTime >= this.duration) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n};\n\nTHREE.MMDGrantSolver = function (mesh) {\n\n\tthis.mesh = mesh;\n};\n\nTHREE.MMDGrantSolver.prototype = {\n\n\tconstructor: THREE.MMDGrantSolver,\n\n\tupdate: function () {\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function () {\n\n\t\t\tfor (var i = 0; i < this.mesh.geometry.grants.length; i++) {\n\n\t\t\t\tvar g = this.mesh.geometry.grants[i];\n\t\t\t\tvar b = this.mesh.skeleton.bones[g.index];\n\t\t\t\tvar pb = this.mesh.skeleton.bones[g.parentIndex];\n\n\t\t\t\tif (g.isLocal) {\n\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tif (g.affectPosition) {}\n\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tif (g.affectRotation) {}\n\t\t\t\t} else {\n\n\t\t\t\t\t// TODO: implement\n\t\t\t\t\tif (g.affectPosition) {}\n\n\t\t\t\t\tif (g.affectRotation) {\n\n\t\t\t\t\t\tq.set(0, 0, 0, 1);\n\t\t\t\t\t\tq.slerp(pb.quaternion, g.ratio);\n\t\t\t\t\t\tb.quaternion.multiply(q);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}()\n\n};\n\nTHREE.MMDHelper = function () {\n\n\tthis.meshes = [];\n\n\tthis.doAnimation = true;\n\tthis.doIk = true;\n\tthis.doGrant = true;\n\tthis.doPhysics = true;\n\tthis.doCameraAnimation = true;\n\n\tthis.sharedPhysics = false;\n\tthis.masterPhysics = null;\n\n\tthis.audioManager = null;\n\tthis.camera = null;\n};\n\nTHREE.MMDHelper.prototype = {\n\n\tconstructor: THREE.MMDHelper,\n\n\tadd: function add(mesh) {\n\n\t\tif (!(mesh instanceof THREE.SkinnedMesh)) {\n\n\t\t\tthrow new Error('THREE.MMDHelper.add() accepts only THREE.SkinnedMesh instance.');\n\t\t}\n\n\t\tif (mesh.mixer === undefined) mesh.mixer = null;\n\t\tif (mesh.ikSolver === undefined) mesh.ikSolver = null;\n\t\tif (mesh.grantSolver === undefined) mesh.grantSolver = null;\n\t\tif (mesh.physics === undefined) mesh.physics = null;\n\t\tif (mesh.looped === undefined) mesh.looped = false;\n\n\t\tthis.meshes.push(mesh);\n\n\t\t// workaround until I make IK and Physics Animation plugin\n\t\tthis.initBackupBones(mesh);\n\t},\n\n\tsetAudio: function setAudio(audio, listener, params) {\n\n\t\tthis.audioManager = new THREE.MMDAudioManager(audio, listener, params);\n\t},\n\n\tsetCamera: function setCamera(camera) {\n\n\t\tcamera.mixer = null;\n\t\tthis.camera = camera;\n\t},\n\n\tsetPhysicses: function setPhysicses(params) {\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.setPhysics(this.meshes[i], params);\n\t\t}\n\t},\n\n\tsetPhysics: function setPhysics(mesh, params) {\n\n\t\tparams = params === undefined ? {} : Object.assign({}, params);\n\n\t\tif (params.world === undefined && this.sharedPhysics) {\n\n\t\t\tvar masterPhysics = this.getMasterPhysics();\n\n\t\t\tif (masterPhysics !== null) params.world = masterPhysics.world;\n\t\t}\n\n\t\tvar warmup = params.warmup !== undefined ? params.warmup : 60;\n\n\t\tvar physics = new THREE.MMDPhysics(mesh, params);\n\n\t\tif (mesh.mixer !== null && mesh.mixer !== undefined && params.preventAnimationWarmup !== true) {\n\n\t\t\tthis.animateOneMesh(0, mesh);\n\t\t\tphysics.reset();\n\t\t}\n\n\t\tphysics.warmup(warmup);\n\n\t\tthis.updateIKParametersDependingOnPhysicsEnabled(mesh, true);\n\n\t\tmesh.physics = physics;\n\t},\n\n\tgetMasterPhysics: function getMasterPhysics() {\n\n\t\tif (this.masterPhysics !== null) return this.masterPhysics;\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tvar physics = this.meshes[i].physics;\n\n\t\t\tif (physics !== undefined && physics !== null) {\n\n\t\t\t\tthis.masterPhysics = physics;\n\t\t\t\treturn this.masterPhysics;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t},\n\n\tenablePhysics: function enablePhysics(enabled) {\n\n\t\tif (enabled === true) {\n\n\t\t\tthis.doPhysics = true;\n\t\t} else {\n\n\t\t\tthis.doPhysics = false;\n\t\t}\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tthis.updateIKParametersDependingOnPhysicsEnabled(this.meshes[i], enabled);\n\t\t}\n\t},\n\n\tupdateIKParametersDependingOnPhysicsEnabled: function updateIKParametersDependingOnPhysicsEnabled(mesh, physicsEnabled) {\n\n\t\tvar iks = mesh.geometry.iks;\n\t\tvar bones = mesh.geometry.bones;\n\n\t\tfor (var j = 0, jl = iks.length; j < jl; j++) {\n\n\t\t\tvar ik = iks[j];\n\t\t\tvar links = ik.links;\n\n\t\t\tfor (var k = 0, kl = links.length; k < kl; k++) {\n\n\t\t\t\tvar link = links[k];\n\n\t\t\t\tif (physicsEnabled === true) {\n\n\t\t\t\t\t// disable IK of the bone the corresponding rigidBody type of which is 1 or 2\n\t\t\t\t\t// because its rotation will be overriden by physics\n\t\t\t\t\tlink.enabled = bones[link.index].rigidBodyType > 0 ? false : true;\n\t\t\t\t} else {\n\n\t\t\t\t\tlink.enabled = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsetAnimations: function setAnimations() {\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.setAnimation(this.meshes[i]);\n\t\t}\n\t},\n\n\tsetAnimation: function setAnimation(mesh) {\n\n\t\tif (mesh.geometry.animations !== undefined) {\n\n\t\t\tmesh.mixer = new THREE.AnimationMixer(mesh);\n\n\t\t\t// TODO: find a workaround not to access (seems like) private properties\n\t\t\t//       the name of them begins with \"_\".\n\t\t\tmesh.mixer.addEventListener('loop', function (e) {\n\n\t\t\t\tif (e.action._clip.tracks.length > 0 && e.action._clip.tracks[0].name.indexOf('.bones') !== 0) return;\n\n\t\t\t\tvar mesh = e.target._root;\n\t\t\t\tmesh.looped = true;\n\t\t\t});\n\n\t\t\tvar foundAnimation = false;\n\t\t\tvar foundMorphAnimation = false;\n\n\t\t\tfor (var i = 0; i < mesh.geometry.animations.length; i++) {\n\n\t\t\t\tvar clip = mesh.geometry.animations[i];\n\n\t\t\t\tvar action = mesh.mixer.clipAction(clip);\n\n\t\t\t\tif (clip.tracks.length > 0 && clip.tracks[0].name.indexOf('.morphTargetInfluences') === 0) {\n\n\t\t\t\t\tif (!foundMorphAnimation) {\n\n\t\t\t\t\t\taction.play();\n\t\t\t\t\t\tfoundMorphAnimation = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (!foundAnimation) {\n\n\t\t\t\t\t\taction.play();\n\t\t\t\t\t\tfoundAnimation = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (foundAnimation) {\n\n\t\t\t\tmesh.ikSolver = new THREE.CCDIKSolver(mesh);\n\n\t\t\t\tif (mesh.geometry.grants !== undefined) {\n\n\t\t\t\t\tmesh.grantSolver = new THREE.MMDGrantSolver(mesh);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tsetCameraAnimation: function setCameraAnimation(camera) {\n\n\t\tif (camera.animations !== undefined) {\n\n\t\t\tcamera.mixer = new THREE.AnimationMixer(camera);\n\t\t\tcamera.mixer.clipAction(camera.animations[0]).play();\n\t\t}\n\t},\n\n\t/*\n  * detect the longest duration among model, camera, and audio animations and then\n  * set it to them to sync.\n  * TODO: touching private properties ( ._actions and ._clip ) so consider better way\n  *       to access them for safe and modularity.\n  */\n\tunifyAnimationDuration: function unifyAnimationDuration(params) {\n\n\t\tparams = params === undefined ? {} : params;\n\n\t\tvar max = 0.0;\n\n\t\tvar camera = this.camera;\n\t\tvar audioManager = this.audioManager;\n\n\t\t// check the longest duration\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tvar mesh = this.meshes[i];\n\t\t\tvar mixer = mesh.mixer;\n\n\t\t\tif (mixer === null) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < mixer._actions.length; j++) {\n\n\t\t\t\tvar action = mixer._actions[j];\n\t\t\t\tmax = Math.max(max, action._clip.duration);\n\t\t\t}\n\t\t}\n\n\t\tif (camera !== null && camera.mixer !== null) {\n\n\t\t\tvar mixer = camera.mixer;\n\n\t\t\tfor (var i = 0; i < mixer._actions.length; i++) {\n\n\t\t\t\tvar action = mixer._actions[i];\n\t\t\t\tmax = Math.max(max, action._clip.duration);\n\t\t\t}\n\t\t}\n\n\t\tif (audioManager !== null) {\n\n\t\t\tmax = Math.max(max, audioManager.duration);\n\t\t}\n\n\t\tif (params.afterglow !== undefined) {\n\n\t\t\tmax += params.afterglow;\n\t\t}\n\n\t\t// set the duration\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tvar mesh = this.meshes[i];\n\t\t\tvar mixer = mesh.mixer;\n\n\t\t\tif (mixer === null) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (var j = 0; j < mixer._actions.length; j++) {\n\n\t\t\t\tvar action = mixer._actions[j];\n\t\t\t\taction._clip.duration = max;\n\t\t\t}\n\t\t}\n\n\t\tif (camera !== null && camera.mixer !== null) {\n\n\t\t\tvar mixer = camera.mixer;\n\n\t\t\tfor (var i = 0; i < mixer._actions.length; i++) {\n\n\t\t\t\tvar action = mixer._actions[i];\n\t\t\t\taction._clip.duration = max;\n\t\t\t}\n\t\t}\n\n\t\tif (audioManager !== null) {\n\n\t\t\taudioManager.duration = max;\n\t\t}\n\t},\n\n\tcontrolAudio: function controlAudio(delta) {\n\n\t\tif (this.audioManager === null) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.audioManager.control(delta);\n\t},\n\n\tanimate: function animate(delta) {\n\n\t\tthis.controlAudio(delta);\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.animateOneMesh(delta, this.meshes[i]);\n\t\t}\n\n\t\tif (this.sharedPhysics) this.updateSharedPhysics(delta);\n\n\t\tthis.animateCamera(delta);\n\t},\n\n\tanimateOneMesh: function animateOneMesh(delta, mesh) {\n\n\t\tvar mixer = mesh.mixer;\n\t\tvar ikSolver = mesh.ikSolver;\n\t\tvar grantSolver = mesh.grantSolver;\n\t\tvar physics = mesh.physics;\n\n\t\tif (mixer !== null && this.doAnimation === true) {\n\n\t\t\t// restore/backupBones are workaround\n\t\t\t// until I make IK, Grant, and Physics Animation plugin\n\t\t\tthis.restoreBones(mesh);\n\n\t\t\tmixer.update(delta);\n\n\t\t\tthis.backupBones(mesh);\n\t\t}\n\n\t\tif (ikSolver !== null && this.doIk === true) {\n\n\t\t\tikSolver.update();\n\t\t}\n\n\t\tif (grantSolver !== null && this.doGrant === true) {\n\n\t\t\tgrantSolver.update();\n\t\t}\n\n\t\tif (mesh.looped === true) {\n\n\t\t\tif (physics !== null) physics.reset();\n\n\t\t\tmesh.looped = false;\n\t\t}\n\n\t\tif (physics !== null && this.doPhysics && !this.sharedPhysics) {\n\n\t\t\tphysics.update(delta);\n\t\t}\n\t},\n\n\tupdateSharedPhysics: function updateSharedPhysics(delta) {\n\n\t\tif (this.meshes.length === 0 || !this.doPhysics || !this.sharedPhysics) return;\n\n\t\tvar physics = this.getMasterPhysics();\n\n\t\tif (physics === null) return;\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tvar p = this.meshes[i].physics;\n\n\t\t\tif (p !== null && p !== undefined) {\n\n\t\t\t\tp.updateRigidBodies();\n\t\t\t}\n\t\t}\n\n\t\tphysics.stepSimulation(delta);\n\n\t\tfor (var i = 0, il = this.meshes.length; i < il; i++) {\n\n\t\t\tvar p = this.meshes[i].physics;\n\n\t\t\tif (p !== null && p !== undefined) {\n\n\t\t\t\tp.updateBones();\n\t\t\t}\n\t\t}\n\t},\n\n\tanimateCamera: function animateCamera(delta) {\n\n\t\tif (this.camera === null) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar mixer = this.camera.mixer;\n\n\t\tif (mixer !== null && this.camera.center !== undefined && this.doCameraAnimation === true) {\n\n\t\t\tmixer.update(delta);\n\n\t\t\t// TODO: Let PerspectiveCamera automatically update?\n\t\t\tthis.camera.updateProjectionMatrix();\n\n\t\t\tthis.camera.up.set(0, 1, 0);\n\t\t\tthis.camera.up.applyQuaternion(this.camera.quaternion);\n\t\t\tthis.camera.lookAt(this.camera.center);\n\t\t}\n\t},\n\n\tposeAsVpd: function poseAsVpd(mesh, vpd, params) {\n\n\t\tif (params === undefined) params = {};\n\n\t\tif (params.preventResetPose !== true) mesh.pose();\n\n\t\tvar bones = mesh.skeleton.bones;\n\t\tvar bones2 = vpd.bones;\n\n\t\tvar table = {};\n\n\t\tfor (var i = 0; i < bones.length; i++) {\n\n\t\t\ttable[bones[i].name] = i;\n\t\t}\n\n\t\tvar thV = new THREE.Vector3();\n\t\tvar thQ = new THREE.Quaternion();\n\n\t\tfor (var i = 0; i < bones2.length; i++) {\n\n\t\t\tvar b = bones2[i];\n\t\t\tvar index = table[b.name];\n\n\t\t\tif (index === undefined) continue;\n\n\t\t\tvar b2 = bones[index];\n\t\t\tvar t = b.translation;\n\t\t\tvar q = b.quaternion;\n\n\t\t\tthV.set(t[0], t[1], t[2]);\n\t\t\tthQ.set(q[0], q[1], q[2], q[3]);\n\n\t\t\tb2.position.add(thV);\n\t\t\tb2.quaternion.multiply(thQ);\n\t\t}\n\n\t\tmesh.updateMatrixWorld(true);\n\n\t\tif (params.preventIk !== true) {\n\n\t\t\tvar solver = new THREE.CCDIKSolver(mesh);\n\t\t\tsolver.update(params.saveOriginalBonesBeforeIK);\n\t\t}\n\n\t\tif (params.preventGrant !== true && mesh.geometry.grants !== undefined) {\n\n\t\t\tvar solver = new THREE.MMDGrantSolver(mesh);\n\t\t\tsolver.update();\n\t\t}\n\t},\n\n\t/*\n  * Note: These following three functions are workaround for r74dev.\n  *       THREE.PropertyMixer.apply() seems to save values into buffer cache\n  *       when mixer.update() is called.\n  *       ikSolver.update() and physics.update() change bone position/quaternion\n  *       without mixer.update() then buffer cache will be inconsistent.\n  *       So trying to avoid buffer cache inconsistency by doing\n  *       backup bones position/quaternion right after mixer.update() call\n  *       and then restore them after rendering.\n  */\n\tinitBackupBones: function initBackupBones(mesh) {\n\n\t\tmesh.skeleton.backupBones = [];\n\n\t\tfor (var i = 0; i < mesh.skeleton.bones.length; i++) {\n\n\t\t\tmesh.skeleton.backupBones.push(mesh.skeleton.bones[i].clone());\n\t\t}\n\t},\n\n\tbackupBones: function backupBones(mesh) {\n\n\t\tmesh.skeleton.backupBoneIsSaved = true;\n\n\t\tfor (var i = 0; i < mesh.skeleton.bones.length; i++) {\n\n\t\t\tvar b = mesh.skeleton.backupBones[i];\n\t\t\tvar b2 = mesh.skeleton.bones[i];\n\t\t\tb.position.copy(b2.position);\n\t\t\tb.quaternion.copy(b2.quaternion);\n\t\t}\n\t},\n\n\trestoreBones: function restoreBones(mesh) {\n\n\t\tif (mesh.skeleton.backupBoneIsSaved !== true) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tmesh.skeleton.backupBoneIsSaved = false;\n\n\t\tfor (var i = 0; i < mesh.skeleton.bones.length; i++) {\n\n\t\t\tvar b = mesh.skeleton.bones[i];\n\t\t\tvar b2 = mesh.skeleton.backupBones[i];\n\t\t\tb.position.copy(b2.position);\n\t\t\tb.quaternion.copy(b2.quaternion);\n\t\t}\n\t}\n\n};\n\nexports.default = MMDLoader;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author sunag / http://www.sunag.com.br/\n */\n\nvar NodeMaterialLoader = function NodeMaterialLoader(manager, library) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.nodes = {};\n\tthis.materials = {};\n\tthis.passes = {};\n\tthis.names = {};\n\tthis.library = library || {};\n};\n\nvar NodeMaterialLoaderUtils = {\n\n\treplaceUUIDObject: function replaceUUIDObject(object, uuid, value, recursive) {\n\n\t\trecursive = recursive !== undefined ? recursive : true;\n\n\t\tif ((typeof uuid === \"undefined\" ? \"undefined\" : _typeof(uuid)) === \"object\") uuid = uuid.uuid;\n\n\t\tif ((typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) === \"object\") {\n\n\t\t\tvar keys = Object.keys(object);\n\n\t\t\tfor (var i = 0; i < keys.length; i++) {\n\n\t\t\t\tvar key = keys[i];\n\n\t\t\t\tif (recursive) {\n\n\t\t\t\t\tobject[key] = this.replaceUUIDObject(object[key], uuid, value);\n\t\t\t\t}\n\n\t\t\t\tif (key === uuid) {\n\n\t\t\t\t\tobject[uuid] = object[key];\n\n\t\t\t\t\tdelete object[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn object === uuid ? value : object;\n\t},\n\n\treplaceUUID: function replaceUUID(json, uuid, value) {\n\n\t\tthis.replaceUUIDObject(json, uuid, value, false);\n\t\tthis.replaceUUIDObject(json.nodes, uuid, value);\n\t\tthis.replaceUUIDObject(json.materials, uuid, value);\n\t\tthis.replaceUUIDObject(json.passes, uuid, value);\n\t\tthis.replaceUUIDObject(json.library, uuid, value, false);\n\n\t\treturn json;\n\t}\n\n};\n\nObject.assign(NodeMaterialLoader.prototype, {\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t}, onProgress, onError);\n\n\t\treturn this;\n\t},\n\n\tgetObjectByName: function getObjectByName(uuid) {\n\n\t\treturn this.names[uuid];\n\t},\n\n\tgetObjectById: function getObjectById(uuid) {\n\n\t\treturn this.library[uuid] || this.nodes[uuid] || this.names[uuid];\n\t},\n\n\tgetNode: function getNode(uuid) {\n\n\t\tvar object = this.getObjectById(uuid);\n\n\t\tif (!object) {\n\n\t\t\tconsole.warn(\"Node \\\"\" + uuid + \"\\\" not found.\");\n\t\t}\n\n\t\treturn object;\n\t},\n\n\tparse: function parse(json) {\n\n\t\tvar uuid, node, object, prop, i;\n\n\t\tfor (uuid in json.nodes) {\n\n\t\t\tnode = json.nodes[uuid];\n\n\t\t\tobject = new THREE[node.type]();\n\n\t\t\tif (node.name) {\n\n\t\t\t\tobject.name = node.name;\n\n\t\t\t\tthis.names[object.name] = object;\n\t\t\t} else {\n\n\t\t\t\t// ignore \"uniform\" shader input ( for optimization )\n\t\t\t\tobject.readonly = true;\n\t\t\t}\n\n\t\t\tif (node.readonly !== undefined) object.readonly = node.readonly;\n\n\t\t\tthis.nodes[uuid] = object;\n\t\t}\n\n\t\tfor (uuid in json.materials) {\n\n\t\t\tnode = json.materials[uuid];\n\n\t\t\tobject = new THREE[node.type]();\n\n\t\t\tif (node.name) {\n\n\t\t\t\tobject.name = node.name;\n\n\t\t\t\tthis.names[object.name] = object;\n\t\t\t}\n\n\t\t\tthis.materials[uuid] = object;\n\t\t}\n\n\t\tfor (uuid in json.passes) {\n\n\t\t\tnode = json.passes[uuid];\n\n\t\t\tobject = new THREE[node.type]();\n\n\t\t\tif (node.name) {\n\n\t\t\t\tobject.name = node.name;\n\n\t\t\t\tthis.names[object.name] = object;\n\t\t\t}\n\n\t\t\tthis.passes[uuid] = object;\n\t\t}\n\n\t\tif (json.material) this.material = this.materials[uuid];\n\t\tif (json.pass) this.pass = this.passes[uuid];\n\n\t\tfor (uuid in json.nodes) {\n\n\t\t\tnode = json.nodes[uuid];\n\t\t\tobject = this.nodes[uuid];\n\n\t\t\tswitch (node.type) {\n\n\t\t\t\tcase \"FloatNode\":\n\n\t\t\t\t\tobject.number = node.number;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ColorNode\":\n\n\t\t\t\t\tobject.value.copy(node);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Vector2Node\":\n\n\t\t\t\t\tobject.x = node.x;\n\t\t\t\t\tobject.y = node.y;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Vector3Node\":\n\n\t\t\t\t\tobject.x = node.x;\n\t\t\t\t\tobject.y = node.y;\n\t\t\t\t\tobject.z = node.z;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Vector4Node\":\n\n\t\t\t\t\tobject.x = node.x;\n\t\t\t\t\tobject.y = node.y;\n\t\t\t\t\tobject.z = node.z;\n\t\t\t\t\tobject.w = node.w;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Matrix3Node\":\n\t\t\t\tcase \"Matrix4Node\":\n\n\t\t\t\t\tobject.value.fromArray(node.elements);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"OperatorNode\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.b = this.getNode(node.b);\n\t\t\t\t\tobject.op = node.op;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Math1Node\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Math2Node\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.b = this.getNode(node.b);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"Math3Node\":\n\n\t\t\t\t\tobject.a = this.getNode(node.a);\n\t\t\t\t\tobject.b = this.getNode(node.b);\n\t\t\t\t\tobject.c = this.getNode(node.c);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"UVNode\":\n\t\t\t\tcase \"ColorsNode\":\n\n\t\t\t\t\tobject.index = node.index;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"LuminanceNode\":\n\n\t\t\t\t\tobject.rgb = this.getNode(node.rgb);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"PositionNode\":\n\t\t\t\tcase \"NormalNode\":\n\t\t\t\tcase \"ReflectNode\":\n\t\t\t\tcase \"LightNode\":\n\n\t\t\t\t\tobject.scope = node.scope;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"SwitchNode\":\n\n\t\t\t\t\tobject.node = this.getNode(node.node);\n\t\t\t\t\tobject.components = node.components;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"JoinNode\":\n\n\t\t\t\t\tfor (prop in node.inputs) {\n\n\t\t\t\t\t\tobject[prop] = this.getNode(node.inputs[prop]);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"CameraNode\":\n\n\t\t\t\t\tobject.setScope(node.scope);\n\n\t\t\t\t\tif (node.camera) object.setCamera(this.getNode(node.camera));\n\n\t\t\t\t\tswitch (node.scope) {\n\n\t\t\t\t\t\tcase THREE.CameraNode.DEPTH:\n\n\t\t\t\t\t\t\tobject.near.number = node.near;\n\t\t\t\t\t\t\tobject.far.number = node.far;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ColorAdjustmentNode\":\n\n\t\t\t\t\tobject.rgb = this.getNode(node.rgb);\n\t\t\t\t\tobject.adjustment = this.getNode(node.adjustment);\n\t\t\t\t\tobject.method = node.method;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"UVTransformNode\":\n\n\t\t\t\t\tobject.uv = this.getNode(node.uv);\n\t\t\t\t\tobject.transform = this.getNode(node.transform);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"BumpNode\":\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\t\t\t\t\tobject.scale = this.getNode(node.scale);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"BlurNode\":\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\t\t\t\t\tobject.scale = this.getNode(node.scale);\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\t\t\t\t\tobject.radius = this.getNode(node.radius);\n\n\t\t\t\t\tif (node.size !== undefined) object.size = new THREE.Vector2(node.size.x, node.size.y);\n\n\t\t\t\t\tobject.blurX = node.blurX;\n\t\t\t\t\tobject.blurY = node.blurY;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ResolutionNode\":\n\n\t\t\t\t\tobject.renderer = this.getNode(node.renderer);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ScreenUVNode\":\n\n\t\t\t\t\tobject.resolution = this.getNode(node.resolution);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"VelocityNode\":\n\n\t\t\t\t\tif (node.target) object.setTarget(this.getNode(node.target));\n\t\t\t\t\tobject.setParams(node.params);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"TimerNode\":\n\n\t\t\t\t\tobject.scope = node.scope;\n\t\t\t\t\tobject.scale = node.scale;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ConstNode\":\n\n\t\t\t\t\tobject.name = node.name;\n\t\t\t\t\tobject.type = node.out;\n\t\t\t\t\tobject.value = node.value;\n\t\t\t\t\tobject.useDefine = node.useDefine === true;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"AttributeNode\":\n\t\t\t\tcase \"VarNode\":\n\n\t\t\t\t\tobject.type = node.out;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"ReflectorNode\":\n\n\t\t\t\t\tobject.setMirror(this.getNode(node.mirror));\n\n\t\t\t\t\tif (node.offset) object.offset = this.getNode(node.offset);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"NoiseNode\":\n\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"FunctionNode\":\n\n\t\t\t\t\tobject.isMethod = node.isMethod;\n\t\t\t\t\tobject.useKeywords = node.useKeywords;\n\n\t\t\t\t\tobject.extensions = node.extensions;\n\t\t\t\t\tobject.keywords = {};\n\n\t\t\t\t\tfor (prop in node.keywords) {\n\n\t\t\t\t\t\tobject.keywords[prop] = this.getNode(node.keywords[prop]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node.includes) {\n\n\t\t\t\t\t\tfor (i = 0; i < node.includes.length; i++) {\n\n\t\t\t\t\t\t\tobject.includes.push(this.getNode(node.includes[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.eval(node.src, object.includes, object.extensions, object.keywords);\n\n\t\t\t\t\tif (!object.isMethod) object.type = node.out;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"FunctionCallNode\":\n\n\t\t\t\t\tfor (prop in node.inputs) {\n\n\t\t\t\t\t\tobject.inputs[prop] = this.getNode(node.inputs[prop]);\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"TextureNode\":\n\t\t\t\tcase \"CubeTextureNode\":\n\t\t\t\tcase \"ScreenNode\":\n\n\t\t\t\t\tif (node.value) object.value = this.getNode(node.value);\n\n\t\t\t\t\tobject.coord = this.getNode(node.coord);\n\n\t\t\t\t\tif (node.bias) object.bias = this.getNode(node.bias);\n\t\t\t\t\tif (object.project !== undefined) object.project = node.project;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"RoughnessToBlinnExponentNode\":\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"RawNode\":\n\n\t\t\t\t\tobject.value = this.getNode(node.value);\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"StandardNode\":\n\t\t\t\tcase \"PhongNode\":\n\t\t\t\tcase \"SpriteNode\":\n\n\t\t\t\t\tobject.color = this.getNode(node.color);\n\n\t\t\t\t\tif (node.alpha) object.alpha = this.getNode(node.alpha);\n\n\t\t\t\t\tif (node.specular) object.specular = this.getNode(node.specular);\n\t\t\t\t\tif (node.shininess) object.shininess = this.getNode(node.shininess);\n\n\t\t\t\t\tif (node.roughness) object.roughness = this.getNode(node.roughness);\n\t\t\t\t\tif (node.metalness) object.metalness = this.getNode(node.metalness);\n\n\t\t\t\t\tif (node.reflectivity) object.reflectivity = this.getNode(node.reflectivity);\n\n\t\t\t\t\tif (node.clearCoat) object.clearCoat = this.getNode(node.clearCoat);\n\t\t\t\t\tif (node.clearCoatRoughness) object.clearCoatRoughness = this.getNode(node.clearCoatRoughness);\n\n\t\t\t\t\tif (node.normal) object.normal = this.getNode(node.normal);\n\t\t\t\t\tif (node.normalScale) object.normalScale = this.getNode(node.normalScale);\n\n\t\t\t\t\tif (node.emissive) object.emissive = this.getNode(node.emissive);\n\t\t\t\t\tif (node.ambient) object.ambient = this.getNode(node.ambient);\n\n\t\t\t\t\tif (node.shadow) object.shadow = this.getNode(node.shadow);\n\t\t\t\t\tif (node.light) object.light = this.getNode(node.light);\n\n\t\t\t\t\tif (node.ao) object.ao = this.getNode(node.ao);\n\n\t\t\t\t\tif (node.environment) object.environment = this.getNode(node.environment);\n\t\t\t\t\tif (node.environmentAlpha) object.environmentAlpha = this.getNode(node.environmentAlpha);\n\n\t\t\t\t\tif (node.transform) object.transform = this.getNode(node.transform);\n\n\t\t\t\t\tif (node.spherical === false) object.spherical = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.warn(node.type, \"not supported.\");\n\n\t\t\t}\n\t\t}\n\n\t\tfor (uuid in json.materials) {\n\n\t\t\tnode = json.materials[uuid];\n\t\t\tobject = this.materials[uuid];\n\n\t\t\tif (node.name !== undefined) object.name = node.name;\n\n\t\t\tif (node.blending !== undefined) object.blending = node.blending;\n\t\t\tif (node.flatShading !== undefined) object.flatShading = node.flatShading;\n\t\t\tif (node.side !== undefined) object.side = node.side;\n\n\t\t\tobject.depthFunc = node.depthFunc;\n\t\t\tobject.depthTest = node.depthTest;\n\t\t\tobject.depthWrite = node.depthWrite;\n\n\t\t\tif (node.wireframe !== undefined) object.wireframe = node.wireframe;\n\t\t\tif (node.wireframeLinewidth !== undefined) object.wireframeLinewidth = node.wireframeLinewidth;\n\t\t\tif (node.wireframeLinecap !== undefined) object.wireframeLinecap = node.wireframeLinecap;\n\t\t\tif (node.wireframeLinejoin !== undefined) object.wireframeLinejoin = node.wireframeLinejoin;\n\n\t\t\tif (node.skinning !== undefined) object.skinning = node.skinning;\n\t\t\tif (node.morphTargets !== undefined) object.morphTargets = node.morphTargets;\n\n\t\t\tif (node.visible !== undefined) object.visible = node.visible;\n\t\t\tif (node.userData !== undefined) object.userData = node.userData;\n\n\t\t\tobject.vertex = this.getNode(node.vertex);\n\t\t\tobject.fragment = this.getNode(node.fragment);\n\n\t\t\tif (object.vertex === object.fragment) {\n\n\t\t\t\t// replace main node\n\n\t\t\t\tobject.node = object.vertex;\n\t\t\t}\n\n\t\t\tobject.build();\n\n\t\t\tif (node.fog !== undefined) object.fog = node.fog;\n\t\t\tif (node.lights !== undefined) object.lights = node.lights;\n\n\t\t\tif (node.transparent !== undefined) object.transparent = node.transparent;\n\t\t}\n\n\t\tfor (uuid in json.passes) {\n\n\t\t\tnode = json.passes[uuid];\n\t\t\tobject = this.passes[uuid];\n\n\t\t\tobject.value = this.getNode(node.value);\n\n\t\t\tobject.build();\n\t\t}\n\n\t\treturn this.material || this.pass || this;\n\t}\n\n});\n\nexports.default = NodeMaterialLoader;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Volume = __webpack_require__(10);\n\nvar _Volume2 = _interopRequireDefault(_Volume);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar NRRDLoader = function NRRDLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nNRRDLoader.prototype = {\n\n\tconstructor: NRRDLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (data) {\n\n\t\t\tonLoad(scope.parse(data));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\t// this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n\n\t\tvar _data = data;\n\n\t\tvar _dataPointer = 0;\n\n\t\tvar _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n\n\t\tvar _littleEndian = true;\n\n\t\tvar headerObject = {};\n\n\t\tfunction scan(type, chunks) {\n\n\t\t\tif (chunks === undefined || chunks === null) {\n\n\t\t\t\tchunks = 1;\n\t\t\t}\n\n\t\t\tvar _chunkSize = 1;\n\t\t\tvar _array_type = Uint8Array;\n\n\t\t\tswitch (type) {\n\n\t\t\t\t// 1 byte data types\n\t\t\t\tcase 'uchar':\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'schar':\n\t\t\t\t\t_array_type = Int8Array;\n\t\t\t\t\tbreak;\n\t\t\t\t// 2 byte data types\n\t\t\t\tcase 'ushort':\n\t\t\t\t\t_array_type = Uint16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sshort':\n\t\t\t\t\t_array_type = Int16Array;\n\t\t\t\t\t_chunkSize = 2;\n\t\t\t\t\tbreak;\n\t\t\t\t// 4 byte data types\n\t\t\t\tcase 'uint':\n\t\t\t\t\t_array_type = Uint32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sint':\n\t\t\t\t\t_array_type = Int32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\t\t_array_type = Float32Array;\n\t\t\t\t\t_chunkSize = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'complex':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'double':\n\t\t\t\t\t_array_type = Float64Array;\n\t\t\t\t\t_chunkSize = 8;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// increase the data pointer in-place\n\t\t\tvar _bytes = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize));\n\n\t\t\t// if required, flip the endianness of the bytes\n\t\t\tif (_nativeLittleEndian != _littleEndian) {\n\n\t\t\t\t// we need to flip here since the format doesn't match the native endianness\n\t\t\t\t_bytes = flipEndianness(_bytes, _chunkSize);\n\t\t\t}\n\n\t\t\tif (chunks == 1) {\n\n\t\t\t\t// if only one chunk was requested, just return one value\n\t\t\t\treturn _bytes[0];\n\t\t\t}\n\n\t\t\t// return the byte array\n\t\t\treturn _bytes;\n\t\t}\n\n\t\t//Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n\t\tfunction flipEndianness(array, chunkSize) {\n\n\t\t\tvar u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n\t\t\tfor (var i = 0; i < array.byteLength; i += chunkSize) {\n\n\t\t\t\tfor (var j = i + chunkSize - 1, k = i; j > k; j--, k++) {\n\n\t\t\t\t\tvar tmp = u8[k];\n\t\t\t\t\tu8[k] = u8[j];\n\t\t\t\t\tu8[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\t//parse the header\n\t\tfunction parseHeader(header) {\n\n\t\t\tvar data, field, fn, i, l, lines, m, _i, _len;\n\t\t\tlines = header.split(/\\r?\\n/);\n\t\t\tfor (_i = 0, _len = lines.length; _i < _len; _i++) {\n\n\t\t\t\tl = lines[_i];\n\t\t\t\tif (l.match(/NRRD\\d+/)) {\n\n\t\t\t\t\theaderObject.isNrrd = true;\n\t\t\t\t} else if (l.match(/^#/)) {} else if (m = l.match(/(.*):(.*)/)) {\n\n\t\t\t\t\tfield = m[1].trim();\n\t\t\t\t\tdata = m[2].trim();\n\t\t\t\t\tfn = THREE.NRRDLoader.prototype.fieldFunctions[field];\n\t\t\t\t\tif (fn) {\n\n\t\t\t\t\t\tfn.call(headerObject, data);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\theaderObject[field] = data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!headerObject.isNrrd) {\n\n\t\t\t\tthrow new Error('Not an NRRD file');\n\t\t\t}\n\t\t\tif (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n\n\t\t\t\tthrow new Error('Bzip is not supported');\n\t\t\t}\n\t\t\tif (!headerObject.vectors) {\n\n\t\t\t\t//if no space direction is set, let's use the identity\n\t\t\t\theaderObject.vectors = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1)];\n\t\t\t\t//apply spacing if defined\n\t\t\t\tif (headerObject.spacings) {\n\n\t\t\t\t\tfor (i = 0; i <= 2; i++) {\n\n\t\t\t\t\t\tif (!isNaN(headerObject.spacings[i])) {\n\n\t\t\t\t\t\t\theaderObject.vectors[i].multiplyScalar(headerObject.spacings[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n\t\tfunction parseDataAsText(data, start, end) {\n\n\t\t\tvar number = '';\n\t\t\tstart = start || 0;\n\t\t\tend = end || data.length;\n\t\t\tvar value;\n\t\t\t//length of the result is the product of the sizes\n\t\t\tvar lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n\n\t\t\t\treturn previous * current;\n\t\t\t}, 1);\n\n\t\t\tvar base = 10;\n\t\t\tif (headerObject.encoding === 'hex') {\n\n\t\t\t\tbase = 16;\n\t\t\t}\n\n\t\t\tvar result = new headerObject.__array(lengthOfTheResult);\n\t\t\tvar resultIndex = 0;\n\t\t\tvar parsingFunction = parseInt;\n\t\t\tif (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n\n\t\t\t\tparsingFunction = parseFloat;\n\t\t\t}\n\t\t\tfor (var i = start; i < end; i++) {\n\n\t\t\t\tvalue = data[i];\n\t\t\t\t//if value is not a space\n\t\t\t\tif ((value < 9 || value > 13) && value !== 32) {\n\n\t\t\t\t\tnumber += String.fromCharCode(value);\n\t\t\t\t} else {\n\n\t\t\t\t\tif (number !== '') {\n\n\t\t\t\t\t\tresult[resultIndex] = parsingFunction(number, base);\n\t\t\t\t\t\tresultIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tnumber = '';\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (number !== '') {\n\n\t\t\t\tresult[resultIndex] = parsingFunction(number, base);\n\t\t\t\tresultIndex++;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tvar _bytes = scan('uchar', data.byteLength);\n\t\tvar _length = _bytes.length;\n\t\tvar _header = null;\n\t\tvar _data_start = 0;\n\t\tvar i;\n\t\tfor (i = 1; i < _length; i++) {\n\n\t\t\tif (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n\n\t\t\t\t// we found two line breaks in a row\n\t\t\t\t// now we know what the header is\n\t\t\t\t_header = this.parseChars(_bytes, 0, i - 2);\n\t\t\t\t// this is were the data starts\n\t\t\t\t_data_start = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// parse the header\n\t\tparseHeader(_header);\n\n\t\tvar _data = _bytes.subarray(_data_start); // the data without header\n\t\tif (headerObject.encoding === 'gzip' || headerObject.encoding === 'gz') {\n\n\t\t\t// we need to decompress the datastream\n\t\t\t// here we start the unzipping and get a typed Uint8Array back\n\t\t\tvar inflate = new Zlib.Gunzip(new Uint8Array(_data)); // eslint-disable-line no-undef\n\t\t\t_data = inflate.decompress();\n\t\t} else if (headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex') {\n\n\t\t\t_data = parseDataAsText(_data);\n\t\t} else if (headerObject.encoding === 'raw') {\n\n\t\t\t//we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n\t\t\tvar _copy = new Uint8Array(_data.length);\n\n\t\t\tfor (var i = 0; i < _data.length; i++) {\n\n\t\t\t\t_copy[i] = _data[i];\n\t\t\t}\n\n\t\t\t_data = _copy;\n\t\t}\n\t\t// .. let's use the underlying array buffer\n\t\t_data = _data.buffer;\n\n\t\tvar volume = new _Volume2.default();\n\t\tvolume.header = headerObject;\n\t\t//\n\t\t// parse the (unzipped) data to a datastream of the correct type\n\t\t//\n\t\tvolume.data = new headerObject.__array(_data);\n\t\t// get the min and max intensities\n\t\tvar min_max = volume.computeMinMax();\n\t\tvar min = min_max[0];\n\t\tvar max = min_max[1];\n\t\t// attach the scalar range to the volume\n\t\tvolume.windowLow = min;\n\t\tvolume.windowHigh = max;\n\n\t\t// get the image dimensions\n\t\tvolume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n\t\tvolume.xLength = volume.dimensions[0];\n\t\tvolume.yLength = volume.dimensions[1];\n\t\tvolume.zLength = volume.dimensions[2];\n\t\t// spacing\n\t\tvar spacingX = new THREE.Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n\t\tvar spacingY = new THREE.Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n\t\tvar spacingZ = new THREE.Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n\t\tvolume.spacing = [spacingX, spacingY, spacingZ];\n\n\t\t// Create IJKtoRAS matrix\n\t\tvolume.matrix = new THREE.Matrix4();\n\n\t\tvar _spaceX = 1;\n\t\tvar _spaceY = 1;\n\t\tvar _spaceZ = 1;\n\n\t\tif (headerObject.space == \"left-posterior-superior\") {\n\n\t\t\t_spaceX = -1;\n\t\t\t_spaceY = -1;\n\t\t} else if (headerObject.space === 'left-anterior-superior') {\n\n\t\t\t_spaceX = -1;\n\t\t}\n\n\t\tif (!headerObject.vectors) {\n\n\t\t\tvolume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n\t\t} else {\n\n\t\t\tvar v = headerObject.vectors;\n\n\t\t\tvolume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n\t\t}\n\n\t\tvolume.inverseMatrix = new THREE.Matrix4();\n\t\tvolume.inverseMatrix.getInverse(volume.matrix);\n\t\tvolume.RASDimensions = new THREE.Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs);\n\n\t\t// .. and set the default threshold\n\t\t// only if the threshold was not already set\n\t\tif (volume.lowerThreshold === -Infinity) {\n\n\t\t\tvolume.lowerThreshold = min;\n\t\t}\n\t\tif (volume.upperThreshold === Infinity) {\n\n\t\t\tvolume.upperThreshold = max;\n\t\t}\n\n\t\treturn volume;\n\t},\n\n\tparseChars: function parseChars(array, start, end) {\n\n\t\t// without borders, use the whole array\n\t\tif (start === undefined) {\n\n\t\t\tstart = 0;\n\t\t}\n\t\tif (end === undefined) {\n\n\t\t\tend = array.length;\n\t\t}\n\n\t\tvar output = '';\n\t\t// create and append the chars\n\t\tvar i = 0;\n\t\tfor (i = start; i < end; ++i) {\n\n\t\t\toutput += String.fromCharCode(array[i]);\n\t\t}\n\n\t\treturn output;\n\t},\n\n\tfieldFunctions: {\n\n\t\ttype: function type(data) {\n\n\t\t\tswitch (data) {\n\n\t\t\t\tcase 'uchar':\n\t\t\t\tcase 'unsigned char':\n\t\t\t\tcase 'uint8':\n\t\t\t\tcase 'uint8_t':\n\t\t\t\t\tthis.__array = Uint8Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'signed char':\n\t\t\t\tcase 'int8':\n\t\t\t\tcase 'int8_t':\n\t\t\t\t\tthis.__array = Int8Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'short':\n\t\t\t\tcase 'short int':\n\t\t\t\tcase 'signed short':\n\t\t\t\tcase 'signed short int':\n\t\t\t\tcase 'int16':\n\t\t\t\tcase 'int16_t':\n\t\t\t\t\tthis.__array = Int16Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'ushort':\n\t\t\t\tcase 'unsigned short':\n\t\t\t\tcase 'unsigned short int':\n\t\t\t\tcase 'uint16':\n\t\t\t\tcase 'uint16_t':\n\t\t\t\t\tthis.__array = Uint16Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'int':\n\t\t\t\tcase 'signed int':\n\t\t\t\tcase 'int32':\n\t\t\t\tcase 'int32_t':\n\t\t\t\t\tthis.__array = Int32Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'uint':\n\t\t\t\tcase 'unsigned int':\n\t\t\t\tcase 'uint32':\n\t\t\t\tcase 'uint32_t':\n\t\t\t\t\tthis.__array = Uint32Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'float':\n\t\t\t\t\tthis.__array = Float32Array;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'double':\n\t\t\t\t\tthis.__array = Float64Array;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Unsupported NRRD data type: ' + data);\n\n\t\t\t}\n\n\t\t\treturn this.type = data;\n\t\t},\n\n\t\tendian: function endian(data) {\n\n\t\t\treturn this.endian = data;\n\t\t},\n\n\t\tencoding: function encoding(data) {\n\n\t\t\treturn this.encoding = data;\n\t\t},\n\n\t\tdimension: function dimension(data) {\n\n\t\t\treturn this.dim = parseInt(data, 10);\n\t\t},\n\n\t\tsizes: function sizes(data) {\n\n\t\t\tvar i;\n\t\t\treturn this.sizes = function () {\n\n\t\t\t\tvar _i, _len, _ref, _results;\n\t\t\t\t_ref = data.split(/\\s+/);\n\t\t\t\t_results = [];\n\t\t\t\tfor (_i = 0, _len = _ref.length; _i < _len; _i++) {\n\n\t\t\t\t\ti = _ref[_i];\n\t\t\t\t\t_results.push(parseInt(i, 10));\n\t\t\t\t}\n\t\t\t\treturn _results;\n\t\t\t}();\n\t\t},\n\n\t\tspace: function space(data) {\n\n\t\t\treturn this.space = data;\n\t\t},\n\n\t\t'space origin': function spaceOrigin(data) {\n\n\t\t\treturn this.space_origin = data.split(\"(\")[1].split(\")\")[0].split(\",\");\n\t\t},\n\n\t\t'space directions': function spaceDirections(data) {\n\n\t\t\tvar f, parts, v;\n\t\t\tparts = data.match(/\\(.*?\\)/g);\n\t\t\treturn this.vectors = function () {\n\n\t\t\t\tvar _i, _len, _results;\n\t\t\t\t_results = [];\n\t\t\t\tfor (_i = 0, _len = parts.length; _i < _len; _i++) {\n\n\t\t\t\t\tv = parts[_i];\n\t\t\t\t\t_results.push(function () {\n\n\t\t\t\t\t\tvar _j, _len2, _ref, _results2;\n\t\t\t\t\t\t_ref = v.slice(1, -1).split(/,/);\n\t\t\t\t\t\t_results2 = [];\n\t\t\t\t\t\tfor (_j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n\n\t\t\t\t\t\t\tf = _ref[_j];\n\t\t\t\t\t\t\t_results2.push(parseFloat(f));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn _results2;\n\t\t\t\t\t}());\n\t\t\t\t}\n\t\t\t\treturn _results;\n\t\t\t}();\n\t\t},\n\n\t\tspacings: function spacings(data) {\n\n\t\t\tvar f, parts;\n\t\t\tparts = data.split(/\\s+/);\n\t\t\treturn this.spacings = function () {\n\n\t\t\t\tvar _i,\n\t\t\t\t    _len,\n\t\t\t\t    _results = [];\n\n\t\t\t\tfor (_i = 0, _len = parts.length; _i < _len; _i++) {\n\n\t\t\t\t\tf = parts[_i];\n\t\t\t\t\t_results.push(parseFloat(f));\n\t\t\t\t}\n\t\t\t\treturn _results;\n\t\t\t}();\n\t\t}\n\t}\n\n};\n\nexports.default = NRRDLoader;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar OBJLoader = function () {\n\n\t// o object_name | g group_name\n\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t// mtllib file_reference\n\tvar material_library_pattern = /^mtllib /;\n\t// usemtl material_name\n\tvar material_use_pattern = /^usemtl /;\n\n\tfunction ParserState() {\n\n\t\tvar state = {\n\t\t\tobjects: [],\n\t\t\tobject: {},\n\n\t\t\tvertices: [],\n\t\t\tnormals: [],\n\t\t\tcolors: [],\n\t\t\tuvs: [],\n\n\t\t\tmaterialLibraries: [],\n\n\t\t\tstartObject: function startObject(name, fromDeclaration) {\n\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\tif (this.object && this.object.fromDeclaration === false) {\n\n\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\tthis.object.fromDeclaration = fromDeclaration !== false;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t}\n\n\t\t\t\tthis.object = {\n\t\t\t\t\tname: name || '',\n\t\t\t\t\tfromDeclaration: fromDeclaration !== false,\n\n\t\t\t\t\tgeometry: {\n\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\tuvs: []\n\t\t\t\t\t},\n\t\t\t\t\tmaterials: [],\n\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\tstartMaterial: function startMaterial(name, libraries) {\n\n\t\t\t\t\t\tvar previous = this._finalize(false);\n\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\tif (previous && (previous.inherited || previous.groupCount <= 0)) {\n\n\t\t\t\t\t\t\tthis.materials.splice(previous.index, 1);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\tmtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n\t\t\t\t\t\t\tsmooth: previous !== undefined ? previous.smooth : this.smooth,\n\t\t\t\t\t\t\tgroupStart: previous !== undefined ? previous.groupEnd : 0,\n\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\tclone: function clone(index) {\n\n\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\tindex: typeof index === 'number' ? index : this.index,\n\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\n\t\t\t\t\t\t\t\treturn cloned;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.materials.push(material);\n\n\t\t\t\t\t\treturn material;\n\t\t\t\t\t},\n\n\t\t\t\t\tcurrentMaterial: function currentMaterial() {\n\n\t\t\t\t\t\tif (this.materials.length > 0) {\n\n\t\t\t\t\t\t\treturn this.materials[this.materials.length - 1];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t},\n\n\t\t\t\t\t_finalize: function _finalize(end) {\n\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\tif (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\tif (end && this.materials.length > 1) {\n\n\t\t\t\t\t\t\tfor (var mi = this.materials.length - 1; mi >= 0; mi--) {\n\n\t\t\t\t\t\t\t\tif (this.materials[mi].groupCount <= 0) {\n\n\t\t\t\t\t\t\t\t\tthis.materials.splice(mi, 1);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\tif (end && this.materials.length === 0) {\n\n\t\t\t\t\t\t\tthis.materials.push({\n\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastMultiMaterial;\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Inherit previous objects material.\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\tif (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n\n\t\t\t\t\tvar declared = previousMaterial.clone(0);\n\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\tthis.object.materials.push(declared);\n\t\t\t\t}\n\n\t\t\t\tthis.objects.push(this.object);\n\t\t\t},\n\n\t\t\tfinalize: function finalize() {\n\n\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tparseVertexIndex: function parseVertexIndex(value, len) {\n\n\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t},\n\n\t\t\tparseNormalIndex: function parseNormalIndex(value, len) {\n\n\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t},\n\n\t\t\tparseUVIndex: function parseUVIndex(value, len) {\n\n\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 2) * 2;\n\t\t\t},\n\n\t\t\taddVertex: function addVertex(a, b, c) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t},\n\n\t\t\taddVertexPoint: function addVertexPoint(a) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t},\n\n\t\t\taddVertexLine: function addVertexLine(a) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t},\n\n\t\t\taddNormal: function addNormal(a, b, c) {\n\n\t\t\t\tvar src = this.normals;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t},\n\n\t\t\taddColor: function addColor(a, b, c) {\n\n\t\t\t\tvar src = this.colors;\n\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t},\n\n\t\t\taddUV: function addUV(a, b, c) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t\tdst.push(src[b + 0], src[b + 1]);\n\t\t\t\tdst.push(src[c + 0], src[c + 1]);\n\t\t\t},\n\n\t\t\taddUVLine: function addUVLine(a) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t},\n\n\t\t\taddFace: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tvar ia = this.parseVertexIndex(a, vLen);\n\t\t\t\tvar ib = this.parseVertexIndex(b, vLen);\n\t\t\t\tvar ic = this.parseVertexIndex(c, vLen);\n\n\t\t\t\tthis.addVertex(ia, ib, ic);\n\n\t\t\t\tif (ua !== undefined && ua !== '') {\n\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\t\t\t\t\tia = this.parseUVIndex(ua, uvLen);\n\t\t\t\t\tib = this.parseUVIndex(ub, uvLen);\n\t\t\t\t\tic = this.parseUVIndex(uc, uvLen);\n\t\t\t\t\tthis.addUV(ia, ib, ic);\n\t\t\t\t}\n\n\t\t\t\tif (na !== undefined && na !== '') {\n\n\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\tia = this.parseNormalIndex(na, nLen);\n\n\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n\t\t\t\t\tthis.addNormal(ia, ib, ic);\n\t\t\t\t}\n\n\t\t\t\tif (this.colors.length > 0) {\n\n\t\t\t\t\tthis.addColor(ia, ib, ic);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddPointGeometry: function addPointGeometry(vertices) {\n\n\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\tthis.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddLineGeometry: function addLineGeometry(vertices, uvs) {\n\n\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\tthis.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t}\n\n\t\t\t\tfor (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n\n\t\t\t\t\tthis.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\tstate.startObject('', false);\n\n\t\treturn state;\n\t}\n\n\t//\n\n\tfunction OBJLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\t\tthis.materials = null;\n\t}\n\n\tOBJLoader.prototype = {\n\n\t\tconstructor: OBJLoader,\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\t\tloader.setPath(this.path);\n\t\t\tloader.load(url, function (text) {\n\n\t\t\t\tonLoad(scope.parse(text));\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tsetPath: function setPath(value) {\n\n\t\t\tthis.path = value;\n\n\t\t\treturn this;\n\t\t},\n\n\t\tsetMaterials: function setMaterials(materials) {\n\n\t\t\tthis.materials = materials;\n\n\t\t\treturn this;\n\t\t},\n\n\t\tparse: function parse(text) {\n\n\t\t\tconsole.time('OBJLoader');\n\n\t\t\tvar state = new ParserState();\n\n\t\t\tif (text.indexOf('\\r\\n') !== -1) {\n\n\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\ttext = text.replace(/\\r\\n/g, '\\n');\n\t\t\t}\n\n\t\t\tif (text.indexOf('\\\\\\n') !== -1) {\n\n\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\ttext = text.replace(/\\\\\\n/g, '');\n\t\t\t}\n\n\t\t\tvar lines = text.split('\\n');\n\t\t\tvar line = '',\n\t\t\t    lineFirstChar = '';\n\t\t\tvar lineLength = 0;\n\t\t\tvar result = [];\n\n\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\tvar trimLeft = typeof ''.trimLeft === 'function';\n\n\t\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\t\tline = lines[i];\n\n\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\tlineLength = line.length;\n\n\t\t\t\tif (lineLength === 0) continue;\n\n\t\t\t\tlineFirstChar = line.charAt(0);\n\n\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\tif (lineFirstChar === '#') continue;\n\n\t\t\t\tif (lineFirstChar === 'v') {\n\n\t\t\t\t\tvar data = line.split(/\\s+/);\n\n\t\t\t\t\tswitch (data[0]) {\n\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\tstate.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\tif (data.length === 8) {\n\n\t\t\t\t\t\t\t\tstate.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\tstate.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\tstate.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t} else if (lineFirstChar === 'f') {\n\n\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\tvar vertexData = lineData.split(/\\s+/);\n\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\tfor (var j = 0, jl = vertexData.length; j < jl; j++) {\n\n\t\t\t\t\t\tvar vertex = vertexData[j];\n\n\t\t\t\t\t\tif (vertex.length > 0) {\n\n\t\t\t\t\t\t\tvar vertexParts = vertex.split('/');\n\t\t\t\t\t\t\tfaceVertices.push(vertexParts);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\tvar v1 = faceVertices[0];\n\n\t\t\t\t\tfor (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n\n\t\t\t\t\t\tvar v2 = faceVertices[j];\n\t\t\t\t\t\tvar v3 = faceVertices[j + 1];\n\n\t\t\t\t\t\tstate.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n\t\t\t\t\t}\n\t\t\t\t} else if (lineFirstChar === 'l') {\n\n\t\t\t\t\tvar lineParts = line.substring(1).trim().split(\" \");\n\t\t\t\t\tvar lineVertices = [],\n\t\t\t\t\t    lineUVs = [];\n\n\t\t\t\t\tif (line.indexOf(\"/\") === -1) {\n\n\t\t\t\t\t\tlineVertices = lineParts;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor (var li = 0, llen = lineParts.length; li < llen; li++) {\n\n\t\t\t\t\t\t\tvar parts = lineParts[li].split(\"/\");\n\n\t\t\t\t\t\t\tif (parts[0] !== \"\") lineVertices.push(parts[0]);\n\t\t\t\t\t\t\tif (parts[1] !== \"\") lineUVs.push(parts[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tstate.addLineGeometry(lineVertices, lineUVs);\n\t\t\t\t} else if (lineFirstChar === 'p') {\n\n\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\tvar pointData = lineData.split(\" \");\n\n\t\t\t\t\tstate.addPointGeometry(pointData);\n\t\t\t\t} else if ((result = object_pattern.exec(line)) !== null) {\n\n\t\t\t\t\t// o object_name\n\t\t\t\t\t// or\n\t\t\t\t\t// g group_name\n\n\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\tvar name = (\" \" + result[0].substr(1).trim()).substr(1);\n\n\t\t\t\t\tstate.startObject(name);\n\t\t\t\t} else if (material_use_pattern.test(line)) {\n\n\t\t\t\t\t// material\n\n\t\t\t\t\tstate.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n\t\t\t\t} else if (material_library_pattern.test(line)) {\n\n\t\t\t\t\t// mtl file\n\n\t\t\t\t\tstate.materialLibraries.push(line.substring(7).trim());\n\t\t\t\t} else if (lineFirstChar === 's') {\n\n\t\t\t\t\tresult = line.split(' ');\n\n\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t/*\n      * http://paulbourke.net/dataformats/obj/\n      * or\n      * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\n      *\n      * From chapter \"Grouping\" Syntax explanation \"s group_number\":\n      * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\n      * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\n      * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\n      * than 0.\"\n      */\n\t\t\t\t\tif (result.length > 1) {\n\n\t\t\t\t\t\tvar value = result[1].trim().toLowerCase();\n\t\t\t\t\t\tstate.object.smooth = value !== '0' && value !== 'off';\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\tstate.object.smooth = true;\n\t\t\t\t\t}\n\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\tif (material) material.smooth = state.object.smooth;\n\t\t\t\t} else {\n\n\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\tif (line === '\\0') continue;\n\n\t\t\t\t\tthrow new Error('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstate.finalize();\n\n\t\t\tvar container = new THREE.Group();\n\t\t\tcontainer.materialLibraries = [].concat(state.materialLibraries);\n\n\t\t\tfor (var i = 0, l = state.objects.length; i < l; i++) {\n\n\t\t\t\tvar object = state.objects[i];\n\t\t\t\tvar geometry = object.geometry;\n\t\t\t\tvar materials = object.materials;\n\t\t\t\tvar isLine = geometry.type === 'Line';\n\t\t\t\tvar isPoints = geometry.type === 'Points';\n\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\tif (geometry.vertices.length === 0) continue;\n\n\t\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\t\tbuffergeometry.addAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));\n\n\t\t\t\tif (geometry.normals.length > 0) {\n\n\t\t\t\t\tbuffergeometry.addAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\n\t\t\t\t} else {\n\n\t\t\t\t\tbuffergeometry.computeVertexNormals();\n\t\t\t\t}\n\n\t\t\t\tif (geometry.colors.length > 0) {\n\n\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\tbuffergeometry.addAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));\n\t\t\t\t}\n\n\t\t\t\tif (geometry.uvs.length > 0) {\n\n\t\t\t\t\tbuffergeometry.addAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));\n\t\t\t\t}\n\n\t\t\t\t// Create materials\n\n\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\tvar material = undefined;\n\n\t\t\t\t\tif (this.materials !== null) {\n\n\t\t\t\t\t\tmaterial = this.materials.create(sourceMaterial.name);\n\n\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\tif (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n\n\t\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\tmaterialLine.copy(material);\n\t\t\t\t\t\t\tmaterialLine.lights = false; // TOFIX\n\t\t\t\t\t\t\tmaterial = materialLine;\n\t\t\t\t\t\t} else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {\n\n\t\t\t\t\t\t\tvar materialPoints = new THREE.PointsMaterial({ size: 10, sizeAttenuation: false });\n\t\t\t\t\t\t\tmaterialLine.copy(material);\n\t\t\t\t\t\t\tmaterial = materialPoints;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!material) {\n\n\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial({ size: 1, sizeAttenuation: false });\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\tmaterial.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;\n\n\t\t\t\t\tcreatedMaterials.push(material);\n\t\t\t\t}\n\n\t\t\t\t// Create mesh\n\n\t\t\t\tvar mesh;\n\n\t\t\t\tif (createdMaterials.length > 1) {\n\n\t\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\t\tbuffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials);\n\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmesh.name = object.name;\n\n\t\t\t\tcontainer.add(mesh);\n\t\t\t}\n\n\t\t\tconsole.timeEnd('OBJLoader');\n\n\t\t\treturn container;\n\t\t}\n\n\t};\n\n\treturn OBJLoader;\n}();\n\nexports.default = OBJLoader;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _LoaderSupport = __webpack_require__(7);\n\nvar _LoaderSupport2 = _interopRequireDefault(_LoaderSupport);\n\nvar _MTLLoader = __webpack_require__(9);\n\nvar _MTLLoader2 = _interopRequireDefault(_MTLLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n  * @author Kai Salmen / https://kaisalmen.de\n  * Development repository: https://github.com/kaisalmen/WWOBJLoader\n  */\n\n'use strict';\n\n// if ( THREE.OBJLoader2 === undefined ) { THREE.OBJLoader2 = {} }\n\n// if ( THREE.LoaderSupport === undefined ) console.error( '\"THREE.LoaderSupport\" is not available. \"THREE.OBJLoader2\" requires it. Please include \"LoaderSupport.js\" in your HTML.' );\n\n/**\n * Use this class to load OBJ data from files or to parse OBJ data from an arraybuffer\n * @class\n *\n * @param {THREE.DefaultLoadingManager} [manager] The loadingManager for the loader to use. Default is {@link THREE.DefaultLoadingManager}\n */\nvar OBJLoader2 = function () {\n\n\tvar OBJLOADER2_VERSION = '2.4.0';\n\tvar Validator = _LoaderSupport2.default.Validator;\n\n\tfunction OBJLoader2(manager) {\n\t\tconsole.info('Using THREE.OBJLoader2 version: ' + OBJLOADER2_VERSION);\n\n\t\tthis.manager = Validator.verifyInput(manager, THREE.DefaultLoadingManager);\n\t\tthis.logging = {\n\t\t\tenabled: true,\n\t\t\tdebug: false\n\t\t};\n\n\t\tthis.modelName = '';\n\t\tthis.instanceNo = 0;\n\t\tthis.path = '';\n\t\tthis.useIndices = false;\n\t\tthis.disregardNormals = false;\n\t\tthis.materialPerSmoothingGroup = false;\n\t\tthis.loaderRootNode = new THREE.Group();\n\n\t\tthis.meshBuilder = new _LoaderSupport2.default.MeshBuilder();\n\t\tthis.callbacks = new _LoaderSupport2.default.Callbacks();\n\t\tthis.workerSupport = new _LoaderSupport2.default.WorkerSupport();\n\t\tthis.terminateWorkerOnLoad = true;\n\t}\n\n\t/**\n  * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} enabled True or false.\n  * @param {boolean} debug True or false.\n  */\n\tOBJLoader2.prototype.setLogging = function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\tthis.meshBuilder.setLogging(this.logging.enabled, this.logging.debug);\n\t};\n\n\t/**\n  * Set the name of the model.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string} modelName\n  */\n\tOBJLoader2.prototype.setModelName = function (modelName) {\n\t\tthis.modelName = Validator.verifyInput(modelName, this.modelName);\n\t};\n\n\t/**\n  * The URL of the base path.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string} path URL\n  */\n\tOBJLoader2.prototype.setPath = function (path) {\n\t\tthis.path = Validator.verifyInput(path, this.path);\n\t};\n\n\t/**\n  * Set the node where the loaded objects will be attached directly.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {THREE.Object3D} streamMeshesTo Object already attached to scenegraph where new meshes will be attached to\n  */\n\tOBJLoader2.prototype.setStreamMeshesTo = function (streamMeshesTo) {\n\t\tthis.loaderRootNode = Validator.verifyInput(streamMeshesTo, this.loaderRootNode);\n\t};\n\n\t/**\n  * Set materials loaded by MTLLoader or any other supplier of an Array of {@link THREE.Material}.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {THREE.Material[]} materials Array of {@link THREE.Material}\n  */\n\tOBJLoader2.prototype.setMaterials = function (materials) {\n\t\tthis.meshBuilder.setMaterials(materials);\n\t};\n\n\t/**\n  * Instructs loaders to create indexed {@link THREE.BufferGeometry}.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} useIndices=false\n  */\n\tOBJLoader2.prototype.setUseIndices = function (useIndices) {\n\t\tthis.useIndices = useIndices === true;\n\t};\n\n\t/**\n  * Tells whether normals should be completely disregarded and regenerated.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} disregardNormals=false\n  */\n\tOBJLoader2.prototype.setDisregardNormals = function (disregardNormals) {\n\t\tthis.disregardNormals = disregardNormals === true;\n\t};\n\n\t/**\n  * Tells whether a material shall be created per smoothing group.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {boolean} materialPerSmoothingGroup=false\n  */\n\tOBJLoader2.prototype.setMaterialPerSmoothingGroup = function (materialPerSmoothingGroup) {\n\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n\t};\n\n\tOBJLoader2.prototype._setCallbacks = function (callbacks) {\n\t\tif (Validator.isValid(callbacks.onProgress)) this.callbacks.setCallbackOnProgress(callbacks.onProgress);\n\t\tif (Validator.isValid(callbacks.onMeshAlter)) this.callbacks.setCallbackOnMeshAlter(callbacks.onMeshAlter);\n\t\tif (Validator.isValid(callbacks.onLoad)) this.callbacks.setCallbackOnLoad(callbacks.onLoad);\n\t\tif (Validator.isValid(callbacks.onLoadMaterials)) this.callbacks.setCallbackOnLoadMaterials(callbacks.onLoadMaterials);\n\n\t\tthis.meshBuilder._setCallbacks(this.callbacks);\n\t};\n\n\t/**\n  * Announce feedback which is give to the registered callbacks.\n  * @memberOf THREE.OBJLoader2\n  * @private\n  *\n  * @param {string} type The type of event\n  * @param {string} text Textual description of the event\n  * @param {number} numericalValue Numerical value describing the progress\n  */\n\tOBJLoader2.prototype.onProgress = function (type, text, numericalValue) {\n\t\tvar content = Validator.isValid(text) ? text : '';\n\t\tvar event = {\n\t\t\tdetail: {\n\t\t\t\ttype: type,\n\t\t\t\tmodelName: this.modelName,\n\t\t\t\tinstanceNo: this.instanceNo,\n\t\t\t\ttext: content,\n\t\t\t\tnumericalValue: numericalValue\n\t\t\t}\n\t\t};\n\n\t\tif (Validator.isValid(this.callbacks.onProgress)) this.callbacks.onProgress(event);\n\n\t\tif (this.logging.enabled && this.logging.debug) console.debug(content);\n\t};\n\n\tOBJLoader2.prototype._onError = function (event) {\n\t\tvar output = 'Error occurred while downloading!';\n\n\t\tif (event.currentTarget && event.currentTarget.statusText !== null) {\n\n\t\t\toutput += '\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\n\t\t}\n\t\tthis.onProgress('error', output, -1);\n\t\tthrow output;\n\t};\n\n\t/**\n  * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string}  url A string containing the path/URL of the file to be loaded.\n  * @param {callback} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.\n  * @param {callback} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n  * @param {callback} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n  * @param {callback} [onMeshAlter] A function to be called after a new mesh raw data becomes available for alteration.\n  * @param {boolean} [useAsync] If true, uses async loading with worker, if false loads data synchronously.\n  */\n\tOBJLoader2.prototype.load = function (url, onLoad, onProgress, onError, onMeshAlter, useAsync) {\n\t\tvar resource = new _LoaderSupport2.default.ResourceDescriptor(url, 'OBJ');\n\t\tthis._loadObj(resource, onLoad, onProgress, onError, onMeshAlter, useAsync);\n\t};\n\n\tOBJLoader2.prototype._loadObj = function (resource, onLoad, onProgress, onError, onMeshAlter, useAsync) {\n\t\tif (!Validator.isValid(onError)) onError = this._onError;\n\n\t\t// fast-fail\n\t\tif (!Validator.isValid(resource)) onError('An invalid ResourceDescriptor was provided. Unable to continue!');\n\t\tvar scope = this;\n\t\tvar fileLoaderOnLoad = function fileLoaderOnLoad(content) {\n\n\t\t\tresource.content = content;\n\t\t\tif (useAsync) {\n\n\t\t\t\tscope.parseAsync(content, onLoad);\n\t\t\t} else {\n\n\t\t\t\tvar callbacks = new _LoaderSupport2.default.Callbacks();\n\t\t\t\tcallbacks.setCallbackOnMeshAlter(onMeshAlter);\n\t\t\t\tscope._setCallbacks(callbacks);\n\t\t\t\tonLoad({\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tloaderRootNode: scope.parse(content),\n\t\t\t\t\t\tmodelName: scope.modelName,\n\t\t\t\t\t\tinstanceNo: scope.instanceNo\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// fast-fail\n\t\tif (!Validator.isValid(resource.url) || Validator.isValid(resource.content)) {\n\n\t\t\tfileLoaderOnLoad(Validator.isValid(resource.content) ? resource.content : null);\n\t\t} else {\n\n\t\t\tif (!Validator.isValid(onProgress)) {\n\t\t\t\tvar numericalValueRef = 0;\n\t\t\t\tvar numericalValue = 0;\n\t\t\t\tonProgress = function onProgress(event) {\n\t\t\t\t\tif (!event.lengthComputable) return;\n\n\t\t\t\t\tnumericalValue = event.loaded / event.total;\n\t\t\t\t\tif (numericalValue > numericalValueRef) {\n\n\t\t\t\t\t\tnumericalValueRef = numericalValue;\n\t\t\t\t\t\tvar output = 'Download of \"' + resource.url + '\": ' + (numericalValue * 100).toFixed(2) + '%';\n\t\t\t\t\t\tscope.onProgress('progressLoad', output, numericalValue);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar fileLoader = new THREE.FileLoader(this.manager);\n\t\t\tfileLoader.setPath(this.path);\n\t\t\tfileLoader.setResponseType('arraybuffer');\n\t\t\tfileLoader.load(resource.url, fileLoaderOnLoad, onProgress, onError);\n\t\t}\n\t};\n\n\t/**\n  * Run the loader according the provided instructions.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {LoaderSupport.PrepData} prepData All parameters and resources required for execution\n  * @param {LoaderSupport.WorkerSupport} [workerSupportExternal] Use pre-existing WorkerSupport\n  */\n\tOBJLoader2.prototype.run = function (prepData, workerSupportExternal) {\n\t\tthis._applyPrepData(prepData);\n\t\tvar available = prepData.checkResourceDescriptorFiles(prepData.resources, [{ ext: \"obj\", type: \"ArrayBuffer\", ignore: false }, { ext: \"mtl\", type: \"String\", ignore: false }, { ext: \"zip\", type: \"String\", ignore: true }]);\n\t\tif (Validator.isValid(workerSupportExternal)) {\n\n\t\t\tthis.terminateWorkerOnLoad = false;\n\t\t\tthis.workerSupport = workerSupportExternal;\n\t\t\tthis.logging.enabled = this.workerSupport.logging.enabled;\n\t\t\tthis.logging.debug = this.workerSupport.logging.debug;\n\t\t}\n\t\tvar scope = this;\n\t\tvar onMaterialsLoaded = function onMaterialsLoaded(materials) {\n\t\t\tif (materials !== null) scope.meshBuilder.setMaterials(materials);\n\t\t\tscope._loadObj(available.obj, scope.callbacks.onLoad, null, null, scope.callbacks.onMeshAlter, prepData.useAsync);\n\t\t};\n\t\tthis._loadMtl(available.mtl, onMaterialsLoaded, prepData.crossOrigin, prepData.materialOptions);\n\t};\n\n\tOBJLoader2.prototype._applyPrepData = function (prepData) {\n\t\tif (Validator.isValid(prepData)) {\n\n\t\t\tthis.setLogging(prepData.logging.enabled, prepData.logging.debug);\n\t\t\tthis.setModelName(prepData.modelName);\n\t\t\tthis.setStreamMeshesTo(prepData.streamMeshesTo);\n\t\t\tthis.meshBuilder.setMaterials(prepData.materials);\n\t\t\tthis.setUseIndices(prepData.useIndices);\n\t\t\tthis.setDisregardNormals(prepData.disregardNormals);\n\t\t\tthis.setMaterialPerSmoothingGroup(prepData.materialPerSmoothingGroup);\n\n\t\t\tthis._setCallbacks(prepData.getCallbacks());\n\t\t}\n\t};\n\n\t/**\n  * Parses OBJ data synchronously from arraybuffer or string.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {arraybuffer|string} content OBJ data as Uint8Array or String\n  */\n\tOBJLoader2.prototype.parse = function (content) {\n\t\t// fast-fail in case of illegal data\n\t\tif (!Validator.isValid(content)) {\n\n\t\t\tconsole.warn('Provided content is not a valid ArrayBuffer or String.');\n\t\t\treturn this.loaderRootNode;\n\t\t}\n\t\tif (this.logging.enabled) console.time('OBJLoader2 parse: ' + this.modelName);\n\t\tthis.meshBuilder.init();\n\n\t\tvar parser = new Parser();\n\t\tparser.setLogging(this.logging.enabled, this.logging.debug);\n\t\tparser.setMaterialPerSmoothingGroup(this.materialPerSmoothingGroup);\n\t\tparser.setUseIndices(this.useIndices);\n\t\tparser.setDisregardNormals(this.disregardNormals);\n\t\t// sync code works directly on the material references\n\t\tparser.setMaterials(this.meshBuilder.getMaterials());\n\n\t\tvar scope = this;\n\t\tvar onMeshLoaded = function onMeshLoaded(payload) {\n\t\t\tvar meshes = scope.meshBuilder.processPayload(payload);\n\t\t\tvar mesh;\n\t\t\tfor (var i in meshes) {\n\t\t\t\tmesh = meshes[i];\n\t\t\t\tscope.loaderRootNode.add(mesh);\n\t\t\t}\n\t\t};\n\t\tparser.setCallbackMeshBuilder(onMeshLoaded);\n\t\tvar onProgressScoped = function onProgressScoped(text, numericalValue) {\n\t\t\tscope.onProgress('progressParse', text, numericalValue);\n\t\t};\n\t\tparser.setCallbackProgress(onProgressScoped);\n\n\t\tif (content instanceof ArrayBuffer || content instanceof Uint8Array) {\n\n\t\t\tif (this.logging.enabled) console.info('Parsing arrayBuffer...');\n\t\t\tparser.parse(content);\n\t\t} else if (typeof content === 'string' || content instanceof String) {\n\n\t\t\tif (this.logging.enabled) console.info('Parsing text...');\n\t\t\tparser.parseText(content);\n\t\t} else {\n\n\t\t\tthrow 'Provided content was neither of type String nor Uint8Array! Aborting...';\n\t\t}\n\t\tif (this.logging.enabled) console.timeEnd('OBJLoader2 parse: ' + this.modelName);\n\n\t\treturn this.loaderRootNode;\n\t};\n\n\t/**\n  * Parses OBJ content asynchronously from arraybuffer.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {arraybuffer} content OBJ data as Uint8Array\n  * @param {callback} onLoad Called after worker successfully completed loading\n  */\n\tOBJLoader2.prototype.parseAsync = function (content, onLoad) {\n\t\tvar scope = this;\n\t\tvar measureTime = false;\n\t\tvar scopedOnLoad = function scopedOnLoad() {\n\t\t\tonLoad({\n\t\t\t\tdetail: {\n\t\t\t\t\tloaderRootNode: scope.loaderRootNode,\n\t\t\t\t\tmodelName: scope.modelName,\n\t\t\t\t\tinstanceNo: scope.instanceNo\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (measureTime && scope.logging.enabled) console.timeEnd('OBJLoader2 parseAsync: ' + scope.modelName);\n\t\t};\n\t\t// fast-fail in case of illegal data\n\t\tif (!Validator.isValid(content)) {\n\n\t\t\tconsole.warn('Provided content is not a valid ArrayBuffer.');\n\t\t\tscopedOnLoad();\n\t\t} else {\n\n\t\t\tmeasureTime = true;\n\t\t}\n\t\tif (measureTime && this.logging.enabled) console.time('OBJLoader2 parseAsync: ' + this.modelName);\n\t\tthis.meshBuilder.init();\n\n\t\tvar scopedOnMeshLoaded = function scopedOnMeshLoaded(payload) {\n\t\t\tvar meshes = scope.meshBuilder.processPayload(payload);\n\t\t\tvar mesh;\n\t\t\tfor (var i in meshes) {\n\t\t\t\tmesh = meshes[i];\n\t\t\t\tscope.loaderRootNode.add(mesh);\n\t\t\t}\n\t\t};\n\t\tvar buildCode = function buildCode(funcBuildObject, funcBuildSingleton) {\n\t\t\tvar workerCode = '';\n\t\t\tworkerCode += '/**\\n';\n\t\t\tworkerCode += '  * This code was constructed by OBJLoader2 buildCode.\\n';\n\t\t\tworkerCode += '  */\\n\\n';\n\t\t\tworkerCode += 'THREE = { LoaderSupport: {} };\\n\\n';\n\t\t\tworkerCode += funcBuildObject('LoaderSupport.Validator', Validator);\n\t\t\tworkerCode += funcBuildSingleton('Parser', Parser);\n\n\t\t\treturn workerCode;\n\t\t};\n\t\tthis.workerSupport.validate(buildCode, 'Parser');\n\t\tthis.workerSupport.setCallbacks(scopedOnMeshLoaded, scopedOnLoad);\n\t\tif (scope.terminateWorkerOnLoad) this.workerSupport.setTerminateRequested(true);\n\n\t\tvar materialNames = {};\n\t\tvar materials = this.meshBuilder.getMaterials();\n\t\tfor (var materialName in materials) {\n\n\t\t\tmaterialNames[materialName] = materialName;\n\t\t}\n\t\tthis.workerSupport.run({\n\t\t\tparams: {\n\t\t\t\tuseAsync: true,\n\t\t\t\tmaterialPerSmoothingGroup: this.materialPerSmoothingGroup,\n\t\t\t\tuseIndices: this.useIndices,\n\t\t\t\tdisregardNormals: this.disregardNormals\n\t\t\t},\n\t\t\tlogging: {\n\t\t\t\tenabled: this.logging.enabled,\n\t\t\t\tdebug: this.logging.debug\n\t\t\t},\n\t\t\tmaterials: {\n\t\t\t\t// in async case only material names are supplied to parser\n\t\t\t\tmaterials: materialNames\n\t\t\t},\n\t\t\tdata: {\n\t\t\t\tinput: content,\n\t\t\t\toptions: null\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n  * Parse OBJ data either from ArrayBuffer or string\n  * @class\n  */\n\tvar Parser = function () {\n\n\t\tfunction Parser() {\n\t\t\tthis.callbackProgress = null;\n\t\t\tthis.callbackMeshBuilder = null;\n\t\t\tthis.contentRef = null;\n\t\t\tthis.legacyMode = false;\n\n\t\t\tthis.materials = {};\n\t\t\tthis.useAsync = false;\n\t\t\tthis.materialPerSmoothingGroup = false;\n\t\t\tthis.useIndices = false;\n\t\t\tthis.disregardNormals = false;\n\n\t\t\tthis.vertices = [];\n\t\t\tthis.colors = [];\n\t\t\tthis.normals = [];\n\t\t\tthis.uvs = [];\n\n\t\t\tthis.rawMesh = {\n\t\t\t\tobjectName: '',\n\t\t\t\tgroupName: '',\n\t\t\t\tactiveMtlName: '',\n\t\t\t\tmtllibName: '',\n\n\t\t\t\t// reset with new mesh\n\t\t\t\tfaceType: -1,\n\t\t\t\tsubGroups: [],\n\t\t\t\tsubGroupInUse: null,\n\t\t\t\tsmoothingGroup: {\n\t\t\t\t\tsplitMaterials: false,\n\t\t\t\t\tnormalized: -1,\n\t\t\t\t\treal: -1\n\t\t\t\t},\n\t\t\t\tcounts: {\n\t\t\t\t\tdoubleIndicesCount: 0,\n\t\t\t\t\tfaceCount: 0,\n\t\t\t\t\tmtlCount: 0,\n\t\t\t\t\tsmoothingGroupCount: 0\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tthis.inputObjectCount = 1;\n\t\t\tthis.outputObjectCount = 1;\n\t\t\tthis.globalCounts = {\n\t\t\t\tvertices: 0,\n\t\t\t\tfaces: 0,\n\t\t\t\tdoubleIndicesCount: 0,\n\t\t\t\tlineByte: 0,\n\t\t\t\tcurrentByte: 0,\n\t\t\t\ttotalBytes: 0\n\t\t\t};\n\n\t\t\tthis.logging = {\n\t\t\t\tenabled: true,\n\t\t\t\tdebug: false\n\t\t\t};\n\t\t}\n\n\t\tParser.prototype.resetRawMesh = function () {\n\t\t\t// faces are stored according combined index of group, material and smoothingGroup (0 or not)\n\t\t\tthis.rawMesh.subGroups = [];\n\t\t\tthis.rawMesh.subGroupInUse = null;\n\t\t\tthis.rawMesh.smoothingGroup.normalized = -1;\n\t\t\tthis.rawMesh.smoothingGroup.real = -1;\n\n\t\t\t// this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\t\t\tthis.pushSmoothingGroup(1);\n\n\t\t\tthis.rawMesh.counts.doubleIndicesCount = 0;\n\t\t\tthis.rawMesh.counts.faceCount = 0;\n\t\t\tthis.rawMesh.counts.mtlCount = 0;\n\t\t\tthis.rawMesh.counts.smoothingGroupCount = 0;\n\t\t};\n\n\t\tParser.prototype.setUseAsync = function (useAsync) {\n\t\t\tthis.useAsync = useAsync;\n\t\t};\n\n\t\tParser.prototype.setMaterialPerSmoothingGroup = function (materialPerSmoothingGroup) {\n\t\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup;\n\t\t};\n\n\t\tParser.prototype.setUseIndices = function (useIndices) {\n\t\t\tthis.useIndices = useIndices;\n\t\t};\n\n\t\tParser.prototype.setDisregardNormals = function (disregardNormals) {\n\t\t\tthis.disregardNormals = disregardNormals;\n\t\t};\n\n\t\tParser.prototype.setMaterials = function (materials) {\n\t\t\tthis.materials = _LoaderSupport2.default.Validator.verifyInput(materials, this.materials);\n\t\t\tthis.materials = _LoaderSupport2.default.Validator.verifyInput(this.materials, {});\n\t\t};\n\n\t\tParser.prototype.setCallbackMeshBuilder = function (callbackMeshBuilder) {\n\t\t\tif (!_LoaderSupport2.default.Validator.isValid(callbackMeshBuilder)) throw 'Unable to run as no \"MeshBuilder\" callback is set.';\n\t\t\tthis.callbackMeshBuilder = callbackMeshBuilder;\n\t\t};\n\n\t\tParser.prototype.setCallbackProgress = function (callbackProgress) {\n\t\t\tthis.callbackProgress = callbackProgress;\n\t\t};\n\n\t\tParser.prototype.setLogging = function (enabled, debug) {\n\t\t\tthis.logging.enabled = enabled === true;\n\t\t\tthis.logging.debug = debug === true;\n\t\t};\n\n\t\tParser.prototype.configure = function () {\n\t\t\tthis.pushSmoothingGroup(1);\n\n\t\t\tif (this.logging.enabled) {\n\n\t\t\t\tvar matKeys = Object.keys(this.materials);\n\t\t\t\tvar matNames = matKeys.length > 0 ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join('\\n\\t\\t- ') : '\\n\\tmaterialNames: None';\n\t\t\t\tvar printedConfig = 'OBJLoader2.Parser configuration:' + matNames + '\\n\\tuseAsync: ' + this.useAsync + '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup + '\\n\\tuseIndices: ' + this.useIndices + '\\n\\tdisregardNormals: ' + this.disregardNormals + '\\n\\tcallbackMeshBuilderName: ' + this.callbackMeshBuilder.name + '\\n\\tcallbackProgressName: ' + this.callbackProgress.name;\n\t\t\t\tconsole.info(printedConfig);\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Parse the provided arraybuffer\n   * @memberOf Parser\n   *\n   * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n   */\n\t\tParser.prototype.parse = function (arrayBuffer) {\n\t\t\tif (this.logging.enabled) console.time('OBJLoader2.Parser.parse');\n\t\t\tthis.configure();\n\n\t\t\tvar arrayBufferView = new Uint8Array(arrayBuffer);\n\t\t\tthis.contentRef = arrayBufferView;\n\t\t\tvar length = arrayBufferView.byteLength;\n\t\t\tthis.globalCounts.totalBytes = length;\n\t\t\tvar buffer = new Array(128);\n\n\t\t\tfor (var code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {\n\n\t\t\t\tcode = arrayBufferView[i];\n\t\t\t\tswitch (code) {\n\t\t\t\t\t// space\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// slash\n\t\t\t\t\tcase 47:\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tslashesCount++;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// LF\n\t\t\t\t\tcase 10:\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\t\t\t\t\tthis.globalCounts.currentByte = i;\n\t\t\t\t\t\tthis.processLine(buffer, bufferPointer, slashesCount);\n\t\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t// CR\n\t\t\t\t\tcase 13:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tword += String.fromCharCode(code);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.finalizeParsing();\n\t\t\tif (this.logging.enabled) console.timeEnd('OBJLoader2.Parser.parse');\n\t\t};\n\n\t\t/**\n   * Parse the provided text\n   * @memberOf Parser\n   *\n   * @param {string} text OBJ data as string\n   */\n\t\tParser.prototype.parseText = function (text) {\n\t\t\tif (this.logging.enabled) console.time('OBJLoader2.Parser.parseText');\n\t\t\tthis.configure();\n\t\t\tthis.legacyMode = true;\n\t\t\tthis.contentRef = text;\n\t\t\tvar length = text.length;\n\t\t\tthis.globalCounts.totalBytes = length;\n\t\t\tvar buffer = new Array(128);\n\n\t\t\tfor (var char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++) {\n\n\t\t\t\tchar = text[i];\n\t\t\t\tswitch (char) {\n\t\t\t\t\tcase ' ':\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '/':\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tslashesCount++;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tif (word.length > 0) buffer[bufferPointer++] = word;\n\t\t\t\t\t\tword = '';\n\t\t\t\t\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\t\t\t\t\tthis.globalCounts.currentByte = i;\n\t\t\t\t\t\tthis.processLine(buffer, bufferPointer, slashesCount);\n\t\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase '\\r':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tword += char;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.finalizeParsing();\n\t\t\tif (this.logging.enabled) console.timeEnd('OBJLoader2.Parser.parseText');\n\t\t};\n\n\t\tParser.prototype.processLine = function (buffer, bufferPointer, slashesCount) {\n\t\t\tif (bufferPointer < 1) return;\n\n\t\t\tvar reconstructString = function reconstructString(content, legacyMode, start, stop) {\n\t\t\t\tvar line = '';\n\t\t\t\tif (stop > start) {\n\n\t\t\t\t\tvar i;\n\t\t\t\t\tif (legacyMode) {\n\n\t\t\t\t\t\tfor (i = start; i < stop; i++) {\n\t\t\t\t\t\t\tline += content[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfor (i = start; i < stop; i++) {\n\t\t\t\t\t\t\tline += String.fromCharCode(content[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tline = line.trim();\n\t\t\t\t}\n\t\t\t\treturn line;\n\t\t\t};\n\n\t\t\tvar bufferLength, length, i, lineDesignation;\n\t\t\tlineDesignation = buffer[0];\n\t\t\tswitch (lineDesignation) {\n\t\t\t\tcase 'v':\n\t\t\t\t\tthis.vertices.push(parseFloat(buffer[1]));\n\t\t\t\t\tthis.vertices.push(parseFloat(buffer[2]));\n\t\t\t\t\tthis.vertices.push(parseFloat(buffer[3]));\n\t\t\t\t\tif (bufferPointer > 4) {\n\n\t\t\t\t\t\tthis.colors.push(parseFloat(buffer[4]));\n\t\t\t\t\t\tthis.colors.push(parseFloat(buffer[5]));\n\t\t\t\t\t\tthis.colors.push(parseFloat(buffer[6]));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vt':\n\t\t\t\t\tthis.uvs.push(parseFloat(buffer[1]));\n\t\t\t\t\tthis.uvs.push(parseFloat(buffer[2]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vn':\n\t\t\t\t\tthis.normals.push(parseFloat(buffer[1]));\n\t\t\t\t\tthis.normals.push(parseFloat(buffer[2]));\n\t\t\t\t\tthis.normals.push(parseFloat(buffer[3]));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'f':\n\t\t\t\t\tbufferLength = bufferPointer - 1;\n\n\t\t\t\t\t// \"f vertex ...\"\n\t\t\t\t\tif (slashesCount === 0) {\n\n\t\t\t\t\t\tthis.checkFaceType(0);\n\t\t\t\t\t\tfor (i = 2, length = bufferLength; i < length; i++) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 1]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \"f vertex/uv ...\"\n\t\t\t\t\t} else if (bufferLength === slashesCount * 2) {\n\n\t\t\t\t\t\tthis.checkFaceType(1);\n\t\t\t\t\t\tfor (i = 3, length = bufferLength - 2; i < length; i += 2) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1], buffer[2]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], buffer[i + 1]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 2], buffer[i + 3]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \"f vertex/uv/normal ...\"\n\t\t\t\t\t} else if (bufferLength * 2 === slashesCount * 3) {\n\n\t\t\t\t\t\tthis.checkFaceType(2);\n\t\t\t\t\t\tfor (i = 4, length = bufferLength - 3; i < length; i += 3) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1], buffer[2], buffer[3]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], buffer[i + 1], buffer[i + 2]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 3], buffer[i + 4], buffer[i + 5]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// \"f vertex//normal ...\"\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.checkFaceType(3);\n\t\t\t\t\t\tfor (i = 3, length = bufferLength - 2; i < length; i += 2) {\n\n\t\t\t\t\t\t\tthis.buildFace(buffer[1], undefined, buffer[2]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], undefined, buffer[i + 1]);\n\t\t\t\t\t\t\tthis.buildFace(buffer[i + 2], undefined, buffer[i + 3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\t\t\t\tcase 'p':\n\t\t\t\t\tbufferLength = bufferPointer - 1;\n\t\t\t\t\tif (bufferLength === slashesCount * 2) {\n\n\t\t\t\t\t\tthis.checkFaceType(4);\n\t\t\t\t\t\tfor (i = 1, length = bufferLength + 1; i < length; i += 2) {\n\t\t\t\t\t\t\tthis.buildFace(buffer[i], buffer[i + 1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.checkFaceType(lineDesignation === 'l' ? 5 : 6);\n\t\t\t\t\t\tfor (i = 1, length = bufferLength + 1; i < length; i++) {\n\t\t\t\t\t\t\tthis.buildFace(buffer[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 's':\n\t\t\t\t\tthis.pushSmoothingGroup(buffer[1]);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\t// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n\t\t\t\t\tthis.processCompletedMesh();\n\t\t\t\t\tthis.rawMesh.groupName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'o':\n\t\t\t\t\t// 'o' is pure meta-information and does not result in creation of new meshes\n\t\t\t\t\tthis.rawMesh.objectName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mtllib':\n\t\t\t\t\tthis.rawMesh.mtllibName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'usemtl':\n\t\t\t\t\tvar mtlName = reconstructString(this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte);\n\t\t\t\t\tif (mtlName !== '' && this.rawMesh.activeMtlName !== mtlName) {\n\n\t\t\t\t\t\tthis.rawMesh.activeMtlName = mtlName;\n\t\t\t\t\t\tthis.rawMesh.counts.mtlCount++;\n\t\t\t\t\t\tthis.checkSubGroup();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tParser.prototype.pushSmoothingGroup = function (smoothingGroup) {\n\t\t\tvar smoothingGroupInt = parseInt(smoothingGroup);\n\t\t\tif (isNaN(smoothingGroupInt)) {\n\t\t\t\tsmoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n\t\t\t}\n\n\t\t\tvar smoothCheck = this.rawMesh.smoothingGroup.normalized;\n\t\t\tthis.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : smoothingGroupInt === 0 ? 0 : 1;\n\t\t\tthis.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n\t\t\tif (smoothCheck !== smoothingGroupInt) {\n\n\t\t\t\tthis.rawMesh.counts.smoothingGroupCount++;\n\t\t\t\tthis.checkSubGroup();\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * Expanded faceTypes include all four face types, both line types and the point type\n   * faceType = 0: \"f vertex ...\"\n   * faceType = 1: \"f vertex/uv ...\"\n   * faceType = 2: \"f vertex/uv/normal ...\"\n   * faceType = 3: \"f vertex//normal ...\"\n   * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n   * faceType = 5: \"l vertex ...\"\n   * faceType = 6: \"p vertex ...\"\n   */\n\t\tParser.prototype.checkFaceType = function (faceType) {\n\t\t\tif (this.rawMesh.faceType !== faceType) {\n\n\t\t\t\tthis.processCompletedMesh();\n\t\t\t\tthis.rawMesh.faceType = faceType;\n\t\t\t\tthis.checkSubGroup();\n\t\t\t}\n\t\t};\n\n\t\tParser.prototype.checkSubGroup = function () {\n\t\t\tvar index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n\t\t\tthis.rawMesh.subGroupInUse = this.rawMesh.subGroups[index];\n\n\t\t\tif (!_LoaderSupport2.default.Validator.isValid(this.rawMesh.subGroupInUse)) {\n\n\t\t\t\tthis.rawMesh.subGroupInUse = {\n\t\t\t\t\tindex: index,\n\t\t\t\t\tobjectName: this.rawMesh.objectName,\n\t\t\t\t\tgroupName: this.rawMesh.groupName,\n\t\t\t\t\tmaterialName: this.rawMesh.activeMtlName,\n\t\t\t\t\tsmoothingGroup: this.rawMesh.smoothingGroup.normalized,\n\t\t\t\t\tvertices: [],\n\t\t\t\t\tindexMappingsCount: 0,\n\t\t\t\t\tindexMappings: [],\n\t\t\t\t\tindices: [],\n\t\t\t\t\tcolors: [],\n\t\t\t\t\tuvs: [],\n\t\t\t\t\tnormals: []\n\t\t\t\t};\n\t\t\t\tthis.rawMesh.subGroups[index] = this.rawMesh.subGroupInUse;\n\t\t\t}\n\t\t};\n\n\t\tParser.prototype.buildFace = function (faceIndexV, faceIndexU, faceIndexN) {\n\t\t\tif (this.disregardNormals) faceIndexN = undefined;\n\t\t\tvar scope = this;\n\t\t\tvar updateSubGroupInUse = function updateSubGroupInUse() {\n\n\t\t\t\tvar faceIndexVi = parseInt(faceIndexV);\n\t\t\t\tvar indexPointerV = 3 * (faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3);\n\n\t\t\t\tvar vertices = scope.rawMesh.subGroupInUse.vertices;\n\t\t\t\tvertices.push(scope.vertices[indexPointerV++]);\n\t\t\t\tvertices.push(scope.vertices[indexPointerV++]);\n\t\t\t\tvertices.push(scope.vertices[indexPointerV]);\n\n\t\t\t\tvar indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n\t\t\t\tif (indexPointerC !== null) {\n\n\t\t\t\t\tvar colors = scope.rawMesh.subGroupInUse.colors;\n\t\t\t\t\tcolors.push(scope.colors[indexPointerC++]);\n\t\t\t\t\tcolors.push(scope.colors[indexPointerC++]);\n\t\t\t\t\tcolors.push(scope.colors[indexPointerC]);\n\t\t\t\t}\n\t\t\t\tif (faceIndexU) {\n\n\t\t\t\t\tvar faceIndexUi = parseInt(faceIndexU);\n\t\t\t\t\tvar indexPointerU = 2 * (faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2);\n\t\t\t\t\tvar uvs = scope.rawMesh.subGroupInUse.uvs;\n\t\t\t\t\tuvs.push(scope.uvs[indexPointerU++]);\n\t\t\t\t\tuvs.push(scope.uvs[indexPointerU]);\n\t\t\t\t}\n\t\t\t\tif (faceIndexN) {\n\n\t\t\t\t\tvar faceIndexNi = parseInt(faceIndexN);\n\t\t\t\t\tvar indexPointerN = 3 * (faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3);\n\t\t\t\t\tvar normals = scope.rawMesh.subGroupInUse.normals;\n\t\t\t\t\tnormals.push(scope.normals[indexPointerN++]);\n\t\t\t\t\tnormals.push(scope.normals[indexPointerN++]);\n\t\t\t\t\tnormals.push(scope.normals[indexPointerN]);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif (this.useIndices) {\n\n\t\t\t\tvar mappingName = faceIndexV + (faceIndexU ? '_' + faceIndexU : '_n') + (faceIndexN ? '_' + faceIndexN : '_n');\n\t\t\t\tvar indicesPointer = this.rawMesh.subGroupInUse.indexMappings[mappingName];\n\t\t\t\tif (_LoaderSupport2.default.Validator.isValid(indicesPointer)) {\n\n\t\t\t\t\tthis.rawMesh.counts.doubleIndicesCount++;\n\t\t\t\t} else {\n\n\t\t\t\t\tindicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n\t\t\t\t\tupdateSubGroupInUse();\n\t\t\t\t\tthis.rawMesh.subGroupInUse.indexMappings[mappingName] = indicesPointer;\n\t\t\t\t\tthis.rawMesh.subGroupInUse.indexMappingsCount++;\n\t\t\t\t}\n\t\t\t\tthis.rawMesh.subGroupInUse.indices.push(indicesPointer);\n\t\t\t} else {\n\n\t\t\t\tupdateSubGroupInUse();\n\t\t\t}\n\t\t\tthis.rawMesh.counts.faceCount++;\n\t\t};\n\n\t\tParser.prototype.createRawMeshReport = function (inputObjectCount) {\n\t\t\treturn 'Input Object number: ' + inputObjectCount + '\\n\\tObject name: ' + this.rawMesh.objectName + '\\n\\tGroup name: ' + this.rawMesh.groupName + '\\n\\tMtllib name: ' + this.rawMesh.mtllibName + '\\n\\tVertex count: ' + this.vertices.length / 3 + '\\n\\tNormal count: ' + this.normals.length / 3 + '\\n\\tUV count: ' + this.uvs.length / 2 + '\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount + '\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount + '\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n\t\t};\n\n\t\t/**\n   * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n   */\n\t\tParser.prototype.finalizeRawMesh = function () {\n\t\t\tvar meshOutputGroupTemp = [];\n\t\t\tvar meshOutputGroup;\n\t\t\tvar absoluteVertexCount = 0;\n\t\t\tvar absoluteIndexMappingsCount = 0;\n\t\t\tvar absoluteIndexCount = 0;\n\t\t\tvar absoluteColorCount = 0;\n\t\t\tvar absoluteNormalCount = 0;\n\t\t\tvar absoluteUvCount = 0;\n\t\t\tvar indices;\n\t\t\tfor (var name in this.rawMesh.subGroups) {\n\n\t\t\t\tmeshOutputGroup = this.rawMesh.subGroups[name];\n\t\t\t\tif (meshOutputGroup.vertices.length > 0) {\n\n\t\t\t\t\tindices = meshOutputGroup.indices;\n\t\t\t\t\tif (indices.length > 0 && absoluteIndexMappingsCount > 0) {\n\n\t\t\t\t\t\tfor (var i in indices) {\n\t\t\t\t\t\t\tindices[i] = indices[i] + absoluteIndexMappingsCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmeshOutputGroupTemp.push(meshOutputGroup);\n\t\t\t\t\tabsoluteVertexCount += meshOutputGroup.vertices.length;\n\t\t\t\t\tabsoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n\t\t\t\t\tabsoluteIndexCount += meshOutputGroup.indices.length;\n\t\t\t\t\tabsoluteColorCount += meshOutputGroup.colors.length;\n\t\t\t\t\tabsoluteUvCount += meshOutputGroup.uvs.length;\n\t\t\t\t\tabsoluteNormalCount += meshOutputGroup.normals.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// do not continue if no result\n\t\t\tvar result = null;\n\t\t\tif (meshOutputGroupTemp.length > 0) {\n\n\t\t\t\tresult = {\n\t\t\t\t\tname: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n\t\t\t\t\tsubGroups: meshOutputGroupTemp,\n\t\t\t\t\tabsoluteVertexCount: absoluteVertexCount,\n\t\t\t\t\tabsoluteIndexCount: absoluteIndexCount,\n\t\t\t\t\tabsoluteColorCount: absoluteColorCount,\n\t\t\t\t\tabsoluteNormalCount: absoluteNormalCount,\n\t\t\t\t\tabsoluteUvCount: absoluteUvCount,\n\t\t\t\t\tfaceCount: this.rawMesh.counts.faceCount,\n\t\t\t\t\tdoubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tParser.prototype.processCompletedMesh = function () {\n\t\t\tvar result = this.finalizeRawMesh();\n\t\t\tif (_LoaderSupport2.default.Validator.isValid(result)) {\n\n\t\t\t\tif (this.colors.length > 0 && this.colors.length !== this.vertices.length) {\n\n\t\t\t\t\tthrow 'Vertex Colors were detected, but vertex count and color count do not match!';\n\t\t\t\t}\n\t\t\t\tif (this.logging.enabled && this.logging.debug) console.debug(this.createRawMeshReport(this.inputObjectCount));\n\t\t\t\tthis.inputObjectCount++;\n\n\t\t\t\tthis.buildMesh(result);\n\t\t\t\tvar progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\t\t\t\tthis.callbackProgress('Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '] Total progress: ' + (progressBytesPercent * 100).toFixed(2) + '%', progressBytesPercent);\n\t\t\t\tthis.resetRawMesh();\n\t\t\t\treturn true;\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\t/**\n   * SubGroups are transformed to too intermediate format that is forwarded to the MeshBuilder.\n   * It is ensured that SubGroups only contain objects with vertices (no need to check).\n   *\n   * @param result\n   */\n\t\tParser.prototype.buildMesh = function (result) {\n\t\t\tvar meshOutputGroups = result.subGroups;\n\n\t\t\tvar vertexFA = new Float32Array(result.absoluteVertexCount);\n\t\t\tthis.globalCounts.vertices += result.absoluteVertexCount / 3;\n\t\t\tthis.globalCounts.faces += result.faceCount;\n\t\t\tthis.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n\t\t\tvar indexUA = result.absoluteIndexCount > 0 ? new Uint32Array(result.absoluteIndexCount) : null;\n\t\t\tvar colorFA = result.absoluteColorCount > 0 ? new Float32Array(result.absoluteColorCount) : null;\n\t\t\tvar normalFA = result.absoluteNormalCount > 0 ? new Float32Array(result.absoluteNormalCount) : null;\n\t\t\tvar uvFA = result.absoluteUvCount > 0 ? new Float32Array(result.absoluteUvCount) : null;\n\t\t\tvar haveVertexColors = _LoaderSupport2.default.Validator.isValid(colorFA);\n\n\t\t\tvar meshOutputGroup;\n\t\t\tvar materialNames = [];\n\n\t\t\tvar createMultiMaterial = meshOutputGroups.length > 1;\n\t\t\tvar materialIndex = 0;\n\t\t\tvar materialIndexMapping = [];\n\t\t\tvar selectedMaterialIndex;\n\t\t\tvar materialGroup;\n\t\t\tvar materialGroups = [];\n\n\t\t\tvar vertexFAOffset = 0;\n\t\t\tvar indexUAOffset = 0;\n\t\t\tvar colorFAOffset = 0;\n\t\t\tvar normalFAOffset = 0;\n\t\t\tvar uvFAOffset = 0;\n\t\t\tvar materialGroupOffset = 0;\n\t\t\tvar materialGroupLength = 0;\n\n\t\t\tvar materialOrg, material, materialName, materialNameOrg;\n\t\t\t// only one specific face type\n\t\t\tfor (var oodIndex in meshOutputGroups) {\n\n\t\t\t\tif (!meshOutputGroups.hasOwnProperty(oodIndex)) continue;\n\t\t\t\tmeshOutputGroup = meshOutputGroups[oodIndex];\n\n\t\t\t\tmaterialNameOrg = meshOutputGroup.materialName;\n\t\t\t\tif (this.rawMesh.faceType < 4) {\n\n\t\t\t\t\tmaterialName = materialNameOrg + (haveVertexColors ? '_vertexColor' : '') + (meshOutputGroup.smoothingGroup === 0 ? '_flat' : '');\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n\t\t\t\t}\n\t\t\t\tmaterialOrg = this.materials[materialNameOrg];\n\t\t\t\tmaterial = this.materials[materialName];\n\n\t\t\t\t// both original and derived names do not lead to an existing material => need to use a default material\n\t\t\t\tif (!_LoaderSupport2.default.Validator.isValid(materialOrg) && !_LoaderSupport2.default.Validator.isValid(material)) {\n\n\t\t\t\t\tvar defaultMaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n\t\t\t\t\tmaterialOrg = this.materials[defaultMaterialName];\n\t\t\t\t\tif (this.logging.enabled) console.warn('object_group \"' + meshOutputGroup.objectName + '_' + meshOutputGroup.groupName + '\" was defined with unresolvable material \"' + materialNameOrg + '\"! Assigning \"' + defaultMaterialName + '\".');\n\t\t\t\t\tmaterialNameOrg = defaultMaterialName;\n\n\t\t\t\t\t// if names are identical then there is no need for later manipulation\n\t\t\t\t\tif (materialNameOrg === materialName) {\n\n\t\t\t\t\t\tmaterial = materialOrg;\n\t\t\t\t\t\tmaterialName = defaultMaterialName;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!_LoaderSupport2.default.Validator.isValid(material)) {\n\n\t\t\t\t\tvar materialCloneInstructions = {\n\t\t\t\t\t\tmaterialNameOrg: materialNameOrg,\n\t\t\t\t\t\tmaterialName: materialName,\n\t\t\t\t\t\tmaterialProperties: {\n\t\t\t\t\t\t\tvertexColors: haveVertexColors ? 2 : 0,\n\t\t\t\t\t\t\tflatShading: meshOutputGroup.smoothingGroup === 0\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tvar payload = {\n\t\t\t\t\t\tcmd: 'materialData',\n\t\t\t\t\t\tmaterials: {\n\t\t\t\t\t\t\tmaterialCloneInstructions: materialCloneInstructions\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tthis.callbackMeshBuilder(payload);\n\n\t\t\t\t\t// fake entry for async; sync Parser always works on material references (Builder update directly visible here)\n\t\t\t\t\tif (this.useAsync) this.materials[materialName] = materialCloneInstructions;\n\t\t\t\t}\n\n\t\t\t\tif (createMultiMaterial) {\n\n\t\t\t\t\t// re-use material if already used before. Reduces materials array size and eliminates duplicates\n\t\t\t\t\tselectedMaterialIndex = materialIndexMapping[materialName];\n\t\t\t\t\tif (!selectedMaterialIndex) {\n\n\t\t\t\t\t\tselectedMaterialIndex = materialIndex;\n\t\t\t\t\t\tmaterialIndexMapping[materialName] = materialIndex;\n\t\t\t\t\t\tmaterialNames.push(materialName);\n\t\t\t\t\t\tmaterialIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tmaterialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n\t\t\t\t\tmaterialGroup = {\n\t\t\t\t\t\tstart: materialGroupOffset,\n\t\t\t\t\t\tcount: materialGroupLength,\n\t\t\t\t\t\tindex: selectedMaterialIndex\n\t\t\t\t\t};\n\t\t\t\t\tmaterialGroups.push(materialGroup);\n\t\t\t\t\tmaterialGroupOffset += materialGroupLength;\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterialNames.push(materialName);\n\t\t\t\t}\n\n\t\t\t\tvertexFA.set(meshOutputGroup.vertices, vertexFAOffset);\n\t\t\t\tvertexFAOffset += meshOutputGroup.vertices.length;\n\n\t\t\t\tif (indexUA) {\n\n\t\t\t\t\tindexUA.set(meshOutputGroup.indices, indexUAOffset);\n\t\t\t\t\tindexUAOffset += meshOutputGroup.indices.length;\n\t\t\t\t}\n\n\t\t\t\tif (colorFA) {\n\n\t\t\t\t\tcolorFA.set(meshOutputGroup.colors, colorFAOffset);\n\t\t\t\t\tcolorFAOffset += meshOutputGroup.colors.length;\n\t\t\t\t}\n\n\t\t\t\tif (normalFA) {\n\n\t\t\t\t\tnormalFA.set(meshOutputGroup.normals, normalFAOffset);\n\t\t\t\t\tnormalFAOffset += meshOutputGroup.normals.length;\n\t\t\t\t}\n\t\t\t\tif (uvFA) {\n\n\t\t\t\t\tuvFA.set(meshOutputGroup.uvs, uvFAOffset);\n\t\t\t\t\tuvFAOffset += meshOutputGroup.uvs.length;\n\t\t\t\t}\n\n\t\t\t\tif (this.logging.enabled && this.logging.debug) {\n\t\t\t\t\tvar materialIndexLine = _LoaderSupport2.default.Validator.isValid(selectedMaterialIndex) ? '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex : '';\n\t\t\t\t\tvar createdReport = '\\tOutput Object no.: ' + this.outputObjectCount + '\\n\\t\\tgroupName: ' + meshOutputGroup.groupName + '\\n\\t\\tIndex: ' + meshOutputGroup.index + '\\n\\t\\tfaceType: ' + this.rawMesh.faceType + '\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName + '\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup + materialIndexLine + '\\n\\t\\tobjectName: ' + meshOutputGroup.objectName + '\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 + '\\n\\t\\t#indices: ' + meshOutputGroup.indices.length + '\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 + '\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 + '\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n\t\t\t\t\tconsole.debug(createdReport);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.outputObjectCount++;\n\t\t\tthis.callbackMeshBuilder({\n\t\t\t\tcmd: 'meshData',\n\t\t\t\tprogress: {\n\t\t\t\t\tnumericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n\t\t\t\t},\n\t\t\t\tparams: {\n\t\t\t\t\tmeshName: result.name\n\t\t\t\t},\n\t\t\t\tmaterials: {\n\t\t\t\t\tmultiMaterial: createMultiMaterial,\n\t\t\t\t\tmaterialNames: materialNames,\n\t\t\t\t\tmaterialGroups: materialGroups\n\t\t\t\t},\n\t\t\t\tbuffers: {\n\t\t\t\t\tvertices: vertexFA,\n\t\t\t\t\tindices: indexUA,\n\t\t\t\t\tcolors: colorFA,\n\t\t\t\t\tnormals: normalFA,\n\t\t\t\t\tuvs: uvFA\n\t\t\t\t},\n\t\t\t\t// 0: mesh, 1: line, 2: point\n\t\t\t\tgeometryType: this.rawMesh.faceType < 4 ? 0 : this.rawMesh.faceType === 6 ? 2 : 1\n\t\t\t}, [vertexFA.buffer], _LoaderSupport2.default.Validator.isValid(indexUA) ? [indexUA.buffer] : null, _LoaderSupport2.default.Validator.isValid(colorFA) ? [colorFA.buffer] : null, _LoaderSupport2.default.Validator.isValid(normalFA) ? [normalFA.buffer] : null, _LoaderSupport2.default.Validator.isValid(uvFA) ? [uvFA.buffer] : null);\n\t\t};\n\n\t\tParser.prototype.finalizeParsing = function () {\n\t\t\tif (this.logging.enabled) console.info('Global output object count: ' + this.outputObjectCount);\n\t\t\tif (this.processCompletedMesh() && this.logging.enabled) {\n\n\t\t\t\tvar parserFinalReport = 'Overall counts: ' + '\\n\\tVertices: ' + this.globalCounts.vertices + '\\n\\tFaces: ' + this.globalCounts.faces + '\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n\t\t\t\tconsole.info(parserFinalReport);\n\t\t\t}\n\t\t};\n\n\t\treturn Parser;\n\t}();\n\n\t/**\n  * Utility method for loading an mtl file according resource description. Provide url or content.\n  * @memberOf THREE.OBJLoader2\n  *\n  * @param {string} url URL to the file\n  * @param {Object} content The file content as arraybuffer or text\n  * @param {function} callbackOnLoad Callback to be called after successful load\n  * @param {string} [crossOrigin] CORS value\n \t * @param {Object} [materialOptions] Set material loading options for MTLLoader\n  */\n\tOBJLoader2.prototype.loadMtl = function (url, content, callbackOnLoad, crossOrigin, materialOptions) {\n\t\tvar resource = new _LoaderSupport2.default.ResourceDescriptor(url, 'MTL');\n\t\tresource.setContent(content);\n\t\tthis._loadMtl(resource, callbackOnLoad, crossOrigin, materialOptions);\n\t};\n\n\tOBJLoader2.prototype._loadMtl = function (resource, callbackOnLoad, crossOrigin, materialOptions) {\n\t\tif (_MTLLoader2.default === undefined) console.error('\"THREE.MTLLoader\" is not available. \"THREE.OBJLoader2\" requires it for loading MTL files.');\n\t\tif (Validator.isValid(resource) && this.logging.enabled) console.time('Loading MTL: ' + resource.name);\n\n\t\tvar materials = [];\n\t\tvar scope = this;\n\t\tvar processMaterials = function processMaterials(materialCreator) {\n\t\t\tvar materialCreatorMaterials = [];\n\t\t\tif (Validator.isValid(materialCreator)) {\n\n\t\t\t\tmaterialCreator.preload();\n\t\t\t\tmaterialCreatorMaterials = materialCreator.materials;\n\t\t\t\tfor (var materialName in materialCreatorMaterials) {\n\n\t\t\t\t\tif (materialCreatorMaterials.hasOwnProperty(materialName)) {\n\n\t\t\t\t\t\tmaterials[materialName] = materialCreatorMaterials[materialName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Validator.isValid(resource) && scope.logging.enabled) console.timeEnd('Loading MTL: ' + resource.name);\n\t\t\tcallbackOnLoad(materials, materialCreator);\n\t\t};\n\n\t\t// fast-fail\n\t\tif (!Validator.isValid(resource) || !Validator.isValid(resource.content) && !Validator.isValid(resource.url)) {\n\n\t\t\tprocessMaterials();\n\t\t} else {\n\n\t\t\tvar mtlLoader = new _MTLLoader2.default(this.manager);\n\t\t\tcrossOrigin = Validator.verifyInput(crossOrigin, 'anonymous');\n\t\t\tmtlLoader.setCrossOrigin(crossOrigin);\n\t\t\tmtlLoader.setPath(resource.path);\n\t\t\tif (Validator.isValid(materialOptions)) mtlLoader.setMaterialOptions(materialOptions);\n\n\t\t\tif (Validator.isValid(resource.content)) {\n\n\t\t\t\tprocessMaterials(Validator.isValid(resource.content) ? mtlLoader.parse(resource.content) : null);\n\t\t\t} else if (Validator.isValid(resource.url)) {\n\n\t\t\t\tvar fileLoader = new THREE.FileLoader(this.manager);\n\t\t\t\tfileLoader.load(resource.url, function (text) {\n\n\t\t\t\t\tresource.content = text;\n\t\t\t\t\tprocessMaterials(mtlLoader.parse(text));\n\t\t\t\t}, this._onProgress, this._onError);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn OBJLoader2;\n}();\n\nexports.default = OBJLoader2;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Filipe Caixeta / http://filipecaixeta.com.br\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for PCD ascii and binary files.\n *\n * Limitations: Compressed binary files are not supported.\n *\n */\n\nvar PCDLoader = function PCDLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.littleEndian = true;\n};\n\nPCDLoader.prototype = {\n\n\tconstructor: PCDLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (data) {\n\n\t\t\tonLoad(scope.parse(data, url));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data, url) {\n\n\t\tfunction parseHeader(data) {\n\n\t\t\tvar PCDheader = {};\n\t\t\tvar result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n\t\t\tvar result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n\n\t\t\tPCDheader.data = result2[1];\n\t\t\tPCDheader.headerLen = result2[0].length + result1;\n\t\t\tPCDheader.str = data.substr(0, PCDheader.headerLen);\n\n\t\t\t// remove comments\n\n\t\t\tPCDheader.str = PCDheader.str.replace(/\\#.*/gi, '');\n\n\t\t\t// parse\n\n\t\t\tPCDheader.version = /VERSION (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.fields = /FIELDS (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.size = /SIZE (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.type = /TYPE (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.count = /COUNT (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.width = /WIDTH (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.height = /HEIGHT (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.viewpoint = /VIEWPOINT (.*)/i.exec(PCDheader.str);\n\t\t\tPCDheader.points = /POINTS (.*)/i.exec(PCDheader.str);\n\n\t\t\t// evaluate\n\n\t\t\tif (PCDheader.version !== null) PCDheader.version = parseFloat(PCDheader.version[1]);\n\n\t\t\tif (PCDheader.fields !== null) PCDheader.fields = PCDheader.fields[1].split(' ');\n\n\t\t\tif (PCDheader.type !== null) PCDheader.type = PCDheader.type[1].split(' ');\n\n\t\t\tif (PCDheader.width !== null) PCDheader.width = parseInt(PCDheader.width[1]);\n\n\t\t\tif (PCDheader.height !== null) PCDheader.height = parseInt(PCDheader.height[1]);\n\n\t\t\tif (PCDheader.viewpoint !== null) PCDheader.viewpoint = PCDheader.viewpoint[1];\n\n\t\t\tif (PCDheader.points !== null) PCDheader.points = parseInt(PCDheader.points[1], 10);\n\n\t\t\tif (PCDheader.points === null) PCDheader.points = PCDheader.width * PCDheader.height;\n\n\t\t\tif (PCDheader.size !== null) {\n\n\t\t\t\tPCDheader.size = PCDheader.size[1].split(' ').map(function (x) {\n\n\t\t\t\t\treturn parseInt(x, 10);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (PCDheader.count !== null) {\n\n\t\t\t\tPCDheader.count = PCDheader.count[1].split(' ').map(function (x) {\n\n\t\t\t\t\treturn parseInt(x, 10);\n\t\t\t\t});\n\t\t\t} else {\n\n\t\t\t\tPCDheader.count = [];\n\n\t\t\t\tfor (var i = 0, l = PCDheader.fields.length; i < l; i++) {\n\n\t\t\t\t\tPCDheader.count.push(1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tPCDheader.offset = {};\n\n\t\t\tvar sizeSum = 0;\n\n\t\t\tfor (var i = 0, l = PCDheader.fields.length; i < l; i++) {\n\n\t\t\t\tif (PCDheader.data === 'ascii') {\n\n\t\t\t\t\tPCDheader.offset[PCDheader.fields[i]] = i;\n\t\t\t\t} else {\n\n\t\t\t\t\tPCDheader.offset[PCDheader.fields[i]] = sizeSum;\n\t\t\t\t\tsizeSum += PCDheader.size[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for binary only\n\n\t\t\tPCDheader.rowSize = sizeSum;\n\n\t\t\treturn PCDheader;\n\t\t}\n\n\t\tvar textData = THREE.LoaderUtils.decodeText(data);\n\n\t\t// parse header (always ascii format)\n\n\t\tvar PCDheader = parseHeader(textData);\n\n\t\t// parse data\n\n\t\tvar position = [];\n\t\tvar normal = [];\n\t\tvar color = [];\n\n\t\t// ascii\n\n\t\tif (PCDheader.data === 'ascii') {\n\n\t\t\tvar offset = PCDheader.offset;\n\t\t\tvar pcdData = textData.substr(PCDheader.headerLen);\n\t\t\tvar lines = pcdData.split('\\n');\n\n\t\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\t\tif (lines[i] === '') continue;\n\n\t\t\t\tvar line = lines[i].split(' ');\n\n\t\t\t\tif (offset.x !== undefined) {\n\n\t\t\t\t\tposition.push(parseFloat(line[offset.x]));\n\t\t\t\t\tposition.push(parseFloat(line[offset.y]));\n\t\t\t\t\tposition.push(parseFloat(line[offset.z]));\n\t\t\t\t}\n\n\t\t\t\tif (offset.rgb !== undefined) {\n\n\t\t\t\t\tvar c = new Float32Array([parseFloat(line[offset.rgb])]);\n\t\t\t\t\tvar dataview = new DataView(c.buffer, 0);\n\t\t\t\t\tcolor.push(dataview.getUint8(0) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(1) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(2) / 255.0);\n\t\t\t\t}\n\n\t\t\t\tif (offset.normal_x !== undefined) {\n\n\t\t\t\t\tnormal.push(parseFloat(line[offset.normal_x]));\n\t\t\t\t\tnormal.push(parseFloat(line[offset.normal_y]));\n\t\t\t\t\tnormal.push(parseFloat(line[offset.normal_z]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// binary\n\n\t\tif (PCDheader.data === 'binary_compressed') {\n\n\t\t\tconsole.error('THREE.PCDLoader: binary_compressed files are not supported');\n\t\t\treturn;\n\t\t}\n\n\t\tif (PCDheader.data === 'binary') {\n\n\t\t\tvar dataview = new DataView(data, PCDheader.headerLen);\n\t\t\tvar offset = PCDheader.offset;\n\n\t\t\tfor (var i = 0, row = 0; i < PCDheader.points; i++, row += PCDheader.rowSize) {\n\n\t\t\t\tif (offset.x !== undefined) {\n\n\t\t\t\t\tposition.push(dataview.getFloat32(row + offset.x, this.littleEndian));\n\t\t\t\t\tposition.push(dataview.getFloat32(row + offset.y, this.littleEndian));\n\t\t\t\t\tposition.push(dataview.getFloat32(row + offset.z, this.littleEndian));\n\t\t\t\t}\n\n\t\t\t\tif (offset.rgb !== undefined) {\n\n\t\t\t\t\tcolor.push(dataview.getUint8(row + offset.rgb + 0) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(row + offset.rgb + 1) / 255.0);\n\t\t\t\t\tcolor.push(dataview.getUint8(row + offset.rgb + 2) / 255.0);\n\t\t\t\t}\n\n\t\t\t\tif (offset.normal_x !== undefined) {\n\n\t\t\t\t\tnormal.push(dataview.getFloat32(row + offset.normal_x, this.littleEndian));\n\t\t\t\t\tnormal.push(dataview.getFloat32(row + offset.normal_y, this.littleEndian));\n\t\t\t\t\tnormal.push(dataview.getFloat32(row + offset.normal_z, this.littleEndian));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// build geometry\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tif (position.length > 0) geometry.addAttribute('position', new THREE.Float32BufferAttribute(position, 3));\n\t\tif (normal.length > 0) geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normal, 3));\n\t\tif (color.length > 0) geometry.addAttribute('color', new THREE.Float32BufferAttribute(color, 3));\n\n\t\tgeometry.computeBoundingSphere();\n\n\t\t// build material\n\n\t\tvar material = new THREE.PointsMaterial({ size: 0.005 });\n\n\t\tif (color.length > 0) {\n\n\t\t\tmaterial.vertexColors = true;\n\t\t} else {\n\n\t\t\tmaterial.color.setHex(Math.random() * 0xffffff);\n\t\t}\n\n\t\t// build mesh\n\n\t\tvar mesh = new THREE.Points(geometry, material);\n\t\tvar name = url.split('').reverse().join('');\n\t\tname = /([^\\/]*)/.exec(name);\n\t\tname = name[1].split('').reverse().join('');\n\t\tmesh.name = name;\n\n\t\treturn mesh;\n\t}\n\n};\n\nexports.default = PCDLoader;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar PDBLoader = function PDBLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nPDBLoader.prototype = {\n\n\tconstructor: PDBLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\t// Based on CanvasMol PDB parser\n\n\tparse: function parse(text) {\n\n\t\tfunction trim(text) {\n\n\t\t\treturn text.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\t\t}\n\n\t\tfunction capitalize(text) {\n\n\t\t\treturn text.charAt(0).toUpperCase() + text.substr(1).toLowerCase();\n\t\t}\n\n\t\tfunction hash(s, e) {\n\n\t\t\treturn 's' + Math.min(s, e) + 'e' + Math.max(s, e);\n\t\t}\n\n\t\tfunction parseBond(start, length) {\n\n\t\t\tvar eatom = parseInt(lines[i].substr(start, length));\n\n\t\t\tif (eatom) {\n\n\t\t\t\tvar h = hash(satom, eatom);\n\n\t\t\t\tif (bhash[h] === undefined) {\n\n\t\t\t\t\tbonds.push([satom - 1, eatom - 1, 1]);\n\t\t\t\t\tbhash[h] = bonds.length - 1;\n\t\t\t\t} else {\n\n\t\t\t\t\t// doesn't really work as almost all PDBs\n\t\t\t\t\t// have just normal bonds appearing multiple\n\t\t\t\t\t// times instead of being double/triple bonds\n\t\t\t\t\t// bonds[bhash[h]][2] += 1;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction buildGeometry() {\n\n\t\t\tvar build = {\n\t\t\t\tgeometryAtoms: new THREE.BufferGeometry(),\n\t\t\t\tgeometryBonds: new THREE.BufferGeometry(),\n\t\t\t\tjson: {\n\t\t\t\t\tatoms: atoms,\n\t\t\t\t\tbonds: bonds\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar geometryAtoms = build.geometryAtoms;\n\t\t\tvar geometryBonds = build.geometryBonds;\n\n\t\t\tvar i, l;\n\n\t\t\tvar verticesAtoms = [];\n\t\t\tvar colorsAtoms = [];\n\t\t\tvar verticesBonds = [];\n\n\t\t\t// atoms\n\n\t\t\tfor (i = 0, l = atoms.length; i < l; i++) {\n\n\t\t\t\tvar atom = atoms[i];\n\n\t\t\t\tvar x = atom[0];\n\t\t\t\tvar y = atom[1];\n\t\t\t\tvar z = atom[2];\n\n\t\t\t\tverticesAtoms.push(x, y, z);\n\n\t\t\t\tvar r = atom[3][0] / 255;\n\t\t\t\tvar g = atom[3][1] / 255;\n\t\t\t\tvar b = atom[3][2] / 255;\n\n\t\t\t\tcolorsAtoms.push(r, g, b);\n\t\t\t}\n\n\t\t\t// bonds\n\n\t\t\tfor (i = 0, l = bonds.length; i < l; i++) {\n\n\t\t\t\tvar bond = bonds[i];\n\n\t\t\t\tvar start = bond[0];\n\t\t\t\tvar end = bond[1];\n\n\t\t\t\tverticesBonds.push(verticesAtoms[start * 3 + 0]);\n\t\t\t\tverticesBonds.push(verticesAtoms[start * 3 + 1]);\n\t\t\t\tverticesBonds.push(verticesAtoms[start * 3 + 2]);\n\n\t\t\t\tverticesBonds.push(verticesAtoms[end * 3 + 0]);\n\t\t\t\tverticesBonds.push(verticesAtoms[end * 3 + 1]);\n\t\t\t\tverticesBonds.push(verticesAtoms[end * 3 + 2]);\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tgeometryAtoms.addAttribute('position', new THREE.Float32BufferAttribute(verticesAtoms, 3));\n\t\t\tgeometryAtoms.addAttribute('color', new THREE.Float32BufferAttribute(colorsAtoms, 3));\n\n\t\t\tgeometryBonds.addAttribute('position', new THREE.Float32BufferAttribute(verticesBonds, 3));\n\n\t\t\treturn build;\n\t\t}\n\n\t\tvar CPK = { h: [255, 255, 255], he: [217, 255, 255], li: [204, 128, 255], be: [194, 255, 0], b: [255, 181, 181], c: [144, 144, 144], n: [48, 80, 248], o: [255, 13, 13], f: [144, 224, 80], ne: [179, 227, 245], na: [171, 92, 242], mg: [138, 255, 0], al: [191, 166, 166], si: [240, 200, 160], p: [255, 128, 0], s: [255, 255, 48], cl: [31, 240, 31], ar: [128, 209, 227], k: [143, 64, 212], ca: [61, 255, 0], sc: [230, 230, 230], ti: [191, 194, 199], v: [166, 166, 171], cr: [138, 153, 199], mn: [156, 122, 199], fe: [224, 102, 51], co: [240, 144, 160], ni: [80, 208, 80], cu: [200, 128, 51], zn: [125, 128, 176], ga: [194, 143, 143], ge: [102, 143, 143], as: [189, 128, 227], se: [255, 161, 0], br: [166, 41, 41], kr: [92, 184, 209], rb: [112, 46, 176], sr: [0, 255, 0], y: [148, 255, 255], zr: [148, 224, 224], nb: [115, 194, 201], mo: [84, 181, 181], tc: [59, 158, 158], ru: [36, 143, 143], rh: [10, 125, 140], pd: [0, 105, 133], ag: [192, 192, 192], cd: [255, 217, 143], in: [166, 117, 115], sn: [102, 128, 128], sb: [158, 99, 181], te: [212, 122, 0], i: [148, 0, 148], xe: [66, 158, 176], cs: [87, 23, 143], ba: [0, 201, 0], la: [112, 212, 255], ce: [255, 255, 199], pr: [217, 255, 199], nd: [199, 255, 199], pm: [163, 255, 199], sm: [143, 255, 199], eu: [97, 255, 199], gd: [69, 255, 199], tb: [48, 255, 199], dy: [31, 255, 199], ho: [0, 255, 156], er: [0, 230, 117], tm: [0, 212, 82], yb: [0, 191, 56], lu: [0, 171, 36], hf: [77, 194, 255], ta: [77, 166, 255], w: [33, 148, 214], re: [38, 125, 171], os: [38, 102, 150], ir: [23, 84, 135], pt: [208, 208, 224], au: [255, 209, 35], hg: [184, 184, 208], tl: [166, 84, 77], pb: [87, 89, 97], bi: [158, 79, 181], po: [171, 92, 0], at: [117, 79, 69], rn: [66, 130, 150], fr: [66, 0, 102], ra: [0, 125, 0], ac: [112, 171, 250], th: [0, 186, 255], pa: [0, 161, 255], u: [0, 143, 255], np: [0, 128, 255], pu: [0, 107, 255], am: [84, 92, 242], cm: [120, 92, 227], bk: [138, 79, 227], cf: [161, 54, 212], es: [179, 31, 212], fm: [179, 31, 186], md: [179, 13, 166], no: [189, 13, 135], lr: [199, 0, 102], rf: [204, 0, 89], db: [209, 0, 79], sg: [217, 0, 69], bh: [224, 0, 56], hs: [230, 0, 46], mt: [235, 0, 38], ds: [235, 0, 38], rg: [235, 0, 38], cn: [235, 0, 38], uut: [235, 0, 38], uuq: [235, 0, 38], uup: [235, 0, 38], uuh: [235, 0, 38], uus: [235, 0, 38], uuo: [235, 0, 38] };\n\n\t\tvar atoms = [];\n\t\tvar bonds = [];\n\t\tvar histogram = {};\n\n\t\tvar bhash = {};\n\n\t\tvar x, y, z, index, e;\n\n\t\t// parse\n\n\t\tvar lines = text.split('\\n');\n\n\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\tif (lines[i].substr(0, 4) === 'ATOM' || lines[i].substr(0, 6) === 'HETATM') {\n\n\t\t\t\tx = parseFloat(lines[i].substr(30, 7));\n\t\t\t\ty = parseFloat(lines[i].substr(38, 7));\n\t\t\t\tz = parseFloat(lines[i].substr(46, 7));\n\t\t\t\tindex = parseInt(lines[i].substr(6, 5)) - 1;\n\n\t\t\t\te = trim(lines[i].substr(76, 2)).toLowerCase();\n\n\t\t\t\tif (e === '') {\n\n\t\t\t\t\te = trim(lines[i].substr(12, 2)).toLowerCase();\n\t\t\t\t}\n\n\t\t\t\tatoms[index] = [x, y, z, CPK[e], capitalize(e)];\n\n\t\t\t\tif (histogram[e] === undefined) {\n\n\t\t\t\t\thistogram[e] = 1;\n\t\t\t\t} else {\n\n\t\t\t\t\thistogram[e] += 1;\n\t\t\t\t}\n\t\t\t} else if (lines[i].substr(0, 6) === 'CONECT') {\n\n\t\t\t\tvar satom = parseInt(lines[i].substr(6, 5));\n\n\t\t\t\tparseBond(11, 5);\n\t\t\t\tparseBond(16, 5);\n\t\t\t\tparseBond(21, 5);\n\t\t\t\tparseBond(26, 5);\n\t\t\t}\n\t\t}\n\n\t\t// build and return geometry\n\n\t\treturn buildGeometry();\n\t}\n\n};\n\nexports.default = PDBLoader;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nvar PlayCanvasLoader = function PlayCanvasLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nPlayCanvasLoader.prototype = {\n\n\tconstructor: PlayCanvasLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(JSON.parse(text)));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(json) {\n\n\t\tfunction parseVertices(data) {\n\n\t\t\tvar attributes = {};\n\n\t\t\t// create a buffer attribute for each array that contains vertex information\n\n\t\t\tfor (var name in data) {\n\n\t\t\t\tvar array = data[name];\n\n\t\t\t\tvar type = array.type;\n\t\t\t\tvar size = array.components;\n\n\t\t\t\tvar attribute;\n\n\t\t\t\tswitch (type) {\n\n\t\t\t\t\tcase 'float32':\n\t\t\t\t\t\tattribute = new THREE.Float32BufferAttribute(array.data, size);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'uint8':\n\t\t\t\t\t\tattribute = new THREE.Uint8BufferAttribute(array.data, size);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'uint16':\n\t\t\t\t\t\tattribute = new THREE.Uint16BufferAttribute(array.data, size);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log('THREE.PlayCanvasLoader: Array type \"%s\" not yet supported.', type);\n\n\t\t\t\t}\n\n\t\t\t\tattributes[name] = attribute;\n\t\t\t}\n\n\t\t\tdata._attributes = attributes;\n\t\t}\n\n\t\tfunction parseMeshes(data) {\n\n\t\t\t// create buffer geometry\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tgeometry.setIndex(data.indices);\n\n\t\t\tvar attributes = model.vertices[data.vertices]._attributes;\n\n\t\t\tfor (var name in attributes) {\n\n\t\t\t\tvar attribute = attributes[name];\n\n\t\t\t\tif (name === 'texCoord0') name = 'uv';\n\n\t\t\t\tgeometry.addAttribute(name, attribute);\n\t\t\t}\n\n\t\t\tdata._geometry = geometry;\n\t\t}\n\n\t\tfunction parseMeshInstances(data) {\n\n\t\t\tvar node = model.nodes[data.node];\n\t\t\tvar mesh = model.meshes[data.mesh];\n\n\t\t\tif (node._geometries === undefined) {\n\n\t\t\t\tnode._geometries = [];\n\t\t\t}\n\n\t\t\tnode._geometries.push(mesh._geometry);\n\t\t}\n\n\t\tfunction parseNodes(data) {\n\n\t\t\tvar object = new THREE.Group();\n\n\t\t\tvar geometries = data._geometries;\n\n\t\t\tif (geometries !== undefined) {\n\n\t\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\t\tfor (var i = 0, l = geometries.length; i < l; i++) {\n\n\t\t\t\t\tvar geometry = geometries[i];\n\n\t\t\t\t\tobject.add(new THREE.Mesh(geometry, material));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var i = 0, l = data.rotation.length; i < l; i++) {\n\n\t\t\t\tdata.rotation[i] *= Math.PI / 180;\n\t\t\t}\n\n\t\t\t//\n\n\t\t\tobject.name = data.name;\n\n\t\t\tobject.position.fromArray(data.position);\n\t\t\tobject.quaternion.setFromEuler(new THREE.Euler().fromArray(data.rotation));\n\t\t\tobject.scale.fromArray(data.scale);\n\n\t\t\tdata._object = object;\n\t\t}\n\n\t\t//\n\n\t\tvar model = json.model;\n\n\t\tfor (var i = 0, l = model.vertices.length; i < l; i++) {\n\n\t\t\tparseVertices(model.vertices[i]);\n\t\t}\n\n\t\tfor (var i = 0, l = model.meshes.length; i < l; i++) {\n\n\t\t\tparseMeshes(model.meshes[i]);\n\t\t}\n\n\t\tfor (var i = 0, l = model.meshInstances.length; i < l; i++) {\n\n\t\t\tparseMeshInstances(model.meshInstances[i]);\n\t\t}\n\n\t\tfor (var i = 0, l = model.nodes.length; i < l; i++) {\n\n\t\t\tparseNodes(model.nodes[i]);\n\t\t}\n\n\t\t// setup scene hierarchy\n\n\t\tfor (var i = 0, l = model.parents.length; i < l; i++) {\n\n\t\t\tvar parent = model.parents[i];\n\n\t\t\tif (parent === -1) continue;\n\n\t\t\tmodel.nodes[parent]._object.add(model.nodes[i]._object);\n\t\t}\n\n\t\treturn model.nodes[0]._object;\n\t}\n\n};\n\nexports.default = PlayCanvasLoader;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Wei Meng / http://about.me/menway\n *\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new THREE.PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * ‚Äúdiffuse_(red|green|blue)‚Äù in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nvar PLYLoader = function PLYLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis.propertyNameMapping = {};\n};\n\nPLYLoader.prototype = {\n\n\tconstructor: PLYLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetPropertyNameMapping: function setPropertyNameMapping(mapping) {\n\n\t\tthis.propertyNameMapping = mapping;\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction parseHeader(data) {\n\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\s/;\n\t\t\tvar headerText = '';\n\t\t\tvar headerLength = 0;\n\t\t\tvar result = patternHeader.exec(data);\n\n\t\t\tif (result !== null) {\n\n\t\t\t\theaderText = result[1];\n\t\t\t\theaderLength = result[0].length;\n\t\t\t}\n\n\t\t\tvar header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength\n\t\t\t};\n\n\t\t\tvar lines = headerText.split('\\n');\n\t\t\tvar currentElement;\n\t\t\tvar lineType, lineValues;\n\n\t\t\tfunction make_ply_element_property(propertValues, propertyNameMapping) {\n\n\t\t\t\tvar property = { type: propertValues[0] };\n\n\t\t\t\tif (property.type === 'list') {\n\n\t\t\t\t\tproperty.name = propertValues[3];\n\t\t\t\t\tproperty.countType = propertValues[1];\n\t\t\t\t\tproperty.itemType = propertValues[2];\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[1];\n\t\t\t\t}\n\n\t\t\t\tif (property.name in propertyNameMapping) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[property.name];\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\t\tvar line = lines[i];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif (line === '') continue;\n\n\t\t\t\tlineValues = line.split(/\\s+/);\n\t\t\t\tlineType = lineValues.shift();\n\t\t\t\tline = lineValues.join(' ');\n\n\t\t\t\tswitch (lineType) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[0];\n\t\t\t\t\t\theader.version = lineValues[1];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push(line);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif (currentElement !== undefined) {\n\n\t\t\t\t\t\t\theader.elements.push(currentElement);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[0];\n\t\t\t\t\t\tcurrentElement.count = parseInt(lineValues[1]);\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log('unhandled', lineType, lineValues);\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (currentElement !== undefined) {\n\n\t\t\t\theader.elements.push(currentElement);\n\t\t\t}\n\n\t\t\treturn header;\n\t\t}\n\n\t\tfunction parseASCIINumber(n, type) {\n\n\t\t\tswitch (type) {\n\n\t\t\t\tcase 'char':case 'uchar':case 'short':case 'ushort':case 'int':case 'uint':\n\t\t\t\tcase 'int8':case 'uint8':case 'int16':case 'uint16':case 'int32':case 'uint32':\n\n\t\t\t\t\treturn parseInt(n);\n\n\t\t\t\tcase 'float':case 'double':case 'float32':case 'float64':\n\n\t\t\t\t\treturn parseFloat(n);\n\n\t\t\t}\n\t\t}\n\n\t\tfunction parseASCIIElement(properties, line) {\n\n\t\t\tvar values = line.split(/\\s+/);\n\n\t\t\tvar element = {};\n\n\t\t\tfor (var i = 0; i < properties.length; i++) {\n\n\t\t\t\tif (properties[i].type === 'list') {\n\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tvar n = parseASCIINumber(values.shift(), properties[i].countType);\n\n\t\t\t\t\tfor (var j = 0; j < n; j++) {\n\n\t\t\t\t\t\tlist.push(parseASCIINumber(values.shift(), properties[i].itemType));\n\t\t\t\t\t}\n\n\t\t\t\t\telement[properties[i].name] = list;\n\t\t\t\t} else {\n\n\t\t\t\t\telement[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn element;\n\t\t}\n\n\t\tfunction parseASCII(data, header) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar result;\n\n\t\t\tvar patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tvar body = '';\n\t\t\tif ((result = patternBody.exec(data)) !== null) {\n\n\t\t\t\tbody = result[1];\n\t\t\t}\n\n\t\t\tvar lines = body.split('\\n');\n\t\t\tvar currentElement = 0;\n\t\t\tvar currentElementCount = 0;\n\n\t\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\t\tvar line = lines[i];\n\t\t\t\tline = line.trim();\n\t\t\t\tif (line === '') {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (currentElementCount >= header.elements[currentElement].count) {\n\n\t\t\t\t\tcurrentElement++;\n\t\t\t\t\tcurrentElementCount = 0;\n\t\t\t\t}\n\n\t\t\t\tvar element = parseASCIIElement(header.elements[currentElement].properties, line);\n\n\t\t\t\thandleElement(buffer, header.elements[currentElement].name, element);\n\n\t\t\t\tcurrentElementCount++;\n\t\t\t}\n\n\t\t\treturn postProcess(buffer);\n\t\t}\n\n\t\tfunction postProcess(buffer) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif (buffer.indices.length > 0) {\n\n\t\t\t\tgeometry.setIndex(buffer.indices);\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(buffer.vertices, 3));\n\n\t\t\t// optional buffer data\n\n\t\t\tif (buffer.normals.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(buffer.normals, 3));\n\t\t\t}\n\n\t\t\tif (buffer.uvs.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(buffer.uvs, 2));\n\t\t\t}\n\n\t\t\tif (buffer.colors.length > 0) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.Float32BufferAttribute(buffer.colors, 3));\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction handleElement(buffer, elementName, element) {\n\n\t\t\tif (elementName === 'vertex') {\n\n\t\t\t\tbuffer.vertices.push(element.x, element.y, element.z);\n\n\t\t\t\tif ('nx' in element && 'ny' in element && 'nz' in element) {\n\n\t\t\t\t\tbuffer.normals.push(element.nx, element.ny, element.nz);\n\t\t\t\t}\n\n\t\t\t\tif ('s' in element && 't' in element) {\n\n\t\t\t\t\tbuffer.uvs.push(element.s, element.t);\n\t\t\t\t}\n\n\t\t\t\tif ('red' in element && 'green' in element && 'blue' in element) {\n\n\t\t\t\t\tbuffer.colors.push(element.red / 255.0, element.green / 255.0, element.blue / 255.0);\n\t\t\t\t}\n\t\t\t} else if (elementName === 'face') {\n\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n\t\t\t\tif (vertex_indices.length === 3) {\n\n\t\t\t\t\tbuffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n\t\t\t\t} else if (vertex_indices.length === 4) {\n\n\t\t\t\t\tbuffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n\t\t\t\t\tbuffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction binaryRead(dataview, at, type, little_endian) {\n\n\t\t\tswitch (type) {\n\n\t\t\t\t// corespondences for non-specific length types here match rply:\n\t\t\t\tcase 'int8':case 'char':\n\t\t\t\t\treturn [dataview.getInt8(at), 1];\n\t\t\t\tcase 'uint8':case 'uchar':\n\t\t\t\t\treturn [dataview.getUint8(at), 1];\n\t\t\t\tcase 'int16':case 'short':\n\t\t\t\t\treturn [dataview.getInt16(at, little_endian), 2];\n\t\t\t\tcase 'uint16':case 'ushort':\n\t\t\t\t\treturn [dataview.getUint16(at, little_endian), 2];\n\t\t\t\tcase 'int32':case 'int':\n\t\t\t\t\treturn [dataview.getInt32(at, little_endian), 4];\n\t\t\t\tcase 'uint32':case 'uint':\n\t\t\t\t\treturn [dataview.getUint32(at, little_endian), 4];\n\t\t\t\tcase 'float32':case 'float':\n\t\t\t\t\treturn [dataview.getFloat32(at, little_endian), 4];\n\t\t\t\tcase 'float64':case 'double':\n\t\t\t\t\treturn [dataview.getFloat64(at, little_endian), 8];\n\n\t\t\t}\n\t\t}\n\n\t\tfunction binaryReadElement(dataview, at, properties, little_endian) {\n\n\t\t\tvar element = {};\n\t\t\tvar result,\n\t\t\t    read = 0;\n\n\t\t\tfor (var i = 0; i < properties.length; i++) {\n\n\t\t\t\tif (properties[i].type === 'list') {\n\n\t\t\t\t\tvar list = [];\n\n\t\t\t\t\tresult = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n\t\t\t\t\tvar n = result[0];\n\t\t\t\t\tread += result[1];\n\n\t\t\t\t\tfor (var j = 0; j < n; j++) {\n\n\t\t\t\t\t\tresult = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n\t\t\t\t\t\tlist.push(result[0]);\n\t\t\t\t\t\tread += result[1];\n\t\t\t\t\t}\n\n\t\t\t\t\telement[properties[i].name] = list;\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead(dataview, at + read, properties[i].type, little_endian);\n\t\t\t\t\telement[properties[i].name] = result[0];\n\t\t\t\t\tread += result[1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn [element, read];\n\t\t}\n\n\t\tfunction parseBinary(data, header) {\n\n\t\t\tvar buffer = {\n\t\t\t\tindices: [],\n\t\t\t\tvertices: [],\n\t\t\t\tnormals: [],\n\t\t\t\tuvs: [],\n\t\t\t\tcolors: []\n\t\t\t};\n\n\t\t\tvar little_endian = header.format === 'binary_little_endian';\n\t\t\tvar body = new DataView(data, header.headerLength);\n\t\t\tvar result,\n\t\t\t    loc = 0;\n\n\t\t\tfor (var currentElement = 0; currentElement < header.elements.length; currentElement++) {\n\n\t\t\t\tfor (var currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n\n\t\t\t\t\tresult = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n\t\t\t\t\tloc += result[1];\n\t\t\t\t\tvar element = result[0];\n\n\t\t\t\t\thandleElement(buffer, header.elements[currentElement].name, element);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn postProcess(buffer);\n\t\t}\n\n\t\t//\n\n\t\tvar geometry;\n\t\tvar scope = this;\n\n\t\tif (data instanceof ArrayBuffer) {\n\n\t\t\tvar text = THREE.LoaderUtils.decodeText(new Uint8Array(data));\n\t\t\tvar header = parseHeader(text);\n\n\t\t\tgeometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n\t\t} else {\n\n\t\t\tgeometry = parseASCII(data, parseHeader(data));\n\t\t}\n\n\t\treturn geometry;\n\t}\n\n};\n\nexports.default = PLYLoader;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Kevin Chapelier / https://github.com/kchapelier\n * See https://github.com/kchapelier/PRWM for more informations about this file format\n */\n\nexports.default = function () {\n\n\t'use strict';\n\n\tvar bigEndianPlatform = null;\n\n\t/**\n  * Check if the endianness of the platform is big-endian (most significant bit first)\n  * @returns {boolean} True if big-endian, false if little-endian\n  */\n\tfunction isBigEndianPlatform() {\n\n\t\tif (bigEndianPlatform === null) {\n\n\t\t\tvar buffer = new ArrayBuffer(2),\n\t\t\t    uint8Array = new Uint8Array(buffer),\n\t\t\t    uint16Array = new Uint16Array(buffer);\n\n\t\t\tuint8Array[0] = 0xAA; // set first byte\n\t\t\tuint8Array[1] = 0xBB; // set second byte\n\t\t\tbigEndianPlatform = uint16Array[0] === 0xAABB;\n\t\t}\n\n\t\treturn bigEndianPlatform;\n\t}\n\n\t// match the values defined in the spec to the TypedArray types\n\tvar InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array];\n\n\t// define the method to use on a DataView, corresponding the TypedArray type\n\tvar getMethods = {\n\t\tUint16Array: 'getUint16',\n\t\tUint32Array: 'getUint32',\n\t\tInt16Array: 'getInt16',\n\t\tInt32Array: 'getInt32',\n\t\tFloat32Array: 'getFloat32',\n\t\tFloat64Array: 'getFloat64'\n\t};\n\n\tfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n\n\t\tvar bytesPerElement = viewType.BYTES_PER_ELEMENT,\n\t\t    result;\n\n\t\tif (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\n\n\t\t\tresult = new viewType(sourceArrayBuffer, position, length);\n\t\t} else {\n\n\t\t\tvar readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n\t\t\t    getMethod = getMethods[viewType.name],\n\t\t\t    littleEndian = !fromBigEndian,\n\t\t\t    i = 0;\n\n\t\t\tresult = new viewType(length);\n\n\t\t\tfor (; i < length; i++) {\n\n\t\t\t\tresult[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tfunction decodePrwm(buffer) {\n\n\t\tvar array = new Uint8Array(buffer),\n\t\t    version = array[0],\n\t\t    flags = array[1],\n\t\t    indexedGeometry = !!(flags >> 7 & 0x01),\n\t\t    indicesType = flags >> 6 & 0x01,\n\t\t    bigEndian = (flags >> 5 & 0x01) === 1,\n\t\t    attributesNumber = flags & 0x1F,\n\t\t    valuesNumber = 0,\n\t\t    indicesNumber = 0;\n\n\t\tif (bigEndian) {\n\n\t\t\tvaluesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n\t\t\tindicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n\t\t} else {\n\n\t\t\tvaluesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n\t\t\tindicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n\t\t}\n\n\t\t/** PRELIMINARY CHECKS **/\n\n\t\tif (version === 0) {\n\n\t\t\tthrow new Error('PRWM decoder: Invalid format version: 0');\n\t\t} else if (version !== 1) {\n\n\t\t\tthrow new Error('PRWM decoder: Unsupported format version: ' + version);\n\t\t}\n\n\t\tif (!indexedGeometry) {\n\n\t\t\tif (indicesType !== 0) {\n\n\t\t\t\tthrow new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n\t\t\t} else if (indicesNumber !== 0) {\n\n\t\t\t\tthrow new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n\t\t\t}\n\t\t}\n\n\t\t/** PARSING **/\n\n\t\tvar pos = 8;\n\n\t\tvar attributes = {},\n\t\t    attributeName,\n\t\t    char,\n\t\t    attributeType,\n\t\t    cardinality,\n\t\t    encodingType,\n\t\t    arrayType,\n\t\t    values,\n\t\t    indices,\n\t\t    i;\n\n\t\tfor (i = 0; i < attributesNumber; i++) {\n\n\t\t\tattributeName = '';\n\n\t\t\twhile (pos < array.length) {\n\n\t\t\t\tchar = array[pos];\n\t\t\t\tpos++;\n\n\t\t\t\tif (char === 0) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\n\t\t\t\t\tattributeName += String.fromCharCode(char);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tflags = array[pos];\n\n\t\t\tattributeType = flags >> 7 & 0x01;\n\t\t\tcardinality = (flags >> 4 & 0x03) + 1;\n\t\t\tencodingType = flags & 0x0F;\n\t\t\tarrayType = InvertedEncodingTypes[encodingType];\n\n\t\t\tpos++;\n\n\t\t\t// padding to next multiple of 4\n\t\t\tpos = Math.ceil(pos / 4) * 4;\n\n\t\t\tvalues = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n\n\t\t\tpos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n\n\t\t\tattributes[attributeName] = {\n\t\t\t\ttype: attributeType,\n\t\t\t\tcardinality: cardinality,\n\t\t\t\tvalues: values\n\t\t\t};\n\t\t}\n\n\t\tpos = Math.ceil(pos / 4) * 4;\n\n\t\tindices = null;\n\n\t\tif (indexedGeometry) {\n\n\t\t\tindices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n\t\t}\n\n\t\treturn {\n\t\t\tversion: version,\n\t\t\tattributes: attributes,\n\t\t\tindices: indices\n\t\t};\n\t}\n\n\t// Define the public interface\n\n\tvar PRWMLoader = function PRWMLoader(manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t};\n\n\tPRWMLoader.prototype = {\n\n\t\tconstructor: PRWMLoader,\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\n\t\t\turl = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\n\n\t\t\tloader.load(url, function (arrayBuffer) {\n\n\t\t\t\tonLoad(scope.parse(arrayBuffer));\n\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\tparse: function parse(arrayBuffer) {\n\n\t\t\tconsole.time('PRWMLoader');\n\n\t\t\tvar data = decodePrwm(arrayBuffer),\n\t\t\t    attributesKey = Object.keys(data.attributes),\n\t\t\t    bufferGeometry = new THREE.BufferGeometry(),\n\t\t\t    attribute,\n\t\t\t    i;\n\n\t\t\tfor (i = 0; i < attributesKey.length; i++) {\n\n\t\t\t\tattribute = data.attributes[attributesKey[i]];\n\t\t\t\tbufferGeometry.addAttribute(attributesKey[i], new THREE.BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n\t\t\t}\n\n\t\t\tif (data.indices !== null) {\n\n\t\t\t\tbufferGeometry.setIndex(new THREE.BufferAttribute(data.indices, 1));\n\t\t\t}\n\n\t\t\tconsole.timeEnd('PRWMLoader');\n\n\t\t\treturn bufferGeometry;\n\t\t}\n\n\t};\n\n\tPRWMLoader.isBigEndianPlatform = function () {\n\n\t\treturn isBigEndianPlatform();\n\t};\n\n\treturn PRWMLoader;\n}();\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n *\t PVRLoader\n *   Author: pierre lepers\n *   Date: 17/09/2014 11:09\n *\n *\t PVR v2 (legacy) parser\n *   TODO : Add Support for PVR v3 format\n *   TODO : implement loadMipmaps option\n */\n\nvar PVRLoader = function PVRLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\tthis._parser = PVRLoader.parse;\n};\n\nPVRLoader.prototype = Object.create(THREE.CompressedTextureLoader.prototype);\nPVRLoader.prototype.constructor = PVRLoader;\n\nPVRLoader.parse = function (buffer, loadMipmaps) {\n\n\tvar headerLengthInt = 13;\n\tvar header = new Uint32Array(buffer, 0, headerLengthInt);\n\n\tvar pvrDatas = {\n\t\tbuffer: buffer,\n\t\theader: header,\n\t\tloadMipmaps: loadMipmaps\n\t};\n\n\tif (header[0] === 0x03525650) {\n\n\t\t// PVR v3\n\n\t\treturn PVRLoader._parseV3(pvrDatas);\n\t} else if (header[11] === 0x21525650) {\n\n\t\t// PVR v2\n\n\t\treturn PVRLoader._parseV2(pvrDatas);\n\t} else {\n\n\t\tconsole.error('THREE.PVRLoader: Unknown PVR format.');\n\t}\n};\n\nPVRLoader._parseV3 = function (pvrDatas) {\n\n\tvar header = pvrDatas.header;\n\tvar bpp, format;\n\n\tvar metaLen = header[12],\n\t    pixelFormat = header[2],\n\t    height = header[6],\n\t    width = header[7],\n\n\t// numSurfs = header[ 9 ],\n\tnumFaces = header[10],\n\t    numMipmaps = header[11];\n\n\tswitch (pixelFormat) {\n\n\t\tcase 0:\n\t\t\t// PVRTC 2bpp RGB\n\t\t\tbpp = 2;\n\t\t\tformat = THREE.RGB_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\t// PVRTC 2bpp RGBA\n\t\t\tbpp = 2;\n\t\t\tformat = THREE.RGBA_PVRTC_2BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\t// PVRTC 4bpp RGB\n\t\t\tbpp = 4;\n\t\t\tformat = THREE.RGB_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\t// PVRTC 4bpp RGBA\n\t\t\tbpp = 4;\n\t\t\tformat = THREE.RGBA_PVRTC_4BPPV1_Format;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tconsole.error('THREE.PVRLoader: Unsupported PVR format:', pixelFormat);\n\n\t}\n\n\tpvrDatas.dataPtr = 52 + metaLen;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numFaces;\n\tpvrDatas.numMipmaps = numMipmaps;\n\tpvrDatas.isCubemap = numFaces === 6;\n\n\treturn PVRLoader._extract(pvrDatas);\n};\n\nPVRLoader._parseV2 = function (pvrDatas) {\n\n\tvar header = pvrDatas.header;\n\n\tvar headerLength = header[0],\n\t    height = header[1],\n\t    width = header[2],\n\t    numMipmaps = header[3],\n\t    flags = header[4],\n\n\t// dataLength = header[ 5 ],\n\t// bpp =  header[ 6 ],\n\t// bitmaskRed = header[ 7 ],\n\t// bitmaskGreen = header[ 8 ],\n\t// bitmaskBlue = header[ 9 ],\n\tbitmaskAlpha = header[10],\n\n\t// pvrTag = header[ 11 ],\n\tnumSurfs = header[12];\n\n\tvar TYPE_MASK = 0xff;\n\tvar PVRTC_2 = 24,\n\t    PVRTC_4 = 25;\n\n\tvar formatFlags = flags & TYPE_MASK;\n\n\tvar bpp, format;\n\tvar _hasAlpha = bitmaskAlpha > 0;\n\n\tif (formatFlags === PVRTC_4) {\n\n\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_4BPPV1_Format : THREE.RGB_PVRTC_4BPPV1_Format;\n\t\tbpp = 4;\n\t} else if (formatFlags === PVRTC_2) {\n\n\t\tformat = _hasAlpha ? THREE.RGBA_PVRTC_2BPPV1_Format : THREE.RGB_PVRTC_2BPPV1_Format;\n\t\tbpp = 2;\n\t} else {\n\n\t\tconsole.error('THREE.PVRLoader: Unknown PVR format:', formatFlags);\n\t}\n\n\tpvrDatas.dataPtr = headerLength;\n\tpvrDatas.bpp = bpp;\n\tpvrDatas.format = format;\n\tpvrDatas.width = width;\n\tpvrDatas.height = height;\n\tpvrDatas.numSurfaces = numSurfs;\n\tpvrDatas.numMipmaps = numMipmaps + 1;\n\n\t// guess cubemap type seems tricky in v2\n\t// it juste a pvr containing 6 surface (no explicit cubemap type)\n\tpvrDatas.isCubemap = numSurfs === 6;\n\n\treturn PVRLoader._extract(pvrDatas);\n};\n\nPVRLoader._extract = function (pvrDatas) {\n\n\tvar pvr = {\n\t\tmipmaps: [],\n\t\twidth: pvrDatas.width,\n\t\theight: pvrDatas.height,\n\t\tformat: pvrDatas.format,\n\t\tmipmapCount: pvrDatas.numMipmaps,\n\t\tisCubemap: pvrDatas.isCubemap\n\t};\n\n\tvar buffer = pvrDatas.buffer;\n\n\tvar dataOffset = pvrDatas.dataPtr,\n\t    bpp = pvrDatas.bpp,\n\t    numSurfs = pvrDatas.numSurfaces,\n\t    dataSize = 0,\n\t    blockSize = 0,\n\t    blockWidth = 0,\n\t    blockHeight = 0,\n\t    widthBlocks = 0,\n\t    heightBlocks = 0;\n\n\tif (bpp === 2) {\n\n\t\tblockWidth = 8;\n\t\tblockHeight = 4;\n\t} else {\n\n\t\tblockWidth = 4;\n\t\tblockHeight = 4;\n\t}\n\n\tblockSize = blockWidth * blockHeight * bpp / 8;\n\n\tpvr.mipmaps.length = pvrDatas.numMipmaps * numSurfs;\n\n\tvar mipLevel = 0;\n\n\twhile (mipLevel < pvrDatas.numMipmaps) {\n\n\t\tvar sWidth = pvrDatas.width >> mipLevel,\n\t\t    sHeight = pvrDatas.height >> mipLevel;\n\n\t\twidthBlocks = sWidth / blockWidth;\n\t\theightBlocks = sHeight / blockHeight;\n\n\t\t// Clamp to minimum number of blocks\n\t\tif (widthBlocks < 2) widthBlocks = 2;\n\t\tif (heightBlocks < 2) heightBlocks = 2;\n\n\t\tdataSize = widthBlocks * heightBlocks * blockSize;\n\n\t\tfor (var surfIndex = 0; surfIndex < numSurfs; surfIndex++) {\n\n\t\t\tvar byteArray = new Uint8Array(buffer, dataOffset, dataSize);\n\n\t\t\tvar mipmap = {\n\t\t\t\tdata: byteArray,\n\t\t\t\twidth: sWidth,\n\t\t\t\theight: sHeight\n\t\t\t};\n\n\t\t\tpvr.mipmaps[surfIndex * pvrDatas.numMipmaps + mipLevel] = mipmap;\n\n\t\t\tdataOffset += dataSize;\n\t\t}\n\n\t\tmipLevel++;\n\t}\n\n\treturn pvr;\n};\n\nexports.default = PVRLoader;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\n\nvar STLLoader = function STLLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nSTLLoader.prototype = {\n\n\tconstructor: STLLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad(scope.parse(text));\n\t\t\t} catch (exception) {\n\n\t\t\t\tif (onError) {\n\n\t\t\t\t\tonError(exception);\n\t\t\t\t}\n\t\t\t}\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction isBinary(data) {\n\n\t\t\tvar expect, face_size, n_faces, reader;\n\t\t\treader = new DataView(data);\n\t\t\tface_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n\t\t\tn_faces = reader.getUint32(80, true);\n\t\t\texpect = 80 + 32 / 8 + n_faces * face_size;\n\n\t\t\tif (expect === reader.byteLength) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// An ASCII STL data must begin with 'solid ' as the first six bytes.\n\t\t\t// However, ASCII STLs lacking the SPACE after the 'd' are known to be\n\t\t\t// plentiful.  So, check the first 5 bytes for 'solid'.\n\n\t\t\t// US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n\t\t\tvar solid = [115, 111, 108, 105, 100];\n\n\t\t\tfor (var i = 0; i < 5; i++) {\n\n\t\t\t\t// If solid[ i ] does not match the i-th byte, then it is not an\n\t\t\t\t// ASCII STL; hence, it is binary and return true.\n\n\t\t\t\tif (solid[i] != reader.getUint8(i, false)) return true;\n\t\t\t}\n\n\t\t\t// First 5 bytes read \"solid\"; declare it to be an ASCII STL\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction parseBinary(data) {\n\n\t\t\tvar reader = new DataView(data);\n\t\t\tvar faces = reader.getUint32(80, true);\n\n\t\t\tvar r,\n\t\t\t    g,\n\t\t\t    b,\n\t\t\t    hasColors = false,\n\t\t\t    colors;\n\t\t\tvar defaultR, defaultG, defaultB, alpha;\n\n\t\t\t// process STL header\n\t\t\t// check for default color in header (\"COLOR=rgba\" sequence).\n\n\t\t\tfor (var index = 0; index < 80 - 10; index++) {\n\n\t\t\t\tif (reader.getUint32(index, false) == 0x434F4C4F /*COLO*/ && reader.getUint8(index + 4) == 0x52 /*'R'*/ && reader.getUint8(index + 5) == 0x3D /*'='*/) {\n\n\t\t\t\t\thasColors = true;\n\t\t\t\t\tcolors = [];\n\n\t\t\t\t\tdefaultR = reader.getUint8(index + 6) / 255;\n\t\t\t\t\tdefaultG = reader.getUint8(index + 7) / 255;\n\t\t\t\t\tdefaultB = reader.getUint8(index + 8) / 255;\n\t\t\t\t\talpha = reader.getUint8(index + 9) / 255;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar dataOffset = 84;\n\t\t\tvar faceLength = 12 * 4 + 2;\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\n\t\t\tfor (var face = 0; face < faces; face++) {\n\n\t\t\t\tvar start = dataOffset + face * faceLength;\n\t\t\t\tvar normalX = reader.getFloat32(start, true);\n\t\t\t\tvar normalY = reader.getFloat32(start + 4, true);\n\t\t\t\tvar normalZ = reader.getFloat32(start + 8, true);\n\n\t\t\t\tif (hasColors) {\n\n\t\t\t\t\tvar packedColor = reader.getUint16(start + 48, true);\n\n\t\t\t\t\tif ((packedColor & 0x8000) === 0) {\n\n\t\t\t\t\t\t// facet has its own unique color\n\n\t\t\t\t\t\tr = (packedColor & 0x1F) / 31;\n\t\t\t\t\t\tg = (packedColor >> 5 & 0x1F) / 31;\n\t\t\t\t\t\tb = (packedColor >> 10 & 0x1F) / 31;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tr = defaultR;\n\t\t\t\t\t\tg = defaultG;\n\t\t\t\t\t\tb = defaultB;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 1; i <= 3; i++) {\n\n\t\t\t\t\tvar vertexstart = start + i * 12;\n\n\t\t\t\t\tvertices.push(reader.getFloat32(vertexstart, true));\n\t\t\t\t\tvertices.push(reader.getFloat32(vertexstart + 4, true));\n\t\t\t\t\tvertices.push(reader.getFloat32(vertexstart + 8, true));\n\n\t\t\t\t\tnormals.push(normalX, normalY, normalZ);\n\n\t\t\t\t\tif (hasColors) {\n\n\t\t\t\t\t\tcolors.push(r, g, b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));\n\n\t\t\tif (hasColors) {\n\n\t\t\t\tgeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));\n\t\t\t\tgeometry.hasColors = true;\n\t\t\t\tgeometry.alpha = alpha;\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseASCII(data) {\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tvar patternFace = /facet([\\s\\S]*?)endfacet/g;\n\t\t\tvar faceCounter = 0;\n\n\t\t\tvar patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source;\n\t\t\tvar patternVertex = new RegExp('vertex' + patternFloat + patternFloat + patternFloat, 'g');\n\t\t\tvar patternNormal = new RegExp('normal' + patternFloat + patternFloat + patternFloat, 'g');\n\n\t\t\tvar vertices = [];\n\t\t\tvar normals = [];\n\n\t\t\tvar normal = new THREE.Vector3();\n\n\t\t\tvar result;\n\n\t\t\twhile ((result = patternFace.exec(data)) !== null) {\n\n\t\t\t\tvar vertexCountPerFace = 0;\n\t\t\t\tvar normalCountPerFace = 0;\n\n\t\t\t\tvar text = result[0];\n\n\t\t\t\twhile ((result = patternNormal.exec(text)) !== null) {\n\n\t\t\t\t\tnormal.x = parseFloat(result[1]);\n\t\t\t\t\tnormal.y = parseFloat(result[2]);\n\t\t\t\t\tnormal.z = parseFloat(result[3]);\n\t\t\t\t\tnormalCountPerFace++;\n\t\t\t\t}\n\n\t\t\t\twhile ((result = patternVertex.exec(text)) !== null) {\n\n\t\t\t\t\tvertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n\t\t\t\t\tnormals.push(normal.x, normal.y, normal.z);\n\t\t\t\t\tvertexCountPerFace++;\n\t\t\t\t}\n\n\t\t\t\t// every face have to own ONE valid normal\n\n\t\t\t\tif (normalCountPerFace !== 1) {\n\n\t\t\t\t\tconsole.error('THREE.STLLoader: Something isn\\'t right with the normal of face number ' + faceCounter);\n\t\t\t\t}\n\n\t\t\t\t// each face have to own THREE valid vertices\n\n\t\t\t\tif (vertexCountPerFace !== 3) {\n\n\t\t\t\t\tconsole.error('THREE.STLLoader: Something isn\\'t right with the vertices of face number ' + faceCounter);\n\t\t\t\t}\n\n\t\t\t\tfaceCounter++;\n\t\t\t}\n\n\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\t\t\tgeometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction ensureString(buffer) {\n\n\t\t\tif (typeof buffer !== 'string') {\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(buffer));\n\t\t\t}\n\n\t\t\treturn buffer;\n\t\t}\n\n\t\tfunction ensureBinary(buffer) {\n\n\t\t\tif (typeof buffer === 'string') {\n\n\t\t\t\tvar array_buffer = new Uint8Array(buffer.length);\n\t\t\t\tfor (var i = 0; i < buffer.length; i++) {\n\n\t\t\t\t\tarray_buffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n\t\t\t\t}\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\t\t\t} else {\n\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\n\t\t// start\n\n\t\tvar binData = ensureBinary(data);\n\n\t\treturn isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data));\n\t}\n\n};\n\nexports.default = STLLoader;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author zz85 / http://joshuakoo.com/\n */\n\nvar SVGLoader = function SVGLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nSVGLoader.prototype = {\n\n\tconstructor: SVGLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(text) {\n\n\t\tfunction parseNode(node, style) {\n\n\t\t\tif (node.nodeType !== 1) return;\n\n\t\t\tswitch (node.nodeName) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (node.hasAttribute('d') && isVisible(style)) paths.push(parsePathNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseRectNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parsePolygonNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parsePolylineNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseCircleNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseEllipseNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle(node, style);\n\t\t\t\t\tif (isVisible(style)) paths.push(parseLineNode(node, style));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log(node);\n\n\t\t\t}\n\n\t\t\tvar nodes = node.childNodes;\n\n\t\t\tfor (var i = 0; i < nodes.length; i++) {\n\n\t\t\t\tparseNode(nodes[i], style);\n\t\t\t}\n\t\t}\n\n\t\tfunction parsePathNode(node, style) {\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\n\t\t\tvar point = new THREE.Vector2();\n\t\t\tvar control = new THREE.Vector2();\n\n\t\t\tvar d = node.getAttribute('d');\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match(/[a-df-z][^a-df-z]*/ig);\n\n\t\t\tfor (var i = 0, l = commands.length; i < l; i++) {\n\n\t\t\t\tvar command = commands[i];\n\n\t\t\t\tvar type = command.charAt(0);\n\t\t\t\tvar data = command.substr(1).trim();\n\n\t\t\t\tswitch (type) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x = numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.moveTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.x = numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.y = numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x = numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 6) {\n\t\t\t\t\t\t\tpath.bezierCurveTo(numbers[j + 0], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], numbers[j + 5]);\n\t\t\t\t\t\t\tcontrol.x = numbers[j + 2];\n\t\t\t\t\t\t\tcontrol.y = numbers[j + 3];\n\t\t\t\t\t\t\tpoint.x = numbers[j + 4];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 5];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.bezierCurveTo(getReflection(point.x, control.x), getReflection(point.y, control.y), numbers[0], numbers[1], numbers[2], numbers[3]);\n\t\t\t\t\t\tcontrol.x = numbers[0];\n\t\t\t\t\t\tcontrol.y = numbers[1];\n\t\t\t\t\t\tpoint.x = numbers[2];\n\t\t\t\t\t\tpoint.y = numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.quadraticCurveTo(numbers[0], numbers[1], numbers[2], numbers[3]);\n\t\t\t\t\t\tcontrol.x = numbers[0];\n\t\t\t\t\t\tcontrol.y = numbers[1];\n\t\t\t\t\t\tpoint.x = numbers[2];\n\t\t\t\t\t\tpoint.y = numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tvar rx = getReflection(point.x, control.x);\n\t\t\t\t\t\tvar ry = getReflection(point.y, control.y);\n\t\t\t\t\t\tpath.quadraticCurveTo(rx, ry, numbers[0], numbers[1]);\n\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\tpoint.x = numbers[0];\n\t\t\t\t\t\tpoint.y = numbers[1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 7) {\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[j + 5];\n\t\t\t\t\t\t\tpoint.y = numbers[j + 6];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x += numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.moveTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.x += numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j++) {\n\t\t\t\t\t\t\tpoint.y += numbers[j];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 2) {\n\t\t\t\t\t\t\tpoint.x += numbers[j + 0];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 1];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo(point.x, point.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 6) {\n\t\t\t\t\t\t\tpath.bezierCurveTo(point.x + numbers[j + 0], point.y + numbers[j + 1], point.x + numbers[j + 2], point.y + numbers[j + 3], point.x + numbers[j + 4], point.y + numbers[j + 5]);\n\t\t\t\t\t\t\tpoint.x += numbers[j + 4];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 5];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t// TODO: Not sure if point needs\n\t\t\t\t\t\t// to be added to reflection...\n\t\t\t\t\t\tgetReflection(point.x, control.x), getReflection(point.y, control.y), point.x + numbers[0], point.y + numbers[1], point.x + numbers[2], point.y + numbers[3]);\n\t\t\t\t\t\tcontrol.x = point.x + numbers[0];\n\t\t\t\t\t\tcontrol.y = point.y + numbers[1];\n\t\t\t\t\t\tpoint.x += numbers[2];\n\t\t\t\t\t\tpoint.y += numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tpath.quadraticCurveTo(point.x + numbers[0], point.y + numbers[1], point.x + numbers[2], point.y + numbers[3]);\n\t\t\t\t\t\tcontrol.x = point.x + numbers[0];\n\t\t\t\t\t\tcontrol.y = point.y + numbers[1];\n\t\t\t\t\t\tpoint.x += numbers[2];\n\t\t\t\t\t\tpoint.y += numbers[3];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tvar rx = getReflection(point.x, control.x);\n\t\t\t\t\t\tvar ry = getReflection(point.y, control.y);\n\t\t\t\t\t\tpath.quadraticCurveTo(rx, ry, point.x + numbers[0], point.y + numbers[1]);\n\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\tpoint.x = point.x + numbers[0];\n\t\t\t\t\t\tpoint.y = point.y + numbers[1];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats(data);\n\t\t\t\t\t\tfor (var j = 0, jl = numbers.length; j < jl; j += 7) {\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[j + 5];\n\t\t\t\t\t\t\tpoint.y += numbers[j + 6];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(path, numbers[j], numbers[j + 1], numbers[j + 2], numbers[j + 3], numbers[j + 4], start, point);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t//\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn(command);\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\t\t\t}\n\n\t\t\treturn path;\n\t\t}\n\n\t\t/**\n   * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n   * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n   * From\n   * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n   * To\n   * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n   */\n\n\t\tfunction parseArcCommand(path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end) {\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs(rx);\n\t\t\try = Math.abs(ry);\n\n\t\t\t// Compute (x1‚Ä≤, y1‚Ä≤)\n\t\t\tvar dx2 = (start.x - end.x) / 2.0;\n\t\t\tvar dy2 = (start.y - end.y) / 2.0;\n\t\t\tvar x1p = Math.cos(x_axis_rotation) * dx2 + Math.sin(x_axis_rotation) * dy2;\n\t\t\tvar y1p = -Math.sin(x_axis_rotation) * dx2 + Math.cos(x_axis_rotation) * dy2;\n\n\t\t\t// Compute (cx‚Ä≤, cy‚Ä≤)\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif (cr > 1) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt(cr);\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\t\t\t}\n\n\t\t\tvar dq = rxs * y1ps + rys * x1ps;\n\t\t\tvar pq = (rxs * rys - dq) / dq;\n\t\t\tvar q = Math.sqrt(Math.max(0, pq));\n\t\t\tif (large_arc_flag === sweep_flag) q = -q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = -q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx‚Ä≤, cy‚Ä≤)\n\t\t\tvar cx = Math.cos(x_axis_rotation) * cxp - Math.sin(x_axis_rotation) * cyp + (start.x + end.x) / 2;\n\t\t\tvar cy = Math.sin(x_axis_rotation) * cxp + Math.cos(x_axis_rotation) * cyp + (start.y + end.y) / 2;\n\n\t\t\t// Step 4: Compute Œ∏1 and ŒîŒ∏\n\t\t\tvar theta = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);\n\t\t\tvar delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry, (-x1p - cxp) / rx, (-y1p - cyp) / ry) % (Math.PI * 2);\n\n\t\t\tpath.currentPath.absellipse(cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation);\n\t\t}\n\n\t\tfunction svgAngle(ux, uy, vx, vy) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\t\t\tvar ang = Math.acos(Math.max(-1, Math.min(1, dot / len))); // floating point precision, slightly over values appear\n\t\t\tif (ux * vy - uy * vx < 0) ang = -ang;\n\t\t\treturn ang;\n\t\t}\n\n\t\t/*\n  * According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n  * rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n  */\n\t\tfunction parseRectNode(node, style) {\n\n\t\t\tvar x = parseFloat(node.getAttribute('x') || 0);\n\t\t\tvar y = parseFloat(node.getAttribute('y') || 0);\n\t\t\tvar rx = parseFloat(node.getAttribute('rx') || 0);\n\t\t\tvar ry = parseFloat(node.getAttribute('ry') || 0);\n\t\t\tvar w = parseFloat(node.getAttribute('width'));\n\t\t\tvar h = parseFloat(node.getAttribute('height'));\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\t\t\tpath.moveTo(x + 2 * rx, y);\n\t\t\tpath.lineTo(x + w - 2 * rx, y);\n\t\t\tif (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y, x + w, y, x + w, y + 2 * ry);\n\t\t\tpath.lineTo(x + w, y + h - 2 * ry);\n\t\t\tif (rx !== 0 || ry !== 0) path.bezierCurveTo(x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h);\n\t\t\tpath.lineTo(x + 2 * rx, y + h);\n\n\t\t\tif (rx !== 0 || ry !== 0) {\n\n\t\t\t\tpath.bezierCurveTo(x, y + h, x, y + h, x, y + h - 2 * ry);\n\t\t\t\tpath.lineTo(x, y + 2 * ry);\n\t\t\t\tpath.bezierCurveTo(x, y, x, y, x + 2 * rx, y);\n\t\t\t}\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parsePolygonNode(node, style) {\n\n\t\t\tfunction iterator(match, a, b) {\n\n\t\t\t\tvar x = parseFloat(a);\n\t\t\t\tvar y = parseFloat(b);\n\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tpath.moveTo(x, y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(x, y);\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute('points').replace(regex, iterator);\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parsePolylineNode(node, style) {\n\n\t\t\tfunction iterator(match, a, b) {\n\n\t\t\t\tvar x = parseFloat(a);\n\t\t\t\tvar y = parseFloat(b);\n\n\t\t\t\tif (index === 0) {\n\t\t\t\t\tpath.moveTo(x, y);\n\t\t\t\t} else {\n\t\t\t\t\tpath.lineTo(x, y);\n\t\t\t\t}\n\n\t\t\t\tindex++;\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute('points').replace(regex, iterator);\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parseCircleNode(node, style) {\n\n\t\t\tvar x = parseFloat(node.getAttribute('cx'));\n\t\t\tvar y = parseFloat(node.getAttribute('cy'));\n\t\t\tvar r = parseFloat(node.getAttribute('r'));\n\n\t\t\tvar subpath = new THREE.Path();\n\t\t\tsubpath.absarc(x, y, r, 0, Math.PI * 2);\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\t\t\tpath.subPaths.push(subpath);\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parseEllipseNode(node, style) {\n\n\t\t\tvar x = parseFloat(node.getAttribute('cx'));\n\t\t\tvar y = parseFloat(node.getAttribute('cy'));\n\t\t\tvar rx = parseFloat(node.getAttribute('rx'));\n\t\t\tvar ry = parseFloat(node.getAttribute('ry'));\n\n\t\t\tvar subpath = new THREE.Path();\n\t\t\tsubpath.absellipse(x, y, rx, ry, 0, Math.PI * 2);\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.color.setStyle(style.fill);\n\t\t\tpath.subPaths.push(subpath);\n\n\t\t\treturn path;\n\t\t}\n\n\t\tfunction parseLineNode(node, style) {\n\n\t\t\tvar x1 = parseFloat(node.getAttribute('x1'));\n\t\t\tvar y1 = parseFloat(node.getAttribute('y1'));\n\t\t\tvar x2 = parseFloat(node.getAttribute('x2'));\n\t\t\tvar y2 = parseFloat(node.getAttribute('y2'));\n\n\t\t\tvar path = new THREE.ShapePath();\n\t\t\tpath.moveTo(x1, y1);\n\t\t\tpath.lineTo(x2, y2);\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle(node, style) {\n\n\t\t\tstyle = Object.assign({}, style); // clone style\n\n\t\t\tif (node.hasAttribute('fill')) style.fill = node.getAttribute('fill');\n\t\t\tif (node.style.fill !== '') style.fill = node.style.fill;\n\n\t\t\treturn style;\n\t\t}\n\n\t\tfunction isVisible(style) {\n\n\t\t\treturn style.fill !== 'none' && style.fill !== 'transparent';\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection(a, b) {\n\n\t\t\treturn 2 * a - (b - a);\n\t\t}\n\n\t\tfunction parseFloats(string) {\n\n\t\t\tvar array = string.split(/[\\s,]+|(?=\\s?[+\\-])/);\n\n\t\t\tfor (var i = 0; i < array.length; i++) {\n\n\t\t\t\tarray[i] = parseFloat(array[i]);\n\t\t\t}\n\n\t\t\treturn array;\n\t\t}\n\n\t\t//\n\n\t\tconsole.log('THREE.SVGLoader');\n\n\t\tvar paths = [];\n\n\t\tconsole.time('THREE.SVGLoader: DOMParser');\n\n\t\tvar xml = new DOMParser().parseFromString(text, 'image/svg+xml'); // application/xml\n\n\t\tconsole.timeEnd('THREE.SVGLoader: DOMParser');\n\n\t\tconsole.time('THREE.SVGLoader: Parse');\n\n\t\tparseNode(xml.documentElement, { fill: '#000' });\n\n\t\t// console.log( paths );\n\n\t\tconsole.timeEnd('THREE.SVGLoader: Parse');\n\n\t\treturn paths;\n\t}\n\n};\n\nexports.default = SVGLoader;\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * Autodesk 3DS threee.js file loader, based on lib3ds.\n *\n * Loads geometry with uv and materials basic properties with texture support.\n *\n * @author @tentone\n * @author @timknip\n * @class TDSLoader\n * @constructor\n */\n\n'use strict';\n\nvar TDSLoader = function TDSLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.debug = false;\n\n\tthis.group = null;\n\tthis.position = 0;\n\n\tthis.materials = [];\n\tthis.meshes = [];\n};\n\nTDSLoader.prototype = {\n\n\tconstructor: TDSLoader,\n\n\t/**\n  * Load 3ds file from url.\n  *\n  * @method load\n  * @param {[type]} url URL for the file.\n  * @param {Function} onLoad onLoad callback, receives group Object3D as argument.\n  * @param {Function} onProgress onProgress callback.\n  * @param {Function} onError onError callback.\n  */\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase(url);\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\n\t\tloader.setResponseType('arraybuffer');\n\n\t\tloader.load(url, function (data) {\n\n\t\t\tonLoad(scope.parse(data, path));\n\t\t}, onProgress, onError);\n\t},\n\n\t/**\n  * Parse arraybuffer data and load 3ds file.\n  *\n  * @method parse\n  * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n  * @param {String} path Path for external resources.\n  * @return {Object3D} Group loaded from 3ds file.\n  */\n\tparse: function parse(arraybuffer, path) {\n\n\t\tthis.group = new THREE.Group();\n\t\tthis.position = 0;\n\t\tthis.materials = [];\n\t\tthis.meshes = [];\n\n\t\tthis.readFile(arraybuffer, path);\n\n\t\tfor (var i = 0; i < this.meshes.length; i++) {\n\n\t\t\tthis.group.add(this.meshes[i]);\n\t\t}\n\n\t\treturn this.group;\n\t},\n\n\t/**\n  * Decode file content to read 3ds data.\n  *\n  * @method readFile\n  * @param {ArrayBuffer} arraybuffer Arraybuffer data to be loaded.\n  */\n\treadFile: function readFile(arraybuffer, path) {\n\n\t\tvar data = new DataView(arraybuffer);\n\t\tvar chunk = this.readChunk(data);\n\n\t\tif (chunk.id === MLIBMAGIC || chunk.id === CMAGIC || chunk.id === M3DMAGIC) {\n\n\t\t\tvar next = this.nextChunk(data, chunk);\n\n\t\t\twhile (next !== 0) {\n\n\t\t\t\tif (next === M3D_VERSION) {\n\n\t\t\t\t\tvar version = this.readDWord(data);\n\t\t\t\t\tthis.debugMessage('3DS file version: ' + version);\n\t\t\t\t} else if (next === MDATA) {\n\n\t\t\t\t\tthis.resetPosition(data);\n\t\t\t\t\tthis.readMeshData(data, path);\n\t\t\t\t} else {\n\n\t\t\t\t\tthis.debugMessage('Unknown main chunk: ' + next.toString(16));\n\t\t\t\t}\n\n\t\t\t\tnext = this.nextChunk(data, chunk);\n\t\t\t}\n\t\t}\n\n\t\tthis.debugMessage('Parsed ' + this.meshes.length + ' meshes');\n\t},\n\n\t/**\n  * Read mesh data chunk.\n  *\n  * @method readMeshData\n  * @param {Dataview} data Dataview in use.\n  */\n\treadMeshData: function readMeshData(data, path) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === MESH_VERSION) {\n\n\t\t\t\tvar version = +this.readDWord(data);\n\t\t\t\tthis.debugMessage('Mesh Version: ' + version);\n\t\t\t} else if (next === MASTER_SCALE) {\n\n\t\t\t\tvar scale = this.readFloat(data);\n\t\t\t\tthis.debugMessage('Master scale: ' + scale);\n\t\t\t\tthis.group.scale.set(scale, scale, scale);\n\t\t\t} else if (next === NAMED_OBJECT) {\n\n\t\t\t\tthis.debugMessage('Named Object');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tthis.readNamedObject(data);\n\t\t\t} else if (next === MAT_ENTRY) {\n\n\t\t\t\tthis.debugMessage('Material');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tthis.readMaterialEntry(data, path);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('Unknown MDATA chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\t},\n\n\t/**\n  * Read named object chunk.\n  *\n  * @method readNamedObject\n  * @param {Dataview} data Dataview in use.\n  */\n\treadNamedObject: function readNamedObject(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar name = this.readString(data, 64);\n\t\tchunk.cur = this.position;\n\n\t\tvar next = this.nextChunk(data, chunk);\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === N_TRI_OBJECT) {\n\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tvar mesh = this.readMesh(data);\n\t\t\t\tmesh.name = name;\n\t\t\t\tthis.meshes.push(mesh);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('Unknown named object chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\t},\n\n\t/**\n  * Read material data chunk and add it to the material list.\n  *\n  * @method readMaterialEntry\n  * @param {Dataview} data Dataview in use.\n  */\n\treadMaterialEntry: function readMaterialEntry(data, path) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === MAT_NAME) {\n\n\t\t\t\tmaterial.name = this.readString(data, 64);\n\t\t\t\tthis.debugMessage('   Name: ' + material.name);\n\t\t\t} else if (next === MAT_WIRE) {\n\n\t\t\t\tthis.debugMessage('   Wireframe');\n\t\t\t\tmaterial.wireframe = true;\n\t\t\t} else if (next === MAT_WIRE_SIZE) {\n\n\t\t\t\tvar value = this.readByte(data);\n\t\t\t\tmaterial.wireframeLinewidth = value;\n\t\t\t\tthis.debugMessage('   Wireframe Thickness: ' + value);\n\t\t\t} else if (next === MAT_TWO_SIDE) {\n\n\t\t\t\tmaterial.side = THREE.DoubleSide;\n\t\t\t\tthis.debugMessage('   DoubleSided');\n\t\t\t} else if (next === MAT_ADDITIVE) {\n\n\t\t\t\tthis.debugMessage('   Additive Blending');\n\t\t\t\tmaterial.blending = THREE.AdditiveBlending;\n\t\t\t} else if (next === MAT_DIFFUSE) {\n\n\t\t\t\tthis.debugMessage('   Diffuse Color');\n\t\t\t\tmaterial.color = this.readColor(data);\n\t\t\t} else if (next === MAT_SPECULAR) {\n\n\t\t\t\tthis.debugMessage('   Specular Color');\n\t\t\t\tmaterial.specular = this.readColor(data);\n\t\t\t} else if (next === MAT_AMBIENT) {\n\n\t\t\t\tthis.debugMessage('   Ambient color');\n\t\t\t\tmaterial.color = this.readColor(data);\n\t\t\t} else if (next === MAT_SHININESS) {\n\n\t\t\t\tvar shininess = this.readWord(data);\n\t\t\t\tmaterial.shininess = shininess;\n\t\t\t\tthis.debugMessage('   Shininess : ' + shininess);\n\t\t\t} else if (next === MAT_TEXMAP) {\n\n\t\t\t\tthis.debugMessage('   ColorMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.map = this.readMap(data, path);\n\t\t\t} else if (next === MAT_BUMPMAP) {\n\n\t\t\t\tthis.debugMessage('   BumpMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.bumpMap = this.readMap(data, path);\n\t\t\t} else if (next === MAT_OPACMAP) {\n\n\t\t\t\tthis.debugMessage('   OpacityMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.alphaMap = this.readMap(data, path);\n\t\t\t} else if (next === MAT_SPECMAP) {\n\n\t\t\t\tthis.debugMessage('   SpecularMap');\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tmaterial.specularMap = this.readMap(data, path);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('   Unknown material chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\n\t\tthis.materials[material.name] = material;\n\t},\n\n\t/**\n  * Read mesh data chunk.\n  *\n  * @method readMesh\n  * @param {Dataview} data Dataview in use.\n  */\n\treadMesh: function readMesh(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\n\t\tvar useBufferGeometry = false;\n\t\tvar geometry = null;\n\t\tvar uvs = [];\n\n\t\tif (useBufferGeometry) {\n\n\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t} else {\n\n\t\t\tgeometry = new THREE.Geometry();\n\t\t}\n\n\t\tvar material = new THREE.MeshPhongMaterial();\n\t\tvar mesh = new THREE.Mesh(geometry, material);\n\t\tmesh.name = 'mesh';\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === POINT_ARRAY) {\n\n\t\t\t\tvar points = this.readWord(data);\n\n\t\t\t\tthis.debugMessage('   Vertex: ' + points);\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tif (useBufferGeometry) {\n\n\t\t\t\t\tvar vertices = [];\n\t\t\t\t\tfor (var i = 0; i < points; i++) {\n\n\t\t\t\t\t\tvertices.push(this.readFloat(data));\n\t\t\t\t\t\tvertices.push(this.readFloat(data));\n\t\t\t\t\t\tvertices.push(this.readFloat(data));\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));\n\t\t\t\t} else {\n\t\t\t\t\t//Geometry\n\n\t\t\t\t\tfor (var i = 0; i < points; i++) {\n\n\t\t\t\t\t\tgeometry.vertices.push(new THREE.Vector3(this.readFloat(data), this.readFloat(data), this.readFloat(data)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (next === FACE_ARRAY) {\n\n\t\t\t\tthis.resetPosition(data);\n\t\t\t\tthis.readFaceArray(data, mesh);\n\t\t\t} else if (next === TEX_VERTS) {\n\n\t\t\t\tvar texels = this.readWord(data);\n\n\t\t\t\tthis.debugMessage('   UV: ' + texels);\n\n\t\t\t\t//BufferGeometry\n\n\t\t\t\tif (useBufferGeometry) {\n\n\t\t\t\t\tvar uvs = [];\n\t\t\t\t\tfor (var i = 0; i < texels; i++) {\n\n\t\t\t\t\t\tuvs.push(this.readFloat(data));\n\t\t\t\t\t\tuvs.push(this.readFloat(data));\n\t\t\t\t\t}\n\t\t\t\t\tgeometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(uvs), 2));\n\t\t\t\t} else {\n\t\t\t\t\t//Geometry\n\n\t\t\t\t\tuvs = [];\n\t\t\t\t\tfor (var i = 0; i < texels; i++) {\n\n\t\t\t\t\t\tuvs.push(new THREE.Vector2(this.readFloat(data), this.readFloat(data)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (next === MESH_MATRIX) {\n\n\t\t\t\tthis.debugMessage('   Tranformation Matrix (TODO)');\n\n\t\t\t\tvar values = [];\n\t\t\t\tfor (var i = 0; i < 12; i++) {\n\n\t\t\t\t\tvalues[i] = this.readFloat(data);\n\t\t\t\t}\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\n\t\t\t\t//X Line\n\t\t\t\tmatrix.elements[0] = values[0];\n\t\t\t\tmatrix.elements[1] = values[6];\n\t\t\t\tmatrix.elements[2] = values[3];\n\t\t\t\tmatrix.elements[3] = values[9];\n\n\t\t\t\t//Y Line\n\t\t\t\tmatrix.elements[4] = values[2];\n\t\t\t\tmatrix.elements[5] = values[8];\n\t\t\t\tmatrix.elements[6] = values[5];\n\t\t\t\tmatrix.elements[7] = values[11];\n\n\t\t\t\t//Z Line\n\t\t\t\tmatrix.elements[8] = values[1];\n\t\t\t\tmatrix.elements[9] = values[7];\n\t\t\t\tmatrix.elements[10] = values[4];\n\t\t\t\tmatrix.elements[11] = values[10];\n\n\t\t\t\t//W Line\n\t\t\t\tmatrix.elements[12] = 0;\n\t\t\t\tmatrix.elements[13] = 0;\n\t\t\t\tmatrix.elements[14] = 0;\n\t\t\t\tmatrix.elements[15] = 1;\n\n\t\t\t\tmatrix.transpose();\n\n\t\t\t\tvar inverse = new THREE.Matrix4();\n\t\t\t\tinverse.getInverse(matrix, true);\n\t\t\t\tgeometry.applyMatrix(inverse);\n\n\t\t\t\tmatrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('   Unknown mesh chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\n\t\tif (!useBufferGeometry) {\n\n\t\t\t//geometry.faceVertexUvs[0][faceIndex][vertexIndex]\n\n\t\t\tif (uvs.length > 0) {\n\n\t\t\t\tvar faceUV = [];\n\n\t\t\t\tfor (var i = 0; i < geometry.faces.length; i++) {\n\n\t\t\t\t\tfaceUV.push([uvs[geometry.faces[i].a], uvs[geometry.faces[i].b], uvs[geometry.faces[i].c]]);\n\t\t\t\t}\n\n\t\t\t\tgeometry.faceVertexUvs[0] = faceUV;\n\t\t\t}\n\n\t\t\tgeometry.computeVertexNormals();\n\t\t}\n\n\t\treturn mesh;\n\t},\n\n\t/**\n  * Read face array data chunk.\n  *\n  * @method readFaceArray\n  * @param {Dataview} data Dataview in use.\n  * @param {Mesh} mesh Mesh to be filled with the data read.\n  */\n\treadFaceArray: function readFaceArray(data, mesh) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar faces = this.readWord(data);\n\n\t\tthis.debugMessage('   Faces: ' + faces);\n\n\t\tfor (var i = 0; i < faces; ++i) {\n\n\t\t\tmesh.geometry.faces.push(new THREE.Face3(this.readWord(data), this.readWord(data), this.readWord(data)));\n\n\t\t\tvar visibility = this.readWord(data);\n\t\t}\n\n\t\t//The rest of the FACE_ARRAY chunk is subchunks\n\n\t\twhile (this.position < chunk.end) {\n\n\t\t\tvar chunk = this.readChunk(data);\n\n\t\t\tif (chunk.id === MSH_MAT_GROUP) {\n\n\t\t\t\tthis.debugMessage('      Material Group');\n\n\t\t\t\tthis.resetPosition(data);\n\n\t\t\t\tvar group = this.readMaterialGroup(data);\n\n\t\t\t\tvar material = this.materials[group.name];\n\n\t\t\t\tif (material !== undefined) {\n\n\t\t\t\t\tmesh.material = material;\n\n\t\t\t\t\tif (material.name === '') {\n\n\t\t\t\t\t\tmaterial.name = mesh.name;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('      Unknown face array chunk: ' + chunk.toString(16));\n\t\t\t}\n\n\t\t\tthis.endChunk(chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\t},\n\n\t/**\n  * Read texture map data chunk.\n  *\n  * @method readMap\n  * @param {Dataview} data Dataview in use.\n  * @return {Texture} Texture read from this data chunk.\n  */\n\treadMap: function readMap(data, path) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar next = this.nextChunk(data, chunk);\n\t\tvar texture = {};\n\n\t\tvar loader = new THREE.TextureLoader(this.manager);\n\t\tloader.setPath(path);\n\n\t\twhile (next !== 0) {\n\n\t\t\tif (next === MAT_MAPNAME) {\n\n\t\t\t\tvar name = this.readString(data, 128);\n\t\t\t\ttexture = loader.load(name);\n\n\t\t\t\tthis.debugMessage('      File: ' + path + name);\n\t\t\t} else if (next === MAT_MAP_UOFFSET) {\n\n\t\t\t\ttexture.offset.x = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      OffsetX: ' + texture.offset.x);\n\t\t\t} else if (next === MAT_MAP_VOFFSET) {\n\n\t\t\t\ttexture.offset.y = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      OffsetY: ' + texture.offset.y);\n\t\t\t} else if (next === MAT_MAP_USCALE) {\n\n\t\t\t\ttexture.repeat.x = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      RepeatX: ' + texture.repeat.x);\n\t\t\t} else if (next === MAT_MAP_VSCALE) {\n\n\t\t\t\ttexture.repeat.y = this.readFloat(data);\n\t\t\t\tthis.debugMessage('      RepeatY: ' + texture.repeat.y);\n\t\t\t} else {\n\n\t\t\t\tthis.debugMessage('      Unknown map chunk: ' + next.toString(16));\n\t\t\t}\n\n\t\t\tnext = this.nextChunk(data, chunk);\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\n\t\treturn texture;\n\t},\n\n\t/**\n  * Read material group data chunk.\n  *\n  * @method readMaterialGroup\n  * @param {Dataview} data Dataview in use.\n  * @return {Object} Object with name and index of the object.\n  */\n\treadMaterialGroup: function readMaterialGroup(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar name = this.readString(data, 64);\n\t\tvar numFaces = this.readWord(data);\n\n\t\tthis.debugMessage('         Name: ' + name);\n\t\tthis.debugMessage('         Faces: ' + numFaces);\n\n\t\tvar index = [];\n\t\tfor (var i = 0; i < numFaces; ++i) {\n\n\t\t\tindex.push(this.readWord(data));\n\t\t}\n\n\t\treturn { name: name, index: index };\n\t},\n\n\t/**\n  * Read a color value.\n  *\n  * @method readColor\n  * @param {DataView} data Dataview.\n  * @return {Color} Color value read..\n  */\n\treadColor: function readColor(data) {\n\n\t\tvar chunk = this.readChunk(data);\n\t\tvar color = new THREE.Color();\n\n\t\tif (chunk.id === COLOR_24 || chunk.id === LIN_COLOR_24) {\n\n\t\t\tvar r = this.readByte(data);\n\t\t\tvar g = this.readByte(data);\n\t\t\tvar b = this.readByte(data);\n\n\t\t\tcolor.setRGB(r / 255, g / 255, b / 255);\n\n\t\t\tthis.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n\t\t} else if (chunk.id === COLOR_F || chunk.id === LIN_COLOR_F) {\n\n\t\t\tvar r = this.readFloat(data);\n\t\t\tvar g = this.readFloat(data);\n\t\t\tvar b = this.readFloat(data);\n\n\t\t\tcolor.setRGB(r, g, b);\n\n\t\t\tthis.debugMessage('      Color: ' + color.r + ', ' + color.g + ', ' + color.b);\n\t\t} else {\n\n\t\t\tthis.debugMessage('      Unknown color chunk: ' + chunk.toString(16));\n\t\t}\n\n\t\tthis.endChunk(chunk);\n\t\treturn color;\n\t},\n\n\t/**\n  * Read next chunk of data.\n  *\n  * @method readChunk\n  * @param {DataView} data Dataview.\n  * @return {Object} Chunk of data read.\n  */\n\treadChunk: function readChunk(data) {\n\n\t\tvar chunk = {};\n\n\t\tchunk.cur = this.position;\n\t\tchunk.id = this.readWord(data);\n\t\tchunk.size = this.readDWord(data);\n\t\tchunk.end = chunk.cur + chunk.size;\n\t\tchunk.cur += 6;\n\n\t\treturn chunk;\n\t},\n\n\t/**\n  * Set position to the end of the current chunk of data.\n  *\n  * @method endChunk\n  * @param {Object} chunk Data chunk.\n  */\n\tendChunk: function endChunk(chunk) {\n\n\t\tthis.position = chunk.end;\n\t},\n\n\t/**\n  * Move to the next data chunk.\n  *\n  * @method nextChunk\n  * @param {DataView} data Dataview.\n  * @param {Object} chunk Data chunk.\n  */\n\tnextChunk: function nextChunk(data, chunk) {\n\n\t\tif (chunk.cur >= chunk.end) {\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tthis.position = chunk.cur;\n\n\t\ttry {\n\n\t\t\tvar next = this.readChunk(data);\n\t\t\tchunk.cur += next.size;\n\t\t\treturn next.id;\n\t\t} catch (e) {\n\n\t\t\tthis.debugMessage('Unable to read chunk at ' + this.position);\n\t\t\treturn 0;\n\t\t}\n\t},\n\n\t/**\n  * Reset dataview position.\n  *\n  * @method resetPosition\n  * @param {DataView} data Dataview.\n  */\n\tresetPosition: function resetPosition() {\n\n\t\tthis.position -= 6;\n\t},\n\n\t/**\n  * Read byte value.\n  *\n  * @method readByte\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadByte: function readByte(data) {\n\n\t\tvar v = data.getUint8(this.position, true);\n\t\tthis.position += 1;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 32 bit float value.\n  *\n  * @method readFloat\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadFloat: function readFloat(data) {\n\n\t\ttry {\n\n\t\t\tvar v = data.getFloat32(this.position, true);\n\t\t\tthis.position += 4;\n\t\t\treturn v;\n\t\t} catch (e) {\n\n\t\t\tthis.debugMessage(e + ' ' + this.position + ' ' + data.byteLength);\n\t\t}\n\t},\n\n\t/**\n  * Read 32 bit signed integer value.\n  *\n  * @method readInt\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadInt: function readInt(data) {\n\n\t\tvar v = data.getInt32(this.position, true);\n\t\tthis.position += 4;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 16 bit signed integer value.\n  *\n  * @method readShort\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadShort: function readShort(data) {\n\n\t\tvar v = data.getInt16(this.position, true);\n\t\tthis.position += 2;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 64 bit unsigned integer value.\n  *\n  * @method readDWord\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadDWord: function readDWord(data) {\n\n\t\tvar v = data.getUint32(this.position, true);\n\t\tthis.position += 4;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read 32 bit unsigned integer value.\n  *\n  * @method readWord\n  * @param {DataView} data Dataview to read data from.\n  * @return {Number} Data read from the dataview.\n  */\n\treadWord: function readWord(data) {\n\n\t\tvar v = data.getUint16(this.position, true);\n\t\tthis.position += 2;\n\t\treturn v;\n\t},\n\n\t/**\n  * Read string value.\n  *\n  * @method readString\n  * @param {DataView} data Dataview to read data from.\n  * @param {Number} maxLength Max size of the string to be read.\n  * @return {String} Data read from the dataview.\n  */\n\treadString: function readString(data, maxLength) {\n\n\t\tvar s = '';\n\n\t\tfor (var i = 0; i < maxLength; i++) {\n\n\t\t\tvar c = this.readByte(data);\n\t\t\tif (!c) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts += String.fromCharCode(c);\n\t\t}\n\n\t\treturn s;\n\t},\n\n\t/**\n  * Set resource path used to determine the file path to attached resources.\n  *\n  * @method setPath\n  * @param {String} path Path to resources.\n  * @return Self for chaining.\n  */\n\tsetPath: function setPath(path) {\n\n\t\tthis.path = path;\n\n\t\treturn this;\n\t},\n\n\t/**\n  * Print debug message to the console.\n  *\n  * Is controlled by a flag to show or hide debug messages.\n  *\n  * @method debugMessage\n  * @param {Object} message Debug message to print to the console.\n  */\n\tdebugMessage: function debugMessage(message) {\n\n\t\tif (this.debug) {\n\n\t\t\tconsole.log(message);\n\t\t}\n\t}\n};\n\nvar NULL_CHUNK = 0x0000;\nvar M3DMAGIC = 0x4D4D;\nvar SMAGIC = 0x2D2D;\nvar LMAGIC = 0x2D3D;\nvar MLIBMAGIC = 0x3DAA;\nvar MATMAGIC = 0x3DFF;\nvar CMAGIC = 0xC23D;\nvar M3D_VERSION = 0x0002;\nvar M3D_KFVERSION = 0x0005;\nvar COLOR_F = 0x0010;\nvar COLOR_24 = 0x0011;\nvar LIN_COLOR_24 = 0x0012;\nvar LIN_COLOR_F = 0x0013;\nvar INT_PERCENTAGE = 0x0030;\nvar FLOAT_PERCENTAGE = 0x0031;\nvar MDATA = 0x3D3D;\nvar MESH_VERSION = 0x3D3E;\nvar MASTER_SCALE = 0x0100;\nvar LO_SHADOW_BIAS = 0x1400;\nvar HI_SHADOW_BIAS = 0x1410;\nvar SHADOW_MAP_SIZE = 0x1420;\nvar SHADOW_SAMPLES = 0x1430;\nvar SHADOW_RANGE = 0x1440;\nvar SHADOW_FILTER = 0x1450;\nvar RAY_BIAS = 0x1460;\nvar O_CONSTS = 0x1500;\nvar AMBIENT_LIGHT = 0x2100;\nvar BIT_MAP = 0x1100;\nvar SOLID_BGND = 0x1200;\nvar V_GRADIENT = 0x1300;\nvar USE_BIT_MAP = 0x1101;\nvar USE_SOLID_BGND = 0x1201;\nvar USE_V_GRADIENT = 0x1301;\nvar FOG = 0x2200;\nvar FOG_BGND = 0x2210;\nvar LAYER_FOG = 0x2302;\nvar DISTANCE_CUE = 0x2300;\nvar DCUE_BGND = 0x2310;\nvar USE_FOG = 0x2201;\nvar USE_LAYER_FOG = 0x2303;\nvar USE_DISTANCE_CUE = 0x2301;\nvar MAT_ENTRY = 0xAFFF;\nvar MAT_NAME = 0xA000;\nvar MAT_AMBIENT = 0xA010;\nvar MAT_DIFFUSE = 0xA020;\nvar MAT_SPECULAR = 0xA030;\nvar MAT_SHININESS = 0xA040;\nvar MAT_SHIN2PCT = 0xA041;\nvar MAT_TRANSPARENCY = 0xA050;\nvar MAT_XPFALL = 0xA052;\nvar MAT_USE_XPFALL = 0xA240;\nvar MAT_REFBLUR = 0xA053;\nvar MAT_SHADING = 0xA100;\nvar MAT_USE_REFBLUR = 0xA250;\nvar MAT_SELF_ILLUM = 0xA084;\nvar MAT_TWO_SIDE = 0xA081;\nvar MAT_DECAL = 0xA082;\nvar MAT_ADDITIVE = 0xA083;\nvar MAT_WIRE = 0xA085;\nvar MAT_FACEMAP = 0xA088;\nvar MAT_TRANSFALLOFF_IN = 0xA08A;\nvar MAT_PHONGSOFT = 0xA08C;\nvar MAT_WIREABS = 0xA08E;\nvar MAT_WIRE_SIZE = 0xA087;\nvar MAT_TEXMAP = 0xA200;\nvar MAT_SXP_TEXT_DATA = 0xA320;\nvar MAT_TEXMASK = 0xA33E;\nvar MAT_SXP_TEXTMASK_DATA = 0xA32A;\nvar MAT_TEX2MAP = 0xA33A;\nvar MAT_SXP_TEXT2_DATA = 0xA321;\nvar MAT_TEX2MASK = 0xA340;\nvar MAT_SXP_TEXT2MASK_DATA = 0xA32C;\nvar MAT_OPACMAP = 0xA210;\nvar MAT_SXP_OPAC_DATA = 0xA322;\nvar MAT_OPACMASK = 0xA342;\nvar MAT_SXP_OPACMASK_DATA = 0xA32E;\nvar MAT_BUMPMAP = 0xA230;\nvar MAT_SXP_BUMP_DATA = 0xA324;\nvar MAT_BUMPMASK = 0xA344;\nvar MAT_SXP_BUMPMASK_DATA = 0xA330;\nvar MAT_SPECMAP = 0xA204;\nvar MAT_SXP_SPEC_DATA = 0xA325;\nvar MAT_SPECMASK = 0xA348;\nvar MAT_SXP_SPECMASK_DATA = 0xA332;\nvar MAT_SHINMAP = 0xA33C;\nvar MAT_SXP_SHIN_DATA = 0xA326;\nvar MAT_SHINMASK = 0xA346;\nvar MAT_SXP_SHINMASK_DATA = 0xA334;\nvar MAT_SELFIMAP = 0xA33D;\nvar MAT_SXP_SELFI_DATA = 0xA328;\nvar MAT_SELFIMASK = 0xA34A;\nvar MAT_SXP_SELFIMASK_DATA = 0xA336;\nvar MAT_REFLMAP = 0xA220;\nvar MAT_REFLMASK = 0xA34C;\nvar MAT_SXP_REFLMASK_DATA = 0xA338;\nvar MAT_ACUBIC = 0xA310;\nvar MAT_MAPNAME = 0xA300;\nvar MAT_MAP_TILING = 0xA351;\nvar MAT_MAP_TEXBLUR = 0xA353;\nvar MAT_MAP_USCALE = 0xA354;\nvar MAT_MAP_VSCALE = 0xA356;\nvar MAT_MAP_UOFFSET = 0xA358;\nvar MAT_MAP_VOFFSET = 0xA35A;\nvar MAT_MAP_ANG = 0xA35C;\nvar MAT_MAP_COL1 = 0xA360;\nvar MAT_MAP_COL2 = 0xA362;\nvar MAT_MAP_RCOL = 0xA364;\nvar MAT_MAP_GCOL = 0xA366;\nvar MAT_MAP_BCOL = 0xA368;\nvar NAMED_OBJECT = 0x4000;\nvar N_DIRECT_LIGHT = 0x4600;\nvar DL_OFF = 0x4620;\nvar DL_OUTER_RANGE = 0x465A;\nvar DL_INNER_RANGE = 0x4659;\nvar DL_MULTIPLIER = 0x465B;\nvar DL_EXCLUDE = 0x4654;\nvar DL_ATTENUATE = 0x4625;\nvar DL_SPOTLIGHT = 0x4610;\nvar DL_SPOT_ROLL = 0x4656;\nvar DL_SHADOWED = 0x4630;\nvar DL_LOCAL_SHADOW2 = 0x4641;\nvar DL_SEE_CONE = 0x4650;\nvar DL_SPOT_RECTANGULAR = 0x4651;\nvar DL_SPOT_ASPECT = 0x4657;\nvar DL_SPOT_PROJECTOR = 0x4653;\nvar DL_SPOT_OVERSHOOT = 0x4652;\nvar DL_RAY_BIAS = 0x4658;\nvar DL_RAYSHAD = 0x4627;\nvar N_CAMERA = 0x4700;\nvar CAM_SEE_CONE = 0x4710;\nvar CAM_RANGES = 0x4720;\nvar OBJ_HIDDEN = 0x4010;\nvar OBJ_VIS_LOFTER = 0x4011;\nvar OBJ_DOESNT_CAST = 0x4012;\nvar OBJ_DONT_RECVSHADOW = 0x4017;\nvar OBJ_MATTE = 0x4013;\nvar OBJ_FAST = 0x4014;\nvar OBJ_PROCEDURAL = 0x4015;\nvar OBJ_FROZEN = 0x4016;\nvar N_TRI_OBJECT = 0x4100;\nvar POINT_ARRAY = 0x4110;\nvar POINT_FLAG_ARRAY = 0x4111;\nvar FACE_ARRAY = 0x4120;\nvar MSH_MAT_GROUP = 0x4130;\nvar SMOOTH_GROUP = 0x4150;\nvar MSH_BOXMAP = 0x4190;\nvar TEX_VERTS = 0x4140;\nvar MESH_MATRIX = 0x4160;\nvar MESH_COLOR = 0x4165;\nvar MESH_TEXTURE_INFO = 0x4170;\nvar KFDATA = 0xB000;\nvar KFHDR = 0xB00A;\nvar KFSEG = 0xB008;\nvar KFCURTIME = 0xB009;\nvar AMBIENT_NODE_TAG = 0xB001;\nvar OBJECT_NODE_TAG = 0xB002;\nvar CAMERA_NODE_TAG = 0xB003;\nvar TARGET_NODE_TAG = 0xB004;\nvar LIGHT_NODE_TAG = 0xB005;\nvar L_TARGET_NODE_TAG = 0xB006;\nvar SPOTLIGHT_NODE_TAG = 0xB007;\nvar NODE_ID = 0xB030;\nvar NODE_HDR = 0xB010;\nvar PIVOT = 0xB013;\nvar INSTANCE_NAME = 0xB011;\nvar MORPH_SMOOTH = 0xB015;\nvar BOUNDBOX = 0xB014;\nvar POS_TRACK_TAG = 0xB020;\nvar COL_TRACK_TAG = 0xB025;\nvar ROT_TRACK_TAG = 0xB021;\nvar SCL_TRACK_TAG = 0xB022;\nvar MORPH_TRACK_TAG = 0xB026;\nvar FOV_TRACK_TAG = 0xB023;\nvar ROLL_TRACK_TAG = 0xB024;\nvar HOT_TRACK_TAG = 0xB027;\nvar FALL_TRACK_TAG = 0xB028;\nvar HIDE_TRACK_TAG = 0xB029;\nvar POLY_2D = 0x5000;\nvar SHAPE_OK = 0x5010;\nvar SHAPE_NOT_OK = 0x5011;\nvar SHAPE_HOOK = 0x5020;\nvar PATH_3D = 0x6000;\nvar PATH_MATRIX = 0x6005;\nvar SHAPE_2D = 0x6010;\nvar M_SCALE = 0x6020;\nvar M_TWIST = 0x6030;\nvar M_TEETER = 0x6040;\nvar M_FIT = 0x6050;\nvar M_BEVEL = 0x6060;\nvar XZ_CURVE = 0x6070;\nvar YZ_CURVE = 0x6080;\nvar INTERPCT = 0x6090;\nvar DEFORM_LIMIT = 0x60A0;\nvar USE_CONTOUR = 0x6100;\nvar USE_TWEEN = 0x6110;\nvar USE_SCALE = 0x6120;\nvar USE_TWIST = 0x6130;\nvar USE_TEETER = 0x6140;\nvar USE_FIT = 0x6150;\nvar USE_BEVEL = 0x6160;\nvar DEFAULT_VIEW = 0x3000;\nvar VIEW_TOP = 0x3010;\nvar VIEW_BOTTOM = 0x3020;\nvar VIEW_LEFT = 0x3030;\nvar VIEW_RIGHT = 0x3040;\nvar VIEW_FRONT = 0x3050;\nvar VIEW_BACK = 0x3060;\nvar VIEW_USER = 0x3070;\nvar VIEW_CAMERA = 0x3080;\nvar VIEW_WINDOW = 0x3090;\nvar VIEWPORT_LAYOUT_OLD = 0x7000;\nvar VIEWPORT_DATA_OLD = 0x7010;\nvar VIEWPORT_LAYOUT = 0x7001;\nvar VIEWPORT_DATA = 0x7011;\nvar VIEWPORT_DATA_3 = 0x7012;\nvar VIEWPORT_SIZE = 0x7020;\nvar NETWORK_VIEW = 0x7030;\n\nexports.default = TDSLoader;\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/*\n * @author Daosheng Mu / https://github.com/DaoshengMu/\n * @author mrdoob / http://mrdoob.com/\n * @author takahirox / https://github.com/takahirox/\n */\n\nvar TGALoader = function TGALoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTGALoader.prototype = {\n\n\tconstructor: TGALoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar texture = new THREE.Texture();\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\n\t\tloader.load(url, function (buffer) {\n\n\t\t\ttexture.image = scope.parse(buffer);\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif (onLoad !== undefined) {\n\n\t\t\t\tonLoad(texture);\n\t\t\t}\n\t\t}, onProgress, onError);\n\n\t\treturn texture;\n\t},\n\n\tparse: function parse(buffer) {\n\n\t\t// reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n\n\t\tfunction tgaCheckHeader(header) {\n\n\t\t\tswitch (header.image_type) {\n\n\t\t\t\t// check indexed type\n\n\t\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\t\tif (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// check colormap type\n\n\t\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\t\tif (header.colormap_type) {\n\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t// What the need of a file without data ?\n\n\t\t\t\tcase TGA_TYPE_NO_DATA:\n\t\t\t\t\tconsole.error('THREE.TGALoader: No data.');\n\n\t\t\t\t// Invalid type ?\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n\n\t\t\t}\n\n\t\t\t// check image width and height\n\n\t\t\tif (header.width <= 0 || header.height <= 0) {\n\n\t\t\t\tconsole.error('THREE.TGALoader: Invalid image size.');\n\t\t\t}\n\n\t\t\t// check image pixel size\n\n\t\t\tif (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n\n\t\t\t\tconsole.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n\t\t\t}\n\t\t}\n\n\t\t// parse tga image buffer\n\n\t\tfunction tgaParse(use_rle, use_pal, header, offset, data) {\n\n\t\t\tvar pixel_data, pixel_size, pixel_total, palettes;\n\n\t\t\tpixel_size = header.pixel_size >> 3;\n\t\t\tpixel_total = header.width * header.height * pixel_size;\n\n\t\t\t// read palettes\n\n\t\t\tif (use_pal) {\n\n\t\t\t\tpalettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n\t\t\t}\n\n\t\t\t// read RLE\n\n\t\t\tif (use_rle) {\n\n\t\t\t\tpixel_data = new Uint8Array(pixel_total);\n\n\t\t\t\tvar c, count, i;\n\t\t\t\tvar shift = 0;\n\t\t\t\tvar pixels = new Uint8Array(pixel_size);\n\n\t\t\t\twhile (shift < pixel_total) {\n\n\t\t\t\t\tc = data[offset++];\n\t\t\t\t\tcount = (c & 0x7f) + 1;\n\n\t\t\t\t\t// RLE pixels\n\n\t\t\t\t\tif (c & 0x80) {\n\n\t\t\t\t\t\t// bind pixel tmp array\n\n\t\t\t\t\t\tfor (i = 0; i < pixel_size; ++i) {\n\n\t\t\t\t\t\t\tpixels[i] = data[offset++];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// copy pixel array\n\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\n\t\t\t\t\t\t\tpixel_data.set(pixels, shift + i * pixel_size);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tshift += pixel_size * count;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// raw pixels\n\n\t\t\t\t\t\tcount *= pixel_size;\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\n\t\t\t\t\t\t\tpixel_data[shift + i] = data[offset++];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tshift += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// raw pixels\n\n\t\t\t\tpixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tpixel_data: pixel_data,\n\t\t\t\tpalettes: palettes\n\t\t\t};\n\t\t}\n\n\t\tfunction tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n\n\t\t\tvar colormap = palettes;\n\t\t\tvar color,\n\t\t\t    i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i++) {\n\n\t\t\t\t\tcolor = image[i];\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar color,\n\t\t\t    i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 2) {\n\n\t\t\t\t\tcolor = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = (color & 0x7C00) >> 7;\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = (color & 0x03E0) >> 2;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = (color & 0x001F) >> 3;\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 3) {\n\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 1];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 2];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 4) {\n\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 1];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 2];\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = image[i + 3];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar color,\n\t\t\t    i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i++) {\n\n\t\t\t\t\tcolor = image[i];\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = color;\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = color;\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = color;\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = 255;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n\n\t\t\tvar i = 0,\n\t\t\t    x,\n\t\t\t    y;\n\t\t\tvar width = header.width;\n\n\t\t\tfor (y = y_start; y !== y_end; y += y_step) {\n\n\t\t\t\tfor (x = x_start; x !== x_end; x += x_step, i += 2) {\n\n\t\t\t\t\timageData[(x + width * y) * 4 + 0] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 1] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 2] = image[i + 0];\n\t\t\t\t\timageData[(x + width * y) * 4 + 3] = image[i + 1];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn imageData;\n\t\t}\n\n\t\tfunction getTgaRGBA(data, width, height, image, palette) {\n\n\t\t\tvar x_start, y_start, x_step, y_step, x_end, y_end;\n\n\t\t\tswitch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n\n\t\t\t\tdefault:\n\t\t\t\tcase TGA_ORIGIN_UL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BL:\n\t\t\t\t\tx_start = 0;\n\t\t\t\t\tx_step = 1;\n\t\t\t\t\tx_end = width;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = -1;\n\t\t\t\t\ty_end = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_UR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = -1;\n\t\t\t\t\tx_end = -1;\n\t\t\t\t\ty_start = 0;\n\t\t\t\t\ty_step = 1;\n\t\t\t\t\ty_end = height;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TGA_ORIGIN_BR:\n\t\t\t\t\tx_start = width - 1;\n\t\t\t\t\tx_step = -1;\n\t\t\t\t\tx_end = -1;\n\t\t\t\t\ty_start = height - 1;\n\t\t\t\t\ty_step = -1;\n\t\t\t\t\ty_end = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (use_grey) {\n\n\t\t\t\tswitch (header.pixel_size) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Format not supported.');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tswitch (header.pixel_size) {\n\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\ttgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 16:\n\t\t\t\t\t\ttgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 24:\n\t\t\t\t\t\ttgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 32:\n\t\t\t\t\t\ttgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.error('THREE.TGALoader: Format not supported.');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Load image data according to specific method\n\t\t\t// var func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n\t\t\t// func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\t\t\treturn data;\n\t\t}\n\n\t\t// TGA constants\n\n\t\tvar TGA_TYPE_NO_DATA = 0,\n\t\t    TGA_TYPE_INDEXED = 1,\n\t\t    TGA_TYPE_RGB = 2,\n\t\t    TGA_TYPE_GREY = 3,\n\t\t    TGA_TYPE_RLE_INDEXED = 9,\n\t\t    TGA_TYPE_RLE_RGB = 10,\n\t\t    TGA_TYPE_RLE_GREY = 11,\n\t\t    TGA_ORIGIN_MASK = 0x30,\n\t\t    TGA_ORIGIN_SHIFT = 0x04,\n\t\t    TGA_ORIGIN_BL = 0x00,\n\t\t    TGA_ORIGIN_BR = 0x01,\n\t\t    TGA_ORIGIN_UL = 0x02,\n\t\t    TGA_ORIGIN_UR = 0x03;\n\n\t\tif (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n\n\t\tvar content = new Uint8Array(buffer),\n\t\t    offset = 0,\n\t\t    header = {\n\t\t\tid_length: content[offset++],\n\t\t\tcolormap_type: content[offset++],\n\t\t\timage_type: content[offset++],\n\t\t\tcolormap_index: content[offset++] | content[offset++] << 8,\n\t\t\tcolormap_length: content[offset++] | content[offset++] << 8,\n\t\t\tcolormap_size: content[offset++],\n\t\t\torigin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n\t\t\twidth: content[offset++] | content[offset++] << 8,\n\t\t\theight: content[offset++] | content[offset++] << 8,\n\t\t\tpixel_size: content[offset++],\n\t\t\tflags: content[offset++]\n\t\t};\n\n\t\t// check tga if it is valid format\n\n\t\ttgaCheckHeader(header);\n\n\t\tif (header.id_length + offset > buffer.length) {\n\n\t\t\tconsole.error('THREE.TGALoader: No data.');\n\t\t}\n\n\t\t// skip the needn't data\n\n\t\toffset += header.id_length;\n\n\t\t// get targa information about RLE compression and palette\n\n\t\tvar use_rle = false,\n\t\t    use_pal = false,\n\t\t    use_grey = false;\n\n\t\tswitch (header.image_type) {\n\n\t\t\tcase TGA_TYPE_RLE_INDEXED:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_INDEXED:\n\t\t\t\tuse_pal = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_RGB:\n\t\t\t\tuse_rle = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RGB:\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_RLE_GREY:\n\t\t\t\tuse_rle = true;\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t\tcase TGA_TYPE_GREY:\n\t\t\t\tuse_grey = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//\n\n\t\tvar canvas = document.createElement('canvas');\n\t\tcanvas.width = header.width;\n\t\tcanvas.height = header.height;\n\n\t\tvar context = canvas.getContext('2d');\n\t\tvar imageData = context.createImageData(header.width, header.height);\n\n\t\tvar result = tgaParse(use_rle, use_pal, header, offset, content);\n\t\tvar rgbaData = getTgaRGBA(imageData.data, header.width, header.height, result.pixel_data, result.palettes);\n\n\t\tcontext.putImageData(imageData, 0, 0);\n\n\t\treturn canvas;\n\t}\n\n};\n\nexports.default = TGALoader;\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author gero3 / https://github.com/gero3\n * @author tentone / https://github.com/tentone\n *\n * Requires opentype.js to be included in the project.\n * Loads TTF files and converts them into typeface JSON that can be used directly\n * to create THREE.Font objects.\n */\n\nvar TTFLoader = function TTFLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\tthis.reversed = false;\n};\n\nTTFLoader.prototype = {\n\n\tconstructor: TTFLoader,\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (buffer) {\n\n\t\t\tonLoad(scope.parse(buffer));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(arraybuffer) {\n\n\t\tfunction convert(font, reversed) {\n\n\t\t\tvar round = Math.round;\n\n\t\t\tvar glyphs = {};\n\t\t\tvar scale = 100000 / ((font.unitsPerEm || 2048) * 72);\n\n\t\t\tfor (var i = 0; i < font.glyphs.length; i++) {\n\n\t\t\t\tvar glyph = font.glyphs.glyphs[i];\n\n\t\t\t\tif (glyph.unicode !== undefined) {\n\n\t\t\t\t\tvar token = {\n\t\t\t\t\t\tha: round(glyph.advanceWidth * scale),\n\t\t\t\t\t\tx_min: round(glyph.xMin * scale),\n\t\t\t\t\t\tx_max: round(glyph.xMax * scale),\n\t\t\t\t\t\to: ''\n\t\t\t\t\t};\n\n\t\t\t\t\tif (reversed) {\n\n\t\t\t\t\t\tglyph.path.commands = reverseCommands(glyph.path.commands);\n\t\t\t\t\t}\n\n\t\t\t\t\tglyph.path.commands.forEach(function (command, i) {\n\n\t\t\t\t\t\tif (command.type.toLowerCase() === 'c') {\n\n\t\t\t\t\t\t\tcommand.type = 'b';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttoken.o += command.type.toLowerCase() + ' ';\n\n\t\t\t\t\t\tif (command.x !== undefined && command.y !== undefined) {\n\n\t\t\t\t\t\t\ttoken.o += round(command.x * scale) + ' ' + round(command.y * scale) + ' ';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (command.x1 !== undefined && command.y1 !== undefined) {\n\n\t\t\t\t\t\t\ttoken.o += round(command.x1 * scale) + ' ' + round(command.y1 * scale) + ' ';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (command.x2 !== undefined && command.y2 !== undefined) {\n\n\t\t\t\t\t\t\ttoken.o += round(command.x2 * scale) + ' ' + round(command.y2 * scale) + ' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tglyphs[String.fromCharCode(glyph.unicode)] = token;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tglyphs: glyphs,\n\t\t\t\tfamilyName: font.familyName,\n\t\t\t\tascender: round(font.ascender * scale),\n\t\t\t\tdescender: round(font.descender * scale),\n\t\t\t\tunderlinePosition: font.tables.post.underlinePosition,\n\t\t\t\tunderlineThickness: font.tables.post.underlineThickness,\n\t\t\t\tboundingBox: {\n\t\t\t\t\txMin: font.tables.head.xMin,\n\t\t\t\t\txMax: font.tables.head.xMax,\n\t\t\t\t\tyMin: font.tables.head.yMin,\n\t\t\t\t\tyMax: font.tables.head.yMax\n\t\t\t\t},\n\t\t\t\tresolution: 1000,\n\t\t\t\toriginal_font_information: font.tables.name\n\t\t\t};\n\t\t}\n\n\t\tfunction reverseCommands(commands) {\n\n\t\t\tvar paths = [];\n\t\t\tvar path;\n\n\t\t\tcommands.forEach(function (c) {\n\n\t\t\t\tif (c.type.toLowerCase() === 'm') {\n\n\t\t\t\t\tpath = [c];\n\t\t\t\t\tpaths.push(path);\n\t\t\t\t} else if (c.type.toLowerCase() !== 'z') {\n\n\t\t\t\t\tpath.push(c);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tvar reversed = [];\n\n\t\t\tpaths.forEach(function (p) {\n\n\t\t\t\tvar result = {\n\t\t\t\t\ttype: 'm',\n\t\t\t\t\tx: p[p.length - 1].x,\n\t\t\t\t\ty: p[p.length - 1].y\n\t\t\t\t};\n\n\t\t\t\treversed.push(result);\n\n\t\t\t\tfor (var i = p.length - 1; i > 0; i--) {\n\n\t\t\t\t\tvar command = p[i];\n\t\t\t\t\tvar result = { type: command.type };\n\n\t\t\t\t\tif (command.x2 !== undefined && command.y2 !== undefined) {\n\n\t\t\t\t\t\tresult.x1 = command.x2;\n\t\t\t\t\t\tresult.y1 = command.y2;\n\t\t\t\t\t\tresult.x2 = command.x1;\n\t\t\t\t\t\tresult.y2 = command.y1;\n\t\t\t\t\t} else if (command.x1 !== undefined && command.y1 !== undefined) {\n\n\t\t\t\t\t\tresult.x1 = command.x1;\n\t\t\t\t\t\tresult.y1 = command.y1;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.x = p[i - 1].x;\n\t\t\t\t\tresult.y = p[i - 1].y;\n\t\t\t\t\treversed.push(result);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn reversed;\n\t\t}\n\n\t\tif (typeof opentype === 'undefined') {\n\n\t\t\tconsole.warn('THREE.TTFLoader: The loader requires opentype.js. Make sure it\\'s included before using the loader.');\n\t\t\treturn null;\n\t\t}\n\n\t\treturn convert(opentype.parse(arraybuffer), this.reversed);\n\t}\n\n};\n\nexports.default = TTFLoader;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar VRMLLoader = function VRMLLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nVRMLLoader.prototype = {\n\n\tconstructor: VRMLLoader,\n\n\t// for IndexedFaceSet support\n\tisRecordingPoints: false,\n\tisRecordingFaces: false,\n\tpoints: [],\n\tindexes: [],\n\n\t// for Background support\n\tisRecordingAngles: false,\n\tisRecordingColors: false,\n\tangles: [],\n\tcolors: [],\n\n\trecordingFieldname: null,\n\n\tcrossOrigin: 'Anonymous',\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\tthis.crossOrigin = value;\n\t},\n\n\tparse: function parse(data) {\n\n\t\tvar texturePath = this.texturePath || '';\n\n\t\tvar textureLoader = new THREE.TextureLoader(this.manager);\n\t\ttextureLoader.setCrossOrigin(this.crossOrigin);\n\n\t\tfunction parseV2(lines, scene) {\n\n\t\t\tvar defines = {};\n\t\t\tvar float_pattern = /(\\b|\\-|\\+)([\\d\\.e]+)/;\n\t\t\tvar float2_pattern = /([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)/g;\n\t\t\tvar float3_pattern = /([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)\\s+([\\d\\.\\+\\-e]+)/g;\n\n\t\t\t/**\n    * Vertically paints the faces interpolating between the\n    * specified colors at the specified angels. This is used for the Background\n    * node, but could be applied to other nodes with multiple faces as well.\n    *\n    * When used with the Background node, default is directionIsDown is true if\n    * interpolating the skyColor down from the Zenith. When interpolationg up from\n    * the Nadir i.e. interpolating the groundColor, the directionIsDown is false.\n    *\n    * The first angle is never specified, it is the Zenith (0 rad). Angles are specified\n    * in radians. The geometry is thought a sphere, but could be anything. The color interpolation\n    * is linear along the Y axis in any case.\n    *\n    * You must specify one more color than you have angles at the beginning of the colors array.\n    * This is the color of the Zenith (the top of the shape).\n    *\n    * @param geometry\n    * @param radius\n    * @param angles\n    * @param colors\n    * @param boolean topDown Whether to work top down or bottom up.\n    */\n\t\t\tfunction paintFaces(geometry, radius, angles, colors, topDown) {\n\n\t\t\t\tvar direction = topDown === true ? 1 : -1;\n\n\t\t\t\tvar coord = [],\n\t\t\t\t    A = {},\n\t\t\t\t    B = {},\n\t\t\t\t    applyColor = false;\n\n\t\t\t\tfor (var k = 0; k < angles.length; k++) {\n\n\t\t\t\t\t// push the vector at which the color changes\n\n\t\t\t\t\tvar vec = {\n\t\t\t\t\t\tx: direction * (Math.cos(angles[k]) * radius),\n\t\t\t\t\t\ty: direction * (Math.sin(angles[k]) * radius)\n\t\t\t\t\t};\n\n\t\t\t\t\tcoord.push(vec);\n\t\t\t\t}\n\n\t\t\t\tvar index = geometry.index;\n\t\t\t\tvar positionAttribute = geometry.attributes.position;\n\t\t\t\tvar colorAttribute = new THREE.BufferAttribute(new Float32Array(geometry.attributes.position.count * 3), 3);\n\n\t\t\t\tvar position = new THREE.Vector3();\n\t\t\t\tvar color = new THREE.Color();\n\n\t\t\t\tfor (var i = 0; i < index.count; i++) {\n\n\t\t\t\t\tvar vertexIndex = index.getX(i);\n\n\t\t\t\t\tposition.fromBufferAttribute(positionAttribute, vertexIndex);\n\n\t\t\t\t\tfor (var j = 0; j < colors.length; j++) {\n\n\t\t\t\t\t\t// linear interpolation between aColor and bColor, calculate proportion\n\t\t\t\t\t\t// A is previous point (angle)\n\n\t\t\t\t\t\tif (j === 0) {\n\n\t\t\t\t\t\t\tA.x = 0;\n\t\t\t\t\t\t\tA.y = topDown === true ? radius : -1 * radius;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tA.x = coord[j - 1].x;\n\t\t\t\t\t\t\tA.y = coord[j - 1].y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// B is current point (angle)\n\n\t\t\t\t\t\tB = coord[j];\n\n\t\t\t\t\t\tif (B !== undefined) {\n\n\t\t\t\t\t\t\t// p has to be between the points A and B which we interpolate\n\n\t\t\t\t\t\t\tapplyColor = topDown === true ? position.y <= A.y && position.y > B.y : position.y >= A.y && position.y < B.y;\n\n\t\t\t\t\t\t\tif (applyColor === true) {\n\n\t\t\t\t\t\t\t\tvar aColor = colors[j];\n\t\t\t\t\t\t\t\tvar bColor = colors[j + 1];\n\n\t\t\t\t\t\t\t\t// below is simple linear interpolation\n\n\t\t\t\t\t\t\t\tvar t = Math.abs(position.y - A.y) / (A.y - B.y);\n\n\t\t\t\t\t\t\t\t// to make it faster, you can only calculate this if the y coord changes, the color is the same for points with the same y\n\n\t\t\t\t\t\t\t\tcolor.copy(aColor).lerp(bColor, t);\n\n\t\t\t\t\t\t\t\tcolorAttribute.setXYZ(vertexIndex, color.r, color.g, color.b);\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar colorIndex = topDown === true ? colors.length - 1 : 0;\n\t\t\t\t\t\t\t\tvar c = colors[colorIndex];\n\t\t\t\t\t\t\t\tcolorAttribute.setXYZ(vertexIndex, c.r, c.g, c.b);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tgeometry.addAttribute('color', colorAttribute);\n\t\t\t}\n\n\t\t\tvar index = [];\n\n\t\t\tfunction parseProperty(node, line) {\n\n\t\t\t\tvar parts = [],\n\t\t\t\t    part,\n\t\t\t\t    property = {},\n\t\t\t\t    fieldName;\n\n\t\t\t\t/**\n     * Expression for matching relevant information, such as a name or value, but not the separators\n     * @type {RegExp}\n     */\n\t\t\t\tvar regex = /[^\\s,\\[\\]]+/g;\n\n\t\t\t\tvar point;\n\n\t\t\t\twhile (null !== (part = regex.exec(line))) {\n\n\t\t\t\t\tparts.push(part[0]);\n\t\t\t\t}\n\n\t\t\t\tfieldName = parts[0];\n\n\t\t\t\t// trigger several recorders\n\t\t\t\tswitch (fieldName) {\n\n\t\t\t\t\tcase 'skyAngle':\n\t\t\t\t\tcase 'groundAngle':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingAngles = true;\n\t\t\t\t\t\tthis.angles = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skyColor':\n\t\t\t\t\tcase 'groundColor':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingColors = true;\n\t\t\t\t\t\tthis.colors = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'point':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingPoints = true;\n\t\t\t\t\t\tthis.points = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'coordIndex':\n\t\t\t\t\tcase 'texCoordIndex':\n\t\t\t\t\t\tthis.recordingFieldname = fieldName;\n\t\t\t\t\t\tthis.isRecordingFaces = true;\n\t\t\t\t\t\tthis.indexes = [];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tif (this.isRecordingFaces) {\n\n\t\t\t\t\t// the parts hold the indexes as strings\n\t\t\t\t\tif (parts.length > 0) {\n\n\t\t\t\t\t\tfor (var ind = 0; ind < parts.length; ind++) {\n\n\t\t\t\t\t\t\t// the part should either be positive integer or -1\n\t\t\t\t\t\t\tif (!/(-?\\d+)/.test(parts[ind])) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// end of current face\n\t\t\t\t\t\t\tif (parts[ind] === '-1') {\n\n\t\t\t\t\t\t\t\tif (index.length > 0) {\n\n\t\t\t\t\t\t\t\t\tthis.indexes.push(index);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// start new one\n\t\t\t\t\t\t\t\tindex = [];\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindex.push(parseInt(parts[ind]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tif (index.length > 0) {\n\n\t\t\t\t\t\t\tthis.indexes.push(index);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// start new one\n\t\t\t\t\t\tindex = [];\n\n\t\t\t\t\t\tthis.isRecordingFaces = false;\n\t\t\t\t\t\tnode[this.recordingFieldname] = this.indexes;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.isRecordingPoints) {\n\n\t\t\t\t\tif (node.nodeType == 'Coordinate') {\n\n\t\t\t\t\t\twhile (null !== (parts = float3_pattern.exec(line))) {\n\n\t\t\t\t\t\t\tpoint = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tz: parseFloat(parts[3])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis.points.push(point);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (node.nodeType == 'TextureCoordinate') {\n\n\t\t\t\t\t\twhile (null !== (parts = float2_pattern.exec(line))) {\n\n\t\t\t\t\t\t\tpoint = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tthis.points.push(point);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tthis.isRecordingPoints = false;\n\t\t\t\t\t\tnode.points = this.points;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.isRecordingAngles) {\n\n\t\t\t\t\t// the parts hold the angles as strings\n\t\t\t\t\tif (parts.length > 0) {\n\n\t\t\t\t\t\tfor (var ind = 0; ind < parts.length; ind++) {\n\n\t\t\t\t\t\t\t// the part should be a float\n\t\t\t\t\t\t\tif (!float_pattern.test(parts[ind])) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.angles.push(parseFloat(parts[ind]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tthis.isRecordingAngles = false;\n\t\t\t\t\t\tnode[this.recordingFieldname] = this.angles;\n\t\t\t\t\t}\n\t\t\t\t} else if (this.isRecordingColors) {\n\n\t\t\t\t\twhile (null !== (parts = float3_pattern.exec(line))) {\n\n\t\t\t\t\t\tvar color = {\n\t\t\t\t\t\t\tr: parseFloat(parts[1]),\n\t\t\t\t\t\t\tg: parseFloat(parts[2]),\n\t\t\t\t\t\t\tb: parseFloat(parts[3])\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.colors.push(color);\n\t\t\t\t\t}\n\n\t\t\t\t\t// end\n\t\t\t\t\tif (/]/.exec(line)) {\n\n\t\t\t\t\t\tthis.isRecordingColors = false;\n\t\t\t\t\t\tnode[this.recordingFieldname] = this.colors;\n\t\t\t\t\t}\n\t\t\t\t} else if (parts[parts.length - 1] !== 'NULL' && fieldName !== 'children') {\n\n\t\t\t\t\tswitch (fieldName) {\n\n\t\t\t\t\t\tcase 'diffuseColor':\n\t\t\t\t\t\tcase 'emissiveColor':\n\t\t\t\t\t\tcase 'specularColor':\n\t\t\t\t\t\tcase 'color':\n\n\t\t\t\t\t\t\tif (parts.length !== 4) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid color format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = {\n\t\t\t\t\t\t\t\tr: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\tg: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tb: parseFloat(parts[3])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'location':\n\t\t\t\t\t\tcase 'direction':\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tcase 'size':\n\t\t\t\t\t\t\tif (parts.length !== 4) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid vector format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tz: parseFloat(parts[3])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'intensity':\n\t\t\t\t\t\tcase 'cutOffAngle':\n\t\t\t\t\t\tcase 'radius':\n\t\t\t\t\t\tcase 'topRadius':\n\t\t\t\t\t\tcase 'bottomRadius':\n\t\t\t\t\t\tcase 'height':\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tcase 'ambientIntensity':\n\t\t\t\t\t\t\tif (parts.length !== 2) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid single float value specification detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = parseFloat(parts[1]);\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\tif (parts.length !== 5) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid quaternion format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = {\n\t\t\t\t\t\t\t\tx: parseFloat(parts[1]),\n\t\t\t\t\t\t\t\ty: parseFloat(parts[2]),\n\t\t\t\t\t\t\t\tz: parseFloat(parts[3]),\n\t\t\t\t\t\t\t\tw: parseFloat(parts[4])\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'on':\n\t\t\t\t\t\tcase 'ccw':\n\t\t\t\t\t\tcase 'solid':\n\t\t\t\t\t\tcase 'colorPerVertex':\n\t\t\t\t\t\tcase 'convex':\n\t\t\t\t\t\t\tif (parts.length !== 2) {\n\n\t\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: Invalid format detected for %s.', fieldName);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tproperty = parts[1] === 'TRUE' ? true : false;\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tnode[fieldName] = property;\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\t\t\t}\n\n\t\t\tfunction getTree(lines) {\n\n\t\t\t\tvar tree = { 'string': 'Scene', children: [] };\n\t\t\t\tvar current = tree;\n\t\t\t\tvar matches;\n\t\t\t\tvar specification;\n\n\t\t\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\t\t\tvar comment = '';\n\n\t\t\t\t\tvar line = lines[i];\n\n\t\t\t\t\t// omit whitespace only lines\n\t\t\t\t\tif (null !== /^\\s+?$/g.exec(line)) {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tline = line.trim();\n\n\t\t\t\t\t// skip empty lines\n\t\t\t\t\tif (line === '') {\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (/#/.exec(line)) {\n\n\t\t\t\t\t\tvar parts = line.split('#');\n\n\t\t\t\t\t\t// discard everything after the #, it is a comment\n\t\t\t\t\t\tline = parts[0];\n\n\t\t\t\t\t\t// well, let's also keep the comment\n\t\t\t\t\t\tcomment = parts[1];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (matches = /([^\\s]*){1}(?:\\s+)?{/.exec(line)) {\n\n\t\t\t\t\t\t// first subpattern should match the Node name\n\n\t\t\t\t\t\tvar block = { 'nodeType': matches[1], 'string': line, 'parent': current, 'children': [], 'comment': comment };\n\t\t\t\t\t\tcurrent.children.push(block);\n\t\t\t\t\t\tcurrent = block;\n\n\t\t\t\t\t\tif (/}/.exec(line)) {\n\n\t\t\t\t\t\t\t// example: geometry Box { size 1 1 1 } # all on the same line\n\t\t\t\t\t\t\tspecification = /{(.*)}/.exec(line)[1];\n\n\t\t\t\t\t\t\t// todo: remove once new parsing is complete?\n\t\t\t\t\t\t\tblock.children.push(specification);\n\n\t\t\t\t\t\t\tparseProperty(current, specification);\n\n\t\t\t\t\t\t\tcurrent = current.parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (/}/.exec(line)) {\n\n\t\t\t\t\t\tcurrent = current.parent;\n\t\t\t\t\t} else if (line !== '') {\n\n\t\t\t\t\t\tparseProperty(current, line);\n\t\t\t\t\t\t// todo: remove once new parsing is complete? we still do not parse geometry and appearance the new way\n\t\t\t\t\t\tcurrent.children.push(line);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tree;\n\t\t\t}\n\n\t\t\tfunction parseNode(data, parent) {\n\n\t\t\t\tvar object;\n\n\t\t\t\tif (typeof data === 'string') {\n\n\t\t\t\t\tif (/USE/.exec(data)) {\n\n\t\t\t\t\t\tvar defineKey = /USE\\s+?([^\\s]+)/.exec(data)[1];\n\n\t\t\t\t\t\tif (undefined == defines[defineKey]) {\n\n\t\t\t\t\t\t\tconsole.warn('THREE.VRMLLoader: %s is not defined.', defineKey);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (/appearance/.exec(data) && defineKey) {\n\n\t\t\t\t\t\t\t\tparent.material = defines[defineKey].clone();\n\t\t\t\t\t\t\t} else if (/geometry/.exec(data) && defineKey) {\n\n\t\t\t\t\t\t\t\tparent.geometry = defines[defineKey].clone();\n\n\t\t\t\t\t\t\t\t// the solid property is not cloned with clone(), is only needed for VRML loading, so we need to transfer it\n\t\t\t\t\t\t\t\tif (undefined !== defines[defineKey].solid && defines[defineKey].solid === false) {\n\n\t\t\t\t\t\t\t\t\tparent.geometry.solid = false;\n\t\t\t\t\t\t\t\t\tparent.material.side = THREE.DoubleSide;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (defineKey) {\n\n\t\t\t\t\t\t\t\tobject = defines[defineKey].clone();\n\t\t\t\t\t\t\t\tparent.add(object);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tobject = parent;\n\n\t\t\t\tif (data.string.indexOf('AmbientLight') > -1 && data.nodeType === 'PointLight') {\n\n\t\t\t\t\tdata.nodeType = 'AmbientLight';\n\t\t\t\t}\n\n\t\t\t\tvar l_visible = data.on !== undefined ? data.on : true;\n\t\t\t\tvar l_intensity = data.intensity !== undefined ? data.intensity : 1;\n\t\t\t\tvar l_color = new THREE.Color();\n\n\t\t\t\tif (data.color) {\n\n\t\t\t\t\tl_color.copy(data.color);\n\t\t\t\t}\n\n\t\t\t\tif (data.nodeType === 'AmbientLight') {\n\n\t\t\t\t\tobject = new THREE.AmbientLight(l_color, l_intensity);\n\t\t\t\t\tobject.visible = l_visible;\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'PointLight') {\n\n\t\t\t\t\tvar l_distance = 0;\n\n\t\t\t\t\tif (data.radius !== undefined && data.radius < 1000) {\n\n\t\t\t\t\t\tl_distance = data.radius;\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.PointLight(l_color, l_intensity, l_distance);\n\t\t\t\t\tobject.visible = l_visible;\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'SpotLight') {\n\n\t\t\t\t\tvar l_intensity = 1;\n\t\t\t\t\tvar l_distance = 0;\n\t\t\t\t\tvar l_angle = Math.PI / 3;\n\t\t\t\t\tvar l_penumbra = 0;\n\t\t\t\t\tvar l_visible = true;\n\n\t\t\t\t\tif (data.radius !== undefined && data.radius < 1000) {\n\n\t\t\t\t\t\tl_distance = data.radius;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.cutOffAngle !== undefined) {\n\n\t\t\t\t\t\tl_angle = data.cutOffAngle;\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.SpotLight(l_color, l_intensity, l_distance, l_angle, l_penumbra);\n\t\t\t\t\tobject.visible = l_visible;\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'Transform' || data.nodeType === 'Group') {\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\tobject.name = /DEF\\s+([^\\s]+)/.exec(data.string)[1];\n\t\t\t\t\t\tdefines[object.name] = object;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.translation !== undefined) {\n\n\t\t\t\t\t\tvar t = data.translation;\n\n\t\t\t\t\t\tobject.position.set(t.x, t.y, t.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.rotation !== undefined) {\n\n\t\t\t\t\t\tvar r = data.rotation;\n\n\t\t\t\t\t\tobject.quaternion.setFromAxisAngle(new THREE.Vector3(r.x, r.y, r.z), r.w);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (data.scale !== undefined) {\n\n\t\t\t\t\t\tvar s = data.scale;\n\n\t\t\t\t\t\tobject.scale.set(s.x, s.y, s.z);\n\t\t\t\t\t}\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'Shape') {\n\n\t\t\t\t\tobject = new THREE.Mesh();\n\n\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\tobject.name = /DEF\\s+([^\\s]+)/.exec(data.string)[1];\n\n\t\t\t\t\t\tdefines[object.name] = object;\n\t\t\t\t\t}\n\n\t\t\t\t\tparent.add(object);\n\t\t\t\t} else if (data.nodeType === 'Background') {\n\n\t\t\t\t\tvar segments = 20;\n\n\t\t\t\t\t// sky (full sphere):\n\n\t\t\t\t\tvar radius = 2e4;\n\n\t\t\t\t\tvar skyGeometry = new THREE.SphereBufferGeometry(radius, segments, segments);\n\t\t\t\t\tvar skyMaterial = new THREE.MeshBasicMaterial({ fog: false, side: THREE.BackSide });\n\n\t\t\t\t\tif (data.skyColor.length > 1) {\n\n\t\t\t\t\t\tpaintFaces(skyGeometry, radius, data.skyAngle, data.skyColor, true);\n\n\t\t\t\t\t\tskyMaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar color = data.skyColor[0];\n\t\t\t\t\t\tskyMaterial.color.setRGB(color.r, color.b, color.g);\n\t\t\t\t\t}\n\n\t\t\t\t\tscene.add(new THREE.Mesh(skyGeometry, skyMaterial));\n\n\t\t\t\t\t// ground (half sphere):\n\n\t\t\t\t\tif (data.groundColor !== undefined) {\n\n\t\t\t\t\t\tradius = 1.2e4;\n\n\t\t\t\t\t\tvar groundGeometry = new THREE.SphereBufferGeometry(radius, segments, segments, 0, 2 * Math.PI, 0.5 * Math.PI, 1.5 * Math.PI);\n\t\t\t\t\t\tvar groundMaterial = new THREE.MeshBasicMaterial({ fog: false, side: THREE.BackSide, vertexColors: THREE.VertexColors });\n\n\t\t\t\t\t\tpaintFaces(groundGeometry, radius, data.groundAngle, data.groundColor, false);\n\n\t\t\t\t\t\tscene.add(new THREE.Mesh(groundGeometry, groundMaterial));\n\t\t\t\t\t}\n\t\t\t\t} else if (/geometry/.exec(data.string)) {\n\n\t\t\t\t\tif (data.nodeType === 'Box') {\n\n\t\t\t\t\t\tvar s = data.size;\n\n\t\t\t\t\t\tparent.geometry = new THREE.BoxBufferGeometry(s.x, s.y, s.z);\n\t\t\t\t\t} else if (data.nodeType === 'Cylinder') {\n\n\t\t\t\t\t\tparent.geometry = new THREE.CylinderBufferGeometry(data.radius, data.radius, data.height);\n\t\t\t\t\t} else if (data.nodeType === 'Cone') {\n\n\t\t\t\t\t\tparent.geometry = new THREE.CylinderBufferGeometry(data.topRadius, data.bottomRadius, data.height);\n\t\t\t\t\t} else if (data.nodeType === 'Sphere') {\n\n\t\t\t\t\t\tparent.geometry = new THREE.SphereBufferGeometry(data.radius);\n\t\t\t\t\t} else if (data.nodeType === 'IndexedFaceSet') {\n\n\t\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\t\tvar positions = [];\n\t\t\t\t\t\tvar uvs = [];\n\n\t\t\t\t\t\tvar position, uv;\n\n\t\t\t\t\t\tvar i, il, j, jl;\n\n\t\t\t\t\t\tfor (i = 0, il = data.children.length; i < il; i++) {\n\n\t\t\t\t\t\t\tvar child = data.children[i];\n\n\t\t\t\t\t\t\t// uvs\n\n\t\t\t\t\t\t\tif (child.nodeType === 'TextureCoordinate') {\n\n\t\t\t\t\t\t\t\tif (child.points) {\n\n\t\t\t\t\t\t\t\t\tfor (j = 0, jl = child.points.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\tuv = child.points[j];\n\t\t\t\t\t\t\t\t\t\tuvs.push(uv.x, uv.y);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// positions\n\n\t\t\t\t\t\t\tif (child.nodeType === 'Coordinate') {\n\n\t\t\t\t\t\t\t\tif (child.points) {\n\n\t\t\t\t\t\t\t\t\tfor (j = 0, jl = child.points.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\tposition = child.points[j];\n\t\t\t\t\t\t\t\t\t\tpositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (child.string.indexOf('DEF') > -1) {\n\n\t\t\t\t\t\t\t\t\tvar name = /DEF\\s+([^\\s]+)/.exec(child.string)[1];\n\n\t\t\t\t\t\t\t\t\tdefines[name] = positions.slice(0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (child.string.indexOf('USE') > -1) {\n\n\t\t\t\t\t\t\t\t\tvar defineKey = /USE\\s+([^\\s]+)/.exec(child.string)[1];\n\n\t\t\t\t\t\t\t\t\tpositions = defines[defineKey];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar skip = 0;\n\n\t\t\t\t\t\t// some shapes only have vertices for use in other shapes\n\n\t\t\t\t\t\tif (data.coordIndex) {\n\n\t\t\t\t\t\t\tvar newPositions = [];\n\t\t\t\t\t\t\tvar newUvs = [];\n\n\t\t\t\t\t\t\tposition = new THREE.Vector3();\n\t\t\t\t\t\t\tuv = new THREE.Vector2();\n\n\t\t\t\t\t\t\tfor (i = 0, il = data.coordIndex.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\tvar indexes = data.coordIndex[i];\n\n\t\t\t\t\t\t\t\t// VRML support multipoint indexed face sets (more then 3 vertices). You must calculate the composing triangles here\n\n\t\t\t\t\t\t\t\tskip = 0;\n\n\t\t\t\t\t\t\t\twhile (indexes.length >= 3 && skip < indexes.length - 2) {\n\n\t\t\t\t\t\t\t\t\tif (data.ccw === undefined) data.ccw = true; // ccw is true by default\n\n\t\t\t\t\t\t\t\t\tvar i1 = indexes[0];\n\t\t\t\t\t\t\t\t\tvar i2 = indexes[skip + (data.ccw ? 1 : 2)];\n\t\t\t\t\t\t\t\t\tvar i3 = indexes[skip + (data.ccw ? 2 : 1)];\n\n\t\t\t\t\t\t\t\t\t// create non indexed geometry, necessary for face normal generation\n\n\t\t\t\t\t\t\t\t\tposition.fromArray(positions, i1 * 3);\n\t\t\t\t\t\t\t\t\tuv.fromArray(uvs, i1 * 2);\n\t\t\t\t\t\t\t\t\tnewPositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\tnewUvs.push(uv.x, uv.y);\n\n\t\t\t\t\t\t\t\t\tposition.fromArray(positions, i2 * 3);\n\t\t\t\t\t\t\t\t\tuv.fromArray(uvs, i2 * 2);\n\t\t\t\t\t\t\t\t\tnewPositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\tnewUvs.push(uv.x, uv.y);\n\n\t\t\t\t\t\t\t\t\tposition.fromArray(positions, i3 * 3);\n\t\t\t\t\t\t\t\t\tuv.fromArray(uvs, i3 * 2);\n\t\t\t\t\t\t\t\t\tnewPositions.push(position.x, position.y, position.z);\n\t\t\t\t\t\t\t\t\tnewUvs.push(uv.x, uv.y);\n\n\t\t\t\t\t\t\t\t\tskip++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpositions = newPositions;\n\t\t\t\t\t\t\tuvs = newUvs;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// do not add dummy mesh to the scene\n\n\t\t\t\t\t\t\tparent.parent.remove(parent);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (false === data.solid) {\n\n\t\t\t\t\t\t\tparent.material.side = THREE.DoubleSide;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// we need to store it on the geometry for use with defines\n\t\t\t\t\t\tgeometry.solid = data.solid;\n\n\t\t\t\t\t\tgeometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n\n\t\t\t\t\t\tif (uvs.length > 0) {\n\n\t\t\t\t\t\t\tgeometry.addAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\t\t\t// see if it's a define\n\t\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\t\tgeometry.name = /DEF ([^\\s]+)/.exec(data.string)[1];\n\t\t\t\t\t\t\tdefines[geometry.name] = geometry;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent.geometry = geometry;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t} else if (/appearance/.exec(data.string)) {\n\n\t\t\t\t\tfor (var i = 0; i < data.children.length; i++) {\n\n\t\t\t\t\t\tvar child = data.children[i];\n\n\t\t\t\t\t\tif (child.nodeType === 'Material') {\n\n\t\t\t\t\t\t\tvar material = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\t\t\tif (child.diffuseColor !== undefined) {\n\n\t\t\t\t\t\t\t\tvar d = child.diffuseColor;\n\n\t\t\t\t\t\t\t\tmaterial.color.setRGB(d.r, d.g, d.b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (child.emissiveColor !== undefined) {\n\n\t\t\t\t\t\t\t\tvar e = child.emissiveColor;\n\n\t\t\t\t\t\t\t\tmaterial.emissive.setRGB(e.r, e.g, e.b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (child.specularColor !== undefined) {\n\n\t\t\t\t\t\t\t\tvar s = child.specularColor;\n\n\t\t\t\t\t\t\t\tmaterial.specular.setRGB(s.r, s.g, s.b);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (child.transparency !== undefined) {\n\n\t\t\t\t\t\t\t\tvar t = child.transparency;\n\n\t\t\t\t\t\t\t\t// transparency is opposite of opacity\n\t\t\t\t\t\t\t\tmaterial.opacity = Math.abs(1 - t);\n\n\t\t\t\t\t\t\t\tmaterial.transparent = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (/DEF/.exec(data.string)) {\n\n\t\t\t\t\t\t\t\tmaterial.name = /DEF ([^\\s]+)/.exec(data.string)[1];\n\n\t\t\t\t\t\t\t\tdefines[material.name] = material;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tparent.material = material;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (child.nodeType === 'ImageTexture') {\n\n\t\t\t\t\t\t\tvar textureName = /\"([^\"]+)\"/.exec(child.children[0]);\n\n\t\t\t\t\t\t\tif (textureName) {\n\n\t\t\t\t\t\t\t\tparent.material.name = textureName[1];\n\n\t\t\t\t\t\t\t\tparent.material.map = textureLoader.load(texturePath + textureName[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, l = data.children.length; i < l; i++) {\n\n\t\t\t\t\tparseNode(data.children[i], object);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparseNode(getTree(lines), scene);\n\t\t}\n\n\t\tvar scene = new THREE.Scene();\n\n\t\tvar lines = data.split('\\n');\n\n\t\t// some lines do not have breaks\n\n\t\tfor (var i = lines.length - 1; i > -1; i--) {\n\n\t\t\tvar line = lines[i];\n\n\t\t\t// split lines with {..{ or {..[ - some have both\n\t\t\tif (/{.*[{\\[]/.test(line)) {\n\n\t\t\t\tvar parts = line.split('{').join('{\\n').split('\\n');\n\t\t\t\tparts.unshift(1);\n\t\t\t\tparts.unshift(i);\n\t\t\t\tlines.splice.apply(lines, parts);\n\t\t\t} else if (/\\].*}/.test(line)) {\n\n\t\t\t\t// split lines with ]..}\n\t\t\t\tvar parts = line.split(']').join(']\\n').split('\\n');\n\t\t\t\tparts.unshift(1);\n\t\t\t\tparts.unshift(i);\n\t\t\t\tlines.splice.apply(lines, parts);\n\t\t\t}\n\n\t\t\tif (/}.*}/.test(line)) {\n\n\t\t\t\t// split lines with }..}\n\t\t\t\tvar parts = line.split('}').join('}\\n').split('\\n');\n\t\t\t\tparts.unshift(1);\n\t\t\t\tparts.unshift(i);\n\t\t\t\tlines.splice.apply(lines, parts);\n\t\t\t}\n\n\t\t\tif (/^\\b[^\\s]+\\b$/.test(line.trim())) {\n\n\t\t\t\t// prevent lines with single words like \"coord\" or \"geometry\", see #12209\n\t\t\t\tlines[i + 1] = line + ' ' + lines[i + 1].trim();\n\t\t\t\tlines.splice(i, 1);\n\t\t\t} else if (line.indexOf('coord') > -1 && line.indexOf('[') < 0 && line.indexOf('{') < 0) {\n\n\t\t\t\t// force the parser to create Coordinate node for empty coords\n\t\t\t\t// coord USE something -> coord USE something Coordinate {}\n\n\t\t\t\tlines[i] += ' Coordinate {}';\n\t\t\t}\n\t\t}\n\n\t\tvar header = lines.shift();\n\n\t\tif (/V1.0/.exec(header)) {\n\n\t\t\tconsole.warn('THREE.VRMLLoader: V1.0 not supported yet.');\n\t\t} else if (/V2.0/.exec(header)) {\n\n\t\t\tparseV2(lines, scene);\n\t\t}\n\n\t\treturn scene;\n\t}\n\n};\n\nexports.default = VRMLLoader;\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _GLTFLoader = __webpack_require__(5);\n\nvar _GLTFLoader2 = _interopRequireDefault(_GLTFLoader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Takahiro / https://github.com/takahirox\n */\n\n// VRM Specification: https://dwango.github.io/vrm/vrm_spec/\n//\n// VRM is based on glTF 2.0 and VRM extension is defined\n// in top-level json.extensions.VRM\n\nvar VRMLoader = function () {\n\n\tfunction VRMLoader(manager) {\n\n\t\tif (_GLTFLoader2.default === undefined) {\n\n\t\t\tthrow new Error('VRMLoader: Import GLTFLoader.');\n\t\t}\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\tthis.gltfLoader = new _GLTFLoader2.default(this.manager);\n\t}\n\n\tVRMLoader.prototype = {\n\n\t\tconstructor: VRMLoader,\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\t\tthis.gltfLoader.load(url, onLoad, onProgress, onError);\n\t\t},\n\n\t\tsetCrossOrigin: function setCrossOrigin(value) {\n\n\t\t\tthis.glTFLoader.setCrossOrigin(value);\n\t\t\treturn this;\n\t\t},\n\n\t\tsetPath: function setPath(value) {\n\n\t\t\tthis.glTFLoader.setPath(value);\n\t\t\treturn this;\n\t\t},\n\n\t\tsetDRACOLoader: function setDRACOLoader(dracoLoader) {\n\n\t\t\tthis.glTFLoader.setDRACOLoader(dracoLoader);\n\t\t\treturn this;\n\t\t}\n\n\t};\n\n\treturn VRMLoader;\n}();\n\nexports.default = VRMLoader;\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * Loader for UTF8 version2 (after r51) encoded models generated by:\n *\thttp://code.google.com/p/webgl-loader/\n *\n * Code to load/decompress mesh is taken from r100 of this webgl-loader\n */\n\nvar UTF8Loader = function UTF8Loader() {};\n\n/**\n * Load UTF8 encoded model\n * @param jsonUrl - URL from which to load json containing information about model\n * @param callback - Callback(THREE.Object3D) on successful loading of model\n * @param options - options on how to load model (see THREE.MTLLoader.MaterialCreator for basic options)\n *                  Additional options include\n *                   geometryBase: Base url from which to load referenced geometries\n *                   materialBase: Base url from which to load referenced textures\n */\n\nUTF8Loader.prototype.load = function (jsonUrl, callback, options) {\n\n\tthis.downloadModelJson(jsonUrl, callback, options);\n};\n\n// BufferGeometryCreator\n\nUTF8Loader.BufferGeometryCreator = function () {};\n\nUTF8Loader.BufferGeometryCreator.prototype.create = function (attribArray, indices) {\n\n\tvar ntris = indices.length / 3;\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar positions = new Float32Array(ntris * 3 * 3);\n\tvar normals = new Float32Array(ntris * 3 * 3);\n\tvar uvs = new Float32Array(ntris * 3 * 2);\n\n\tvar i, j, offset;\n\n\tvar end = attribArray.length;\n\tvar stride = 8;\n\n\t// extract positions\n\n\tj = 0;\n\toffset = 0;\n\n\tfor (i = offset; i < end; i += stride) {\n\n\t\tpositions[j++] = attribArray[i];\n\t\tpositions[j++] = attribArray[i + 1];\n\t\tpositions[j++] = attribArray[i + 2];\n\t}\n\n\t// extract uvs\n\n\tj = 0;\n\toffset = 3;\n\n\tfor (i = offset; i < end; i += stride) {\n\n\t\tuvs[j++] = attribArray[i];\n\t\tuvs[j++] = attribArray[i + 1];\n\t}\n\n\t// extract normals\n\n\tj = 0;\n\toffset = 5;\n\n\tfor (i = offset; i < end; i += stride) {\n\n\t\tnormals[j++] = attribArray[i];\n\t\tnormals[j++] = attribArray[i + 1];\n\t\tnormals[j++] = attribArray[i + 2];\n\t}\n\n\tgeometry.setIndex(new THREE.BufferAttribute(indices, 1));\n\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\tgeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\tgeometry.addAttribute('uv', new THREE.BufferAttribute(uvs, 2));\n\n\tgeometry.computeBoundingSphere();\n\n\treturn geometry;\n};\n\n// UTF-8 decoder from webgl-loader (r100)\n// http://code.google.com/p/webgl-loader/\n\n// Model manifest description. Contains objects like:\n// name: {\n//   materials: { 'material_name': { ... } ... },\n//   decodeParams: {\n//     decodeOffsets: [ ... ],\n//     decodeScales: [ ... ],\n//   },\n//   urls: {\n//     'url': [\n//       { material: 'material_name',\n//         attribRange: [#, #],\n//         indexRange: [#, #],\n//         names: [ 'object names' ... ],\n//         lengths: [#, #, # ... ]\n//       }\n//     ],\n//     ...\n//   }\n// }\n\nvar DEFAULT_DECODE_PARAMS = {\n\n\tdecodeOffsets: [-4095, -4095, -4095, 0, 0, -511, -511, -511],\n\tdecodeScales: [1 / 8191, 1 / 8191, 1 / 8191, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023]\n\n\t// TODO: normal decoding? (see walt.js)\n\t// needs to know: input, output (from vertex format!)\n\t//\n\t// Should split attrib/index.\n\t// 1) Decode position and non-normal attributes.\n\t// 2) Decode indices, computing normals\n\t// 3) Maybe normalize normals? Only necessary for refinement, or fixed?\n\t// 4) Maybe refine normals? Should this be part of regular refinement?\n\t// 5) Morphing\n\n};\n\n// Triangle strips!\n\n// TODO: will it be an optimization to specialize this method at\n// runtime for different combinations of stride, decodeOffset and\n// decodeScale?\n\nUTF8Loader.prototype.decompressAttribsInner_ = function (str, inputStart, inputEnd, output, outputStart, stride, decodeOffset, decodeScale) {\n\n\tvar prev = 0;\n\n\tfor (var j = inputStart; j < inputEnd; j++) {\n\n\t\tvar code = str.charCodeAt(j);\n\t\tprev += code >> 1 ^ -(code & 1);\n\n\t\toutput[outputStart] = decodeScale * (prev + decodeOffset);\n\t\toutputStart += stride;\n\t}\n};\n\nUTF8Loader.prototype.decompressIndices_ = function (str, inputStart, numIndices, output, outputStart) {\n\n\tvar highest = 0;\n\n\tfor (var i = 0; i < numIndices; i++) {\n\n\t\tvar code = str.charCodeAt(inputStart++);\n\n\t\toutput[outputStart++] = highest - code;\n\n\t\tif (code === 0) {\n\n\t\t\thighest++;\n\t\t}\n\t}\n};\n\nUTF8Loader.prototype.decompressAABBs_ = function (str, inputStart, numBBoxen, decodeOffsets, decodeScales) {\n\n\tvar numFloats = 6 * numBBoxen;\n\n\tvar inputEnd = inputStart + numFloats;\n\tvar outputStart = 0;\n\n\tvar bboxen = new Float32Array(numFloats);\n\n\tfor (var i = inputStart; i < inputEnd; i += 6) {\n\n\t\tvar minX = str.charCodeAt(i + 0) + decodeOffsets[0];\n\t\tvar minY = str.charCodeAt(i + 1) + decodeOffsets[1];\n\t\tvar minZ = str.charCodeAt(i + 2) + decodeOffsets[2];\n\n\t\tvar radiusX = str.charCodeAt(i + 3) + 1 >> 1;\n\t\tvar radiusY = str.charCodeAt(i + 4) + 1 >> 1;\n\t\tvar radiusZ = str.charCodeAt(i + 5) + 1 >> 1;\n\n\t\tbboxen[outputStart++] = decodeScales[0] * (minX + radiusX);\n\t\tbboxen[outputStart++] = decodeScales[1] * (minY + radiusY);\n\t\tbboxen[outputStart++] = decodeScales[2] * (minZ + radiusZ);\n\n\t\tbboxen[outputStart++] = decodeScales[0] * radiusX;\n\t\tbboxen[outputStart++] = decodeScales[1] * radiusY;\n\t\tbboxen[outputStart++] = decodeScales[2] * radiusZ;\n\t}\n\n\treturn bboxen;\n};\n\nUTF8Loader.prototype.decompressMesh = function (str, meshParams, decodeParams, name, idx, callback) {\n\n\t// Extract conversion parameters from attribArrays.\n\n\tvar stride = decodeParams.decodeScales.length;\n\n\tvar decodeOffsets = decodeParams.decodeOffsets;\n\tvar decodeScales = decodeParams.decodeScales;\n\n\tvar attribStart = meshParams.attribRange[0];\n\tvar numVerts = meshParams.attribRange[1];\n\n\t// Decode attributes.\n\n\tvar inputOffset = attribStart;\n\tvar attribsOut = new Float32Array(stride * numVerts);\n\n\tfor (var j = 0; j < stride; j++) {\n\n\t\tvar end = inputOffset + numVerts;\n\n\t\tvar decodeScale = decodeScales[j];\n\n\t\tif (decodeScale) {\n\n\t\t\t// Assume if decodeScale is never set, simply ignore the\n\t\t\t// attribute.\n\n\t\t\tthis.decompressAttribsInner_(str, inputOffset, end, attribsOut, j, stride, decodeOffsets[j], decodeScale);\n\t\t}\n\n\t\tinputOffset = end;\n\t}\n\n\tvar numIndices = 3 * meshParams.indexRange[1];\n\n\tvar indicesOut = new Uint16Array(numIndices);\n\n\tthis.decompressIndices_(str, inputOffset, numIndices, indicesOut, 0);\n\n\t// Decode bboxen.\n\n\tvar bboxen = undefined;\n\tvar bboxOffset = meshParams.bboxes;\n\n\tif (bboxOffset) {\n\n\t\tbboxen = this.decompressAABBs_(str, bboxOffset, meshParams.names.length, decodeOffsets, decodeScales);\n\t}\n\n\tcallback(name, idx, attribsOut, indicesOut, bboxen, meshParams);\n};\n\nUTF8Loader.prototype.copyAttrib = function (stride, attribsOutFixed, lastAttrib, index) {\n\n\tfor (var j = 0; j < stride; j++) {\n\n\t\tlastAttrib[j] = attribsOutFixed[stride * index + j];\n\t}\n};\n\nUTF8Loader.prototype.decodeAttrib2 = function (str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, index) {\n\n\tfor (var j = 0; j < 5; j++) {\n\n\t\tvar code = str.charCodeAt(deltaStart + numVerts * j + index);\n\t\tvar delta = code >> 1 ^ -(code & 1);\n\n\t\tlastAttrib[j] += delta;\n\t\tattribsOutFixed[stride * index + j] = lastAttrib[j];\n\t\tattribsOut[stride * index + j] = decodeScales[j] * (lastAttrib[j] + decodeOffsets[j]);\n\t}\n};\n\nUTF8Loader.prototype.accumulateNormal = function (i0, i1, i2, attribsOutFixed, crosses) {\n\n\tvar p0x = attribsOutFixed[8 * i0];\n\tvar p0y = attribsOutFixed[8 * i0 + 1];\n\tvar p0z = attribsOutFixed[8 * i0 + 2];\n\n\tvar p1x = attribsOutFixed[8 * i1];\n\tvar p1y = attribsOutFixed[8 * i1 + 1];\n\tvar p1z = attribsOutFixed[8 * i1 + 2];\n\n\tvar p2x = attribsOutFixed[8 * i2];\n\tvar p2y = attribsOutFixed[8 * i2 + 1];\n\tvar p2z = attribsOutFixed[8 * i2 + 2];\n\n\tp1x -= p0x;\n\tp1y -= p0y;\n\tp1z -= p0z;\n\n\tp2x -= p0x;\n\tp2y -= p0y;\n\tp2z -= p0z;\n\n\tp0x = p1y * p2z - p1z * p2y;\n\tp0y = p1z * p2x - p1x * p2z;\n\tp0z = p1x * p2y - p1y * p2x;\n\n\tcrosses[3 * i0] += p0x;\n\tcrosses[3 * i0 + 1] += p0y;\n\tcrosses[3 * i0 + 2] += p0z;\n\n\tcrosses[3 * i1] += p0x;\n\tcrosses[3 * i1 + 1] += p0y;\n\tcrosses[3 * i1 + 2] += p0z;\n\n\tcrosses[3 * i2] += p0x;\n\tcrosses[3 * i2 + 1] += p0y;\n\tcrosses[3 * i2 + 2] += p0z;\n};\n\nUTF8Loader.prototype.decompressMesh2 = function (str, meshParams, decodeParams, name, idx, callback) {\n\n\tvar MAX_BACKREF = 96;\n\n\t// Extract conversion parameters from attribArrays.\n\n\tvar stride = decodeParams.decodeScales.length;\n\n\tvar decodeOffsets = decodeParams.decodeOffsets;\n\tvar decodeScales = decodeParams.decodeScales;\n\n\tvar deltaStart = meshParams.attribRange[0];\n\tvar numVerts = meshParams.attribRange[1];\n\n\tvar codeStart = meshParams.codeRange[0];\n\n\tvar numIndices = 3 * meshParams.codeRange[2];\n\n\tvar indicesOut = new Uint16Array(numIndices);\n\n\tvar crosses = new Int32Array(3 * numVerts);\n\n\tvar lastAttrib = new Uint16Array(stride);\n\n\tvar attribsOutFixed = new Uint16Array(stride * numVerts);\n\tvar attribsOut = new Float32Array(stride * numVerts);\n\n\tvar highest = 0;\n\tvar outputStart = 0;\n\n\tfor (var i = 0; i < numIndices; i += 3) {\n\n\t\tvar code = str.charCodeAt(codeStart++);\n\n\t\tvar max_backref = Math.min(i, MAX_BACKREF);\n\n\t\tif (code < max_backref) {\n\n\t\t\t// Parallelogram\n\n\t\t\tvar winding = code % 3;\n\t\t\tvar backref = i - (code - winding);\n\t\t\tvar i0, i1, i2;\n\n\t\t\tswitch (winding) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\ti0 = indicesOut[backref + 2];\n\t\t\t\t\ti1 = indicesOut[backref + 1];\n\t\t\t\t\ti2 = indicesOut[backref + 0];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\ti0 = indicesOut[backref + 0];\n\t\t\t\t\ti1 = indicesOut[backref + 2];\n\t\t\t\t\ti2 = indicesOut[backref + 1];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\ti0 = indicesOut[backref + 1];\n\t\t\t\t\ti1 = indicesOut[backref + 0];\n\t\t\t\t\ti2 = indicesOut[backref + 2];\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tindicesOut[outputStart++] = i0;\n\t\t\tindicesOut[outputStart++] = i1;\n\n\t\t\tcode = str.charCodeAt(codeStart++);\n\n\t\t\tvar index = highest - code;\n\t\t\tindicesOut[outputStart++] = index;\n\n\t\t\tif (code === 0) {\n\n\t\t\t\tfor (var j = 0; j < 5; j++) {\n\n\t\t\t\t\tvar deltaCode = str.charCodeAt(deltaStart + numVerts * j + highest);\n\n\t\t\t\t\tvar prediction = (deltaCode >> 1 ^ -(deltaCode & 1)) + attribsOutFixed[stride * i0 + j] + attribsOutFixed[stride * i1 + j] - attribsOutFixed[stride * i2 + j];\n\n\t\t\t\t\tlastAttrib[j] = prediction;\n\n\t\t\t\t\tattribsOutFixed[stride * highest + j] = prediction;\n\t\t\t\t\tattribsOut[stride * highest + j] = decodeScales[j] * (prediction + decodeOffsets[j]);\n\t\t\t\t}\n\n\t\t\t\thighest++;\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index);\n\t\t\t}\n\n\t\t\tthis.accumulateNormal(i0, i1, index, attribsOutFixed, crosses);\n\t\t} else {\n\n\t\t\t// Simple\n\n\t\t\tvar index0 = highest - (code - max_backref);\n\n\t\t\tindicesOut[outputStart++] = index0;\n\n\t\t\tif (code === max_backref) {\n\n\t\t\t\tthis.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index0);\n\t\t\t}\n\n\t\t\tcode = str.charCodeAt(codeStart++);\n\n\t\t\tvar index1 = highest - code;\n\t\t\tindicesOut[outputStart++] = index1;\n\n\t\t\tif (code === 0) {\n\n\t\t\t\tthis.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index1);\n\t\t\t}\n\n\t\t\tcode = str.charCodeAt(codeStart++);\n\n\t\t\tvar index2 = highest - code;\n\t\t\tindicesOut[outputStart++] = index2;\n\n\t\t\tif (code === 0) {\n\n\t\t\t\tfor (var j = 0; j < 5; j++) {\n\n\t\t\t\t\tlastAttrib[j] = (attribsOutFixed[stride * index0 + j] + attribsOutFixed[stride * index1 + j]) / 2;\n\t\t\t\t}\n\n\t\t\t\tthis.decodeAttrib2(str, stride, decodeOffsets, decodeScales, deltaStart, numVerts, attribsOut, attribsOutFixed, lastAttrib, highest++);\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index2);\n\t\t\t}\n\n\t\t\tthis.accumulateNormal(index0, index1, index2, attribsOutFixed, crosses);\n\t\t}\n\t}\n\n\tfor (var i = 0; i < numVerts; i++) {\n\n\t\tvar nx = crosses[3 * i];\n\t\tvar ny = crosses[3 * i + 1];\n\t\tvar nz = crosses[3 * i + 2];\n\n\t\tvar norm = 511.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n\n\t\tvar cx = str.charCodeAt(deltaStart + 5 * numVerts + i);\n\t\tvar cy = str.charCodeAt(deltaStart + 6 * numVerts + i);\n\t\tvar cz = str.charCodeAt(deltaStart + 7 * numVerts + i);\n\n\t\tattribsOut[stride * i + 5] = norm * nx + (cx >> 1 ^ -(cx & 1));\n\t\tattribsOut[stride * i + 6] = norm * ny + (cy >> 1 ^ -(cy & 1));\n\t\tattribsOut[stride * i + 7] = norm * nz + (cz >> 1 ^ -(cz & 1));\n\t}\n\n\tcallback(name, idx, attribsOut, indicesOut, undefined, meshParams);\n};\n\nUTF8Loader.prototype.downloadMesh = function (path, name, meshEntry, decodeParams, callback) {\n\n\tvar loader = this;\n\tvar idx = 0;\n\n\tfunction onprogress(data) {\n\n\t\twhile (idx < meshEntry.length) {\n\n\t\t\tvar meshParams = meshEntry[idx];\n\t\t\tvar indexRange = meshParams.indexRange;\n\n\t\t\tif (indexRange) {\n\n\t\t\t\tvar meshEnd = indexRange[0] + 3 * indexRange[1];\n\n\t\t\t\tif (data.length < meshEnd) break;\n\n\t\t\t\tloader.decompressMesh(data, meshParams, decodeParams, name, idx, callback);\n\t\t\t} else {\n\n\t\t\t\tvar codeRange = meshParams.codeRange;\n\t\t\t\tvar meshEnd = codeRange[0] + codeRange[1];\n\n\t\t\t\tif (data.length < meshEnd) break;\n\n\t\t\t\tloader.decompressMesh2(data, meshParams, decodeParams, name, idx, callback);\n\t\t\t}\n\n\t\t\t++idx;\n\t\t}\n\t}\n\n\tgetHttpRequest(path, function (data) {\n\n\t\tonprogress(data);\n\n\t\t// TODO: handle errors.\n\t});\n};\n\nUTF8Loader.prototype.downloadMeshes = function (path, meshUrlMap, decodeParams, callback) {\n\n\tfor (var url in meshUrlMap) {\n\n\t\tvar meshEntry = meshUrlMap[url];\n\t\tthis.downloadMesh(path + url, url, meshEntry, decodeParams, callback);\n\t}\n};\n\nUTF8Loader.prototype.createMeshCallback = function (materialBaseUrl, loadModelInfo, allDoneCallback) {\n\n\tvar nCompletedUrls = 0;\n\tvar nExpectedUrls = 0;\n\n\tvar expectedMeshesPerUrl = {};\n\tvar decodedMeshesPerUrl = {};\n\n\tvar modelParts = {};\n\n\tvar meshUrlMap = loadModelInfo.urls;\n\n\tfor (var url in meshUrlMap) {\n\n\t\texpectedMeshesPerUrl[url] = meshUrlMap[url].length;\n\t\tdecodedMeshesPerUrl[url] = 0;\n\n\t\tnExpectedUrls++;\n\n\t\tmodelParts[url] = new THREE.Object3D();\n\t}\n\n\tvar model = new THREE.Object3D();\n\n\t// Prepare materials first...\n\n\tvar materialCreator = new THREE.MTLLoader.MaterialCreator(materialBaseUrl, loadModelInfo.options);\n\tmaterialCreator.setMaterials(loadModelInfo.materials);\n\n\tmaterialCreator.preload();\n\n\t// Create callback for creating mesh parts\n\n\tvar bufferGeometryCreator = new UTF8Loader.BufferGeometryCreator();\n\n\tvar meshCallback = function meshCallback(name, idx, attribArray, indexArray, bboxen, meshParams) {\n\n\t\t// Got ourselves a new mesh\n\n\t\t// name identifies this part of the model (url)\n\t\t// idx is the mesh index of this mesh of the part\n\t\t// attribArray defines the vertices\n\t\t// indexArray defines the faces\n\t\t// bboxen defines the bounding box\n\t\t// meshParams contains the material info\n\n\t\tvar geometry = bufferGeometryCreator.create(attribArray, indexArray);\n\t\tvar material = materialCreator.create(meshParams.material);\n\n\t\tvar mesh = new THREE.Mesh(geometry, material);\n\t\tmodelParts[name].add(mesh);\n\n\t\t//model.add(new THREE.Mesh(geometry, material));\n\n\t\tdecodedMeshesPerUrl[name]++;\n\n\t\tif (decodedMeshesPerUrl[name] === expectedMeshesPerUrl[name]) {\n\n\t\t\tnCompletedUrls++;\n\n\t\t\tmodel.add(modelParts[name]);\n\n\t\t\tif (nCompletedUrls === nExpectedUrls) {\n\n\t\t\t\t// ALL DONE!!!\n\n\t\t\t\tallDoneCallback(model);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn meshCallback;\n};\n\nUTF8Loader.prototype.downloadModel = function (geometryBase, materialBase, model, callback) {\n\n\tvar meshCallback = this.createMeshCallback(materialBase, model, callback);\n\tthis.downloadMeshes(geometryBase, model.urls, model.decodeParams, meshCallback);\n};\n\nUTF8Loader.prototype.downloadModelJson = function (jsonUrl, callback, options) {\n\n\tgetJsonRequest(jsonUrl, function (loaded) {\n\n\t\tif (!loaded.decodeParams) {\n\n\t\t\tif (options && options.decodeParams) {\n\n\t\t\t\tloaded.decodeParams = options.decodeParams;\n\t\t\t} else {\n\n\t\t\t\tloaded.decodeParams = DEFAULT_DECODE_PARAMS;\n\t\t\t}\n\t\t}\n\n\t\tloaded.options = options;\n\n\t\tvar geometryBase = jsonUrl.substr(0, jsonUrl.lastIndexOf(\"/\") + 1);\n\t\tvar materialBase = geometryBase;\n\n\t\tif (options && options.geometryBase) {\n\n\t\t\tgeometryBase = options.geometryBase;\n\n\t\t\tif (geometryBase.charAt(geometryBase.length - 1) !== \"/\") {\n\n\t\t\t\tgeometryBase = geometryBase + \"/\";\n\t\t\t}\n\t\t}\n\n\t\tif (options && options.materialBase) {\n\n\t\t\tmaterialBase = options.materialBase;\n\n\t\t\tif (materialBase.charAt(materialBase.length - 1) !== \"/\") {\n\n\t\t\t\tmaterialBase = materialBase + \"/\";\n\t\t\t}\n\t\t}\n\n\t\tthis.downloadModel(geometryBase, materialBase, loaded, callback);\n\t}.bind(this));\n};\n\n// XMLHttpRequest stuff\n\nfunction getHttpRequest(url, onload, opt_onprogress) {\n\n\tvar req = new THREE.FileLoader();\n\treq.load(url, onload, opt_onprogress);\n}\n\nfunction getJsonRequest(url, onjson) {\n\n\tgetHttpRequest(url, function (e) {\n\n\t\tonjson(JSON.parse(e));\n\t}, function () {});\n}\n\nfunction addListeners(dom, listeners) {\n\n\t// TODO: handle event capture, object binding.\n\n\tfor (var key in listeners) {\n\n\t\tdom.addEventListener(key, listeners[key]);\n\t}\n}\n\nexports.default = UTF8Loader;\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author Alex Pletzer\n *\n * Updated on 22.03.2017\n * VTK header is now parsed and used to extract all the compressed data\n * @author Andrii Iudin https://github.com/andreyyudin\n * @author Paul Kibet Korir https://github.com/polarise\n * @author Sriram Somasundharam https://github.com/raamssundar\n */\n\nvar VTKLoader = function VTKLoader(manager) {\n\n\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nObject.assign(VTKLoader.prototype, THREE.EventDispatcher.prototype, {\n\n\tload: function load(url, onLoad, onProgress, onError) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\tloader.setResponseType('arraybuffer');\n\t\tloader.load(url, function (text) {\n\n\t\t\tonLoad(scope.parse(text));\n\t\t}, onProgress, onError);\n\t},\n\n\tparse: function parse(data) {\n\n\t\tfunction parseASCII(data) {\n\n\t\t\t// connectivity of the triangles\n\t\t\tvar indices = [];\n\n\t\t\t// triangles vertices\n\t\t\tvar positions = [];\n\n\t\t\t// red, green, blue colors in the range 0 to 1\n\t\t\tvar colors = [];\n\n\t\t\t// normal vector, one per vertex\n\t\t\tvar normals = [];\n\n\t\t\tvar result;\n\n\t\t\t// pattern for reading vertices, 3 floats or integers\n\t\t\tvar pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g;\n\n\t\t\t// pattern for connectivity, an integer followed by any number of ints\n\t\t\t// the first integer is the number of polygon nodes\n\t\t\tvar patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/;\n\n\t\t\t// indicates start of vertex data section\n\t\t\tvar patPOINTS = /^POINTS /;\n\n\t\t\t// indicates start of polygon connectivity section\n\t\t\tvar patPOLYGONS = /^POLYGONS /;\n\n\t\t\t// indicates start of triangle strips section\n\t\t\tvar patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /;\n\n\t\t\t// POINT_DATA number_of_values\n\t\t\tvar patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/;\n\n\t\t\t// CELL_DATA number_of_polys\n\t\t\tvar patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/;\n\n\t\t\t// Start of color section\n\t\t\tvar patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/;\n\n\t\t\t// NORMALS Normals float\n\t\t\tvar patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n\n\t\t\tvar inPointsSection = false;\n\t\t\tvar inPolygonsSection = false;\n\t\t\tvar inTriangleStripSection = false;\n\t\t\tvar inPointDataSection = false;\n\t\t\tvar inCellDataSection = false;\n\t\t\tvar inColorSection = false;\n\t\t\tvar inNormalsSection = false;\n\n\t\t\tvar lines = data.split('\\n');\n\n\t\t\tfor (var i in lines) {\n\n\t\t\t\tvar line = lines[i];\n\n\t\t\t\tif (inPointsSection) {\n\n\t\t\t\t\t// get the vertices\n\t\t\t\t\twhile ((result = pat3Floats.exec(line)) !== null) {\n\n\t\t\t\t\t\tvar x = parseFloat(result[1]);\n\t\t\t\t\t\tvar y = parseFloat(result[2]);\n\t\t\t\t\t\tvar z = parseFloat(result[3]);\n\t\t\t\t\t\tpositions.push(x, y, z);\n\t\t\t\t\t}\n\t\t\t\t} else if (inPolygonsSection) {\n\n\t\t\t\t\tif ((result = patConnectivity.exec(line)) !== null) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tvar numVertices = parseInt(result[1]);\n\t\t\t\t\t\tvar inds = result[2].split(/\\s+/);\n\n\t\t\t\t\t\tif (numVertices >= 3) {\n\n\t\t\t\t\t\t\tvar i0 = parseInt(inds[0]);\n\t\t\t\t\t\t\tvar i1, i2;\n\t\t\t\t\t\t\tvar k = 1;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor (var j = 0; j < numVertices - 2; ++j) {\n\n\t\t\t\t\t\t\t\ti1 = parseInt(inds[k]);\n\t\t\t\t\t\t\t\ti2 = parseInt(inds[k + 1]);\n\t\t\t\t\t\t\t\tindices.push(i0, i1, i2);\n\t\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (inTriangleStripSection) {\n\n\t\t\t\t\tif ((result = patConnectivity.exec(line)) !== null) {\n\n\t\t\t\t\t\t// numVertices i0 i1 i2 ...\n\t\t\t\t\t\tvar numVertices = parseInt(result[1]);\n\t\t\t\t\t\tvar inds = result[2].split(/\\s+/);\n\n\t\t\t\t\t\tif (numVertices >= 3) {\n\n\t\t\t\t\t\t\tvar i0, i1, i2;\n\t\t\t\t\t\t\t// split the polygon in numVertices - 2 triangles\n\t\t\t\t\t\t\tfor (var j = 0; j < numVertices - 2; j++) {\n\n\t\t\t\t\t\t\t\tif (j % 2 === 1) {\n\n\t\t\t\t\t\t\t\t\ti0 = parseInt(inds[j]);\n\t\t\t\t\t\t\t\t\ti1 = parseInt(inds[j + 2]);\n\t\t\t\t\t\t\t\t\ti2 = parseInt(inds[j + 1]);\n\t\t\t\t\t\t\t\t\tindices.push(i0, i1, i2);\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\ti0 = parseInt(inds[j]);\n\t\t\t\t\t\t\t\t\ti1 = parseInt(inds[j + 1]);\n\t\t\t\t\t\t\t\t\ti2 = parseInt(inds[j + 2]);\n\t\t\t\t\t\t\t\t\tindices.push(i0, i1, i2);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (inPointDataSection || inCellDataSection) {\n\n\t\t\t\t\tif (inColorSection) {\n\n\t\t\t\t\t\t// Get the colors\n\n\t\t\t\t\t\twhile ((result = pat3Floats.exec(line)) !== null) {\n\n\t\t\t\t\t\t\tvar r = parseFloat(result[1]);\n\t\t\t\t\t\t\tvar g = parseFloat(result[2]);\n\t\t\t\t\t\t\tvar b = parseFloat(result[3]);\n\t\t\t\t\t\t\tcolors.push(r, g, b);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (inNormalsSection) {\n\n\t\t\t\t\t\t// Get the normal vectors\n\n\t\t\t\t\t\twhile ((result = pat3Floats.exec(line)) !== null) {\n\n\t\t\t\t\t\t\tvar nx = parseFloat(result[1]);\n\t\t\t\t\t\t\tvar ny = parseFloat(result[2]);\n\t\t\t\t\t\t\tvar nz = parseFloat(result[3]);\n\t\t\t\t\t\t\tnormals.push(nx, ny, nz);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (patPOLYGONS.exec(line) !== null) {\n\n\t\t\t\t\tinPolygonsSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patPOINTS.exec(line) !== null) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = true;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinTriangleStripSection = true;\n\t\t\t\t} else if (patPOINT_DATA.exec(line) !== null) {\n\n\t\t\t\t\tinPointDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patCELL_DATA.exec(line) !== null) {\n\n\t\t\t\t\tinCellDataSection = true;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patCOLOR_SCALARS.exec(line) !== null) {\n\n\t\t\t\t\tinColorSection = true;\n\t\t\t\t\tinNormalsSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t} else if (patNORMALS.exec(line) !== null) {\n\n\t\t\t\t\tinNormalsSection = true;\n\t\t\t\t\tinColorSection = false;\n\t\t\t\t\tinPointsSection = false;\n\t\t\t\t\tinPolygonsSection = false;\n\t\t\t\t\tinTriangleStripSection = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar geometry;\n\t\t\tvar stagger = 'point';\n\n\t\t\tif (colors.length === indices.length) {\n\n\t\t\t\tstagger = 'cell';\n\t\t\t}\n\n\t\t\tif (stagger === 'point') {\n\n\t\t\t\t// Nodal. Use BufferGeometry\n\t\t\t\tgeometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex(new THREE.BufferAttribute(new Uint32Array(indices), 1));\n\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(positions), 3));\n\n\t\t\t\tif (colors.length === positions.length) {\n\n\t\t\t\t\tgeometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3));\n\t\t\t\t}\n\n\t\t\t\tif (normals.length === positions.length) {\n\n\t\t\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3));\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Cell centered colors. The only way to attach a solid color to each triangle\n\t\t\t\t// is to use Geometry, which is less efficient than BufferGeometry\n\t\t\t\tgeometry = new THREE.Geometry();\n\n\t\t\t\tvar numTriangles = indices.length / 3;\n\t\t\t\tvar numPoints = positions.length / 3;\n\t\t\t\tvar face;\n\t\t\t\tvar ia, ib, ic;\n\t\t\t\tvar x, y, z;\n\t\t\t\tvar r, g, b;\n\n\t\t\t\tfor (var j = 0; j < numPoints; ++j) {\n\n\t\t\t\t\tx = positions[3 * j + 0];\n\t\t\t\t\ty = positions[3 * j + 1];\n\t\t\t\t\tz = positions[3 * j + 2];\n\t\t\t\t\tgeometry.vertices.push(new THREE.Vector3(x, y, z));\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < numTriangles; ++i) {\n\n\t\t\t\t\tia = indices[3 * i + 0];\n\t\t\t\t\tib = indices[3 * i + 1];\n\t\t\t\t\tic = indices[3 * i + 2];\n\t\t\t\t\tgeometry.faces.push(new THREE.Face3(ia, ib, ic));\n\t\t\t\t}\n\n\t\t\t\tif (colors.length === numTriangles * 3) {\n\n\t\t\t\t\tfor (var i = 0; i < numTriangles; ++i) {\n\n\t\t\t\t\t\tface = geometry.faces[i];\n\t\t\t\t\t\tr = colors[3 * i + 0];\n\t\t\t\t\t\tg = colors[3 * i + 1];\n\t\t\t\t\t\tb = colors[3 * i + 2];\n\t\t\t\t\t\tface.color = new THREE.Color().setRGB(r, g, b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction parseBinary(data) {\n\n\t\t\tvar count, pointIndex, i, numberOfPoints, s;\n\t\t\tvar buffer = new Uint8Array(data);\n\t\t\tvar dataView = new DataView(data);\n\n\t\t\t// Points and normals, by default, are empty\n\t\t\tvar points = [];\n\t\t\tvar normals = [];\n\t\t\tvar indices = [];\n\n\t\t\t// Going to make a big array of strings\n\t\t\tvar vtk = [];\n\t\t\tvar index = 0;\n\n\t\t\tfunction findString(buffer, start) {\n\n\t\t\t\tvar index = start;\n\t\t\t\tvar c = buffer[index];\n\t\t\t\tvar s = [];\n\t\t\t\twhile (c !== 10) {\n\n\t\t\t\t\ts.push(String.fromCharCode(c));\n\t\t\t\t\tindex++;\n\t\t\t\t\tc = buffer[index];\n\t\t\t\t}\n\n\t\t\t\treturn { start: start,\n\t\t\t\t\tend: index,\n\t\t\t\t\tnext: index + 1,\n\t\t\t\t\tparsedString: s.join('') };\n\t\t\t}\n\n\t\t\tvar state, line;\n\n\t\t\twhile (true) {\n\n\t\t\t\t// Get a string\n\t\t\t\tstate = findString(buffer, index);\n\t\t\t\tline = state.parsedString;\n\n\t\t\t\tif (line.indexOf('POINTS') === 0) {\n\n\t\t\t\t\tvtk.push(line);\n\t\t\t\t\t// Add the points\n\t\t\t\t\tnumberOfPoints = parseInt(line.split(' ')[1], 10);\n\n\t\t\t\t\t// Each point is 3 4-byte floats\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tpoints = new Float32Array(numberOfPoints * 3);\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfPoints; i++) {\n\n\t\t\t\t\t\tpoints[3 * i] = dataView.getFloat32(pointIndex, false);\n\t\t\t\t\t\tpoints[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n\t\t\t\t\t\tpoints[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n\t\t\t\t\t\tpointIndex = pointIndex + 12;\n\t\t\t\t\t}\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\t\t\t\t} else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n\n\t\t\t\t\tvar numberOfStrips = parseInt(line.split(' ')[1], 10);\n\t\t\t\t\tvar size = parseInt(line.split(' ')[2], 10);\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfStrips);\n\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfStrips; i++) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tvar indexCount = dataView.getInt32(pointIndex, false);\n\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor (s = 0; s < indexCount; s++) {\n\n\t\t\t\t\t\t\tstrip.push(dataView.getInt32(pointIndex, false));\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// retrieves the n-2 triangles from the triangle strip\n\t\t\t\t\t\tfor (var j = 0; j < indexCount - 2; j++) {\n\n\t\t\t\t\t\t\tif (j % 2) {\n\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\t\t\t\t} else if (line.indexOf('POLYGONS') === 0) {\n\n\t\t\t\t\tvar numberOfStrips = parseInt(line.split(' ')[1], 10);\n\t\t\t\t\tvar size = parseInt(line.split(' ')[2], 10);\n\t\t\t\t\t// 4 byte integers\n\t\t\t\t\tcount = size * 4;\n\n\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfStrips);\n\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfStrips; i++) {\n\n\t\t\t\t\t\t// For each strip, read the first value, then record that many more points\n\t\t\t\t\t\tvar indexCount = dataView.getInt32(pointIndex, false);\n\t\t\t\t\t\tvar strip = [];\n\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\tfor (s = 0; s < indexCount; s++) {\n\n\t\t\t\t\t\t\tstrip.push(dataView.getInt32(pointIndex, false));\n\t\t\t\t\t\t\tpointIndex += 4;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// divide the polygon in n-2 triangle\n\t\t\t\t\t\tfor (var j = 1; j < indexCount - 1; j++) {\n\n\t\t\t\t\t\t\tindices[indicesIndex++] = strip[0];\n\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// increment our next pointer\n\t\t\t\t\tstate.next = state.next + count + 1;\n\t\t\t\t} else if (line.indexOf('POINT_DATA') === 0) {\n\n\t\t\t\t\tnumberOfPoints = parseInt(line.split(' ')[1], 10);\n\n\t\t\t\t\t// Grab the next line\n\t\t\t\t\tstate = findString(buffer, state.next);\n\n\t\t\t\t\t// Now grab the binary data\n\t\t\t\t\tcount = numberOfPoints * 4 * 3;\n\n\t\t\t\t\tnormals = new Float32Array(numberOfPoints * 3);\n\t\t\t\t\tpointIndex = state.next;\n\t\t\t\t\tfor (i = 0; i < numberOfPoints; i++) {\n\n\t\t\t\t\t\tnormals[3 * i] = dataView.getFloat32(pointIndex, false);\n\t\t\t\t\t\tnormals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n\t\t\t\t\t\tnormals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n\t\t\t\t\t\tpointIndex += 12;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment past our data\n\t\t\t\t\tstate.next = state.next + count;\n\t\t\t\t}\n\n\t\t\t\t// Increment index\n\t\t\t\tindex = state.next;\n\n\t\t\t\tif (index >= buffer.byteLength) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\tgeometry.setIndex(new THREE.BufferAttribute(indices, 1));\n\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(points, 3));\n\n\t\t\tif (normals.length === points.length) {\n\n\t\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\t\t\t}\n\n\t\t\treturn geometry;\n\t\t}\n\n\t\tfunction Float32Concat(first, second) {\n\n\t\t\tvar firstLength = first.length,\n\t\t\t    result = new Float32Array(firstLength + second.length);\n\n\t\t\tresult.set(first);\n\t\t\tresult.set(second, firstLength);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction Int32Concat(first, second) {\n\n\t\t\tvar firstLength = first.length,\n\t\t\t    result = new Int32Array(firstLength + second.length);\n\n\t\t\tresult.set(first);\n\t\t\tresult.set(second, firstLength);\n\n\t\t\treturn result;\n\t\t}\n\n\t\tfunction parseXML(stringFile) {\n\n\t\t\t// Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n\n\t\t\tfunction xmlToJson(xml) {\n\n\t\t\t\t// Create the return object\n\t\t\t\tvar obj = {};\n\n\t\t\t\tif (xml.nodeType === 1) {\n\t\t\t\t\t// element\n\n\t\t\t\t\t// do attributes\n\n\t\t\t\t\tif (xml.attributes) {\n\n\t\t\t\t\t\tif (xml.attributes.length > 0) {\n\n\t\t\t\t\t\t\tobj['attributes'] = {};\n\n\t\t\t\t\t\t\tfor (var j = 0; j < xml.attributes.length; j++) {\n\n\t\t\t\t\t\t\t\tvar attribute = xml.attributes.item(j);\n\t\t\t\t\t\t\t\tobj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (xml.nodeType === 3) {\n\t\t\t\t\t// text\n\n\t\t\t\t\tobj = xml.nodeValue.trim();\n\t\t\t\t}\n\n\t\t\t\t// do children\n\t\t\t\tif (xml.hasChildNodes()) {\n\n\t\t\t\t\tfor (var i = 0; i < xml.childNodes.length; i++) {\n\n\t\t\t\t\t\tvar item = xml.childNodes.item(i);\n\t\t\t\t\t\tvar nodeName = item.nodeName;\n\n\t\t\t\t\t\tif (typeof obj[nodeName] === 'undefined') {\n\n\t\t\t\t\t\t\tvar tmp = xmlToJson(item);\n\n\t\t\t\t\t\t\tif (tmp !== '') obj[nodeName] = tmp;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif (typeof obj[nodeName].push === 'undefined') {\n\n\t\t\t\t\t\t\t\tvar old = obj[nodeName];\n\t\t\t\t\t\t\t\tobj[nodeName] = [old];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar tmp = xmlToJson(item);\n\n\t\t\t\t\t\t\tif (tmp !== '') obj[nodeName].push(tmp);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn obj;\n\t\t\t}\n\n\t\t\t// Taken from Base64-js\n\t\t\tfunction Base64toByteArray(b64) {\n\n\t\t\t\tvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n\t\t\t\tvar i;\n\t\t\t\tvar lookup = [];\n\t\t\t\tvar revLookup = [];\n\t\t\t\tvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\t\t\t\tvar len = code.length;\n\n\t\t\t\tfor (i = 0; i < len; i++) {\n\n\t\t\t\t\tlookup[i] = code[i];\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < len; ++i) {\n\n\t\t\t\t\trevLookup[code.charCodeAt(i)] = i;\n\t\t\t\t}\n\n\t\t\t\trevLookup['-'.charCodeAt(0)] = 62;\n\t\t\t\trevLookup['_'.charCodeAt(0)] = 63;\n\n\t\t\t\tvar j, l, tmp, placeHolders, arr;\n\t\t\t\tvar len = b64.length;\n\n\t\t\t\tif (len % 4 > 0) {\n\n\t\t\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4');\n\t\t\t\t}\n\n\t\t\t\tplaceHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n\t\t\t\tarr = new Arr(len * 3 / 4 - placeHolders);\n\t\t\t\tl = placeHolders > 0 ? len - 4 : len;\n\n\t\t\t\tvar L = 0;\n\n\t\t\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\n\t\t\t\t\ttmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n\t\t\t\t\tarr[L++] = (tmp & 0xFF0000) >> 16;\n\t\t\t\t\tarr[L++] = (tmp & 0xFF00) >> 8;\n\t\t\t\t\tarr[L++] = tmp & 0xFF;\n\t\t\t\t}\n\n\t\t\t\tif (placeHolders === 2) {\n\n\t\t\t\t\ttmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n\t\t\t\t\tarr[L++] = tmp & 0xFF;\n\t\t\t\t} else if (placeHolders === 1) {\n\n\t\t\t\t\ttmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n\t\t\t\t\tarr[L++] = tmp >> 8 & 0xFF;\n\t\t\t\t\tarr[L++] = tmp & 0xFF;\n\t\t\t\t}\n\n\t\t\t\treturn arr;\n\t\t\t}\n\n\t\t\tfunction parseDataArray(ele, compressed) {\n\n\t\t\t\tvar numBytes = 0;\n\n\t\t\t\tif (json.attributes.header_type === 'UInt64') {\n\n\t\t\t\t\tnumBytes = 8;\n\t\t\t\t} else if (json.attributes.header_type === 'UInt32') {\n\n\t\t\t\t\tnumBytes = 4;\n\t\t\t\t}\n\n\t\t\t\t// Check the format\n\t\t\t\tif (ele.attributes.format === 'binary' && compressed) {\n\n\t\t\t\t\tvar rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\tvar txt = new Float32Array();\n\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\tvar txt = new Int32Array();\n\t\t\t\t\t}\n\n\t\t\t\t\t// VTP data with the header has the following structure:\n\t\t\t\t\t// [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n\t\t\t\t\t//\n\t\t\t\t\t// Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n\t\t\t\t\t// [#blocks] = Number of blocks\n\t\t\t\t\t// [#u-size] = Block size before compression\n\t\t\t\t\t// [#p-size] = Size of last partial block (zero if it not needed)\n\t\t\t\t\t// [#c-size-i] = Size in bytes of block i after compression\n\t\t\t\t\t//\n\t\t\t\t\t// The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n\t\t\t\t\t// computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\t\t\t\t\trawData = ele['#text'];\n\n\t\t\t\t\tbyteData = Base64toByteArray(rawData);\n\n\t\t\t\t\tblocks = byteData[0];\n\t\t\t\t\tfor (var i = 1; i < numBytes - 1; i++) {\n\n\t\t\t\t\t\tblocks = blocks | byteData[i] << i * numBytes;\n\t\t\t\t\t}\n\n\t\t\t\t\theaderSize = (blocks + 3) * numBytes;\n\t\t\t\t\tpadding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n\t\t\t\t\theaderSize = headerSize + padding;\n\n\t\t\t\t\tdataOffsets = [];\n\t\t\t\t\tcurrentOffset = headerSize;\n\t\t\t\t\tdataOffsets.push(currentOffset);\n\n\t\t\t\t\t// Get the blocks sizes after the compression.\n\t\t\t\t\t// There are three blocks before c-size-i, so we skip 3*numBytes\n\t\t\t\t\tcSizeStart = 3 * numBytes;\n\n\t\t\t\t\tfor (var i = 0; i < blocks; i++) {\n\n\t\t\t\t\t\tvar currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n\t\t\t\t\t\tfor (var j = 1; j < numBytes - 1; j++) {\n\n\t\t\t\t\t\t\t// Each data point consists of 8 bytes regardless of the header type\n\t\t\t\t\t\t\tcurrentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentOffset = currentOffset + currentBlockSize;\n\t\t\t\t\t\tdataOffsets.push(currentOffset);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (var i = 0; i < dataOffsets.length - 1; i++) {\n\n\t\t\t\t\t\tvar inflate = new Zlib.Inflate(byteData.slice(dataOffsets[i], dataOffsets[i + 1]), { resize: true, verify: true }); // eslint-disable-line no-undef\n\t\t\t\t\t\tcontent = inflate.decompress();\n\t\t\t\t\t\tcontent = content.buffer;\n\n\t\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\t\tcontent = new Float32Array(content);\n\t\t\t\t\t\t\ttxt = Float32Concat(txt, content);\n\t\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\t\tcontent = new Int32Array(content);\n\t\t\t\t\t\t\ttxt = Int32Concat(txt, content);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele['#text'];\n\n\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\tif (ele.attributes.format === 'binary') {\n\n\t\t\t\t\t\t\tif (!compressed) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\t\tif (idx !== 0) return true;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\tif (ele.attributes.format === 'binary') {\n\n\t\t\t\t\t\t\tif (!compressed) {\n\n\t\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\t\tif (idx !== 0) return true;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\tif (idx % 2 !== 1) return true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tif (ele.attributes.format === 'binary' && !compressed) {\n\n\t\t\t\t\t\tvar content = Base64toByteArray(ele['#text']);\n\n\t\t\t\t\t\t//  VTP data for the uncompressed case has the following structure:\n\t\t\t\t\t\t// [#bytes][DATA]\n\t\t\t\t\t\t// where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\t\t\t\t\t\tcontent = content.slice(numBytes).buffer;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif (ele['#text']) {\n\n\t\t\t\t\t\t\tvar content = ele['#text'].split(/\\s+/).filter(function (el) {\n\n\t\t\t\t\t\t\t\tif (el !== '') return el;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar content = new Int32Array(0).buffer;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete ele['#text'];\n\n\t\t\t\t\t// Get the content and optimize it\n\t\t\t\t\tif (ele.attributes.type === 'Float32') {\n\n\t\t\t\t\t\tvar txt = new Float32Array(content);\n\t\t\t\t\t} else if (ele.attributes.type === 'Int32') {\n\n\t\t\t\t\t\tvar txt = new Int32Array(content);\n\t\t\t\t\t} else if (ele.attributes.type === 'Int64') {\n\n\t\t\t\t\t\tvar txt = new Int32Array(content);\n\n\t\t\t\t\t\tif (ele.attributes.format === 'binary') {\n\n\t\t\t\t\t\t\ttxt = txt.filter(function (el, idx) {\n\n\t\t\t\t\t\t\t\tif (idx % 2 !== 1) return true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // endif ( ele.attributes.format === 'binary' && compressed )\n\n\t\t\t\treturn txt;\n\t\t\t}\n\n\t\t\t// Main part\n\t\t\t// Get Dom\n\t\t\tvar dom = null;\n\n\t\t\tif (window.DOMParser) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tdom = new DOMParser().parseFromString(stringFile, 'text/xml');\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tdom = null;\n\t\t\t\t}\n\t\t\t} else if (window.ActiveXObject) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tdom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\t\t\t\t\tdom.async = false;\n\n\t\t\t\t\tif (!dom.loadXML()) {\n\n\t\t\t\t\t\tthrow new Error(dom.parseError.reason + dom.parseError.srcText);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\n\t\t\t\t\tdom = null;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tthrow new Error('Cannot parse xml string!');\n\t\t\t}\n\n\t\t\t// Get the doc\n\t\t\tvar doc = dom.documentElement;\n\t\t\t// Convert to json\n\t\t\tvar json = xmlToJson(doc);\n\t\t\tvar points = [];\n\t\t\tvar normals = [];\n\t\t\tvar indices = [];\n\n\t\t\tif (json.PolyData) {\n\n\t\t\t\tvar piece = json.PolyData.Piece;\n\t\t\t\tvar compressed = json.attributes.hasOwnProperty('compressor');\n\n\t\t\t\t// Can be optimized\n\t\t\t\t// Loop through the sections\n\t\t\t\tvar sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\t\t\t\tvar sectionIndex = 0,\n\t\t\t\t    numberOfSections = sections.length;\n\n\t\t\t\twhile (sectionIndex < numberOfSections) {\n\n\t\t\t\t\tvar section = piece[sections[sectionIndex]];\n\n\t\t\t\t\t// If it has a DataArray in it\n\n\t\t\t\t\tif (section && section.DataArray) {\n\n\t\t\t\t\t\t// Depending on the number of DataArrays\n\n\t\t\t\t\t\tif (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n\n\t\t\t\t\t\t\tvar arr = section.DataArray;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar arr = [section.DataArray];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar dataArrayIndex = 0,\n\t\t\t\t\t\t    numberOfDataArrays = arr.length;\n\n\t\t\t\t\t\twhile (dataArrayIndex < numberOfDataArrays) {\n\n\t\t\t\t\t\t\t// Parse the DataArray\n\t\t\t\t\t\t\tif ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n\n\t\t\t\t\t\t\t\tarr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdataArrayIndex++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tswitch (sections[sectionIndex]) {\n\n\t\t\t\t\t\t\t// if iti is point data\n\t\t\t\t\t\t\tcase 'PointData':\n\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\t\t\t\t\t\t\t\tvar normalsName = section.attributes.Normals;\n\n\t\t\t\t\t\t\t\tif (numberOfPoints > 0) {\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, len = arr.length; i < len; i++) {\n\n\t\t\t\t\t\t\t\t\t\tif (normalsName === arr[i].attributes.Name) {\n\n\t\t\t\t\t\t\t\t\t\t\tvar components = arr[i].attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\t\t\tnormals = new Float32Array(numberOfPoints * components);\n\t\t\t\t\t\t\t\t\t\t\tnormals.set(arr[i].text, 0);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is points\n\t\t\t\t\t\t\tcase 'Points':\n\n\t\t\t\t\t\t\t\tvar numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n\t\t\t\t\t\t\t\tif (numberOfPoints > 0) {\n\n\t\t\t\t\t\t\t\t\tvar components = section.DataArray.attributes.NumberOfComponents;\n\t\t\t\t\t\t\t\t\tpoints = new Float32Array(numberOfPoints * components);\n\t\t\t\t\t\t\t\t\tpoints.set(section.DataArray.text, 0);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is strips\n\t\t\t\t\t\t\tcase 'Strips':\n\n\t\t\t\t\t\t\t\tvar numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n\t\t\t\t\t\t\t\tif (numberOfStrips > 0) {\n\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array(section.DataArray[0].text.length);\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array(section.DataArray[1].text.length);\n\t\t\t\t\t\t\t\t\tconnectivity.set(section.DataArray[0].text, 0);\n\t\t\t\t\t\t\t\t\toffset.set(section.DataArray[1].text, 0);\n\n\t\t\t\t\t\t\t\t\tvar size = numberOfStrips + connectivity.length;\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfStrips);\n\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, len = numberOfStrips; i < len; i++) {\n\n\t\t\t\t\t\t\t\t\t\tvar strip = [];\n\n\t\t\t\t\t\t\t\t\t\tfor (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n\n\t\t\t\t\t\t\t\t\t\t\tstrip.push(connectivity[s]);\n\n\t\t\t\t\t\t\t\t\t\t\tif (i > 0) len0 = offset[i - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tfor (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\tif (j % 2) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 1];\n\t\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = strip[j + 2];\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tif (i > 0) len0 = offset[i - 1];\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t// if it is polys\n\t\t\t\t\t\t\tcase 'Polys':\n\n\t\t\t\t\t\t\t\tvar numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n\t\t\t\t\t\t\t\tif (numberOfPolys > 0) {\n\n\t\t\t\t\t\t\t\t\tvar connectivity = new Int32Array(section.DataArray[0].text.length);\n\t\t\t\t\t\t\t\t\tvar offset = new Int32Array(section.DataArray[1].text.length);\n\t\t\t\t\t\t\t\t\tconnectivity.set(section.DataArray[0].text, 0);\n\t\t\t\t\t\t\t\t\toffset.set(section.DataArray[1].text, 0);\n\n\t\t\t\t\t\t\t\t\tvar size = numberOfPolys + connectivity.length;\n\t\t\t\t\t\t\t\t\tindices = new Uint32Array(3 * size - 9 * numberOfPolys);\n\t\t\t\t\t\t\t\t\tvar indicesIndex = 0,\n\t\t\t\t\t\t\t\t\t    connectivityIndex = 0;\n\t\t\t\t\t\t\t\t\tvar i = 0,\n\t\t\t\t\t\t\t\t\t    len = numberOfPolys,\n\t\t\t\t\t\t\t\t\t    len0 = 0;\n\n\t\t\t\t\t\t\t\t\twhile (i < len) {\n\n\t\t\t\t\t\t\t\t\t\tvar poly = [];\n\t\t\t\t\t\t\t\t\t\tvar s = 0,\n\t\t\t\t\t\t\t\t\t\t    len1 = offset[i];\n\n\t\t\t\t\t\t\t\t\t\twhile (s < len1 - len0) {\n\n\t\t\t\t\t\t\t\t\t\t\tpoly.push(connectivity[connectivityIndex++]);\n\t\t\t\t\t\t\t\t\t\t\ts++;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar j = 1;\n\n\t\t\t\t\t\t\t\t\t\twhile (j < len1 - len0 - 1) {\n\n\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = poly[0];\n\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = poly[j];\n\t\t\t\t\t\t\t\t\t\t\tindices[indicesIndex++] = poly[j + 1];\n\t\t\t\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\tlen0 = offset[i - 1];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsectionIndex++;\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.setIndex(new THREE.BufferAttribute(indices, 1));\n\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(points, 3));\n\n\t\t\t\tif (normals.length === points.length) {\n\n\t\t\t\t\tgeometry.addAttribute('normal', new THREE.BufferAttribute(normals, 3));\n\t\t\t\t}\n\n\t\t\t\treturn geometry;\n\t\t\t} else {\n\n\t\t\t\t// TODO for vtu,vti,and other xml formats\n\n\t\t\t}\n\t\t}\n\n\t\tfunction getStringFile(data) {\n\n\t\t\tvar stringFile = '';\n\t\t\tvar charArray = new Uint8Array(data);\n\t\t\tvar i = 0;\n\t\t\tvar len = charArray.length;\n\n\t\t\twhile (len--) {\n\n\t\t\t\tstringFile += String.fromCharCode(charArray[i++]);\n\t\t\t}\n\n\t\t\treturn stringFile;\n\t\t}\n\n\t\t// get the 5 first lines of the files to check if there is the key word binary\n\t\tvar meta = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n\t\tif (meta[0].indexOf('xml') !== -1) {\n\n\t\t\treturn parseXML(getStringFile(data));\n\t\t} else if (meta[2].includes('ASCII')) {\n\n\t\t\treturn parseASCII(getStringFile(data));\n\t\t} else {\n\n\t\t\treturn parseBinary(data);\n\t\t}\n\t}\n\n});\n\nexports.default = VTKLoader;\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// ( function ( global, factory ) {\n//\n// \ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n// \t\ttypeof define === 'function' && define.amd ? define( factory ) :\n// \t\t\t( global.THREE = global.THREE || {}, global.THREE.XLoader = factory() );\n//\n// }( this, ( function () {\n\n'use strict';\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n\n\tif (!(instance instanceof Constructor)) {\n\n\t\tthrow new TypeError(\"Cannot call a class as a function\");\n\t}\n};\n\nvar createClass = function () {\n\n\tfunction defineProperties(target, props) {\n\n\t\tfor (var i = 0; i < props.length; i++) {\n\n\t\t\tvar descriptor = props[i];\n\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\tdescriptor.configurable = true;\n\t\t\tif (\"value\" in descriptor) descriptor.writable = true;\n\t\t\tObject.defineProperty(target, descriptor.key, descriptor);\n\t\t}\n\t}\n\n\treturn function (Constructor, protoProps, staticProps) {\n\n\t\tif (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\tif (staticProps) defineProperties(Constructor, staticProps);\n\t\treturn Constructor;\n\t};\n}();\n\nvar XboneInf = function XboneInf() {\n\n\tclassCallCheck(this, XboneInf);\n\n\tthis.boneName = \"\";\n\tthis.BoneIndex = 0;\n\tthis.Indeces = [];\n\tthis.Weights = [];\n\tthis.initMatrix = null;\n\tthis.OffsetMatrix = null;\n};\n\nvar XAnimationInfo = function XAnimationInfo() {\n\n\tclassCallCheck(this, XAnimationInfo);\n\n\tthis.animeName = \"\";\n\tthis.boneName = \"\";\n\tthis.targetBone = null;\n\tthis.keyType = 4;\n\tthis.frameStartLv = 0;\n\tthis.keyFrames = [];\n\tthis.InverseMx = null;\n};\n\nvar XAnimationObj = function () {\n\n\tfunction XAnimationObj(_flags) {\n\n\t\tclassCallCheck(this, XAnimationObj);\n\n\t\tthis.fps = 30;\n\t\tthis.name = 'xanimation';\n\t\tthis.length = 0;\n\t\tthis.hierarchy = [];\n\t\tthis.putFlags = _flags;\n\t\tif (this.putFlags.putPos === undefined) {\n\n\t\t\tthis.putFlags.putPos = true;\n\t\t}\n\t\tif (this.putFlags.putRot === undefined) {\n\n\t\t\tthis.putFlags.putRot = true;\n\t\t}\n\t\tif (this.putFlags.putScl === undefined) {\n\n\t\t\tthis.putFlags.putScl = true;\n\t\t}\n\t}\n\n\tcreateClass(XAnimationObj, [{\n\t\tkey: \"make\",\n\t\tvalue: function make(XAnimationInfoArray) {\n\n\t\t\tfor (var i = 0; i < XAnimationInfoArray.length; i++) {\n\n\t\t\t\tthis.hierarchy.push(this.makeBonekeys(XAnimationInfoArray[i]));\n\t\t\t}\n\t\t\tthis.length = this.hierarchy[0].keys[this.hierarchy[0].keys.length - 1].time;\n\t\t}\n\t}, {\n\t\tkey: \"clone\",\n\t\tvalue: function clone() {\n\n\t\t\treturn Object.assign({}, this);\n\t\t}\n\t}, {\n\t\tkey: \"makeBonekeys\",\n\t\tvalue: function makeBonekeys(XAnimationInfo) {\n\n\t\t\tvar refObj = {};\n\t\t\trefObj.name = XAnimationInfo.boneName;\n\t\t\trefObj.parent = \"\";\n\t\t\trefObj.keys = this.keyFrameRefactor(XAnimationInfo);\n\t\t\trefObj.copy = function () {\n\n\t\t\t\treturn Object.assign({}, this);\n\t\t\t};\n\t\t\treturn refObj;\n\t\t}\n\t}, {\n\t\tkey: \"keyFrameRefactor\",\n\t\tvalue: function keyFrameRefactor(XAnimationInfo) {\n\n\t\t\tvar keys = [];\n\t\t\tfor (var i = 0; i < XAnimationInfo.keyFrames.length; i++) {\n\n\t\t\t\tvar keyframe = {};\n\t\t\t\tkeyframe.time = XAnimationInfo.keyFrames[i].time * this.fps;\n\t\t\t\tif (XAnimationInfo.keyFrames[i].pos && this.putFlags.putPos) {\n\n\t\t\t\t\tkeyframe.pos = XAnimationInfo.keyFrames[i].pos;\n\t\t\t\t}\n\t\t\t\tif (XAnimationInfo.keyFrames[i].rot && this.putFlags.putRot) {\n\n\t\t\t\t\tkeyframe.rot = XAnimationInfo.keyFrames[i].rot;\n\t\t\t\t}\n\t\t\t\tif (XAnimationInfo.keyFrames[i].scl && this.putFlags.putScl) {\n\n\t\t\t\t\tkeyframe.scl = XAnimationInfo.keyFrames[i].scl;\n\t\t\t\t}\n\t\t\t\tif (XAnimationInfo.keyFrames[i].matrix) {\n\n\t\t\t\t\tkeyframe.matrix = XAnimationInfo.keyFrames[i].matrix;\n\t\t\t\t\tif (this.putFlags.putPos) {\n\n\t\t\t\t\t\tkeyframe.pos = new THREE.Vector3().setFromMatrixPosition(keyframe.matrix);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.putFlags.putRot) {\n\n\t\t\t\t\t\tkeyframe.rot = new THREE.Quaternion().setFromRotationMatrix(keyframe.matrix);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.putFlags.putScl) {\n\n\t\t\t\t\t\tkeyframe.scl = new THREE.Vector3().setFromMatrixScale(keyframe.matrix);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tkeys.push(keyframe);\n\t\t\t}\n\t\t\treturn keys;\n\t\t}\n\t}]);\n\treturn XAnimationObj;\n}();\n\nvar XKeyFrameInfo = function XKeyFrameInfo() {\n\n\tclassCallCheck(this, XKeyFrameInfo);\n\n\tthis.index = 0;\n\tthis.Frame = 0;\n\tthis.time = 0.0;\n\tthis.matrix = null;\n};\n\nvar XLoader = function () {\n\n\tfunction XLoader(manager, texloader) {\n\n\t\tclassCallCheck(this, XLoader);\n\n\t\tthis.debug = false;\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\tthis.texloader = texloader !== undefined ? texloader : new THREE.TextureLoader();\n\t\tthis.url = \"\";\n\t\tthis.baseDir = \"\";\n\t\tthis._putMatLength = 0;\n\t\tthis._nowMat = null;\n\t\tthis._tmpUvArray = [];\n\t\tthis._facesNormal = [];\n\t\tthis._nowFrameName = \"\";\n\t\tthis.frameHierarchie = [];\n\t\tthis.Hierarchies = {};\n\t\tthis.HieStack = [];\n\t\tthis._currentObject = {};\n\t\tthis._currentFrame = {};\n\t\tthis._data = null;\n\t\tthis.onLoad = null;\n\t\tthis.IsUvYReverse = true;\n\t\tthis.Meshes = [];\n\t\tthis.animations = [];\n\t\tthis.animTicksPerSecond = 30;\n\t\tthis._currentGeo = null;\n\t\tthis._currentAnime = null;\n\t\tthis._currentAnimeFrames = null;\n\t}\n\n\tcreateClass(XLoader, [{\n\t\tkey: '_setArgOption',\n\t\tvalue: function _setArgOption(_arg) {\n\n\t\t\tvar _start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n\t\t\tif (!_arg) {\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (var i = _start; i < _arg.length; i++) {\n\n\t\t\t\tswitch (i) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tthis.url = _arg[i];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tthis.options = _arg[i];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options === undefined) {\n\n\t\t\t\tthis.options = {};\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'load',\n\t\tvalue: function load(_arg, onLoad, onProgress, onError) {\n\n\t\t\tvar _this = this;\n\n\t\t\tthis._setArgOption(_arg);\n\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\tloader.setResponseType('arraybuffer');\n\t\t\tloader.load(this.url, function (response) {\n\n\t\t\t\t_this._parse(response, onLoad);\n\t\t\t}, onProgress, onError);\n\t\t}\n\t}, {\n\t\tkey: 'fromResponsedData',\n\t\tvalue: function fromResponsedData(_data, _arg, onLoad) {\n\n\t\t\tthis._setArgOption(_arg);\n\t\t\tthis._parse(_data, onLoad);\n\t\t}\n\t}, {\n\t\tkey: '_readLine',\n\t\tvalue: function _readLine(line) {\n\n\t\t\tvar readed = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tvar find = -1;\n\t\t\t\tfind = line.indexOf('//', readed);\n\t\t\t\tif (find === -1) {\n\n\t\t\t\t\tfind = line.indexOf('#', readed);\n\t\t\t\t}\n\t\t\t\tif (find > -1 && find < 2) {\n\n\t\t\t\t\tvar foundNewLine = -1;\n\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\\n\", readed);\n\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\treaded = foundNewLine + 2;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\", readed);\n\t\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treaded = line.indexOf(\"\\n\", readed) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn line.substr(readed);\n\t\t}\n\t}, {\n\t\tkey: '_readLine',\n\t\tvalue: function _readLine(line) {\n\n\t\t\tvar readed = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tvar find = -1;\n\t\t\t\tfind = line.indexOf('//', readed);\n\t\t\t\tif (find === -1) {\n\n\t\t\t\t\tfind = line.indexOf('#', readed);\n\t\t\t\t}\n\t\t\t\tif (find > -1 && find < 2) {\n\n\t\t\t\t\tvar foundNewLine = -1;\n\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\\n\", readed);\n\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\treaded = foundNewLine + 2;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tfoundNewLine = line.indexOf(\"\\r\", readed);\n\t\t\t\t\t\tif (foundNewLine > 0) {\n\n\t\t\t\t\t\t\treaded = foundNewLine + 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\treaded = line.indexOf(\"\\n\", readed) + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn line.substr(readed);\n\t\t}\n\t}, {\n\t\tkey: '_isBinary',\n\t\tvalue: function _isBinary(binData) {\n\n\t\t\tvar reader = new DataView(binData);\n\t\t\tvar face_size = 32 / 8 * 3 + 32 / 8 * 3 * 3 + 16 / 8;\n\t\t\tvar n_faces = reader.getUint32(80, true);\n\t\t\tvar expect = 80 + 32 / 8 + n_faces * face_size;\n\t\t\tif (expect === reader.byteLength) {\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar fileLength = reader.byteLength;\n\t\t\tfor (var index = 0; index < fileLength; index++) {\n\n\t\t\t\tif (reader.getUint8(index, false) > 127) {\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}, {\n\t\tkey: 'ensureBinary',\n\t\tvalue: function ensureBinary(buf) {\n\n\t\t\tif (typeof buf === \"string\") {\n\n\t\t\t\tvar array_buffer = new Uint8Array(buf.length);\n\t\t\t\tfor (var i = 0; i < buf.length; i++) {\n\n\t\t\t\t\tarray_buffer[i] = buf.charCodeAt(i) & 0xff;\n\t\t\t\t}\n\t\t\t\treturn array_buffer.buffer || array_buffer;\n\t\t\t} else {\n\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'ensureString',\n\t\tvalue: function ensureString(buf) {\n\n\t\t\tif (typeof buf !== \"string\") {\n\n\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(buf));\n\t\t\t} else {\n\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_parse',\n\t\tvalue: function _parse(data, onLoad) {\n\n\t\t\tvar binData = this.ensureBinary(data);\n\t\t\tthis._data = this.ensureString(data);\n\t\t\tthis.onLoad = onLoad;\n\t\t\treturn this._isBinary(binData) ? this._parseBinary(binData) : this._parseASCII();\n\t\t}\n\t}, {\n\t\tkey: '_parseBinary',\n\t\tvalue: function _parseBinary(data) {\n\n\t\t\treturn this._parseASCII(THREE.LoaderUtils.decodeText(new Uint8Array(data)));\n\t\t}\n\t}, {\n\t\tkey: '_parseASCII',\n\t\tvalue: function _parseASCII() {\n\n\t\t\tif (this.url.lastIndexOf(\"/\") > 0) {\n\n\t\t\t\tthis.baseDir = this.url.substr(0, this.url.lastIndexOf(\"/\") + 1);\n\t\t\t}\n\t\t\tvar endRead = 16;\n\t\t\tthis.Hierarchies.children = [];\n\t\t\tthis._hierarchieParse(this.Hierarchies, endRead);\n\t\t\tthis._changeRoot();\n\t\t\tthis._currentObject = this.Hierarchies.children.shift();\n\t\t\tthis.mainloop();\n\t\t}\n\t}, {\n\t\tkey: '_hierarchieParse',\n\t\tvalue: function _hierarchieParse(_parent, _end) {\n\n\t\t\tvar endRead = _end;\n\t\t\twhile (true) {\n\n\t\t\t\tvar find1 = this._data.indexOf('{', endRead) + 1;\n\t\t\t\tvar findEnd = this._data.indexOf('}', endRead);\n\t\t\t\tvar findNext = this._data.indexOf('{', find1) + 1;\n\t\t\t\tif (find1 > 0 && findEnd > find1) {\n\n\t\t\t\t\tvar _currentObject = {};\n\t\t\t\t\t_currentObject.children = [];\n\t\t\t\t\tvar nameData = this._readLine(this._data.substr(endRead, find1 - endRead - 1)).trim();\n\t\t\t\t\tvar word = nameData.split(/ /g);\n\t\t\t\t\tif (word.length > 0) {\n\n\t\t\t\t\t\t_currentObject.type = word[0];\n\t\t\t\t\t\tif (word.length >= 2) {\n\n\t\t\t\t\t\t\t_currentObject.name = word[1];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_currentObject.name = word[0] + this.Hierarchies.children.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_currentObject.name = nameData;\n\t\t\t\t\t\t_currentObject.type = \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif (_currentObject.type === \"Animation\") {\n\n\t\t\t\t\t\t_currentObject.data = this._data.substr(findNext, findEnd - findNext).trim();\n\t\t\t\t\t\tvar refs = this._hierarchieParse(_currentObject, findEnd + 1);\n\t\t\t\t\t\tendRead = refs.end;\n\t\t\t\t\t\t_currentObject.children = refs.parent.children;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar DataEnder = this._data.lastIndexOf(';', findNext > 0 ? Math.min(findNext, findEnd) : findEnd);\n\t\t\t\t\t\t_currentObject.data = this._data.substr(find1, DataEnder - find1).trim();\n\t\t\t\t\t\tif (findNext <= 0 || findEnd < findNext) {\n\n\t\t\t\t\t\t\tendRead = findEnd + 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar nextStart = Math.max(DataEnder + 1, find1);\n\t\t\t\t\t\t\tvar _refs = this._hierarchieParse(_currentObject, nextStart);\n\t\t\t\t\t\t\tendRead = _refs.end;\n\t\t\t\t\t\t\t_currentObject.children = _refs.parent.children;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_currentObject.parent = _parent;\n\t\t\t\t\tif (_currentObject.type != \"template\") {\n\n\t\t\t\t\t\t_parent.children.push(_currentObject);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tendRead = find1 === -1 ? this._data.length : findEnd + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tparent: _parent,\n\t\t\t\tend: endRead\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: 'mainloop',\n\t\tvalue: function mainloop() {\n\n\t\t\tvar _this2 = this;\n\n\t\t\tthis.mainProc();\n\t\t\tif (this._currentObject.parent || this._currentObject.children.length > 0 || !this._currentObject.worked) {\n\n\t\t\t\tsetTimeout(function () {\n\n\t\t\t\t\t_this2.mainloop();\n\t\t\t\t}, 1);\n\t\t\t} else {\n\n\t\t\t\tsetTimeout(function () {\n\n\t\t\t\t\t_this2.onLoad({\n\t\t\t\t\t\tmodels: _this2.Meshes,\n\t\t\t\t\t\tanimations: _this2.animations\n\t\t\t\t\t});\n\t\t\t\t}, 1);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: 'mainProc',\n\t\tvalue: function mainProc() {\n\n\t\t\tvar breakFlag = false;\n\t\t\twhile (true) {\n\n\t\t\t\tif (!this._currentObject.worked) {\n\n\t\t\t\t\tswitch (this._currentObject.type) {\n\n\t\t\t\t\t\tcase \"template\":\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"AnimTicksPerSecond\":\n\t\t\t\t\t\t\tthis.animTicksPerSecond = parseInt(this._currentObject.data);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Frame\":\n\t\t\t\t\t\t\tthis._setFrame();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"FrameTransformMatrix\":\n\t\t\t\t\t\t\tthis._setFrameTransformMatrix();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\tthis._currentGeo = {};\n\t\t\t\t\t\t\tthis._currentGeo.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\tthis._currentGeo.parentName = this._getParentName(this._currentObject).trim();\n\t\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount = [];\n\t\t\t\t\t\t\tthis._currentGeo.Geometry = new THREE.Geometry();\n\t\t\t\t\t\t\tthis._currentGeo.Materials = [];\n\t\t\t\t\t\t\tthis._currentGeo.normalVectors = [];\n\t\t\t\t\t\t\tthis._currentGeo.BoneInfs = [];\n\t\t\t\t\t\t\tthis._currentGeo.baseFrame = this._currentFrame;\n\t\t\t\t\t\t\tthis._makeBoneFrom_CurrentFrame();\n\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\tthis._readVertexDatas();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshTextureCoords\":\n\t\t\t\t\t\t\tthis._setMeshTextureCoords();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"VertexDuplicationIndices\":\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshMaterialList\":\n\t\t\t\t\t\t\tthis._setMeshMaterialList();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Material\":\n\t\t\t\t\t\t\tthis._setMaterial();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"SkinWeights\":\n\t\t\t\t\t\t\tthis._setSkinWeights();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"AnimationSet\":\n\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t\tthis._currentAnime = {};\n\t\t\t\t\t\t\tthis._currentAnime.name = this._currentObject.name.trim();\n\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames = [];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"Animation\":\n\t\t\t\t\t\t\tif (this._currentAnimeFrames) {\n\n\t\t\t\t\t\t\t\tthis._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis._currentAnimeFrames = new XAnimationInfo();\n\t\t\t\t\t\t\tthis._currentAnimeFrames.boneName = this._currentObject.data.trim();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"AnimationKey\":\n\t\t\t\t\t\t\tthis._readAnimationKey();\n\t\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tthis._currentObject.worked = true;\n\t\t\t\t}\n\t\t\t\tif (this._currentObject.children.length > 0) {\n\n\t\t\t\t\tthis._currentObject = this._currentObject.children.shift();\n\t\t\t\t\tif (this.debug) {\n\n\t\t\t\t\t\tconsole.log('processing ' + this._currentObject.name);\n\t\t\t\t\t}\n\t\t\t\t\tif (breakFlag) break;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (this._currentObject.worked) {\n\n\t\t\t\t\t\tif (this._currentObject.parent && !this._currentObject.parent.parent) {\n\n\t\t\t\t\t\t\tthis._changeRoot();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._currentObject.parent) {\n\n\t\t\t\t\t\tthis._currentObject = this._currentObject.parent;\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreakFlag = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (breakFlag) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}, {\n\t\tkey: '_changeRoot',\n\t\tvalue: function _changeRoot() {\n\n\t\t\tif (this._currentGeo != null && this._currentGeo.name) {\n\n\t\t\t\tthis._makeOutputGeometry();\n\t\t\t}\n\t\t\tthis._currentGeo = {};\n\t\t\tif (this._currentAnime != null && this._currentAnime.name) {\n\n\t\t\t\tif (this._currentAnimeFrames) {\n\n\t\t\t\t\tthis._currentAnime.AnimeFrames.push(this._currentAnimeFrames);\n\t\t\t\t\tthis._currentAnimeFrames = null;\n\t\t\t\t}\n\t\t\t\tthis._makeOutputAnimation();\n\t\t\t}\n\t\t\tthis._currentAnime = {};\n\t\t}\n\t}, {\n\t\tkey: '_getParentName',\n\t\tvalue: function _getParentName(_obj) {\n\n\t\t\tif (_obj.parent) {\n\n\t\t\t\tif (_obj.parent.name) {\n\n\t\t\t\t\treturn _obj.parent.name;\n\t\t\t\t} else {\n\n\t\t\t\t\treturn this._getParentName(_obj.parent);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_setFrame',\n\t\tvalue: function _setFrame() {\n\n\t\t\tthis._nowFrameName = this._currentObject.name.trim();\n\t\t\tthis._currentFrame = {};\n\t\t\tthis._currentFrame.name = this._nowFrameName;\n\t\t\tthis._currentFrame.children = [];\n\t\t\tif (this._currentObject.parent && this._currentObject.parent.name) {\n\n\t\t\t\tthis._currentFrame.parentName = this._currentObject.parent.name;\n\t\t\t}\n\t\t\tthis.frameHierarchie.push(this._nowFrameName);\n\t\t\tthis.HieStack[this._nowFrameName] = this._currentFrame;\n\t\t}\n\t}, {\n\t\tkey: '_setFrameTransformMatrix',\n\t\tvalue: function _setFrameTransformMatrix() {\n\n\t\t\tthis._currentFrame.FrameTransformMatrix = new THREE.Matrix4();\n\t\t\tvar data = this._currentObject.data.split(\",\");\n\t\t\tthis._ParseMatrixData(this._currentFrame.FrameTransformMatrix, data);\n\t\t\tthis._makeBoneFrom_CurrentFrame();\n\t\t}\n\t}, {\n\t\tkey: '_makeBoneFrom_CurrentFrame',\n\t\tvalue: function _makeBoneFrom_CurrentFrame() {\n\n\t\t\tif (!this._currentFrame.FrameTransformMatrix) {\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar b = new THREE.Bone();\n\t\t\tb.name = this._currentFrame.name;\n\t\t\tb.applyMatrix(this._currentFrame.FrameTransformMatrix);\n\t\t\tb.matrixWorld = b.matrix;\n\t\t\tb.FrameTransformMatrix = this._currentFrame.FrameTransformMatrix;\n\t\t\tthis._currentFrame.putBone = b;\n\t\t\tif (this._currentFrame.parentName) {\n\n\t\t\t\tfor (var frame in this.HieStack) {\n\n\t\t\t\t\tif (this.HieStack[frame].name === this._currentFrame.parentName) {\n\n\t\t\t\t\t\tthis.HieStack[frame].putBone.add(this._currentFrame.putBone);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_readVertexDatas',\n\t\tvalue: function _readVertexDatas() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\tvar maxLength = 0;\n\t\t\tvar nowReadedLine = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tvar changeMode = false;\n\t\t\t\tif (mode_local === 0) {\n\n\t\t\t\t\tvar refO = this._readInt1(endRead);\n\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\tmode_local = 1;\n\t\t\t\t\tnowReadedLine = 0;\n\t\t\t\t\tmaxLength = this._currentObject.data.indexOf(';;', endRead) + 1;\n\t\t\t\t\tif (maxLength <= 0) {\n\n\t\t\t\t\t\tmaxLength = this._currentObject.data.length;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tvar find = 0;\n\t\t\t\t\tswitch (mode) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf(',', endRead) + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf(';,', endRead) + 1;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (find === 0 || find > maxLength) {\n\n\t\t\t\t\t\tfind = maxLength;\n\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\tchangeMode = true;\n\t\t\t\t\t}\n\t\t\t\t\tswitch (this._currentObject.type) {\n\n\t\t\t\t\t\tcase \"Mesh\":\n\t\t\t\t\t\t\tswitch (mode) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tthis._readVertex1(this._currentObject.data.substr(endRead, find - endRead));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tthis._readFace1(this._currentObject.data.substr(endRead, find - endRead));\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"MeshNormals\":\n\t\t\t\t\t\t\tswitch (mode) {\n\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tthis._readNormalVector1(this._currentObject.data.substr(endRead, find - endRead));\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tthis._readNormalFace1(this._currentObject.data.substr(endRead, find - endRead), nowReadedLine);\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\tnowReadedLine++;\n\t\t\t\t\tif (changeMode) {\n\n\t\t\t\t\t\tmode++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_readInt1',\n\t\tvalue: function _readInt1(start) {\n\n\t\t\tvar find = this._currentObject.data.indexOf(';', start);\n\t\t\treturn {\n\t\t\t\trefI: parseInt(this._currentObject.data.substr(start, find - start)),\n\t\t\t\tendRead: find + 1\n\t\t\t};\n\t\t}\n\t}, {\n\t\tkey: '_readVertex1',\n\t\tvalue: function _readVertex1(line) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(0, line.length - 2).split(\";\");\n\t\t\tthis._currentGeo.Geometry.vertices.push(new THREE.Vector3(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])));\n\t\t\tthis._currentGeo.Geometry.skinIndices.push(new THREE.Vector4(0, 0, 0, 0));\n\t\t\tthis._currentGeo.Geometry.skinWeights.push(new THREE.Vector4(1, 0, 0, 0));\n\t\t\tthis._currentGeo.VertexSetedBoneCount.push(0);\n\t\t}\n\t}, {\n\t\tkey: '_readFace1',\n\t\tvalue: function _readFace1(line) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(2, line.length - 4).split(\",\");\n\t\t\tthis._currentGeo.Geometry.faces.push(new THREE.Face3(parseInt(data[0], 10), parseInt(data[1], 10), parseInt(data[2], 10), new THREE.Vector3(1, 1, 1).normalize()));\n\t\t}\n\t}, {\n\t\tkey: '_readNormalVector1',\n\t\tvalue: function _readNormalVector1(line) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(0, line.length - 2).split(\";\");\n\t\t\tthis._currentGeo.normalVectors.push(new THREE.Vector3(parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])));\n\t\t}\n\t}, {\n\t\tkey: '_readNormalFace1',\n\t\tvalue: function _readNormalFace1(line, nowReaded) {\n\n\t\t\tvar data = this._readLine(line.trim()).substr(2, line.length - 4).split(\",\");\n\t\t\tvar nowID = parseInt(data[0], 10);\n\t\t\tvar v1 = this._currentGeo.normalVectors[nowID];\n\t\t\tnowID = parseInt(data[1], 10);\n\t\t\tvar v2 = this._currentGeo.normalVectors[nowID];\n\t\t\tnowID = parseInt(data[2], 10);\n\t\t\tvar v3 = this._currentGeo.normalVectors[nowID];\n\t\t\tthis._currentGeo.Geometry.faces[nowReaded].vertexNormals = [v1, v2, v3];\n\t\t}\n\t}, {\n\t\tkey: '_setMeshNormals',\n\t\tvalue: function _setMeshNormals() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tswitch (mode) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (mode_local === 0) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1(0);\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local = 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf(',', endRead) + 1;\n\t\t\t\t\t\t\tif (find === -1) {\n\n\t\t\t\t\t\t\t\tfind = this._currentObject.data.indexOf(';;', endRead) + 1;\n\t\t\t\t\t\t\t\tmode = 2;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t\t\t\t\tvar data = this._readLine(line.trim()).split(\";\");\n\t\t\t\t\t\t\tthis._currentGeo.normalVectors.push([parseFloat(data[0]), parseFloat(data[1]), parseFloat(data[2])]);\n\t\t\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_setMeshTextureCoords',\n\t\tvalue: function _setMeshTextureCoords() {\n\n\t\t\tthis._tmpUvArray = [];\n\t\t\tthis._currentGeo.Geometry.faceVertexUvs = [];\n\t\t\tthis._currentGeo.Geometry.faceVertexUvs.push([]);\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tswitch (mode) {\n\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tif (mode_local === 0) {\n\n\t\t\t\t\t\t\tvar refO = this._readInt1(0);\n\t\t\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\t\t\tmode_local = 1;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar find = this._currentObject.data.indexOf(',', endRead) + 1;\n\t\t\t\t\t\t\tif (find === 0) {\n\n\t\t\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\t\t\tmode = 2;\n\t\t\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t\t\t\t\tvar data = this._readLine(line.trim()).split(\";\");\n\t\t\t\t\t\t\tif (this.IsUvYReverse) {\n\n\t\t\t\t\t\t\t\tthis._tmpUvArray.push(new THREE.Vector2(parseFloat(data[0]), 1 - parseFloat(data[1])));\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tthis._tmpUvArray.push(new THREE.Vector2(parseFloat(data[0]), parseFloat(data[1])));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tendRead = find + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0] = [];\n\t\t\tfor (var m = 0; m < this._currentGeo.Geometry.faces.length; m++) {\n\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m] = [];\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].a]);\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].b]);\n\t\t\t\tthis._currentGeo.Geometry.faceVertexUvs[0][m].push(this._tmpUvArray[this._currentGeo.Geometry.faces[m].c]);\n\t\t\t}\n\t\t\tthis._currentGeo.Geometry.uvsNeedUpdate = true;\n\t\t}\n\t}, {\n\t\tkey: '_setMeshMaterialList',\n\t\tvalue: function _setMeshMaterialList() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar mode = 0;\n\t\t\tvar mode_local = 0;\n\t\t\twhile (true) {\n\n\t\t\t\tif (mode_local < 2) {\n\n\t\t\t\t\tvar refO = this._readInt1(endRead);\n\t\t\t\t\tendRead = refO.endRead;\n\t\t\t\t\tmode_local++;\n\t\t\t\t} else {\n\n\t\t\t\t\tvar find = this._currentObject.data.indexOf(';', endRead);\n\t\t\t\t\tif (find === -1) {\n\n\t\t\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t\t\t\tmode = 3;\n\t\t\t\t\t\tmode_local = 0;\n\t\t\t\t\t}\n\t\t\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t\t\tvar data = this._readLine(line.trim()).split(\",\");\n\t\t\t\t\tfor (var i = 0; i < data.length; i++) {\n\n\t\t\t\t\t\tthis._currentGeo.Geometry.faces[i].materialIndex = parseInt(data[i]);\n\t\t\t\t\t}\n\t\t\t\t\tendRead = this._currentObject.data.length;\n\t\t\t\t}\n\t\t\t\tif (endRead >= this._currentObject.data.length || mode >= 3) {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_setMaterial',\n\t\tvalue: function _setMaterial() {\n\n\t\t\tvar _nowMat = new THREE.MeshPhongMaterial({\n\t\t\t\tcolor: Math.random() * 0xffffff\n\t\t\t});\n\t\t\t_nowMat.side = THREE.FrontSide;\n\t\t\t_nowMat.name = this._currentObject.name;\n\t\t\tvar endRead = 0;\n\t\t\tvar find = this._currentObject.data.indexOf(';;', endRead);\n\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data = this._readLine(line.trim()).split(\";\");\n\t\t\t_nowMat.color.r = parseFloat(data[0]);\n\t\t\t_nowMat.color.g = parseFloat(data[1]);\n\t\t\t_nowMat.color.b = parseFloat(data[2]);\n\t\t\tendRead = find + 2;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\t_nowMat.shininess = parseFloat(this._readLine(line));\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';;', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data2 = this._readLine(line.trim()).split(\";\");\n\t\t\t_nowMat.specular.r = parseFloat(data2[0]);\n\t\t\t_nowMat.specular.g = parseFloat(data2[1]);\n\t\t\t_nowMat.specular.b = parseFloat(data2[2]);\n\t\t\tendRead = find + 2;\n\t\t\tfind = this._currentObject.data.indexOf(';;', endRead);\n\t\t\tif (find === -1) {\n\n\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t}\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data3 = this._readLine(line.trim()).split(\";\");\n\t\t\t_nowMat.emissive.r = parseFloat(data3[0]);\n\t\t\t_nowMat.emissive.g = parseFloat(data3[1]);\n\t\t\t_nowMat.emissive.b = parseFloat(data3[2]);\n\t\t\tvar localObject = null;\n\t\t\twhile (true) {\n\n\t\t\t\tif (this._currentObject.children.length > 0) {\n\n\t\t\t\t\tlocalObject = this._currentObject.children.shift();\n\t\t\t\t\tif (this.debug) {\n\n\t\t\t\t\t\tconsole.log('processing ' + localObject.name);\n\t\t\t\t\t}\n\t\t\t\t\tvar fileName = localObject.data.substr(1, localObject.data.length - 2);\n\t\t\t\t\tswitch (localObject.type) {\n\n\t\t\t\t\t\tcase \"TextureFilename\":\n\t\t\t\t\t\t\t_nowMat.map = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"BumpMapFilename\":\n\t\t\t\t\t\t\t_nowMat.bumpMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\t_nowMat.bumpScale = 0.05;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"NormalMapFilename\":\n\t\t\t\t\t\t\t_nowMat.normalMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\t_nowMat.normalScale = new THREE.Vector2(2, 2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"EmissiveMapFilename\":\n\t\t\t\t\t\t\t_nowMat.emissiveMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"LightMapFilename\":\n\t\t\t\t\t\t\t_nowMat.lightMap = this.texloader.load(this.baseDir + fileName);\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._currentGeo.Materials.push(_nowMat);\n\t\t}\n\t}, {\n\t\tkey: '_setSkinWeights',\n\t\tvalue: function _setSkinWeights() {\n\n\t\t\tvar boneInf = new XboneInf();\n\t\t\tvar endRead = 0;\n\t\t\tvar find = this._currentObject.data.indexOf(';', endRead);\n\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tendRead = find + 1;\n\t\t\tboneInf.boneName = line.substr(1, line.length - 2);\n\t\t\tboneInf.BoneIndex = this._currentGeo.BoneInfs.length;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data = this._readLine(line.trim()).split(\",\");\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\n\t\t\t\tboneInf.Indeces.push(parseInt(data[i]));\n\t\t\t}\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data2 = this._readLine(line.trim()).split(\",\");\n\t\t\tfor (var _i = 0; _i < data2.length; _i++) {\n\n\t\t\t\tboneInf.Weights.push(parseFloat(data2[_i]));\n\t\t\t}\n\t\t\tendRead = find + 1;\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tif (find <= 0) {\n\n\t\t\t\tfind = this._currentObject.data.length;\n\t\t\t}\n\t\t\tline = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tvar data3 = this._readLine(line.trim()).split(\",\");\n\t\t\tboneInf.OffsetMatrix = new THREE.Matrix4();\n\t\t\tthis._ParseMatrixData(boneInf.OffsetMatrix, data3);\n\t\t\tthis._currentGeo.BoneInfs.push(boneInf);\n\t\t}\n\t}, {\n\t\tkey: '_makePutBoneList',\n\t\tvalue: function _makePutBoneList(_RootName, _bones) {\n\n\t\t\tvar putting = false;\n\t\t\tfor (var frame in this.HieStack) {\n\n\t\t\t\tif (this.HieStack[frame].name === _RootName || putting) {\n\n\t\t\t\t\tputting = true;\n\t\t\t\t\tvar b = new THREE.Bone();\n\t\t\t\t\tb.name = this.HieStack[frame].name;\n\t\t\t\t\tb.applyMatrix(this.HieStack[frame].FrameTransformMatrix);\n\t\t\t\t\tb.matrixWorld = b.matrix;\n\t\t\t\t\tb.FrameTransformMatrix = this.HieStack[frame].FrameTransformMatrix;\n\t\t\t\t\tb.pos = new THREE.Vector3().setFromMatrixPosition(b.FrameTransformMatrix).toArray();\n\t\t\t\t\tb.rotq = new THREE.Quaternion().setFromRotationMatrix(b.FrameTransformMatrix).toArray();\n\t\t\t\t\tb.scl = new THREE.Vector3().setFromMatrixScale(b.FrameTransformMatrix).toArray();\n\t\t\t\t\tif (this.HieStack[frame].parentName && this.HieStack[frame].parentName.length > 0) {\n\n\t\t\t\t\t\tfor (var i = 0; i < _bones.length; i++) {\n\n\t\t\t\t\t\t\tif (this.HieStack[frame].parentName === _bones[i].name) {\n\n\t\t\t\t\t\t\t\t_bones[i].add(b);\n\t\t\t\t\t\t\t\tb.parent = i;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t_bones.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_makeOutputGeometry',\n\t\tvalue: function _makeOutputGeometry() {\n\n\t\t\tthis._currentGeo.Geometry.computeBoundingBox();\n\t\t\tthis._currentGeo.Geometry.computeBoundingSphere();\n\t\t\tthis._currentGeo.Geometry.verticesNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.normalsNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.colorsNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.uvsNeedUpdate = true;\n\t\t\tthis._currentGeo.Geometry.groupsNeedUpdate = true;\n\t\t\tvar mesh = null;\n\t\t\tif (this._currentGeo.BoneInfs.length > 0) {\n\n\t\t\t\tvar putBones = [];\n\t\t\t\tthis._makePutBoneList(this._currentGeo.baseFrame.parentName, putBones);\n\t\t\t\tfor (var bi = 0; bi < this._currentGeo.BoneInfs.length; bi++) {\n\n\t\t\t\t\tvar boneIndex = 0;\n\t\t\t\t\tfor (var bb = 0; bb < putBones.length; bb++) {\n\n\t\t\t\t\t\tif (putBones[bb].name === this._currentGeo.BoneInfs[bi].boneName) {\n\n\t\t\t\t\t\t\tboneIndex = bb;\n\t\t\t\t\t\t\tputBones[bb].OffsetMatrix = new THREE.Matrix4();\n\t\t\t\t\t\t\tputBones[bb].OffsetMatrix.copy(this._currentGeo.BoneInfs[bi].OffsetMatrix);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (var vi = 0; vi < this._currentGeo.BoneInfs[bi].Indeces.length; vi++) {\n\n\t\t\t\t\t\tvar nowVertexID = this._currentGeo.BoneInfs[bi].Indeces[vi];\n\t\t\t\t\t\tvar nowVal = this._currentGeo.BoneInfs[bi].Weights[vi];\n\t\t\t\t\t\tswitch (this._currentGeo.VertexSetedBoneCount[nowVertexID]) {\n\n\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].x = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].x = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].y = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].y = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].z = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].z = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinIndices[nowVertexID].w = boneIndex;\n\t\t\t\t\t\t\t\tthis._currentGeo.Geometry.skinWeights[nowVertexID].w = nowVal;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._currentGeo.VertexSetedBoneCount[nowVertexID]++;\n\t\t\t\t\t\tif (this._currentGeo.VertexSetedBoneCount[nowVertexID] > 4) {\n\n\t\t\t\t\t\t\tconsole.log('warn! over 4 bone weight! :' + nowVertexID);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (var sk = 0; sk < this._currentGeo.Materials.length; sk++) {\n\n\t\t\t\t\tthis._currentGeo.Materials[sk].skinning = true;\n\t\t\t\t}\n\t\t\t\tvar offsetList = [];\n\t\t\t\tfor (var _bi = 0; _bi < putBones.length; _bi++) {\n\n\t\t\t\t\tif (putBones[_bi].OffsetMatrix) {\n\n\t\t\t\t\t\toffsetList.push(putBones[_bi].OffsetMatrix);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\toffsetList.push(new THREE.Matrix4());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar bufferGeometry = new THREE.BufferGeometry().fromGeometry(this._currentGeo.Geometry);\n\t\t\t\tbufferGeometry.bones = putBones;\n\t\t\t\tmesh = new THREE.SkinnedMesh(bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\n\t\t\t\tmesh.skeleton.boneInverses = offsetList;\n\t\t\t} else {\n\n\t\t\t\tvar _bufferGeometry = new THREE.BufferGeometry().fromGeometry(this._currentGeo.Geometry);\n\t\t\t\tmesh = new THREE.Mesh(_bufferGeometry, this._currentGeo.Materials.length === 1 ? this._currentGeo.Materials[0] : this._currentGeo.Materials);\n\t\t\t}\n\t\t\tmesh.name = this._currentGeo.name;\n\t\t\tvar worldBaseMx = new THREE.Matrix4();\n\t\t\tvar currentMxFrame = this._currentGeo.baseFrame.putBone;\n\t\t\tif (currentMxFrame && currentMxFrame.parent) {\n\n\t\t\t\twhile (true) {\n\n\t\t\t\t\tcurrentMxFrame = currentMxFrame.parent;\n\t\t\t\t\tif (currentMxFrame) {\n\n\t\t\t\t\t\tworldBaseMx.multiply(currentMxFrame.FrameTransformMatrix);\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmesh.applyMatrix(worldBaseMx);\n\t\t\t}\n\t\t\tthis.Meshes.push(mesh);\n\t\t}\n\t}, {\n\t\tkey: '_readAnimationKey',\n\t\tvalue: function _readAnimationKey() {\n\n\t\t\tvar endRead = 0;\n\t\t\tvar find = this._currentObject.data.indexOf(';', endRead);\n\t\t\tvar line = this._currentObject.data.substr(endRead, find - endRead);\n\t\t\tendRead = find + 1;\n\t\t\tvar nowKeyType = parseInt(this._readLine(line));\n\t\t\tfind = this._currentObject.data.indexOf(';', endRead);\n\t\t\tendRead = find + 1;\n\t\t\tline = this._currentObject.data.substr(endRead);\n\t\t\tvar data = this._readLine(line.trim()).split(\";;,\");\n\t\t\tfor (var i = 0; i < data.length; i++) {\n\n\t\t\t\tvar data2 = data[i].split(\";\");\n\t\t\t\tvar keyInfo = new XKeyFrameInfo();\n\t\t\t\tkeyInfo.type = nowKeyType;\n\t\t\t\tkeyInfo.Frame = parseInt(data2[0]);\n\t\t\t\tkeyInfo.index = this._currentAnimeFrames.keyFrames.length;\n\t\t\t\tkeyInfo.time = keyInfo.Frame;\n\t\t\t\tif (nowKeyType != 4) {\n\n\t\t\t\t\tvar frameFound = false;\n\t\t\t\t\tfor (var mm = 0; mm < this._currentAnimeFrames.keyFrames.length; mm++) {\n\n\t\t\t\t\t\tif (this._currentAnimeFrames.keyFrames[mm].Frame === keyInfo.Frame) {\n\n\t\t\t\t\t\t\tkeyInfo = this._currentAnimeFrames.keyFrames[mm];\n\t\t\t\t\t\t\tframeFound = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar frameValue = data2[2].split(\",\");\n\t\t\t\t\tswitch (nowKeyType) {\n\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tkeyInfo.rot = new THREE.Quaternion(parseFloat(frameValue[1]), parseFloat(frameValue[2]), parseFloat(frameValue[3]), parseFloat(frameValue[0]) * -1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tkeyInfo.scl = new THREE.Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tkeyInfo.pos = new THREE.Vector3(parseFloat(frameValue[0]), parseFloat(frameValue[1]), parseFloat(frameValue[2]));\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (!frameFound) {\n\n\t\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push(keyInfo);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\tkeyInfo.matrix = new THREE.Matrix4();\n\t\t\t\t\tthis._ParseMatrixData(keyInfo.matrix, data2[2].split(\",\"));\n\t\t\t\t\tthis._currentAnimeFrames.keyFrames.push(keyInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, {\n\t\tkey: '_makeOutputAnimation',\n\t\tvalue: function _makeOutputAnimation() {\n\n\t\t\tvar animationObj = new XAnimationObj(this.options);\n\t\t\tanimationObj.fps = this.animTicksPerSecond;\n\t\t\tanimationObj.name = this._currentAnime.name;\n\t\t\tanimationObj.make(this._currentAnime.AnimeFrames);\n\t\t\tthis.animations.push(animationObj);\n\t\t}\n\t}, {\n\t\tkey: 'assignAnimation',\n\t\tvalue: function assignAnimation(_model, _animation, _isBind) {\n\n\t\t\tvar model = _model;\n\t\t\tvar animation = _animation;\n\t\t\tif (!model) {\n\n\t\t\t\tmodel = this.Meshes[0];\n\t\t\t}\n\t\t\tif (!animation) {\n\n\t\t\t\tanimation = this.animations[0];\n\t\t\t}\n\t\t\tif (!model || !animation) {\n\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tvar put = {};\n\t\t\tput.fps = animation.fps;\n\t\t\tput.name = animation.name;\n\t\t\tput.length = animation.length;\n\t\t\tput.hierarchy = [];\n\t\t\tfor (var b = 0; b < model.skeleton.bones.length; b++) {\n\n\t\t\t\tvar findAnimation = false;\n\t\t\t\tfor (var i = 0; i < animation.hierarchy.length; i++) {\n\n\t\t\t\t\tif (model.skeleton.bones[b].name === animation.hierarchy[i].name) {\n\n\t\t\t\t\t\tfindAnimation = true;\n\t\t\t\t\t\tvar c_key = animation.hierarchy[i].copy();\n\t\t\t\t\t\tc_key.parent = -1;\n\t\t\t\t\t\tif (model.skeleton.bones[b].parent && model.skeleton.bones[b].parent.type === \"Bone\") {\n\n\t\t\t\t\t\t\tfor (var bb = 0; bb < put.hierarchy.length; bb++) {\n\n\t\t\t\t\t\t\t\tif (put.hierarchy[bb].name === model.skeleton.bones[b].parent.name) {\n\n\t\t\t\t\t\t\t\t\tc_key.parent = bb;\n\t\t\t\t\t\t\t\t\tc_key.parentName = model.skeleton.bones[b].parent.name;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tput.hierarchy.push(c_key);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!findAnimation) {\n\n\t\t\t\t\tvar _c_key = animation.hierarchy[0].copy();\n\t\t\t\t\t_c_key.name = model.skeleton.bones[b].name;\n\t\t\t\t\t_c_key.parent = -1;\n\t\t\t\t\tfor (var k = 0; k < _c_key.keys.length; k++) {\n\n\t\t\t\t\t\tif (_c_key.keys[k].pos) {\n\n\t\t\t\t\t\t\t_c_key.keys[k].pos.set(0, 0, 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_c_key.keys[k].scl) {\n\n\t\t\t\t\t\t\t_c_key.keys[k].scl.set(1, 1, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (_c_key.keys[k].rot) {\n\n\t\t\t\t\t\t\t_c_key.keys[k].rot.set(0, 0, 0, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tput.hierarchy.push(_c_key);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!model.geometry.animations) {\n\n\t\t\t\tmodel.geometry.animations = [];\n\t\t\t}\n\n\t\t\tmodel.geometry.animations.push(THREE.AnimationClip.parseAnimation(put, model.skeleton.bones));\n\t\t\tif (!model.animationMixer) {\n\n\t\t\t\tmodel.animationMixer = new THREE.AnimationMixer(model);\n\t\t\t}\n\n\t\t\treturn put;\n\t\t}\n\t}, {\n\t\tkey: '_ParseMatrixData',\n\t\tvalue: function _ParseMatrixData(targetMatrix, data) {\n\n\t\t\ttargetMatrix.set(parseFloat(data[0]), parseFloat(data[4]), parseFloat(data[8]), parseFloat(data[12]), parseFloat(data[1]), parseFloat(data[5]), parseFloat(data[9]), parseFloat(data[13]), parseFloat(data[2]), parseFloat(data[6]), parseFloat(data[10]), parseFloat(data[14]), parseFloat(data[3]), parseFloat(data[7]), parseFloat(data[11]), parseFloat(data[15]));\n\t\t}\n\t}]);\n\treturn XLoader;\n}();\n\n// \treturn XLoader;\n//\n// } ) ) );\n\nexports.default = XLoader;\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnrealBloomPass = exports.TexturePass = exports.TAARenderPass = exports.SSAOPass = exports.SSAARenderPass = exports.SMAAPass = exports.ShaderPass = exports.SavePass = exports.SAOPass = exports.RenderPass = exports.Pass = exports.OutlinePass = exports.MaskPass = exports.HalftonePass = exports.GlitchPass = exports.FilmPass = exports.EffectComposer = exports.DotScreenPass = exports.CubeTexturePass = exports.ClearPass = exports.ClearMaskPass = exports.BokehPass = exports.BloomPass = exports.AdaptiveToneMappingPass = undefined;\n\nvar _AdaptiveToneMappingPass = __webpack_require__(91);\n\nvar _AdaptiveToneMappingPass2 = _interopRequireDefault(_AdaptiveToneMappingPass);\n\nvar _BloomPass = __webpack_require__(92);\n\nvar _BloomPass2 = _interopRequireDefault(_BloomPass);\n\nvar _BokehPass = __webpack_require__(93);\n\nvar _BokehPass2 = _interopRequireDefault(_BokehPass);\n\nvar _ClearMaskPass = __webpack_require__(94);\n\nvar _ClearMaskPass2 = _interopRequireDefault(_ClearMaskPass);\n\nvar _ClearPass = __webpack_require__(95);\n\nvar _ClearPass2 = _interopRequireDefault(_ClearPass);\n\nvar _CubeTexturePass = __webpack_require__(96);\n\nvar _CubeTexturePass2 = _interopRequireDefault(_CubeTexturePass);\n\nvar _DotScreenPass = __webpack_require__(97);\n\nvar _DotScreenPass2 = _interopRequireDefault(_DotScreenPass);\n\nvar _EffectComposer = __webpack_require__(98);\n\nvar _EffectComposer2 = _interopRequireDefault(_EffectComposer);\n\nvar _FilmPass = __webpack_require__(99);\n\nvar _FilmPass2 = _interopRequireDefault(_FilmPass);\n\nvar _GlitchPass = __webpack_require__(100);\n\nvar _GlitchPass2 = _interopRequireDefault(_GlitchPass);\n\nvar _HalftonePass = __webpack_require__(101);\n\nvar _HalftonePass2 = _interopRequireDefault(_HalftonePass);\n\nvar _MaskPass = __webpack_require__(102);\n\nvar _MaskPass2 = _interopRequireDefault(_MaskPass);\n\nvar _OutlinePass = __webpack_require__(103);\n\nvar _OutlinePass2 = _interopRequireDefault(_OutlinePass);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _RenderPass = __webpack_require__(104);\n\nvar _RenderPass2 = _interopRequireDefault(_RenderPass);\n\nvar _SAOPass = __webpack_require__(105);\n\nvar _SAOPass2 = _interopRequireDefault(_SAOPass);\n\nvar _SavePass = __webpack_require__(106);\n\nvar _SavePass2 = _interopRequireDefault(_SavePass);\n\nvar _ShaderPass = __webpack_require__(3);\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nvar _SMAAPass = __webpack_require__(107);\n\nvar _SMAAPass2 = _interopRequireDefault(_SMAAPass);\n\nvar _SSAARenderPass = __webpack_require__(24);\n\nvar _SSAARenderPass2 = _interopRequireDefault(_SSAARenderPass);\n\nvar _SSAOPass = __webpack_require__(108);\n\nvar _SSAOPass2 = _interopRequireDefault(_SSAOPass);\n\nvar _TAARenderPass = __webpack_require__(109);\n\nvar _TAARenderPass2 = _interopRequireDefault(_TAARenderPass);\n\nvar _TexturePass = __webpack_require__(110);\n\nvar _TexturePass2 = _interopRequireDefault(_TexturePass);\n\nvar _UnrealBloomPass = __webpack_require__(111);\n\nvar _UnrealBloomPass2 = _interopRequireDefault(_UnrealBloomPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.AdaptiveToneMappingPass = _AdaptiveToneMappingPass2.default;\nexports.BloomPass = _BloomPass2.default;\nexports.BokehPass = _BokehPass2.default;\nexports.ClearMaskPass = _ClearMaskPass2.default;\nexports.ClearPass = _ClearPass2.default;\nexports.CubeTexturePass = _CubeTexturePass2.default;\nexports.DotScreenPass = _DotScreenPass2.default;\nexports.EffectComposer = _EffectComposer2.default;\nexports.FilmPass = _FilmPass2.default;\nexports.GlitchPass = _GlitchPass2.default;\nexports.HalftonePass = _HalftonePass2.default;\nexports.MaskPass = _MaskPass2.default;\nexports.OutlinePass = _OutlinePass2.default;\nexports.Pass = _Pass2.default;\nexports.RenderPass = _RenderPass2.default;\nexports.SAOPass = _SAOPass2.default;\nexports.SavePass = _SavePass2.default;\nexports.ShaderPass = _ShaderPass2.default;\nexports.SMAAPass = _SMAAPass2.default;\nexports.SSAARenderPass = _SSAARenderPass2.default;\nexports.SSAOPass = _SSAOPass2.default;\nexports.TAARenderPass = _TAARenderPass2.default;\nexports.TexturePass = _TexturePass2.default;\nexports.UnrealBloomPass = _UnrealBloomPass2.default;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _LuminosityShader = __webpack_require__(11);\n\nvar _LuminosityShader2 = _interopRequireDefault(_LuminosityShader);\n\nvar _ToneMapShader = __webpack_require__(12);\n\nvar _ToneMapShader2 = _interopRequireDefault(_ToneMapShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author miibond\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {\n\n\t_Pass2.default.call(this);\n\n\tthis.resolution = resolution !== undefined ? resolution : 256;\n\tthis.needsInit = true;\n\tthis.adaptive = adaptive !== undefined ? !!adaptive : true;\n\n\tthis.luminanceRT = null;\n\tthis.previousLuminanceRT = null;\n\tthis.currentLuminanceRT = null;\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.NoBlending,\n\t\tdepthTest: false\n\n\t});\n\n\tif (_LuminosityShader2.default === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.LuminosityShader\");\n\n\tthis.materialLuminance = new THREE.ShaderMaterial({\n\n\t\tuniforms: THREE.UniformsUtils.clone(_LuminosityShader2.default.uniforms),\n\t\tvertexShader: _LuminosityShader2.default.vertexShader,\n\t\tfragmentShader: _LuminosityShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\n\tthis.adaptLuminanceShader = {\n\t\tdefines: {\n\t\t\t\"MIP_LEVEL_1X1\": (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n\t\t},\n\t\tuniforms: {\n\t\t\t\"lastLum\": { value: null },\n\t\t\t\"currentLum\": { value: null },\n\t\t\t\"minLuminance\": { value: 0.01 },\n\t\t\t\"delta\": { value: 0.016 },\n\t\t\t\"tau\": { value: 1.0 }\n\t\t},\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join('\\n'),\n\t\tfragmentShader: [\"varying vec2 vUv;\", \"uniform sampler2D lastLum;\", \"uniform sampler2D currentLum;\", \"uniform float minLuminance;\", \"uniform float delta;\", \"uniform float tau;\", \"void main() {\", \"vec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );\", \"vec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );\", \"float fLastLum = max( minLuminance, lastLum.r );\", \"float fCurrentLum = max( minLuminance, currentLum.r );\",\n\n\t\t//The adaption seems to work better in extreme lighting differences\n\t\t//if the input luminance is squared.\n\t\t\"fCurrentLum *= fCurrentLum;\",\n\n\t\t// Adapt the luminance using Pattanaik's technique\n\t\t\"float fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));\",\n\t\t// \"fAdaptedLum = sqrt(fAdaptedLum);\",\n\t\t\"gl_FragColor.r = fAdaptedLum;\", \"}\"].join('\\n')\n\t};\n\n\tthis.materialAdaptiveLum = new THREE.ShaderMaterial({\n\n\t\tuniforms: THREE.UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n\t\tvertexShader: this.adaptLuminanceShader.vertexShader,\n\t\tfragmentShader: this.adaptLuminanceShader.fragmentShader,\n\t\tdefines: Object.assign({}, this.adaptLuminanceShader.defines),\n\t\tblending: THREE.NoBlending\n\t});\n\n\tif (_ToneMapShader2.default === undefined) console.error(\"THREE.AdaptiveToneMappingPass relies on THREE.ToneMapShader\");\n\n\tthis.materialToneMap = new THREE.ShaderMaterial({\n\n\t\tuniforms: THREE.UniformsUtils.clone(_ToneMapShader2.default.uniforms),\n\t\tvertexShader: _ToneMapShader2.default.vertexShader,\n\t\tfragmentShader: _ToneMapShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: AdaptiveToneMappingPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (this.needsInit) {\n\n\t\t\tthis.reset(renderer);\n\n\t\t\tthis.luminanceRT.texture.type = readBuffer.texture.type;\n\t\t\tthis.previousLuminanceRT.texture.type = readBuffer.texture.type;\n\t\t\tthis.currentLuminanceRT.texture.type = readBuffer.texture.type;\n\t\t\tthis.needsInit = false;\n\t\t}\n\n\t\tif (this.adaptive) {\n\n\t\t\t//Render the luminance of the current scene into a render target with mipmapping enabled\n\t\t\tthis.quad.material = this.materialLuminance;\n\t\t\tthis.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.currentLuminanceRT);\n\n\t\t\t//Use the new luminance values, the previous luminance and the frame delta to\n\t\t\t//adapt the luminance over time.\n\t\t\tthis.quad.material = this.materialAdaptiveLum;\n\t\t\tthis.materialAdaptiveLum.uniforms.delta.value = delta;\n\t\t\tthis.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n\t\t\tthis.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.luminanceRT);\n\n\t\t\t//Copy the new adapted luminance value so that it can be used by the next frame.\n\t\t\tthis.quad.material = this.materialCopy;\n\t\t\tthis.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.previousLuminanceRT);\n\t\t}\n\n\t\tthis.quad.material = this.materialToneMap;\n\t\tthis.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t},\n\n\treset: function reset(renderer) {\n\n\t\t// render targets\n\t\tif (this.luminanceRT) {\n\n\t\t\tthis.luminanceRT.dispose();\n\t\t}\n\t\tif (this.currentLuminanceRT) {\n\n\t\t\tthis.currentLuminanceRT.dispose();\n\t\t}\n\t\tif (this.previousLuminanceRT) {\n\n\t\t\tthis.previousLuminanceRT.dispose();\n\t\t}\n\n\t\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n\t\tthis.luminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n\t\tthis.luminanceRT.texture.name = \"AdaptiveToneMappingPass.l\";\n\t\tthis.luminanceRT.texture.generateMipmaps = false;\n\n\t\tthis.previousLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n\t\tthis.previousLuminanceRT.texture.name = \"AdaptiveToneMappingPass.pl\";\n\t\tthis.previousLuminanceRT.texture.generateMipmaps = false;\n\n\t\t// We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\t\tpars.minFilter = THREE.LinearMipMapLinearFilter;\n\t\tthis.currentLuminanceRT = new THREE.WebGLRenderTarget(this.resolution, this.resolution, pars);\n\t\tthis.currentLuminanceRT.texture.name = \"AdaptiveToneMappingPass.cl\";\n\n\t\tif (this.adaptive) {\n\n\t\t\tthis.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n\t\t}\n\t\t//Put something in the adaptive luminance texture so that the scene can render initially\n\t\tthis.quad.material = new THREE.MeshBasicMaterial({ color: 0x777777 });\n\t\tthis.materialLuminance.needsUpdate = true;\n\t\tthis.materialAdaptiveLum.needsUpdate = true;\n\t\tthis.materialToneMap.needsUpdate = true;\n\t\t// renderer.render( this.scene, this.camera, this.luminanceRT );\n\t\t// renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n\t\t// renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n\t},\n\n\tsetAdaptive: function setAdaptive(adaptive) {\n\n\t\tif (adaptive) {\n\n\t\t\tthis.adaptive = true;\n\t\t\tthis.materialToneMap.defines[\"ADAPTED_LUMINANCE\"] = \"\";\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n\t\t} else {\n\n\t\t\tthis.adaptive = false;\n\t\t\tdelete this.materialToneMap.defines[\"ADAPTED_LUMINANCE\"];\n\t\t\tthis.materialToneMap.uniforms.luminanceMap.value = null;\n\t\t}\n\t\tthis.materialToneMap.needsUpdate = true;\n\t},\n\n\tsetAdaptionRate: function setAdaptionRate(rate) {\n\n\t\tif (rate) {\n\n\t\t\tthis.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n\t\t}\n\t},\n\n\tsetMinLuminance: function setMinLuminance(minLum) {\n\n\t\tif (minLum) {\n\n\t\t\tthis.materialToneMap.uniforms.minLuminance.value = minLum;\n\t\t\tthis.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n\t\t}\n\t},\n\n\tsetMaxLuminance: function setMaxLuminance(maxLum) {\n\n\t\tif (maxLum) {\n\n\t\t\tthis.materialToneMap.uniforms.maxLuminance.value = maxLum;\n\t\t}\n\t},\n\n\tsetAverageLuminance: function setAverageLuminance(avgLum) {\n\n\t\tif (avgLum) {\n\n\t\t\tthis.materialToneMap.uniforms.averageLuminance.value = avgLum;\n\t\t}\n\t},\n\n\tsetMiddleGrey: function setMiddleGrey(middleGrey) {\n\n\t\tif (middleGrey) {\n\n\t\t\tthis.materialToneMap.uniforms.middleGrey.value = middleGrey;\n\t\t}\n\t},\n\n\tdispose: function dispose() {\n\n\t\tif (this.luminanceRT) {\n\n\t\t\tthis.luminanceRT.dispose();\n\t\t}\n\t\tif (this.previousLuminanceRT) {\n\n\t\t\tthis.previousLuminanceRT.dispose();\n\t\t}\n\t\tif (this.currentLuminanceRT) {\n\n\t\t\tthis.currentLuminanceRT.dispose();\n\t\t}\n\t\tif (this.materialLuminance) {\n\n\t\t\tthis.materialLuminance.dispose();\n\t\t}\n\t\tif (this.materialAdaptiveLum) {\n\n\t\t\tthis.materialAdaptiveLum.dispose();\n\t\t}\n\t\tif (this.materialCopy) {\n\n\t\t\tthis.materialCopy.dispose();\n\t\t}\n\t\tif (this.materialToneMap) {\n\n\t\t\tthis.materialToneMap.dispose();\n\t\t}\n\t}\n\n});\n\nexports.default = AdaptiveToneMappingPass;\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _ConvolutionShader = __webpack_require__(13);\n\nvar _ConvolutionShader2 = _interopRequireDefault(_ConvolutionShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar BloomPass = function BloomPass(strength, kernelSize, sigma, resolution) {\n\n\t_Pass2.default.call(this);\n\n\tstrength = strength !== undefined ? strength : 1;\n\tkernelSize = kernelSize !== undefined ? kernelSize : 25;\n\tsigma = sigma !== undefined ? sigma : 4.0;\n\tresolution = resolution !== undefined ? resolution : 256;\n\n\t// render targets\n\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\n\tthis.renderTargetX = new THREE.WebGLRenderTarget(resolution, resolution, pars);\n\tthis.renderTargetX.texture.name = \"BloomPass.x\";\n\tthis.renderTargetY = new THREE.WebGLRenderTarget(resolution, resolution, pars);\n\tthis.renderTargetY.texture.name = \"BloomPass.y\";\n\n\t// copy material\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.BloomPass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\n\tthis.copyUniforms[\"opacity\"].value = strength;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\ttransparent: true\n\n\t});\n\n\t// convolution material\n\n\tif (_ConvolutionShader2.default === undefined) console.error(\"THREE.BloomPass relies on THREE.ConvolutionShader\");\n\n\tvar convolutionShader = _ConvolutionShader2.default;\n\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone(convolutionShader.uniforms);\n\n\tthis.convolutionUniforms[\"uImageIncrement\"].value = BloomPass.blurX;\n\tthis.convolutionUniforms[\"cKernel\"].value = _ConvolutionShader2.default.buildKernel(sigma);\n\n\tthis.materialConvolution = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.convolutionUniforms,\n\t\tvertexShader: convolutionShader.vertexShader,\n\t\tfragmentShader: convolutionShader.fragmentShader,\n\t\tdefines: {\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed(1),\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed(0)\n\t\t}\n\n\t});\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nBloomPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: BloomPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t// Render quad with blured scene into texture (convolution pass 1)\n\n\t\tthis.quad.material = this.materialConvolution;\n\n\t\tthis.convolutionUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.convolutionUniforms[\"uImageIncrement\"].value = BloomPass.blurX;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetX, true);\n\n\t\t// Render quad with blured scene into texture (convolution pass 2)\n\n\t\tthis.convolutionUniforms[\"tDiffuse\"].value = this.renderTargetX.texture;\n\t\tthis.convolutionUniforms[\"uImageIncrement\"].value = BloomPass.blurY;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetY, true);\n\n\t\t// Render original scene with superimposed blur to texture\n\n\t\tthis.quad.material = this.materialCopy;\n\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetY.texture;\n\n\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\trenderer.render(this.scene, this.camera, readBuffer, this.clear);\n\t}\n\n});\n\nBloomPass.blurX = new THREE.Vector2(0.001953125, 0.0);\nBloomPass.blurY = new THREE.Vector2(0.0, 0.001953125);\n\nexports.default = BloomPass;\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _global = __webpack_require__(8);\n\nvar _global2 = _interopRequireDefault(_global);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _BokehShader = __webpack_require__(14);\n\nvar _BokehShader2 = _interopRequireDefault(_BokehShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar window = _global2.default;\n\n/**\n * Depth-of-field post-process with bokeh shader\n */\n\nvar BokehPass = function BokehPass(scene, camera, params) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tvar focus = params.focus !== undefined ? params.focus : 1.0;\n\tvar aspect = params.aspect !== undefined ? params.aspect : camera.aspect;\n\tvar aperture = params.aperture !== undefined ? params.aperture : 0.025;\n\tvar maxblur = params.maxblur !== undefined ? params.maxblur : 1.0;\n\n\t// render targets\n\n\tvar width = params.width || window.innerWidth || 1;\n\tvar height = params.height || window.innerHeight || 1;\n\n\tthis.renderTargetColor = new THREE.WebGLRenderTarget(width, height, {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t});\n\tthis.renderTargetColor.texture.name = \"BokehPass.color\";\n\n\tthis.renderTargetDepth = this.renderTargetColor.clone();\n\tthis.renderTargetDepth.texture.name = \"BokehPass.depth\";\n\n\t// depth material\n\n\tthis.materialDepth = new THREE.MeshDepthMaterial();\n\tthis.materialDepth.depthPacking = THREE.RGBADepthPacking;\n\tthis.materialDepth.blending = THREE.NoBlending;\n\n\t// bokeh material\n\n\tif (_BokehShader2.default === undefined) {\n\n\t\tconsole.error(\"THREE.BokehPass relies on THREE.BokehShader\");\n\t}\n\n\tvar bokehShader = _BokehShader2.default;\n\tvar bokehUniforms = THREE.UniformsUtils.clone(bokehShader.uniforms);\n\n\tbokehUniforms[\"tDepth\"].value = this.renderTargetDepth.texture;\n\n\tbokehUniforms[\"focus\"].value = focus;\n\tbokehUniforms[\"aspect\"].value = aspect;\n\tbokehUniforms[\"aperture\"].value = aperture;\n\tbokehUniforms[\"maxblur\"].value = maxblur;\n\tbokehUniforms[\"nearClip\"].value = camera.near;\n\tbokehUniforms[\"farClip\"].value = camera.far;\n\n\tthis.materialBokeh = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, bokehShader.defines),\n\t\tuniforms: bokehUniforms,\n\t\tvertexShader: bokehShader.vertexShader,\n\t\tfragmentShader: bokehShader.fragmentShader\n\t});\n\n\tthis.uniforms = bokehUniforms;\n\tthis.needsSwap = false;\n\n\tthis.camera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene2 = new THREE.Scene();\n\n\tthis.quad2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad2.frustumCulled = false; // Avoid getting clipped\n\tthis.scene2.add(this.quad2);\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n};\n\nBokehPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: BokehPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.quad2.material = this.materialBokeh;\n\n\t\t// Render depth into texture\n\n\t\tthis.scene.overrideMaterial = this.materialDepth;\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor(0xffffff);\n\t\trenderer.setClearAlpha(1.0);\n\t\trenderer.render(this.scene, this.camera, this.renderTargetDepth, true);\n\n\t\t// Render bokeh composite\n\n\t\tthis.uniforms[\"tColor\"].value = readBuffer.texture;\n\t\tthis.uniforms[\"nearClip\"].value = this.camera.near;\n\t\tthis.uniforms[\"farClip\"].value = this.camera.far;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene2, this.camera2);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene2, this.camera2, writeBuffer, this.clear);\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\t\trenderer.setClearColor(this.oldClearColor);\n\t\trenderer.setClearAlpha(this.oldClearAlpha);\n\t\trenderer.autoClear = this.oldAutoClear;\n\t}\n\n});\n\nexports.default = BokehPass;\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar ClearMaskPass = function ClearMaskPass() {\n\n\t_Pass2.default.call(this);\n\n\tthis.needsSwap = false;\n};\n\nClearMaskPass.prototype = Object.create(_Pass2.default.prototype);\n\nObject.assign(ClearMaskPass.prototype, {\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\trenderer.state.buffers.stencil.setTest(false);\n\t}\n\n});\n\nexports.default = ClearMaskPass;\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar ClearPass = function ClearPass(clearColor, clearAlpha) {\n\n\t_Pass2.default.call(this);\n\n\tthis.needsSwap = false;\n\n\tthis.clearColor = clearColor !== undefined ? clearColor : 0x000000;\n\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n};\n\nClearPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: ClearPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldClearColor, oldClearAlpha;\n\n\t\tif (this.clearColor) {\n\n\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t}\n\n\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\t\trenderer.clear();\n\n\t\tif (this.clearColor) {\n\n\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t}\n\t}\n\n});\n\nexports.default = ClearPass;\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author bhouston / http://clara.io/\n */\n\nvar CubeTexturePass = function CubeTexturePass(camera, envMap, opacity) {\n\n\t_Pass2.default.call(this);\n\n\tthis.camera = camera;\n\n\tthis.needsSwap = false;\n\n\tthis.cubeShader = THREE.ShaderLib['cube'];\n\tthis.cubeMesh = new THREE.Mesh(new THREE.BoxBufferGeometry(10, 10, 10), new THREE.ShaderMaterial({\n\t\tuniforms: this.cubeShader.uniforms,\n\t\tvertexShader: this.cubeShader.vertexShader,\n\t\tfragmentShader: this.cubeShader.fragmentShader,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\tside: THREE.BackSide\n\t}));\n\n\tthis.envMap = envMap;\n\tthis.opacity = opacity !== undefined ? opacity : 1.0;\n\n\tthis.cubeScene = new THREE.Scene();\n\tthis.cubeCamera = new THREE.PerspectiveCamera();\n\tthis.cubeScene.add(this.cubeMesh);\n};\n\nCubeTexturePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: CubeTexturePass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n\t\tthis.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n\n\t\tthis.cubeMesh.material.uniforms[\"tCube\"].value = this.envMap;\n\t\tthis.cubeMesh.material.uniforms[\"opacity\"].value = this.opacity;\n\t\tthis.cubeMesh.material.transparent = this.opacity < 1.0;\n\n\t\trenderer.render(this.cubeScene, this.cubeCamera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\trenderer.autoClear = oldAutoClear;\n\t}\n\n});\n\nexports.default = CubeTexturePass;\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _DotScreenShader = __webpack_require__(15);\n\nvar _DotScreenShader2 = _interopRequireDefault(_DotScreenShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar DotScreenPass = function DotScreenPass(center, angle, scale) {\n\n\t_Pass2.default.call(this);\n\n\tif (_DotScreenShader2.default === undefined) console.error(\"THREE.DotScreenPass relies on THREE.DotScreenShader\");\n\n\tvar shader = _DotScreenShader2.default;\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tif (center !== undefined) this.uniforms[\"center\"].value.copy(center);\n\tif (angle !== undefined) this.uniforms[\"angle\"].value = angle;\n\tif (scale !== undefined) this.uniforms[\"scale\"].value = scale;\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t});\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nDotScreenPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: DotScreenPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.uniforms[\"tSize\"].value.set(readBuffer.width, readBuffer.height);\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n\n});\n\nexports.default = DotScreenPass;\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _ShaderPass = __webpack_require__(3);\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar EffectComposer = function EffectComposer(renderer, renderTarget) {\n\n\tthis.renderer = renderer;\n\n\tif (renderTarget === undefined) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar size = renderer.getDrawingBufferSize();\n\t\trenderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.CopyShader');\n\t}\n\n\tif (_ShaderPass2.default === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.ShaderPass');\n\t}\n\n\tthis.copyPass = new _ShaderPass2.default(_CopyShader2.default);\n};\n\nObject.assign(EffectComposer.prototype, {\n\n\tswapBuffers: function swapBuffers() {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\t},\n\n\taddPass: function addPass(pass) {\n\n\t\tthis.passes.push(pass);\n\n\t\tvar size = this.renderer.getDrawingBufferSize();\n\t\tpass.setSize(size.width, size.height);\n\t},\n\n\tinsertPass: function insertPass(pass, index) {\n\n\t\tthis.passes.splice(index, 0, pass);\n\t},\n\n\trender: function render(delta) {\n\n\t\tvar maskActive = false;\n\n\t\tvar pass,\n\t\t    i,\n\t\t    il = this.passes.length;\n\n\t\tfor (i = 0; i < il; i++) {\n\n\t\t\tpass = this.passes[i];\n\n\t\t\tif (pass.enabled === false) continue;\n\n\t\t\tpass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);\n\n\t\t\tif (pass.needsSwap) {\n\n\t\t\t\tif (maskActive) {\n\n\t\t\t\t\tvar context = this.renderer.context;\n\n\t\t\t\t\tcontext.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n\n\t\t\t\t\tthis.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);\n\n\t\t\t\t\tcontext.stencilFunc(context.EQUAL, 1, 0xffffffff);\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\t\t\t}\n\n\t\t\tif (THREE.MaskPass !== undefined) {\n\n\t\t\t\tif (pass instanceof THREE.MaskPass) {\n\n\t\t\t\t\tmaskActive = true;\n\t\t\t\t} else if (pass instanceof THREE.ClearMaskPass) {\n\n\t\t\t\t\tmaskActive = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\treset: function reset(renderTarget) {\n\n\t\tif (renderTarget === undefined) {\n\n\t\t\tvar size = this.renderer.getDrawingBufferSize();\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize(size.width, size.height);\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.renderTarget1.setSize(width, height);\n\t\tthis.renderTarget2.setSize(width, height);\n\n\t\tfor (var i = 0; i < this.passes.length; i++) {\n\n\t\t\tthis.passes[i].setSize(width, height);\n\t\t}\n\t}\n\n});\n\nexports.default = EffectComposer;\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _FilmShader = __webpack_require__(16);\n\nvar _FilmShader2 = _interopRequireDefault(_FilmShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar FilmPass = function FilmPass(noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale) {\n\n\t_Pass2.default.call(this);\n\n\tif (_FilmShader2.default === undefined) console.error(\"THREE.FilmPass relies on THREE.FilmShader\");\n\n\tvar shader = _FilmShader2.default;\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t});\n\n\tif (grayscale !== undefined) this.uniforms.grayscale.value = grayscale;\n\tif (noiseIntensity !== undefined) this.uniforms.nIntensity.value = noiseIntensity;\n\tif (scanlinesIntensity !== undefined) this.uniforms.sIntensity.value = scanlinesIntensity;\n\tif (scanlinesCount !== undefined) this.uniforms.sCount.value = scanlinesCount;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nFilmPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: FilmPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.uniforms[\"time\"].value += delta;\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n\n});\n\nexports.default = FilmPass;\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _DigitalGlitch = __webpack_require__(17);\n\nvar _DigitalGlitch2 = _interopRequireDefault(_DigitalGlitch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar GlitchPass = function GlitchPass(dt_size) {\n\n\t_Pass2.default.call(this);\n\n\tif (_DigitalGlitch2.default === undefined) console.error(\"THREE.GlitchPass relies on THREE.DigitalGlitch\");\n\n\tvar shader = _DigitalGlitch2.default;\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tif (dt_size == undefined) dt_size = 64;\n\n\tthis.uniforms[\"tDisp\"].value = this.generateHeightmap(dt_size);\n\n\tthis.material = new THREE.ShaderMaterial({\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\t});\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n\n\tthis.goWild = false;\n\tthis.curF = 0;\n\tthis.generateTrigger();\n};\n\nGlitchPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: GlitchPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.uniforms['seed'].value = Math.random(); //default seeding\n\t\tthis.uniforms['byp'].value = 0;\n\n\t\tif (this.curF % this.randX == 0 || this.goWild == true) {\n\n\t\t\tthis.uniforms['amount'].value = Math.random() / 30;\n\t\t\tthis.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);\n\t\t\tthis.uniforms['seed_x'].value = THREE.Math.randFloat(-1, 1);\n\t\t\tthis.uniforms['seed_y'].value = THREE.Math.randFloat(-1, 1);\n\t\t\tthis.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.curF = 0;\n\t\t\tthis.generateTrigger();\n\t\t} else if (this.curF % this.randX < this.randX / 5) {\n\n\t\t\tthis.uniforms['amount'].value = Math.random() / 90;\n\t\t\tthis.uniforms['angle'].value = THREE.Math.randFloat(-Math.PI, Math.PI);\n\t\t\tthis.uniforms['distortion_x'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.uniforms['distortion_y'].value = THREE.Math.randFloat(0, 1);\n\t\t\tthis.uniforms['seed_x'].value = THREE.Math.randFloat(-0.3, 0.3);\n\t\t\tthis.uniforms['seed_y'].value = THREE.Math.randFloat(-0.3, 0.3);\n\t\t} else if (this.goWild == false) {\n\n\t\t\tthis.uniforms['byp'].value = 1;\n\t\t}\n\n\t\tthis.curF++;\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t},\n\n\tgenerateTrigger: function generateTrigger() {\n\n\t\tthis.randX = THREE.Math.randInt(120, 240);\n\t},\n\n\tgenerateHeightmap: function generateHeightmap(dt_size) {\n\n\t\tvar data_arr = new Float32Array(dt_size * dt_size * 3);\n\t\tvar length = dt_size * dt_size;\n\n\t\tfor (var i = 0; i < length; i++) {\n\n\t\t\tvar val = THREE.Math.randFloat(0, 1);\n\t\t\tdata_arr[i * 3 + 0] = val;\n\t\t\tdata_arr[i * 3 + 1] = val;\n\t\t\tdata_arr[i * 3 + 2] = val;\n\t\t}\n\n\t\tvar texture = new THREE.DataTexture(data_arr, dt_size, dt_size, THREE.RGBFormat, THREE.FloatType);\n\t\ttexture.needsUpdate = true;\n\t\treturn texture;\n\t}\n\n});\n\nexports.default = GlitchPass;\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _HalftoneShader = __webpack_require__(18);\n\nvar _HalftoneShader2 = _interopRequireDefault(_HalftoneShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author meatbags / xavierburrow.com, github/meatbags\n *\n * RGB Halftone pass for three.js effects composer. Requires THREE.HalftoneShader.\n *\n */\n\nvar HalftonePass = function HalftonePass(width, height, params) {\n\n  _Pass2.default.call(this);\n\n  if (_HalftoneShader2.default === undefined) {\n\n    console.error('THREE.HalftonePass requires THREE.HalftoneShader');\n  }\n\n  this.uniforms = THREE.UniformsUtils.clone(_HalftoneShader2.default.uniforms);\n  this.material = new THREE.ShaderMaterial({\n    uniforms: this.uniforms,\n    fragmentShader: _HalftoneShader2.default.fragmentShader,\n    vertexShader: _HalftoneShader2.default.vertexShader\n  });\n\n  // set params\n  this.uniforms.width.value = width;\n  this.uniforms.height.value = height;\n\n  for (var key in params) {\n\n    if (params.hasOwnProperty(key) && this.uniforms.hasOwnProperty(key)) {\n\n      this.uniforms[key].value = params[key];\n    }\n  }\n\n  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new THREE.Scene();\n  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n  this.quad.frustumCulled = false;\n  this.scene.add(this.quad);\n};\n\nHalftonePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n  constructor: HalftonePass,\n\n  render: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n    this.material.uniforms[\"tDiffuse\"].value = readBuffer.texture;\n    this.quad.material = this.material;\n\n    if (this.renderToScreen) {\n\n      renderer.render(this.scene, this.camera);\n    } else {\n\n      renderer.render(this.scene, this.camera, writeBuffer, this.clear);\n    }\n  },\n\n  setSize: function setSize(width, height) {\n\n    this.uniforms.width.value = width;\n    this.uniforms.height.value = height;\n  }\n});\n\nexports.default = HalftonePass;\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar MaskPass = function MaskPass(scene, camera) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.inverse = false;\n};\n\nMaskPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: MaskPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar context = renderer.context;\n\t\tvar state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask(false);\n\t\tstate.buffers.depth.setMask(false);\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked(true);\n\t\tstate.buffers.depth.setLocked(true);\n\n\t\t// set up stencil\n\n\t\tvar writeValue, clearValue;\n\n\t\tif (this.inverse) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\t\t}\n\n\t\tstate.buffers.stencil.setTest(true);\n\t\tstate.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);\n\t\tstate.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);\n\t\tstate.buffers.stencil.setClear(clearValue);\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.render(this.scene, this.camera, readBuffer, this.clear);\n\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\n\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\tstate.buffers.color.setLocked(false);\n\t\tstate.buffers.depth.setLocked(false);\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1\n\t\tstate.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);\n\t}\n\n});\n\nexports.default = MaskPass;\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author spidersharma / http://eduperiment.com/\n */\n\nvar OutlinePass = function OutlinePass(resolution, scene, camera, selectedObjects) {\n\n\tthis.renderScene = scene;\n\tthis.renderCamera = camera;\n\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\tthis.visibleEdgeColor = new THREE.Color(1, 1, 1);\n\tthis.hiddenEdgeColor = new THREE.Color(0.1, 0.04, 0.02);\n\tthis.edgeGlow = 0.0;\n\tthis.usePatternTexture = false;\n\tthis.edgeThickness = 1.0;\n\tthis.edgeStrength = 3.0;\n\tthis.downSampleRatio = 2;\n\tthis.pulsePeriod = 0;\n\n\t_Pass2.default.call(this);\n\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\n\tvar resx = Math.round(this.resolution.x / this.downSampleRatio);\n\tvar resy = Math.round(this.resolution.y / this.downSampleRatio);\n\n\tthis.maskBufferMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\n\tthis.maskBufferMaterial.side = THREE.DoubleSide;\n\tthis.renderTargetMaskBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n\tthis.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.side = THREE.DoubleSide;\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\tthis.prepareMaskMaterial.side = THREE.DoubleSide;\n\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\n\n\tthis.renderTargetDepthBuffer = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, pars);\n\tthis.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\tthis.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\tthis.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\tthis.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n\tthis.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\tthis.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\tthis.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);\n\tthis.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\tvar MAX_EDGE_THICKNESS = 4;\n\tvar MAX_EDGE_GLOW = 4;\n\n\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n\tthis.separableBlurMaterial1.uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\tthis.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = 1;\n\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n\tthis.separableBlurMaterial2.uniforms[\"texSize\"].value = new THREE.Vector2(Math.round(resx / 2), Math.round(resy / 2));\n\tthis.separableBlurMaterial2.uniforms[\"kernelRadius\"].value = MAX_EDGE_GLOW;\n\n\t// Overlay material\n\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t// copy material\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.OutlinePass relies on THREE.CopyShader\");\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t});\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n\n\tthis.tempPulseColor1 = new THREE.Color();\n\tthis.tempPulseColor2 = new THREE.Color();\n\tthis.textureMatrix = new THREE.Matrix4();\n\n\tfunction replaceDepthToViewZ(string, camera) {\n\n\t\tvar type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\treturn string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n\t}\n};\n\nOutlinePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: OutlinePass,\n\n\tdispose: function dispose() {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.renderTargetMaskBuffer.setSize(width, height);\n\n\t\tvar resx = Math.round(width / this.downSampleRatio);\n\t\tvar resy = Math.round(height / this.downSampleRatio);\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n\t\tthis.renderTargetBlurBuffer1.setSize(resx, resy);\n\t\tthis.renderTargetEdgeBuffer1.setSize(resx, resy);\n\t\tthis.separableBlurMaterial1.uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\tresx = Math.round(resx / 2);\n\t\tresy = Math.round(resy / 2);\n\n\t\tthis.renderTargetBlurBuffer2.setSize(resx, resy);\n\t\tthis.renderTargetEdgeBuffer2.setSize(resx, resy);\n\n\t\tthis.separableBlurMaterial2.uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\t},\n\n\tchangeVisibilityOfSelectedObjects: function changeVisibilityOfSelectedObjects(bVisible) {\n\n\t\tfunction gatherSelectedMeshesCallBack(object) {\n\n\t\t\tif (object.isMesh) {\n\n\t\t\t\tif (bVisible) {\n\n\t\t\t\t\tobject.visible = object.userData.oldVisible;\n\t\t\t\t\tdelete object.userData.oldVisible;\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.userData.oldVisible = object.visible;\n\t\t\t\t\tobject.visible = bVisible;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (var i = 0; i < this.selectedObjects.length; i++) {\n\n\t\t\tvar selectedObject = this.selectedObjects[i];\n\t\t\tselectedObject.traverse(gatherSelectedMeshesCallBack);\n\t\t}\n\t},\n\n\tchangeVisibilityOfNonSelectedObjects: function changeVisibilityOfNonSelectedObjects(bVisible) {\n\n\t\tvar selectedMeshes = [];\n\n\t\tfunction gatherSelectedMeshesCallBack(object) {\n\n\t\t\tif (object.isMesh) selectedMeshes.push(object);\n\t\t}\n\n\t\tfor (var i = 0; i < this.selectedObjects.length; i++) {\n\n\t\t\tvar selectedObject = this.selectedObjects[i];\n\t\t\tselectedObject.traverse(gatherSelectedMeshesCallBack);\n\t\t}\n\n\t\tfunction VisibilityChangeCallBack(object) {\n\n\t\t\tif (object.isMesh || object.isLine || object.isSprite) {\n\n\t\t\t\tvar bFound = false;\n\n\t\t\t\tfor (var i = 0; i < selectedMeshes.length; i++) {\n\n\t\t\t\t\tvar selectedObjectId = selectedMeshes[i].id;\n\n\t\t\t\t\tif (selectedObjectId === object.id) {\n\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!bFound) {\n\n\t\t\t\t\tvar visibility = object.visible;\n\n\t\t\t\t\tif (!bVisible || object.bVisible) object.visible = bVisible;\n\n\t\t\t\t\tobject.bVisible = visibility;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.renderScene.traverse(VisibilityChangeCallBack);\n\t},\n\n\tupdateTextureMatrix: function updateTextureMatrix() {\n\n\t\tthis.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n\t\tthis.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n\t\tthis.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n\t},\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tif (this.selectedObjects.length > 0) {\n\n\t\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t\trenderer.setClearColor(0xffffff, 1);\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis.changeVisibilityOfSelectedObjects(false);\n\n\t\t\tvar currentBackground = this.renderScene.background;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.render(this.renderScene, this.renderCamera, this.renderTargetDepthBuffer, true);\n\n\t\t\t// Make selected objects visible\n\t\t\tthis.changeVisibilityOfSelectedObjects(true);\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis.updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis.changeVisibilityOfNonSelectedObjects(false);\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[\"cameraNearFar\"].value = new THREE.Vector2(this.renderCamera.near, this.renderCamera.far);\n\t\t\tthis.prepareMaskMaterial.uniforms[\"depthTexture\"].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[\"textureMatrix\"].value = this.textureMatrix;\n\t\t\trenderer.render(this.renderScene, this.renderCamera, this.renderTargetMaskBuffer, true);\n\t\t\tthis.renderScene.overrideMaterial = null;\n\t\t\tthis.changeVisibilityOfNonSelectedObjects(true);\n\n\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis.quad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetMaskDownSampleBuffer, true);\n\n\t\t\tthis.tempPulseColor1.copy(this.visibleEdgeColor);\n\t\t\tthis.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n\t\t\tif (this.pulsePeriod > 0) {\n\n\t\t\t\tvar scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar(scalar);\n\t\t\t\tthis.tempPulseColor2.multiplyScalar(scalar);\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis.quad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"texSize\"].value = new THREE.Vector2(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"visibleEdgeColor\"].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[\"hiddenEdgeColor\"].value = this.tempPulseColor2;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis.quad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"kernelRadius\"].value = this.edgeThickness;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetBlurBuffer1, true);\n\t\t\tthis.separableBlurMaterial1.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer1, true);\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis.quad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetBlurBuffer2, true);\n\t\t\tthis.separableBlurMaterial2.uniforms[\"colorTexture\"].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[\"direction\"].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetEdgeBuffer2, true);\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis.quad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[\"maskTexture\"].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeTexture1\"].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeTexture2\"].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[\"patternTexture\"].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeStrength\"].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[\"edgeGlow\"].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[\"usePatternTexture\"].value = this.usePatternTexture;\n\n\t\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\t\trenderer.render(this.scene, this.camera, readBuffer, false);\n\n\t\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.quad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t}\n\t},\n\n\tgetPrepareMaskMaterial: function getPrepareMaskMaterial() {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"depthTexture\": { value: null },\n\t\t\t\t\"cameraNearFar\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"textureMatrix\": { value: new THREE.Matrix4() }\n\t\t\t},\n\n\t\t\tvertexShader: ['varying vec4 projTexCoord;', 'varying vec4 vPosition;', 'uniform mat4 textureMatrix;', 'void main() {', '\tvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tprojTexCoord = textureMatrix * worldPosition;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\t\t\tfragmentShader: ['#include <packing>', 'varying vec4 vPosition;', 'varying vec4 projTexCoord;', 'uniform sampler2D depthTexture;', 'uniform vec2 cameraNearFar;', 'void main() {', '\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));', '\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );', '\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;', '\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);', '}'].join('\\n')\n\n\t\t});\n\t},\n\n\tgetEdgeDetectionMaterial: function getEdgeDetectionMaterial() {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"visibleEdgeColor\": { value: new THREE.Vector3(1.0, 1.0, 1.0) },\n\t\t\t\t\"hiddenEdgeColor\": { value: new THREE.Vector3(1.0, 1.0, 1.0) }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetSeperableBlurMaterial: function getSeperableBlurMaterial(maxRadius) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"MAX_RADIUS\": maxRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"kernelRadius\": { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetOverlayMaterial: function getOverlayMaterial() {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tuniforms: {\n\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\"edgeTexture1\": { value: null },\n\t\t\t\t\"edgeTexture2\": { value: null },\n\t\t\t\t\"patternTexture\": { value: null },\n\t\t\t\t\"edgeStrength\": { value: 1.0 },\n\t\t\t\t\"edgeGlow\": { value: 1.0 },\n\t\t\t\t\"usePatternTexture\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}\",\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t});\n\t}\n\n});\n\nOutlinePass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nOutlinePass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\nexports.default = OutlinePass;\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar RenderPass = function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.overrideMaterial = overrideMaterial;\n\n\tthis.clearColor = clearColor;\n\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\tthis.clear = true;\n\tthis.clearDepth = false;\n\tthis.needsSwap = false;\n};\n\nRenderPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: RenderPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\tvar oldClearColor, oldClearAlpha;\n\n\t\tif (this.clearColor) {\n\n\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t}\n\n\t\tif (this.clearDepth) {\n\n\t\t\trenderer.clearDepth();\n\t\t}\n\n\t\trenderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\tif (this.clearColor) {\n\n\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\t\trenderer.autoClear = oldAutoClear;\n\t}\n\n});\n\nexports.default = RenderPass;\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _SAOShader = __webpack_require__(19);\n\nvar _SAOShader2 = _interopRequireDefault(_SAOShader);\n\nvar _DepthLimitedBlurShader = __webpack_require__(20);\n\nvar _DepthLimitedBlurShader2 = _interopRequireDefault(_DepthLimitedBlurShader);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _UnpackDepthRGBAShader = __webpack_require__(21);\n\nvar _UnpackDepthRGBAShader2 = _interopRequireDefault(_UnpackDepthRGBAShader);\n\nvar _BlurShaderUtils = __webpack_require__(22);\n\nvar _BlurShaderUtils2 = _interopRequireDefault(_BlurShaderUtils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author ludobaka / ludobaka.github.io\n * SAO implementation inspired from bhouston previous SAO work\n */\n\nvar SAOPass = function SAOPass(scene, camera, depthTexture, useNormals, resolution) {\n\n\t_Pass2.default.call(this);\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.supportsDepthTextureExtension = depthTexture !== undefined ? depthTexture : false;\n\tthis.supportsNormalTexture = useNormals !== undefined ? useNormals : false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.params = {\n\t\toutput: 0,\n\t\tsaoBias: 0.5,\n\t\tsaoIntensity: 0.18,\n\t\tsaoScale: 1,\n\t\tsaoKernelRadius: 100,\n\t\tsaoMinResolution: 0,\n\t\tsaoBlur: true,\n\t\tsaoBlurRadius: 8,\n\t\tsaoBlurStdDev: 4,\n\t\tsaoBlurDepthCutoff: 0.01\n\t};\n\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\tthis.saoRenderTarget = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBAFormat\n\t});\n\tthis.blurIntermediateRenderTarget = this.saoRenderTarget.clone();\n\tthis.beautyRenderTarget = this.saoRenderTarget.clone();\n\n\tthis.normalRenderTarget = new THREE.WebGLRenderTarget(this.resolution.x, this.resolution.y, {\n\t\tminFilter: THREE.NearestFilter,\n\t\tmagFilter: THREE.NearestFilter,\n\t\tformat: THREE.RGBAFormat\n\t});\n\tthis.depthRenderTarget = this.normalRenderTarget.clone();\n\n\tif (this.supportsDepthTextureExtension) {\n\n\t\tvar depthTexture = new THREE.DepthTexture();\n\t\tdepthTexture.type = THREE.UnsignedShortType;\n\t\tdepthTexture.minFilter = THREE.NearestFilter;\n\t\tdepthTexture.maxFilter = THREE.NearestFilter;\n\n\t\tthis.beautyRenderTarget.depthTexture = depthTexture;\n\t\tthis.beautyRenderTarget.depthBuffer = true;\n\t}\n\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\tthis.normalMaterial = new THREE.MeshNormalMaterial();\n\tthis.normalMaterial.blending = THREE.NoBlending;\n\n\tif (_SAOShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.SAOShader');\n\t}\n\n\tthis.saoMaterial = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, _SAOShader2.default.defines),\n\t\tfragmentShader: _SAOShader2.default.fragmentShader,\n\t\tvertexShader: _SAOShader2.default.vertexShader,\n\t\tuniforms: THREE.UniformsUtils.clone(_SAOShader2.default.uniforms)\n\t});\n\tthis.saoMaterial.extensions.derivatives = true;\n\tthis.saoMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.saoMaterial.defines['NORMAL_TEXTURE'] = this.supportsNormalTexture ? 1 : 0;\n\tthis.saoMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.saoMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n\tthis.saoMaterial.uniforms['tNormal'].value = this.normalRenderTarget.texture;\n\tthis.saoMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n\tthis.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.getInverse(this.camera.projectionMatrix);\n\tthis.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\n\tthis.saoMaterial.blending = THREE.NoBlending;\n\n\tif (_DepthLimitedBlurShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.DepthLimitedBlurShader');\n\t}\n\n\tthis.vBlurMaterial = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_DepthLimitedBlurShader2.default.uniforms),\n\t\tdefines: Object.assign({}, _DepthLimitedBlurShader2.default.defines),\n\t\tvertexShader: _DepthLimitedBlurShader2.default.vertexShader,\n\t\tfragmentShader: _DepthLimitedBlurShader2.default.fragmentShader\n\t});\n\tthis.vBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.vBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.vBlurMaterial.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\n\tthis.vBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n\tthis.vBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n\tthis.vBlurMaterial.blending = THREE.NoBlending;\n\n\tthis.hBlurMaterial = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_DepthLimitedBlurShader2.default.uniforms),\n\t\tdefines: Object.assign({}, _DepthLimitedBlurShader2.default.defines),\n\t\tvertexShader: _DepthLimitedBlurShader2.default.vertexShader,\n\t\tfragmentShader: _DepthLimitedBlurShader2.default.fragmentShader\n\t});\n\tthis.hBlurMaterial.defines['DEPTH_PACKING'] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.hBlurMaterial.defines['PERSPECTIVE_CAMERA'] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.hBlurMaterial.uniforms['tDiffuse'].value = this.blurIntermediateRenderTarget.texture;\n\tthis.hBlurMaterial.uniforms['tDepth'].value = this.supportsDepthTextureExtension ? depthTexture : this.depthRenderTarget.texture;\n\tthis.hBlurMaterial.uniforms['size'].value.set(this.resolution.x, this.resolution.y);\n\tthis.hBlurMaterial.blending = THREE.NoBlending;\n\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.CopyShader');\n\t}\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_CopyShader2.default.uniforms),\n\t\tvertexShader: _CopyShader2.default.vertexShader,\n\t\tfragmentShader: _CopyShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\tthis.materialCopy.transparent = true;\n\tthis.materialCopy.depthTest = false;\n\tthis.materialCopy.depthWrite = false;\n\tthis.materialCopy.blending = THREE.CustomBlending;\n\tthis.materialCopy.blendSrc = THREE.DstColorFactor;\n\tthis.materialCopy.blendDst = THREE.ZeroFactor;\n\tthis.materialCopy.blendEquation = THREE.AddEquation;\n\tthis.materialCopy.blendSrcAlpha = THREE.DstAlphaFactor;\n\tthis.materialCopy.blendDstAlpha = THREE.ZeroFactor;\n\tthis.materialCopy.blendEquationAlpha = THREE.AddEquation;\n\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error('THREE.SAOPass relies on THREE.UnpackDepthRGBAShader');\n\t}\n\n\tthis.depthCopy = new THREE.ShaderMaterial({\n\t\tuniforms: THREE.UniformsUtils.clone(_UnpackDepthRGBAShader2.default.uniforms),\n\t\tvertexShader: _UnpackDepthRGBAShader2.default.vertexShader,\n\t\tfragmentShader: _UnpackDepthRGBAShader2.default.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t});\n\n\tthis.quadCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.quadScene = new THREE.Scene();\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quadScene.add(this.quad);\n};\n\nSAOPass.OUTPUT = {\n\t'Beauty': 1,\n\t'Default': 0,\n\t'SAO': 2,\n\t'Depth': 3,\n\t'Normal': 4\n};\n\nSAOPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\tconstructor: SAOPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t// Rendering readBuffer first when rendering to screen\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.materialCopy.blending = THREE.NoBlending;\n\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = readBuffer.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t\tthis.renderPass(renderer, this.materialCopy, null);\n\t\t}\n\n\t\tif (this.params.output === 1) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.clearTarget(this.depthRenderTarget);\n\n\t\tthis.saoMaterial.uniforms['bias'].value = this.params.saoBias;\n\t\tthis.saoMaterial.uniforms['intensity'].value = this.params.saoIntensity;\n\t\tthis.saoMaterial.uniforms['scale'].value = this.params.saoScale;\n\t\tthis.saoMaterial.uniforms['kernelRadius'].value = this.params.saoKernelRadius;\n\t\tthis.saoMaterial.uniforms['minResolution'].value = this.params.saoMinResolution;\n\t\tthis.saoMaterial.uniforms['cameraNear'].value = this.camera.near;\n\t\tthis.saoMaterial.uniforms['cameraFar'].value = this.camera.far;\n\t\t// this.saoMaterial.uniforms['randomSeed'].value = Math.random();\n\n\t\tvar depthCutoff = this.params.saoBlurDepthCutoff * (this.camera.far - this.camera.near);\n\t\tthis.vBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\n\t\tthis.hBlurMaterial.uniforms['depthCutoff'].value = depthCutoff;\n\n\t\tthis.vBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\n\t\tthis.vBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\n\t\tthis.hBlurMaterial.uniforms['cameraNear'].value = this.camera.near;\n\t\tthis.hBlurMaterial.uniforms['cameraFar'].value = this.camera.far;\n\n\t\tthis.params.saoBlurRadius = Math.floor(this.params.saoBlurRadius);\n\t\tif (this.prevStdDev !== this.params.saoBlurStdDev || this.prevNumSamples !== this.params.saoBlurRadius) {\n\n\t\t\t_BlurShaderUtils2.default.configure(this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2(0, 1));\n\t\t\t_BlurShaderUtils2.default.configure(this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2(1, 0));\n\t\t\tthis.prevStdDev = this.params.saoBlurStdDev;\n\t\t\tthis.prevNumSamples = this.params.saoBlurRadius;\n\t\t}\n\n\t\t// Rendering scene to depth texture\n\t\trenderer.setClearColor(0x000000);\n\t\trenderer.render(this.scene, this.camera, this.beautyRenderTarget, true);\n\n\t\t// Re-render scene if depth texture extension is not supported\n\t\tif (!this.supportsDepthTextureExtension) {\n\n\t\t\t// Clear rule : far clipping plane in both RGBA and Basic encoding\n\t\t\tthis.renderOverride(renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0);\n\t\t}\n\n\t\tif (this.supportsNormalTexture) {\n\n\t\t\t// Clear rule : default normal is facing the camera\n\t\t\tthis.renderOverride(renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0);\n\t\t}\n\n\t\t// Rendering SAO texture\n\t\tthis.renderPass(renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0);\n\n\t\t// Blurring SAO texture\n\t\tif (this.params.saoBlur) {\n\n\t\t\tthis.renderPass(renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0);\n\t\t\tthis.renderPass(renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0);\n\t\t}\n\n\t\tvar outputMaterial = this.materialCopy;\n\t\t// Setting up SAO rendering\n\t\tif (this.params.output === 3) {\n\n\t\t\tif (this.supportsDepthTextureExtension) {\n\n\t\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = this.beautyRenderTarget.depthTexture;\n\t\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t\t} else {\n\n\t\t\t\tthis.depthCopy.uniforms['tDiffuse'].value = this.depthRenderTarget.texture;\n\t\t\t\tthis.depthCopy.needsUpdate = true;\n\t\t\t\toutputMaterial = this.depthCopy;\n\t\t\t}\n\t\t} else if (this.params.output === 4) {\n\n\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = this.normalRenderTarget.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t} else {\n\n\t\t\tthis.materialCopy.uniforms['tDiffuse'].value = this.saoRenderTarget.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t}\n\n\t\t// Blending depends on output, only want a CustomBlending when showing SAO\n\t\tif (this.params.output === 0) {\n\n\t\t\toutputMaterial.blending = THREE.CustomBlending;\n\t\t} else {\n\n\t\t\toutputMaterial.blending = THREE.NoBlending;\n\t\t}\n\n\t\t// Rendering SAOPass result on top of previous pass\n\t\tthis.renderPass(renderer, outputMaterial, this.renderToScreen ? null : readBuffer);\n\n\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\trenderer.autoClear = oldAutoClear;\n\t},\n\n\trenderPass: function renderPass(renderer, passMaterial, renderTarget, clearColor, clearAlpha) {\n\n\t\t// save original state\n\t\tvar originalClearColor = renderer.getClearColor();\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\n\t\tvar originalAutoClear = renderer.autoClear;\n\n\t\t// setup pass state\n\t\trenderer.autoClear = false;\n\t\tvar clearNeeded = clearColor !== undefined && clearColor !== null;\n\t\tif (clearNeeded) {\n\n\t\t\trenderer.setClearColor(clearColor);\n\t\t\trenderer.setClearAlpha(clearAlpha || 0.0);\n\t\t}\n\n\t\tthis.quad.material = passMaterial;\n\t\trenderer.render(this.quadScene, this.quadCamera, renderTarget, clearNeeded);\n\n\t\t// restore original state\n\t\trenderer.autoClear = originalAutoClear;\n\t\trenderer.setClearColor(originalClearColor);\n\t\trenderer.setClearAlpha(originalClearAlpha);\n\t},\n\n\trenderOverride: function renderOverride(renderer, overrideMaterial, renderTarget, clearColor, clearAlpha) {\n\n\t\tvar originalClearColor = renderer.getClearColor();\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\n\t\tvar originalAutoClear = renderer.autoClear;\n\n\t\trenderer.autoClear = false;\n\n\t\tclearColor = overrideMaterial.clearColor || clearColor;\n\t\tclearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\t\tvar clearNeeded = clearColor !== undefined && clearColor !== null;\n\t\tif (clearNeeded) {\n\n\t\t\trenderer.setClearColor(clearColor);\n\t\t\trenderer.setClearAlpha(clearAlpha || 0.0);\n\t\t}\n\n\t\tthis.scene.overrideMaterial = overrideMaterial;\n\t\trenderer.render(this.scene, this.camera, renderTarget, clearNeeded);\n\t\tthis.scene.overrideMaterial = null;\n\n\t\t// restore original state\n\t\trenderer.autoClear = originalAutoClear;\n\t\trenderer.setClearColor(originalClearColor);\n\t\trenderer.setClearAlpha(originalClearAlpha);\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.beautyRenderTarget.setSize(width, height);\n\t\tthis.saoRenderTarget.setSize(width, height);\n\t\tthis.blurIntermediateRenderTarget.setSize(width, height);\n\t\tthis.normalRenderTarget.setSize(width, height);\n\t\tthis.depthRenderTarget.setSize(width, height);\n\n\t\tthis.saoMaterial.uniforms['size'].value.set(width, height);\n\t\tthis.saoMaterial.uniforms['cameraInverseProjectionMatrix'].value.getInverse(this.camera.projectionMatrix);\n\t\tthis.saoMaterial.uniforms['cameraProjectionMatrix'].value = this.camera.projectionMatrix;\n\t\tthis.saoMaterial.needsUpdate = true;\n\n\t\tthis.vBlurMaterial.uniforms['size'].value.set(width, height);\n\t\tthis.vBlurMaterial.needsUpdate = true;\n\n\t\tthis.hBlurMaterial.uniforms['size'].value.set(width, height);\n\t\tthis.hBlurMaterial.needsUpdate = true;\n\t}\n\n});\n\nexports.default = SAOPass;\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar SavePass = function SavePass(renderTarget) {\n\n\t_Pass2.default.call(this);\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.SavePass relies on THREE.CopyShader\");\n\n\tvar shader = _CopyShader2.default;\n\n\tthis.textureID = \"tDiffuse\";\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t});\n\n\tthis.renderTarget = renderTarget;\n\n\tif (this.renderTarget === undefined) {\n\n\t\tthis.renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false });\n\t\tthis.renderTarget.texture.name = \"SavePass.rt\";\n\t}\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nSavePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: SavePass,\n\n\trender: function render(renderer, writeBuffer, readBuffer) {\n\n\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t}\n\n\t\tthis.quad.material = this.material;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTarget, this.clear);\n\t}\n\n});\n\nexports.default = SavePass;\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _SMAAShader = __webpack_require__(23);\n\nvar _SMAAShader2 = _interopRequireDefault(_SMAAShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author mpk / http://polko.me/\n */\n\nvar SMAAPass = function SMAAPass(width, height) {\n\n\t_Pass2.default.call(this);\n\n\t// render targets\n\n\tthis.edgesRT = new THREE.WebGLRenderTarget(width, height, {\n\t\tdepthBuffer: false,\n\t\tstencilBuffer: false,\n\t\tgenerateMipmaps: false,\n\t\tminFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t});\n\tthis.edgesRT.texture.name = \"SMAAPass.edges\";\n\n\tthis.weightsRT = new THREE.WebGLRenderTarget(width, height, {\n\t\tdepthBuffer: false,\n\t\tstencilBuffer: false,\n\t\tgenerateMipmaps: false,\n\t\tminFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBAFormat\n\t});\n\tthis.weightsRT.texture.name = \"SMAAPass.weights\";\n\n\t// textures\n\n\tvar areaTextureImage = new Image();\n\tareaTextureImage.src = this.getAreaTexture();\n\n\tthis.areaTexture = new THREE.Texture();\n\tthis.areaTexture.name = \"SMAAPass.area\";\n\tthis.areaTexture.image = areaTextureImage;\n\tthis.areaTexture.format = THREE.RGBFormat;\n\tthis.areaTexture.minFilter = THREE.LinearFilter;\n\tthis.areaTexture.generateMipmaps = false;\n\tthis.areaTexture.needsUpdate = true;\n\tthis.areaTexture.flipY = false;\n\n\tvar searchTextureImage = new Image();\n\tsearchTextureImage.src = this.getSearchTexture();\n\n\tthis.searchTexture = new THREE.Texture();\n\tthis.searchTexture.name = \"SMAAPass.search\";\n\tthis.searchTexture.image = searchTextureImage;\n\tthis.searchTexture.magFilter = THREE.NearestFilter;\n\tthis.searchTexture.minFilter = THREE.NearestFilter;\n\tthis.searchTexture.generateMipmaps = false;\n\tthis.searchTexture.needsUpdate = true;\n\tthis.searchTexture.flipY = false;\n\n\t// materials - pass 1\n\n\tif (_SMAAShader2.default === undefined) {\n\t\tconsole.error(\"THREE.SMAAPass relies on THREE.SMAAShader\");\n\t}\n\n\tthis.uniformsEdges = THREE.UniformsUtils.clone(_SMAAShader2.default[0].uniforms);\n\n\tthis.uniformsEdges[\"resolution\"].value.set(1 / width, 1 / height);\n\n\tthis.materialEdges = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, _SMAAShader2.default[0].defines),\n\t\tuniforms: this.uniformsEdges,\n\t\tvertexShader: _SMAAShader2.default[0].vertexShader,\n\t\tfragmentShader: _SMAAShader2.default[0].fragmentShader\n\t});\n\n\t// materials - pass 2\n\n\tthis.uniformsWeights = THREE.UniformsUtils.clone(_SMAAShader2.default[1].uniforms);\n\n\tthis.uniformsWeights[\"resolution\"].value.set(1 / width, 1 / height);\n\tthis.uniformsWeights[\"tDiffuse\"].value = this.edgesRT.texture;\n\tthis.uniformsWeights[\"tArea\"].value = this.areaTexture;\n\tthis.uniformsWeights[\"tSearch\"].value = this.searchTexture;\n\n\tthis.materialWeights = new THREE.ShaderMaterial({\n\t\tdefines: Object.assign({}, _SMAAShader2.default[1].defines),\n\t\tuniforms: this.uniformsWeights,\n\t\tvertexShader: _SMAAShader2.default[1].vertexShader,\n\t\tfragmentShader: _SMAAShader2.default[1].fragmentShader\n\t});\n\n\t// materials - pass 3\n\n\tthis.uniformsBlend = THREE.UniformsUtils.clone(_SMAAShader2.default[2].uniforms);\n\n\tthis.uniformsBlend[\"resolution\"].value.set(1 / width, 1 / height);\n\tthis.uniformsBlend[\"tDiffuse\"].value = this.weightsRT.texture;\n\n\tthis.materialBlend = new THREE.ShaderMaterial({\n\t\tuniforms: this.uniformsBlend,\n\t\tvertexShader: _SMAAShader2.default[2].vertexShader,\n\t\tfragmentShader: _SMAAShader2.default[2].fragmentShader\n\t});\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nSMAAPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: SMAAPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t// pass 1\n\n\t\tthis.uniformsEdges[\"tDiffuse\"].value = readBuffer.texture;\n\n\t\tthis.quad.material = this.materialEdges;\n\n\t\trenderer.render(this.scene, this.camera, this.edgesRT, this.clear);\n\n\t\t// pass 2\n\n\t\tthis.quad.material = this.materialWeights;\n\n\t\trenderer.render(this.scene, this.camera, this.weightsRT, this.clear);\n\n\t\t// pass 3\n\n\t\tthis.uniformsBlend[\"tColor\"].value = readBuffer.texture;\n\n\t\tthis.quad.material = this.materialBlend;\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tthis.edgesRT.setSize(width, height);\n\t\tthis.weightsRT.setSize(width, height);\n\n\t\tthis.materialEdges.uniforms['resolution'].value.set(1 / width, 1 / height);\n\t\tthis.materialWeights.uniforms['resolution'].value.set(1 / width, 1 / height);\n\t\tthis.materialBlend.uniforms['resolution'].value.set(1 / width, 1 / height);\n\t},\n\n\tgetAreaTexture: function getAreaTexture() {\n\t\treturn 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII=';\n\t},\n\n\tgetSearchTexture: function getSearchTexture() {\n\t\treturn 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII=';\n\t}\n\n});\n\nexports.default = SMAAPass;\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _ShaderPass = __webpack_require__(3);\n\nvar _ShaderPass2 = _interopRequireDefault(_ShaderPass);\n\nvar _SSAOShader = __webpack_require__(25);\n\nvar _SSAOShader2 = _interopRequireDefault(_SSAOShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n'use strict';\n\n/**\n * Screen-space ambient occlusion pass.\n *\n * Has the following parameters\n *  - radius\n *  \t- Ambient occlusion shadow radius (numeric value).\n *  - onlyAO\n *  \t- Display only ambient occlusion result (boolean value).\n *  - aoClamp\n *  \t- Ambient occlusion clamp (numeric value).\n *  - lumInfluence\n *  \t- Pixel luminosity influence in AO calculation (numeric value).\n *\n * To output to screen set renderToScreens true\n *\n * @author alteredq / http://alteredqualia.com/\n * @author tentone\n * @class SSAOPass\n */\nvar SSAOPass = function SSAOPass(scene, camera, width, height) {\n\n\tif (_SSAOShader2.default === undefined) {\n\n\t\tconsole.warn('THREE.SSAOPass depends on THREE.SSAOShader');\n\t\treturn new _ShaderPass2.default();\n\t}\n\n\t_ShaderPass2.default.call(this, _SSAOShader2.default);\n\n\tthis.width = width !== undefined ? width : 512;\n\tthis.height = height !== undefined ? height : 256;\n\n\tthis.renderToScreen = false;\n\n\tthis.camera2 = camera;\n\tthis.scene2 = scene;\n\n\t//Depth material\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\t//Depth render target\n\tthis.depthRenderTarget = new THREE.WebGLRenderTarget(this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter });\n\t//this.depthRenderTarget.texture.name = 'SSAOShader.rt';\n\n\t//Shader uniforms\n\tthis.uniforms['tDepth'].value = this.depthRenderTarget.texture;\n\tthis.uniforms['size'].value.set(this.width, this.height);\n\tthis.uniforms['cameraNear'].value = this.camera2.near;\n\tthis.uniforms['cameraFar'].value = this.camera2.far;\n\n\tthis.uniforms['radius'].value = 4;\n\tthis.uniforms['onlyAO'].value = false;\n\tthis.uniforms['aoClamp'].value = 0.25;\n\tthis.uniforms['lumInfluence'].value = 0.7;\n\n\t//Setters and getters for uniforms\n\tvar self = this;\n\tObject.defineProperties(this, {\n\n\t\tradius: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['radius'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['radius'].value = value;\n\t\t\t}\n\t\t},\n\n\t\tonlyAO: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['onlyAO'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['onlyAO'].value = value;\n\t\t\t}\n\t\t},\n\n\t\taoClamp: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['aoClamp'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['aoClamp'].value = value;\n\t\t\t}\n\t\t},\n\n\t\tlumInfluence: {\n\t\t\tget: function get() {\n\t\t\t\treturn this.uniforms['lumInfluence'].value;\n\t\t\t},\n\t\t\tset: function set(value) {\n\t\t\t\tthis.uniforms['lumInfluence'].value = value;\n\t\t\t}\n\t\t}\n\n\t});\n};\n\nSSAOPass.prototype = Object.create(_ShaderPass2.default.prototype);\n\n/**\n * Render using this pass.\n *\n * @method render\n * @param {WebGLRenderer} renderer\n * @param {WebGLRenderTarget} writeBuffer Buffer to write output.\n * @param {WebGLRenderTarget} readBuffer Input buffer.\n * @param {Number} delta Delta time in milliseconds.\n * @param {Boolean} maskActive Not used in this pass.\n */\nSSAOPass.prototype.render = function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t//Render depth into depthRenderTarget\n\tthis.scene2.overrideMaterial = this.depthMaterial;\n\n\trenderer.render(this.scene2, this.camera2, this.depthRenderTarget, true);\n\n\tthis.scene2.overrideMaterial = null;\n\n\t//SSAO shaderPass\n\t_ShaderPass2.default.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta, maskActive);\n};\n\n/**\n * Change scene to be renderer by this render pass.\n *\n * @method setScene\n * @param {Scene} scene\n */\nSSAOPass.prototype.setScene = function (scene) {\n\n\tthis.scene2 = scene;\n};\n\n/**\n * Set camera used by this render pass.\n *\n * @method setCamera\n * @param {Camera} camera\n */\nSSAOPass.prototype.setCamera = function (camera) {\n\n\tthis.camera2 = camera;\n\n\tthis.uniforms['cameraNear'].value = this.camera2.near;\n\tthis.uniforms['cameraFar'].value = this.camera2.far;\n};\n\n/**\n * Set resolution of this render pass.\n *\n * @method setSize\n * @param {Number} width\n * @param {Number} height\n */\nSSAOPass.prototype.setSize = function (width, height) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.uniforms['size'].value.set(this.width, this.height);\n\tthis.depthRenderTarget.setSize(this.width, this.height);\n};\n\nexports.default = SSAOPass;\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _SSAARenderPass = __webpack_require__(24);\n\nvar _SSAARenderPass2 = _interopRequireDefault(_SSAARenderPass);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n *\n * Temporal Anti-Aliasing Render Pass\n *\n * @author bhouston / http://clara.io/\n *\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\n *\n * References:\n *\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\n *\n */\n\nvar TAARenderPass = function TAARenderPass(scene, camera, params) {\n\n\tif (_SSAARenderPass2.default === undefined) {\n\n\t\tconsole.error(\"THREE.TAARenderPass relies on THREE.SSAARenderPass\");\n\t}\n\n\t_SSAARenderPass2.default.call(this, scene, camera, params);\n\n\tthis.sampleLevel = 0;\n\tthis.accumulate = false;\n};\n\nTAARenderPass.JitterVectors = _SSAARenderPass2.default.JitterVectors;\n\nTAARenderPass.prototype = Object.assign(Object.create(_SSAARenderPass2.default.prototype), {\n\n\tconstructor: TAARenderPass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta) {\n\n\t\tif (!this.accumulate) {\n\n\t\t\t_SSAARenderPass2.default.prototype.render.call(this, renderer, writeBuffer, readBuffer, delta);\n\n\t\t\tthis.accumulateIndex = -1;\n\t\t\treturn;\n\t\t}\n\n\t\tvar jitterOffsets = TAARenderPass.JitterVectors[5];\n\n\t\tif (!this.sampleRenderTarget) {\n\n\t\t\tthis.sampleRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n\t\t\tthis.sampleRenderTarget.texture.name = \"TAARenderPass.sample\";\n\t\t}\n\n\t\tif (!this.holdRenderTarget) {\n\n\t\t\tthis.holdRenderTarget = new THREE.WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n\t\t\tthis.holdRenderTarget.texture.name = \"TAARenderPass.hold\";\n\t\t}\n\n\t\tif (this.accumulate && this.accumulateIndex === -1) {\n\n\t\t\t_SSAARenderPass2.default.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, delta);\n\n\t\t\tthis.accumulateIndex = 0;\n\t\t}\n\n\t\tvar autoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tvar sampleWeight = 1.0 / jitterOffsets.length;\n\n\t\tif (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = sampleWeight;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = writeBuffer.texture;\n\n\t\t\t// render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\t\t\tvar numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\t\t\tfor (var i = 0; i < numSamplesPerFrame; i++) {\n\n\t\t\t\tvar j = this.accumulateIndex;\n\t\t\t\tvar jitterOffset = jitterOffsets[j];\n\n\t\t\t\tif (this.camera.setViewOffset) {\n\n\t\t\t\t\tthis.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n\t\t\t\t\treadBuffer.width, readBuffer.height);\n\t\t\t\t}\n\n\t\t\t\trenderer.render(this.scene, this.camera, writeBuffer, true);\n\t\t\t\trenderer.render(this.scene2, this.camera2, this.sampleRenderTarget, this.accumulateIndex === 0);\n\n\t\t\t\tthis.accumulateIndex++;\n\n\t\t\t\tif (this.accumulateIndex >= jitterOffsets.length) break;\n\t\t\t}\n\n\t\t\tif (this.camera.clearViewOffset) this.camera.clearViewOffset();\n\t\t}\n\n\t\tvar accumulationWeight = this.accumulateIndex * sampleWeight;\n\n\t\tif (accumulationWeight > 0) {\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = this.sampleRenderTarget.texture;\n\t\t\trenderer.render(this.scene2, this.camera2, writeBuffer, true);\n\t\t}\n\n\t\tif (accumulationWeight < 1.0) {\n\n\t\t\tthis.copyUniforms[\"opacity\"].value = 1.0 - accumulationWeight;\n\t\t\tthis.copyUniforms[\"tDiffuse\"].value = this.holdRenderTarget.texture;\n\t\t\trenderer.render(this.scene2, this.camera2, writeBuffer, accumulationWeight === 0);\n\t\t}\n\n\t\trenderer.autoClear = autoClear;\n\t}\n\n});\n\nexports.default = TAARenderPass;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nvar TexturePass = function TexturePass(map, opacity) {\n\n\t_Pass2.default.call(this);\n\n\tif (_CopyShader2.default === undefined) console.error(\"THREE.TexturePass relies on THREE.CopyShader\");\n\n\tvar shader = _CopyShader2.default;\n\n\tthis.map = map;\n\tthis.opacity = opacity !== undefined ? opacity : 1.0;\n\n\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\tthis.material = new THREE.ShaderMaterial({\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\tdepthTest: false,\n\t\tdepthWrite: false\n\n\t});\n\n\tthis.needsSwap = false;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nTexturePass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: TexturePass,\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\tthis.quad.material = this.material;\n\n\t\tthis.uniforms[\"opacity\"].value = this.opacity;\n\t\tthis.uniforms[\"tDiffuse\"].value = this.map;\n\t\tthis.material.transparent = this.opacity < 1.0;\n\n\t\trenderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\trenderer.autoClear = oldAutoClear;\n\t}\n\n});\n\nexports.default = TexturePass;\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nvar _Pass = __webpack_require__(1);\n\nvar _Pass2 = _interopRequireDefault(_Pass);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _LuminosityHighPassShader = __webpack_require__(26);\n\nvar _LuminosityHighPassShader2 = _interopRequireDefault(_LuminosityHighPassShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author spidersharma / http://eduperiment.com/\n *\n * Inspired from Unreal Engine\n * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nvar UnrealBloomPass = function UnrealBloomPass(resolution, strength, radius, threshold) {\n\n\t_Pass2.default.call(this);\n\n\tthis.strength = strength !== undefined ? strength : 1;\n\tthis.radius = radius;\n\tthis.threshold = threshold;\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\t// render targets\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\tthis.renderTargetsHorizontal = [];\n\tthis.renderTargetsVertical = [];\n\tthis.nMips = 5;\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tthis.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.h\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsHorizontal.push(renderTarget);\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.v\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsVertical.push(renderTarget);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// luminosity high pass material\n\n\tif (_LuminosityHighPassShader2.default === undefined) console.error(\"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\");\n\n\tvar highPassShader = _LuminosityHighPassShader2.default;\n\tthis.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);\n\n\tthis.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n\tthis.highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n\tthis.materialHighPassFilter = new THREE.ShaderMaterial({\n\t\tuniforms: this.highPassUniforms,\n\t\tvertexShader: highPassShader.vertexShader,\n\t\tfragmentShader: highPassShader.fragmentShader,\n\t\tdefines: {}\n\t});\n\n\t// Gaussian Blur Materials\n\tthis.separableBlurMaterials = [];\n\tvar kernelSizeArray = [3, 5, 7, 9, 11];\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tthis.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n\n\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// Composite material\n\tthis.compositeMaterial = this.getCompositeMaterial(this.nMips);\n\tthis.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n\tthis.compositeMaterial.needsUpdate = true;\n\n\tvar bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n\tthis.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n\tthis.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];\n\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t// copy material\n\tif (_CopyShader2.default === undefined) {\n\n\t\tconsole.error(\"THREE.BloomPass relies on THREE.CopyShader\");\n\t}\n\n\tvar copyShader = _CopyShader2.default;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t});\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.basic = new THREE.MeshBasicMaterial();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(_Pass2.default.prototype), {\n\n\tconstructor: UnrealBloomPass,\n\n\tdispose: function dispose() {\n\n\t\tfor (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].dispose();\n\t\t}\n\n\t\tfor (var i = 0; i < this.renderTargetsVertical.length; i++) {\n\n\t\t\tthis.renderTargetsVertical[i].dispose();\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\t},\n\n\tsetSize: function setSize(width, height) {\n\n\t\tvar resx = Math.round(width / 2);\n\t\tvar resy = Math.round(height / 2);\n\n\t\tthis.renderTargetBright.setSize(resx, resy);\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].setSize(resx, resy);\n\t\t\tthis.renderTargetsVertical[i].setSize(resx, resy);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\t\tresx = Math.round(resx / 2);\n\t\t\tresy = Math.round(resy / 2);\n\t\t}\n\t},\n\n\trender: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor(new THREE.Color(0, 0, 0), 0);\n\n\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t// Render input to screen\n\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.quad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, true);\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n\t\tthis.quad.material = this.materialHighPassFilter;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetBright, true);\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.quad.material = this.separableBlurMaterials[i];\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], true);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsVertical[i], true);\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[i];\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.quad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], true);\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.quad.material = this.materialCopy;\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n\n\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, false);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, readBuffer, false);\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\trenderer.autoClear = oldAutoClear;\n\t},\n\n\tgetSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2(0.5, 0.5) }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\n\\\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat x = float(i);\\\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetCompositeMaterial: function getCompositeMaterial(nMips) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D blurTexture1;\\\n\t\t\t\tuniform sampler2D blurTexture2;\\\n\t\t\t\tuniform sampler2D blurTexture3;\\\n\t\t\t\tuniform sampler2D blurTexture4;\\\n\t\t\t\tuniform sampler2D blurTexture5;\\\n\t\t\t\tuniform sampler2D dirtTexture;\\\n\t\t\t\tuniform float bloomStrength;\\\n\t\t\t\tuniform float bloomRadius;\\\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\n\t\t\t\t\\\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\n\t\t\t\t}\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\n\t\t\t\t}\"\n\t\t});\n\t}\n\n});\n\nUnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\nexports.default = UnrealBloomPass;\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WaterRefractionShader = exports.VignetteShader = exports.VerticalTiltShiftShader = exports.VerticalBlurShader = exports.UnpackDepthRGBAShader = exports.TriangleBlurShader = exports.ToneMapShader = exports.TechnicolorShader = exports.SSAOShader = exports.SobelOperatorShader = exports.SMAAShader = exports.SepiaShader = exports.SAOShader = exports.RGBShiftShader = exports.PixelShader = exports.ParallaxShader = exports.NormalMapShader = exports.MirrorShader = exports.LuminosityShader = exports.LuminosityHighPassShader = exports.KaleidoShader = exports.HueSaturationShader = exports.HorizontalTiltShiftShader = exports.HorizontalBlurShader = exports.HalftoneShader = exports.GammaCorrectionShader = exports.FXAAShader = exports.FresnelShader = exports.FreiChenShader = exports.FocusShader = exports.FilmShader = exports.DotScreenShader = exports.DOFMipMapShader = exports.DigitalGlitch = exports.DepthLimitedBlurShader = exports.CopyShader = exports.ConvolutionShader = exports.ColorifyShader = exports.ColorCorrectionShader = exports.BrightnessContrastShader = exports.BokehShader2 = exports.BokehShader = exports.BlurShaderUtils = exports.BlendShader = exports.BleachBypassShader = exports.BasicShader = undefined;\n\nvar _BasicShader = __webpack_require__(113);\n\nvar _BasicShader2 = _interopRequireDefault(_BasicShader);\n\nvar _BleachBypassShader = __webpack_require__(114);\n\nvar _BleachBypassShader2 = _interopRequireDefault(_BleachBypassShader);\n\nvar _BlendShader = __webpack_require__(115);\n\nvar _BlendShader2 = _interopRequireDefault(_BlendShader);\n\nvar _BlurShaderUtils = __webpack_require__(22);\n\nvar _BlurShaderUtils2 = _interopRequireDefault(_BlurShaderUtils);\n\nvar _BokehShader = __webpack_require__(14);\n\nvar _BokehShader2 = _interopRequireDefault(_BokehShader);\n\nvar _BokehShader3 = __webpack_require__(116);\n\nvar _BokehShader4 = _interopRequireDefault(_BokehShader3);\n\nvar _BrightnessContrastShader = __webpack_require__(117);\n\nvar _BrightnessContrastShader2 = _interopRequireDefault(_BrightnessContrastShader);\n\nvar _ColorCorrectionShader = __webpack_require__(118);\n\nvar _ColorCorrectionShader2 = _interopRequireDefault(_ColorCorrectionShader);\n\nvar _ColorifyShader = __webpack_require__(119);\n\nvar _ColorifyShader2 = _interopRequireDefault(_ColorifyShader);\n\nvar _ConvolutionShader = __webpack_require__(13);\n\nvar _ConvolutionShader2 = _interopRequireDefault(_ConvolutionShader);\n\nvar _CopyShader = __webpack_require__(2);\n\nvar _CopyShader2 = _interopRequireDefault(_CopyShader);\n\nvar _DepthLimitedBlurShader = __webpack_require__(20);\n\nvar _DepthLimitedBlurShader2 = _interopRequireDefault(_DepthLimitedBlurShader);\n\nvar _DigitalGlitch = __webpack_require__(17);\n\nvar _DigitalGlitch2 = _interopRequireDefault(_DigitalGlitch);\n\nvar _DOFMipMapShader = __webpack_require__(120);\n\nvar _DOFMipMapShader2 = _interopRequireDefault(_DOFMipMapShader);\n\nvar _DotScreenShader = __webpack_require__(15);\n\nvar _DotScreenShader2 = _interopRequireDefault(_DotScreenShader);\n\nvar _FilmShader = __webpack_require__(16);\n\nvar _FilmShader2 = _interopRequireDefault(_FilmShader);\n\nvar _FocusShader = __webpack_require__(121);\n\nvar _FocusShader2 = _interopRequireDefault(_FocusShader);\n\nvar _FreiChenShader = __webpack_require__(122);\n\nvar _FreiChenShader2 = _interopRequireDefault(_FreiChenShader);\n\nvar _FresnelShader = __webpack_require__(123);\n\nvar _FresnelShader2 = _interopRequireDefault(_FresnelShader);\n\nvar _FXAAShader = __webpack_require__(124);\n\nvar _FXAAShader2 = _interopRequireDefault(_FXAAShader);\n\nvar _GammaCorrectionShader = __webpack_require__(125);\n\nvar _GammaCorrectionShader2 = _interopRequireDefault(_GammaCorrectionShader);\n\nvar _HalftoneShader = __webpack_require__(18);\n\nvar _HalftoneShader2 = _interopRequireDefault(_HalftoneShader);\n\nvar _HorizontalBlurShader = __webpack_require__(126);\n\nvar _HorizontalBlurShader2 = _interopRequireDefault(_HorizontalBlurShader);\n\nvar _HorizontalTiltShiftShader = __webpack_require__(127);\n\nvar _HorizontalTiltShiftShader2 = _interopRequireDefault(_HorizontalTiltShiftShader);\n\nvar _HueSaturationShader = __webpack_require__(128);\n\nvar _HueSaturationShader2 = _interopRequireDefault(_HueSaturationShader);\n\nvar _KaleidoShader = __webpack_require__(129);\n\nvar _KaleidoShader2 = _interopRequireDefault(_KaleidoShader);\n\nvar _LuminosityHighPassShader = __webpack_require__(26);\n\nvar _LuminosityHighPassShader2 = _interopRequireDefault(_LuminosityHighPassShader);\n\nvar _LuminosityShader = __webpack_require__(11);\n\nvar _LuminosityShader2 = _interopRequireDefault(_LuminosityShader);\n\nvar _MirrorShader = __webpack_require__(130);\n\nvar _MirrorShader2 = _interopRequireDefault(_MirrorShader);\n\nvar _NormalMapShader = __webpack_require__(131);\n\nvar _NormalMapShader2 = _interopRequireDefault(_NormalMapShader);\n\nvar _OceanShaders = __webpack_require__(132);\n\nvar _OceanShaders2 = _interopRequireDefault(_OceanShaders);\n\nvar _ParallaxShader = __webpack_require__(133);\n\nvar _ParallaxShader2 = _interopRequireDefault(_ParallaxShader);\n\nvar _PixelShader = __webpack_require__(134);\n\nvar _PixelShader2 = _interopRequireDefault(_PixelShader);\n\nvar _RGBShiftShader = __webpack_require__(135);\n\nvar _RGBShiftShader2 = _interopRequireDefault(_RGBShiftShader);\n\nvar _SAOShader = __webpack_require__(19);\n\nvar _SAOShader2 = _interopRequireDefault(_SAOShader);\n\nvar _SepiaShader = __webpack_require__(136);\n\nvar _SepiaShader2 = _interopRequireDefault(_SepiaShader);\n\nvar _SMAAShader = __webpack_require__(23);\n\nvar _SMAAShader2 = _interopRequireDefault(_SMAAShader);\n\nvar _SobelOperatorShader = __webpack_require__(137);\n\nvar _SobelOperatorShader2 = _interopRequireDefault(_SobelOperatorShader);\n\nvar _SSAOShader = __webpack_require__(25);\n\nvar _SSAOShader2 = _interopRequireDefault(_SSAOShader);\n\nvar _TechnicolorShader = __webpack_require__(138);\n\nvar _TechnicolorShader2 = _interopRequireDefault(_TechnicolorShader);\n\nvar _ToneMapShader = __webpack_require__(12);\n\nvar _ToneMapShader2 = _interopRequireDefault(_ToneMapShader);\n\nvar _TriangleBlurShader = __webpack_require__(139);\n\nvar _TriangleBlurShader2 = _interopRequireDefault(_TriangleBlurShader);\n\nvar _UnpackDepthRGBAShader = __webpack_require__(21);\n\nvar _UnpackDepthRGBAShader2 = _interopRequireDefault(_UnpackDepthRGBAShader);\n\nvar _VerticalBlurShader = __webpack_require__(140);\n\nvar _VerticalBlurShader2 = _interopRequireDefault(_VerticalBlurShader);\n\nvar _VerticalTiltShiftShader = __webpack_require__(141);\n\nvar _VerticalTiltShiftShader2 = _interopRequireDefault(_VerticalTiltShiftShader);\n\nvar _VignetteShader = __webpack_require__(142);\n\nvar _VignetteShader2 = _interopRequireDefault(_VignetteShader);\n\nvar _WaterRefractionShader = __webpack_require__(143);\n\nvar _WaterRefractionShader2 = _interopRequireDefault(_WaterRefractionShader);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.BasicShader = _BasicShader2.default;\nexports.BleachBypassShader = _BleachBypassShader2.default;\nexports.BlendShader = _BlendShader2.default;\nexports.BlurShaderUtils = _BlurShaderUtils2.default;\nexports.BokehShader = _BokehShader2.default;\nexports.BokehShader2 = _BokehShader4.default;\nexports.BrightnessContrastShader = _BrightnessContrastShader2.default;\nexports.ColorCorrectionShader = _ColorCorrectionShader2.default;\nexports.ColorifyShader = _ColorifyShader2.default;\nexports.ConvolutionShader = _ConvolutionShader2.default;\nexports.CopyShader = _CopyShader2.default;\nexports.DepthLimitedBlurShader = _DepthLimitedBlurShader2.default;\nexports.DigitalGlitch = _DigitalGlitch2.default;\nexports.DOFMipMapShader = _DOFMipMapShader2.default;\nexports.DotScreenShader = _DotScreenShader2.default;\nexports.FilmShader = _FilmShader2.default;\nexports.FocusShader = _FocusShader2.default;\nexports.FreiChenShader = _FreiChenShader2.default;\nexports.FresnelShader = _FresnelShader2.default;\nexports.FXAAShader = _FXAAShader2.default;\nexports.GammaCorrectionShader = _GammaCorrectionShader2.default;\nexports.HalftoneShader = _HalftoneShader2.default;\nexports.HorizontalBlurShader = _HorizontalBlurShader2.default;\nexports.HorizontalTiltShiftShader = _HorizontalTiltShiftShader2.default;\nexports.HueSaturationShader = _HueSaturationShader2.default;\nexports.KaleidoShader = _KaleidoShader2.default;\nexports.LuminosityHighPassShader = _LuminosityHighPassShader2.default;\nexports.LuminosityShader = _LuminosityShader2.default;\nexports.MirrorShader = _MirrorShader2.default;\nexports.NormalMapShader = _NormalMapShader2.default;\nexports.ParallaxShader = _ParallaxShader2.default;\nexports.PixelShader = _PixelShader2.default;\nexports.RGBShiftShader = _RGBShiftShader2.default;\nexports.SAOShader = _SAOShader2.default;\nexports.SepiaShader = _SepiaShader2.default;\nexports.SMAAShader = _SMAAShader2.default;\nexports.SobelOperatorShader = _SobelOperatorShader2.default;\nexports.SSAOShader = _SSAOShader2.default;\nexports.TechnicolorShader = _TechnicolorShader2.default;\nexports.ToneMapShader = _ToneMapShader2.default;\nexports.TriangleBlurShader = _TriangleBlurShader2.default;\nexports.UnpackDepthRGBAShader = _UnpackDepthRGBAShader2.default;\nexports.VerticalBlurShader = _VerticalBlurShader2.default;\nexports.VerticalTiltShiftShader = _VerticalTiltShiftShader2.default;\nexports.VignetteShader = _VignetteShader2.default;\nexports.WaterRefractionShader = _WaterRefractionShader2.default;\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author mrdoob / http://www.mrdoob.com\n *\n * Simple test shader\n */\n\nvar BasicShader = {\n\n\tuniforms: {},\n\n\tvertexShader: [\"void main() {\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"void main() {\", \"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BasicShader;\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\n * - based on Nvidia example\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\n */\n\nvar BleachBypassShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 base = texture2D( tDiffuse, vUv );\", \"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\", \"float lum = dot( lumCoeff, base.rgb );\", \"vec3 blend = vec3( lum );\", \"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\", \"vec3 result1 = 2.0 * base.rgb * blend;\", \"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\", \"vec3 newColor = mix( result1, result2, L );\", \"float A2 = opacity * base.a;\", \"vec3 mixRGB = A2 * newColor.rgb;\", \"mixRGB += ( ( 1.0 - A2 ) * base.rgb );\", \"gl_FragColor = vec4( mixRGB, base.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BleachBypassShader;\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Blend two textures\n */\n\nvar BlendShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse1\": { value: null },\n\t\t\"tDiffuse2\": { value: null },\n\t\t\"mixRatio\": { value: 0.5 },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float opacity;\", \"uniform float mixRatio;\", \"uniform sampler2D tDiffuse1;\", \"uniform sampler2D tDiffuse2;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel1 = texture2D( tDiffuse1, vUv );\", \"vec4 texel2 = texture2D( tDiffuse2, vUv );\", \"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BlendShader;\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\nvar BokehShader2 = {\n\n\tuniforms: {\n\n\t\t\"textureWidth\": { value: 1.0 },\n\t\t\"textureHeight\": { value: 1.0 },\n\n\t\t\"focalDepth\": { value: 1.0 },\n\t\t\"focalLength\": { value: 24.0 },\n\t\t\"fstop\": { value: 0.9 },\n\n\t\t\"tColor\": { value: null },\n\t\t\"tDepth\": { value: null },\n\n\t\t\"maxblur\": { value: 1.0 },\n\n\t\t\"showFocus\": { value: 0 },\n\t\t\"manualdof\": { value: 0 },\n\t\t\"vignetting\": { value: 0 },\n\t\t\"depthblur\": { value: 0 },\n\n\t\t\"threshold\": { value: 0.5 },\n\t\t\"gain\": { value: 2.0 },\n\t\t\"bias\": { value: 0.5 },\n\t\t\"fringe\": { value: 0.7 },\n\n\t\t\"znear\": { value: 0.1 },\n\t\t\"zfar\": { value: 100 },\n\n\t\t\"noise\": { value: 1 },\n\t\t\"dithering\": { value: 0.0001 },\n\t\t\"pentagon\": { value: 0 },\n\n\t\t\"shaderFocus\": { value: 1 },\n\t\t\"focusCoords\": { value: new THREE.Vector2() }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"#include <packing>\", \"varying vec2 vUv;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"uniform float textureWidth;\", \"uniform float textureHeight;\", \"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\", \"uniform float focalLength; //focal length in mm\", \"uniform float fstop; //f-stop value\", \"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\", \"/*\", \"make sure that these two values are the same for your camera, otherwise distances will be wrong.\", \"*/\", \"uniform float znear; // camera clipping start\", \"uniform float zfar; // camera clipping end\", \"//------------------------------------------\", \"//user variables\", \"const int samples = SAMPLES; //samples on the first ring\", \"const int rings = RINGS; //ring count\", \"const int maxringsamples = rings * samples;\", \"uniform bool manualdof; // manual dof calculation\", \"float ndofstart = 1.0; // near dof blur start\", \"float ndofdist = 2.0; // near dof blur falloff distance\", \"float fdofstart = 1.0; // far dof blur start\", \"float fdofdist = 3.0; // far dof blur falloff distance\", \"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\", \"uniform bool vignetting; // use optical lens vignetting\", \"float vignout = 1.3; // vignetting outer border\", \"float vignin = 0.0; // vignetting inner border\", \"float vignfade = 22.0; // f-stops till vignete fades\", \"uniform bool shaderFocus;\", \"// disable if you use external focalDepth value\", \"uniform vec2 focusCoords;\", \"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\", \"// if center of screen use vec2(0.5, 0.5);\", \"uniform float maxblur;\", \"//clamp value of max blur (0.0 = no blur, 1.0 default)\", \"uniform float threshold; // highlight threshold;\", \"uniform float gain; // highlight gain;\", \"uniform float bias; // bokeh edge bias\", \"uniform float fringe; // bokeh chromatic aberration / fringing\", \"uniform bool noise; //use noise instead of pattern for sample dithering\", \"uniform float dithering;\", \"uniform bool depthblur; // blur the depth buffer\", \"float dbsize = 1.25; // depth blur size\", \"/*\", \"next part is experimental\", \"not looking good with small sample and ring count\", \"looks okay starting from samples = 4, rings = 4\", \"*/\", \"uniform bool pentagon; //use pentagon as bokeh shape?\", \"float feather = 0.4; //pentagon shape feather\", \"//------------------------------------------\", \"float getDepth( const in vec2 screenPosition ) {\", \"\t#if DEPTH_PACKING == 1\", \"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\", \"\t#else\", \"\treturn texture2D( tDepth, screenPosition ).x;\", \"\t#endif\", \"}\", \"float penta(vec2 coords) {\", \"//pentagonal shape\", \"float scale = float(rings) - 1.3;\", \"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\", \"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\", \"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\", \"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\", \"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\", \"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\", \"vec4  one = vec4( 1.0 );\", \"vec4 P = vec4((coords),vec2(scale, scale));\", \"vec4 dist = vec4(0.0);\", \"float inorout = -4.0;\", \"dist.x = dot( P, HS0 );\", \"dist.y = dot( P, HS1 );\", \"dist.z = dot( P, HS2 );\", \"dist.w = dot( P, HS3 );\", \"dist = smoothstep( -feather, feather, dist );\", \"inorout += dot( dist, one );\", \"dist.x = dot( P, HS4 );\", \"dist.y = HS5.w - abs( P.z );\", \"dist = smoothstep( -feather, feather, dist );\", \"inorout += dist.x;\", \"return clamp( inorout, 0.0, 1.0 );\", \"}\", \"float bdepth(vec2 coords) {\", \"// Depth buffer blur\", \"float d = 0.0;\", \"float kernel[9];\", \"vec2 offset[9];\", \"vec2 wh = vec2(1.0/textureWidth,1.0/textureHeight) * dbsize;\", \"offset[0] = vec2(-wh.x,-wh.y);\", \"offset[1] = vec2( 0.0, -wh.y);\", \"offset[2] = vec2( wh.x -wh.y);\", \"offset[3] = vec2(-wh.x,  0.0);\", \"offset[4] = vec2( 0.0,   0.0);\", \"offset[5] = vec2( wh.x,  0.0);\", \"offset[6] = vec2(-wh.x, wh.y);\", \"offset[7] = vec2( 0.0,  wh.y);\", \"offset[8] = vec2( wh.x, wh.y);\", \"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\", \"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\", \"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\", \"for( int i=0; i<9; i++ ) {\", \"float tmp = getDepth( coords + offset[ i ] );\", \"d += tmp * kernel[i];\", \"}\", \"return d;\", \"}\", \"vec3 color(vec2 coords,float blur) {\", \"//processing the sample\", \"vec3 col = vec3(0.0);\", \"vec2 texel = vec2(1.0/textureWidth,1.0/textureHeight);\", \"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\", \"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\", \"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\", \"vec3 lumcoeff = vec3(0.299,0.587,0.114);\", \"float lum = dot(col.rgb, lumcoeff);\", \"float thresh = max((lum-threshold)*gain, 0.0);\", \"return col+mix(vec3(0.0),col,thresh*blur);\", \"}\", \"vec3 debugFocus(vec3 col, float blur, float depth) {\", \"float edge = 0.002*depth; //distance based edge smoothing\", \"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\", \"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\", \"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\", \"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\", \"return col;\", \"}\", \"float linearize(float depth) {\", \"return -zfar * znear / (depth * (zfar - znear) - zfar);\", \"}\", \"float vignette() {\", \"float dist = distance(vUv.xy, vec2(0.5,0.5));\", \"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\", \"return clamp(dist,0.0,1.0);\", \"}\", \"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\", \"float rings2 = float(rings);\", \"float step = PI*2.0 / float(ringsamples);\", \"float pw = cos(j*step)*i;\", \"float ph = sin(j*step)*i;\", \"float p = 1.0;\", \"if (pentagon) {\", \"p = penta(vec2(pw,ph));\", \"}\", \"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\", \"return 1.0 * mix(1.0, i /rings2, bias) * p;\", \"}\", \"void main() {\", \"//scene depth calculation\", \"float depth = linearize( getDepth( vUv.xy ) );\", \"// Blur depth?\", \"if (depthblur) {\", \"depth = linearize(bdepth(vUv.xy));\", \"}\", \"//focal plane calculation\", \"float fDepth = focalDepth;\", \"if (shaderFocus) {\", \"fDepth = linearize( getDepth( focusCoords ) );\", \"}\", \"// dof blur factor calculation\", \"float blur = 0.0;\", \"if (manualdof) {\", \"float a = depth-fDepth; // Focal plane\", \"float b = (a-fdofstart)/fdofdist; // Far DoF\", \"float c = (-a-ndofstart)/ndofdist; // Near Dof\", \"blur = (a>0.0) ? b : c;\", \"} else {\", \"float f = focalLength; // focal length in mm\", \"float d = fDepth*1000.0; // focal plane in mm\", \"float o = depth*1000.0; // depth in mm\", \"float a = (o*f)/(o-f);\", \"float b = (d*f)/(d-f);\", \"float c = (d-f)/(d*fstop*CoC);\", \"blur = abs(a-b)*c;\", \"}\", \"blur = clamp(blur,0.0,1.0);\", \"// calculation of pattern for dithering\", \"vec2 noise = vec2(rand(vUv.xy), rand( vUv.xy + vec2( 0.4, 0.6 ) ) )*dithering*blur;\", \"// getting blur x and y step factor\", \"float w = (1.0/textureWidth)*blur*maxblur+noise.x;\", \"float h = (1.0/textureHeight)*blur*maxblur+noise.y;\", \"// calculation of final color\", \"vec3 col = vec3(0.0);\", \"if(blur < 0.05) {\", \"//some optimization thingy\", \"col = texture2D(tColor, vUv.xy).rgb;\", \"} else {\", \"col = texture2D(tColor, vUv.xy).rgb;\", \"float s = 1.0;\", \"int ringsamples;\", \"for (int i = 1; i <= rings; i++) {\", \"/*unboxstart*/\", \"ringsamples = i * samples;\", \"for (int j = 0 ; j < maxringsamples ; j++) {\", \"if (j >= ringsamples) break;\", \"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\", \"}\", \"/*unboxend*/\", \"}\", \"col /= s; //divide by sample count\", \"}\", \"if (showFocus) {\", \"col = debugFocus(col, blur, depth);\", \"}\", \"if (vignetting) {\", \"col *= vignette();\", \"}\", \"gl_FragColor.rgb = col;\", \"gl_FragColor.a = 1.0;\", \"} \"].join(\"\\n\")\n\n};\n\nexports.default = BokehShader2;\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author tapio / http://tapio.github.com/\n *\n * Brightness and contrast adjustment\n * https://github.com/evanw/glfx.js\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nvar BrightnessContrastShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"brightness\": { value: 0 },\n\t\t\"contrast\": { value: 0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float brightness;\", \"uniform float contrast;\", \"varying vec2 vUv;\", \"void main() {\", \"gl_FragColor = texture2D( tDiffuse, vUv );\", \"gl_FragColor.rgb += brightness;\", \"if (contrast > 0.0) {\", \"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\", \"} else {\", \"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = BrightnessContrastShader;\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Color correction\n */\n\nvar ColorCorrectionShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"powRGB\": { value: new THREE.Vector3(2, 2, 2) },\n\t\t\"mulRGB\": { value: new THREE.Vector3(1, 1, 1) },\n\t\t\"addRGB\": { value: new THREE.Vector3(0, 0, 0) }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 powRGB;\", \"uniform vec3 mulRGB;\", \"uniform vec3 addRGB;\", \"varying vec2 vUv;\", \"void main() {\", \"gl_FragColor = texture2D( tDiffuse, vUv );\", \"gl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ColorCorrectionShader;\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Colorify shader\n */\n\nvar ColorifyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"color\": { value: new THREE.Color(0xffffff) }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform vec3 color;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"gl_FragColor = vec4( v * color, texel.w );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ColorifyShader;\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader using mipmaps\n * - from Matt Handley @applmak\n * - requires power-of-2 sized render target with enabled mipmaps\n */\n\nvar DOFMipMapShader = {\n\n\tuniforms: {\n\n\t\t\"tColor\": { value: null },\n\t\t\"tDepth\": { value: null },\n\t\t\"focus\": { value: 1.0 },\n\t\t\"maxblur\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float focus;\", \"uniform float maxblur;\", \"uniform sampler2D tColor;\", \"uniform sampler2D tDepth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 depth = texture2D( tDepth, vUv );\", \"float factor = depth.x - focus;\", \"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\", \"gl_FragColor = col;\", \"gl_FragColor.a = 1.0;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = DOFMipMapShader;\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Focus shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nvar FocusShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"screenWidth\": { value: 1024 },\n\t\t\"screenHeight\": { value: 1024 },\n\t\t\"sampleDistance\": { value: 0.94 },\n\t\t\"waveFactor\": { value: 0.00125 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float screenWidth;\", \"uniform float screenHeight;\", \"uniform float sampleDistance;\", \"uniform float waveFactor;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 color, org, tmp, add;\", \"float sample_dist, f;\", \"vec2 vin;\", \"vec2 uv = vUv;\", \"add = color = org = texture2D( tDiffuse, uv );\", \"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\", \"sample_dist = dot( vin, vin ) * 2.0;\", \"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\", \"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\", \"if( tmp.b < color.b ) color = tmp;\", \"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\", \"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\", \"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\", \"}\"].join(\"\\n\")\n};\n\nexports.default = FocusShader;\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n *\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nvar FreiChenShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"aspect\": { value: new THREE.Vector2(512, 512) }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"uniform vec2 aspect;\", \"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\", \"mat3 G[9];\",\n\n\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\", \"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\", \"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\", \"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\", \"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\", \"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\", \"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\", \"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\", \"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\", \"void main(void)\", \"{\", \"G[0] = g0,\", \"G[1] = g1,\", \"G[2] = g2,\", \"G[3] = g3,\", \"G[4] = g4,\", \"G[5] = g5,\", \"G[6] = g6,\", \"G[7] = g7,\", \"G[8] = g8;\", \"mat3 I;\", \"float cnv[9];\", \"vec3 sample;\",\n\n\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\"for (float i=0.0; i<3.0; i++) {\", \"for (float j=0.0; j<3.0; j++) {\", \"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\", \"I[int(i)][int(j)] = length(sample);\", \"}\", \"}\",\n\n\t/* calculate the convolution values for all the masks */\n\t\"for (int i=0; i<9; i++) {\", \"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\", \"cnv[i] = dp3 * dp3;\", \"}\", \"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\", \"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\", \"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\", \"}\"].join(\"\\n\")\n};\n\nexports.default = FreiChenShader;\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Based on Nvidia Cg tutorial\n */\n\nvar FresnelShader = {\n\n\tuniforms: {\n\n\t\t\"mRefractionRatio\": { value: 1.02 },\n\t\t\"mFresnelBias\": { value: 0.1 },\n\t\t\"mFresnelPower\": { value: 2.0 },\n\t\t\"mFresnelScale\": { value: 1.0 },\n\t\t\"tCube\": { value: null }\n\n\t},\n\n\tvertexShader: [\"uniform float mRefractionRatio;\", \"uniform float mFresnelBias;\", \"uniform float mFresnelScale;\", \"uniform float mFresnelPower;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\", \"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\", \"vec3 I = worldPosition.xyz - cameraPosition;\", \"vReflect = reflect( I, worldNormal );\", \"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\", \"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\", \"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\", \"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\", \"gl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform samplerCube tCube;\", \"varying vec3 vReflect;\", \"varying vec3 vRefract[3];\", \"varying float vReflectionFactor;\", \"void main() {\", \"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\", \"vec4 refractedColor = vec4( 1.0 );\", \"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\", \"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\", \"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\", \"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = FresnelShader;\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author davidedc / http://www.sketchpatch.net/\n *\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nvar FXAAShader = {\n\n  uniforms: {\n\n    \"tDiffuse\": { value: null },\n    \"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n  },\n\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n  fragmentShader: [\"precision highp float;\", \"\", \"uniform sampler2D tDiffuse;\", \"\", \"uniform vec2 resolution;\", \"\", \"varying vec2 vUv;\", \"\", \"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\", \"\", \"//----------------------------------------------------------------------------------\", \"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\", \"// SDK Version: v3.00\", \"// Email:       gameworks@nvidia.com\", \"// Site:        http://developer.nvidia.com/\", \"//\", \"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\", \"//\", \"// Redistribution and use in source and binary forms, with or without\", \"// modification, are permitted provided that the following conditions\", \"// are met:\", \"//  * Redistributions of source code must retain the above copyright\", \"//    notice, this list of conditions and the following disclaimer.\", \"//  * Redistributions in binary form must reproduce the above copyright\", \"//    notice, this list of conditions and the following disclaimer in the\", \"//    documentation and/or other materials provided with the distribution.\", \"//  * Neither the name of NVIDIA CORPORATION nor the names of its\", \"//    contributors may be used to endorse or promote products derived\", \"//    from this software without specific prior written permission.\", \"//\", \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\", \"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\", \"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\", \"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\", \"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\", \"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\", \"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\", \"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\", \"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\", \"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\", \"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\", \"//\", \"//----------------------------------------------------------------------------------\", \"\", \"#define FXAA_PC 1\", \"#define FXAA_GLSL_100 1\", \"#define FXAA_QUALITY_PRESET 12\", \"\", \"#define FXAA_GREEN_AS_LUMA 1\", \"\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_PC_CONSOLE\", \"    //\", \"    // The console algorithm for PC is included\", \"    // for developers targeting really low spec machines.\", \"    // Likely better to just run FXAA_PC, and use a really low preset.\", \"    //\", \"    #define FXAA_PC_CONSOLE 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_120\", \"    #define FXAA_GLSL_120 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_130\", \"    #define FXAA_GLSL_130 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_3\", \"    #define FXAA_HLSL_3 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_4\", \"    #define FXAA_HLSL_4 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_5\", \"    #define FXAA_HLSL_5 0\", \"#endif\", \"/*==========================================================================*/\", \"#ifndef FXAA_GREEN_AS_LUMA\", \"    //\", \"    // For those using non-linear color,\", \"    // and either not able to get luma in alpha, or not wanting to,\", \"    // this enables FXAA to run using green as a proxy for luma.\", \"    // So with this enabled, no need to pack luma in alpha.\", \"    //\", \"    // This will turn off AA on anything which lacks some amount of green.\", \"    // Pure red and blue or combination of only R and B, will get no AA.\", \"    //\", \"    // Might want to lower the settings for both,\", \"    //    fxaaConsoleEdgeThresholdMin\", \"    //    fxaaQualityEdgeThresholdMin\", \"    // In order to insure AA does not get turned off on colors\", \"    // which contain a minor amount of green.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_GREEN_AS_LUMA 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_EARLY_EXIT\", \"    //\", \"    // Controls algorithm's early exit path.\", \"    // On PS3 turning this ON adds 2 cycles to the shader.\", \"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\", \"    // Turning this off on console will result in a more blurry image.\", \"    // So this defaults to on.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_EARLY_EXIT 1\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_DISCARD\", \"    //\", \"    // Only valid for PC OpenGL currently.\", \"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\", \"    //\", \"    // 1 = Use discard on pixels which don't need AA.\", \"    //     For APIs which enable concurrent TEX+ROP from same surface.\", \"    // 0 = Return unchanged color on pixels which don't need AA.\", \"    //\", \"    #define FXAA_DISCARD 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_FAST_PIXEL_OFFSET\", \"    //\", \"    // Used for GLSL 120 only.\", \"    //\", \"    // 1 = GL API supports fast pixel offsets\", \"    // 0 = do not use fast pixel offsets\", \"    //\", \"    #ifdef GL_EXT_gpu_shader4\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifndef FXAA_FAST_PIXEL_OFFSET\", \"        #define FXAA_FAST_PIXEL_OFFSET 0\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GATHER4_ALPHA\", \"    //\", \"    // 1 = API supports gather4 on alpha channel.\", \"    // 0 = API does not support gather4 on alpha channel.\", \"    //\", \"    #if (FXAA_HLSL_5 == 1)\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifndef FXAA_GATHER4_ALPHA\", \"        #define FXAA_GATHER4_ALPHA 0\", \"    #endif\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                        FXAA QUALITY - TUNING KNOBS\", \"------------------------------------------------------------------------------\", \"NOTE the other tuning knobs are now in the shader function inputs!\", \"============================================================================*/\", \"#ifndef FXAA_QUALITY_PRESET\", \"    //\", \"    // Choose the quality preset.\", \"    // This needs to be compiled into the shader as it effects code.\", \"    // Best option to include multiple presets is to\", \"    // in each shader define the preset, then include this file.\", \"    //\", \"    // OPTIONS\", \"    // -----------------------------------------------------------------------\", \"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\", \"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\", \"    // 39       - no dither, very expensive\", \"    //\", \"    // NOTES\", \"    // -----------------------------------------------------------------------\", \"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\", \"    // 13 = about same speed as FXAA 3.9 and better than 12\", \"    // 23 = closest to FXAA 3.9 visually and performance wise\", \"    //  _ = the lowest digit is directly related to performance\", \"    // _  = the highest digit is directly related to style\", \"    //\", \"    #define FXAA_QUALITY_PRESET 12\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"\", \"                           FXAA QUALITY - PRESETS\", \"\", \"============================================================================*/\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - MEDIUM DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 10)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 3.0\", \"    #define FXAA_QUALITY_P2 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 11)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 3.0\", \"    #define FXAA_QUALITY_P3 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 12)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 4.0\", \"    #define FXAA_QUALITY_P4 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 13)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 4.0\", \"    #define FXAA_QUALITY_P5 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 14)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 4.0\", \"    #define FXAA_QUALITY_P6 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 15)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 12.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - LOW DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 20)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 2.0\", \"    #define FXAA_QUALITY_P2 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 21)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 22)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 23)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 24)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 3.0\", \"    #define FXAA_QUALITY_P6 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 25)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 26)\", \"    #define FXAA_QUALITY_PS 9\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 4.0\", \"    #define FXAA_QUALITY_P8 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 27)\", \"    #define FXAA_QUALITY_PS 10\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 4.0\", \"    #define FXAA_QUALITY_P9 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 28)\", \"    #define FXAA_QUALITY_PS 11\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 4.0\", \"    #define FXAA_QUALITY_P10 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 29)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - EXTREME QUALITY\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 39)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.0\", \"    #define FXAA_QUALITY_P2 1.0\", \"    #define FXAA_QUALITY_P3 1.0\", \"    #define FXAA_QUALITY_P4 1.0\", \"    #define FXAA_QUALITY_P5 1.5\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                                API PORTING\", \"\", \"============================================================================*/\", \"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard discard\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 vec2\", \"    #define FxaaFloat3 vec3\", \"    #define FxaaFloat4 vec4\", \"    #define FxaaHalf float\", \"    #define FxaaHalf2 vec2\", \"    #define FxaaHalf3 vec3\", \"    #define FxaaHalf4 vec4\", \"    #define FxaaInt2 ivec2\", \"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\", \"    #define FxaaTex sampler2D\", \"#else\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard clip(-1)\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 float2\", \"    #define FxaaFloat3 float3\", \"    #define FxaaFloat4 float4\", \"    #define FxaaHalf half\", \"    #define FxaaHalf2 half2\", \"    #define FxaaHalf3 half3\", \"    #define FxaaHalf4 half4\", \"    #define FxaaSat(x) saturate(x)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_100 == 1)\", \"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\", \"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_120 == 1)\", \"    // Requires,\", \"    //  #version 120\", \"    // And at least,\", \"    //  #extension GL_EXT_gpu_shader4 : enable\", \"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\", \"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\", \"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\", \"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\", \"    #else\", \"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\", \"    #endif\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_130 == 1)\", \"    // Requires \\\"#version 130\\\" or better\", \"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_3 == 1)\", \"    #define FxaaInt2 float2\", \"    #define FxaaTex sampler2D\", \"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\", \"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_4 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_5 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\", \"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\", \"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\", \"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\", \"============================================================================*/\", \"#if (FXAA_GREEN_AS_LUMA == 0)\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\", \"#else\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\", \"#endif\", \"\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                             FXAA3 QUALITY - PC\", \"\", \"============================================================================*/\", \"#if (FXAA_PC == 1)\", \"/*--------------------------------------------------------------------------*/\", \"FxaaFloat4 FxaaPixelShader(\", \"    //\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy} = center of pixel\", \"    FxaaFloat2 pos,\", \"    //\", \"    // Used only for FXAA Console, and not used on the 360 version.\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy_} = upper left of pixel\", \"    // {_zw} = lower right of pixel\", \"    FxaaFloat4 fxaaConsolePosPos,\", \"    //\", \"    // Input color texture.\", \"    // {rgb_} = color in linear or perceptual color space\", \"    // if (FXAA_GREEN_AS_LUMA == 0)\", \"    //     {__a} = luma in perceptual color space (not linear)\", \"    FxaaTex tex,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 2nd sampler.\", \"    // This sampler needs to have an exponent bias of -1.\", \"    FxaaTex fxaaConsole360TexExpBiasNegOne,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 3nd sampler.\", \"    // This sampler needs to have an exponent bias of -2.\", \"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This must be from a constant/uniform.\", \"    // {x_} = 1.0/screenWidthInPixels\", \"    // {_y} = 1.0/screenHeightInPixels\", \"    FxaaFloat2 fxaaQualityRcpFrame,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This must be from a constant/uniform.\", \"    // This effects sub-pixel AA quality and inversely sharpness.\", \"    //   Where N ranges between,\", \"    //     N = 0.50 (default)\", \"    //     N = 0.33 (sharper)\", \"    // {x__} = -N/screenWidthInPixels\", \"    // {_y_} = -N/screenHeightInPixels\", \"    // {_z_} =  N/screenWidthInPixels\", \"    // {__w} =  N/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Not used on 360, but used on PS3 and PC.\", \"    // This must be from a constant/uniform.\", \"    // {x__} = -2.0/screenWidthInPixels\", \"    // {_y_} = -2.0/screenHeightInPixels\", \"    // {_z_} =  2.0/screenWidthInPixels\", \"    // {__w} =  2.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\", \"    // This must be from a constant/uniform.\", \"    // {x__} =  8.0/screenWidthInPixels\", \"    // {_y_} =  8.0/screenHeightInPixels\", \"    // {_z_} = -4.0/screenWidthInPixels\", \"    // {__w} = -4.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_SUBPIX define.\", \"    // It is here now to allow easier tuning.\", \"    // Choose the amount of sub-pixel aliasing removal.\", \"    // This can effect sharpness.\", \"    //   1.00 - upper limit (softer)\", \"    //   0.75 - default amount of filtering\", \"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\", \"    //   0.25 - almost off\", \"    //   0.00 - completely off\", \"    FxaaFloat fxaaQualitySubpix,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // The minimum amount of local contrast required to apply algorithm.\", \"    //   0.333 - too little (faster)\", \"    //   0.250 - low quality\", \"    //   0.166 - default\", \"    //   0.125 - high quality\", \"    //   0.063 - overkill (slower)\", \"    FxaaFloat fxaaQualityEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\", \"    //   0.0625 - high quality (faster)\", \"    //   0.0312 - visible limit (slower)\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaQualityEdgeThresholdMin,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only three safe values here: 2 and 4 and 8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // For all other platforms can be a non-power of two.\", \"    //   8.0 is sharper (default!!!)\", \"    //   4.0 is softer\", \"    //   2.0 is really soft (good only for vector graphics inputs)\", \"    FxaaFloat fxaaConsoleEdgeSharpness,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only two safe values here: 1/4 and 1/8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // Other platforms can use other values.\", \"    //   0.125 leaves less aliasing, but is softer (default!!!)\", \"    //   0.25 leaves more aliasing, and is sharper\", \"    FxaaFloat fxaaConsoleEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // This only applies when FXAA_EARLY_EXIT is 1.\", \"    // This does not apply to PS3,\", \"    // PS3 was simplified to avoid more shader instructions.\", \"    //   0.06 - faster but more aliasing in darks\", \"    //   0.05 - default\", \"    //   0.04 - slower and less aliasing in darks\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaConsoleEdgeThresholdMin,\", \"    //\", \"    // Extra constants for 360 FXAA Console only.\", \"    // Use zeros or anything else for other platforms.\", \"    // These must be in physical constant registers and NOT immedates.\", \"    // Immedates will result in compiler un-optimizing.\", \"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\", \"    FxaaFloat4 fxaaConsole360ConstDir\", \") {\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posM;\", \"    posM.x = pos.x;\", \"    posM.y = pos.y;\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        #if (FXAA_DISCARD == 0)\", \"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"            #if (FXAA_GREEN_AS_LUMA == 0)\", \"                #define lumaM rgbyM.w\", \"            #else\", \"                #define lumaM rgbyM.y\", \"            #endif\", \"        #endif\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\", \"        #else\", \"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\", \"        #endif\", \"        #if (FXAA_DISCARD == 1)\", \"            #define lumaM luma4A.w\", \"        #endif\", \"        #define lumaE luma4A.z\", \"        #define lumaS luma4A.x\", \"        #define lumaSE luma4A.y\", \"        #define lumaNW luma4B.w\", \"        #define lumaN luma4B.z\", \"        #define lumaW luma4B.x\", \"    #else\", \"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            #define lumaM rgbyM.w\", \"        #else\", \"            #define lumaM rgbyM.y\", \"        #endif\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat maxSM = max(lumaS, lumaM);\", \"    FxaaFloat minSM = min(lumaS, lumaM);\", \"    FxaaFloat maxESM = max(lumaE, maxSM);\", \"    FxaaFloat minESM = min(lumaE, minSM);\", \"    FxaaFloat maxWN = max(lumaN, lumaW);\", \"    FxaaFloat minWN = min(lumaN, lumaW);\", \"    FxaaFloat rangeMax = max(maxWN, maxESM);\", \"    FxaaFloat rangeMin = min(minWN, minESM);\", \"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\", \"    FxaaFloat range = rangeMax - rangeMin;\", \"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\", \"    FxaaBool earlyExit = range < rangeMaxClamped;\", \"/*--------------------------------------------------------------------------*/\", \"    if(earlyExit)\", \"        #if (FXAA_DISCARD == 1)\", \"            FxaaDiscard;\", \"        #else\", \"            return rgbyM;\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_GATHER4_ALPHA == 0)\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #else\", \"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\", \"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNS = lumaN + lumaS;\", \"    FxaaFloat lumaWE = lumaW + lumaE;\", \"    FxaaFloat subpixRcpRange = 1.0/range;\", \"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\", \"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\", \"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNESE = lumaNE + lumaSE;\", \"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\", \"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\", \"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\", \"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\", \"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\", \"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\", \"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\", \"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\", \"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\", \"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\", \"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\", \"    FxaaBool horzSpan = edgeHorz >= edgeVert;\", \"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\", \"/*--------------------------------------------------------------------------*/\", \"    if(!horzSpan) lumaN = lumaW;\", \"    if(!horzSpan) lumaS = lumaE;\", \"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\", \"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat gradientN = lumaN - lumaM;\", \"    FxaaFloat gradientS = lumaS - lumaM;\", \"    FxaaFloat lumaNN = lumaN + lumaM;\", \"    FxaaFloat lumaSS = lumaS + lumaM;\", \"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\", \"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\", \"    if(pairN) lengthSign = -lengthSign;\", \"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posB;\", \"    posB.x = posM.x;\", \"    posB.y = posM.y;\", \"    FxaaFloat2 offNP;\", \"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\", \"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\", \"    if(!horzSpan) posB.x += lengthSign * 0.5;\", \"    if( horzSpan) posB.y += lengthSign * 0.5;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posN;\", \"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\", \"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat2 posP;\", \"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\", \"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\", \"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\", \"    FxaaFloat subpixE = subpixC * subpixC;\", \"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\", \"/*--------------------------------------------------------------------------*/\", \"    if(!pairN) lumaNN = lumaSS;\", \"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\", \"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\", \"    FxaaFloat subpixF = subpixD * subpixE;\", \"    FxaaBool lumaMLTZero = lumaMM < 0.0;\", \"/*--------------------------------------------------------------------------*/\", \"    lumaEndN -= lumaNN * 0.5;\", \"    lumaEndP -= lumaNN * 0.5;\", \"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\", \"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\", \"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\", \"    FxaaBool doneNP = (!doneN) || (!doneP);\", \"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\", \"/*--------------------------------------------------------------------------*/\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 3)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 4)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 5)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 6)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\", \"/*--------------------------------------------------------------------------*/\", \"                        #if (FXAA_QUALITY_PS > 7)\", \"                        if(doneNP) {\", \"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                            doneN = abs(lumaEndN) >= gradientScaled;\", \"                            doneP = abs(lumaEndP) >= gradientScaled;\", \"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\", \"                            doneNP = (!doneN) || (!doneP);\", \"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_QUALITY_PS > 8)\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 9)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 10)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 11)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 12)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                        }\", \"                        #endif\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat dstN = posM.x - posN.x;\", \"    FxaaFloat dstP = posP.x - posM.x;\", \"    if(!horzSpan) dstN = posM.y - posN.y;\", \"    if(!horzSpan) dstP = posP.y - posM.y;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLength = (dstP + dstN);\", \"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLengthRcp = 1.0/spanLength;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool directionN = dstN < dstP;\", \"    FxaaFloat dst = min(dstN, dstP);\", \"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\", \"    FxaaFloat subpixG = subpixF * subpixF;\", \"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\", \"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\", \"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\", \"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\", \"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\", \"    #if (FXAA_DISCARD == 1)\", \"        return FxaaTexTop(tex, posM);\", \"    #else\", \"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\", \"    #endif\", \"}\", \"/*==========================================================================*/\", \"#endif\", \"\", \"void main() {\", \"  gl_FragColor = FxaaPixelShader(\", \"    vUv,\", \"    vec4(0.0),\", \"    tDiffuse,\", \"    tDiffuse,\", \"    tDiffuse,\", \"    resolution,\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    0.75,\", \"    0.166,\", \"    0.0833,\", \"    0.0,\", \"    0.0,\", \"    0.0,\", \"    vec4(0.0)\", \"  );\", \"\", \"  // TODO avoid querying texture twice for same texel\", \"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = FXAAShader;\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * Gamma Correction Shader\n * http://en.wikipedia.org/wiki/gamma_correction\n */\n\nvar GammaCorrectionShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\", \"gl_FragColor = LinearToGamma( tex, float( GAMMA_FACTOR ) );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = GammaCorrectionShader;\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nvar HorizontalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"h\": { value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float h;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HorizontalBlurShader;\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nvar HorizontalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"h\": { value: 1.0 / 512.0 },\n\t\t\"r\": { value: 0.35 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float h;\", \"uniform float r;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"float hh = h * abs( r - vUv.y );\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HorizontalTiltShiftShader;\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author tapio / http://tapio.github.com/\n *\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nvar HueSaturationShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"hue\": { value: 0 },\n\t\t\"saturation\": { value: 0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float hue;\", \"uniform float saturation;\", \"varying vec2 vUv;\", \"void main() {\", \"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t// hue\n\t\"float angle = hue * 3.14159265;\", \"float s = sin(angle), c = cos(angle);\", \"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\", \"float len = length(gl_FragColor.rgb);\", \"gl_FragColor.rgb = vec3(\", \"dot(gl_FragColor.rgb, weights.xyz),\", \"dot(gl_FragColor.rgb, weights.zxy),\", \"dot(gl_FragColor.rgb, weights.yzx)\", \");\",\n\n\t// saturation\n\t\"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\", \"if (saturation > 0.0) {\", \"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\", \"} else {\", \"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\", \"}\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = HueSaturationShader;\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * Kaleidoscope Shader\n * Radial reflection around center point\n * Ported from: http://pixelshaders.com/editor/\n * by Toby Schachman / http://tobyschachman.com/\n *\n * sides: number of reflections\n * angle: initial angle in radians\n */\n\nvar KaleidoShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"sides\": { value: 6.0 },\n\t\t\"angle\": { value: 0.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float sides;\", \"uniform float angle;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 p = vUv - 0.5;\", \"float r = length(p);\", \"float a = atan(p.y, p.x) + angle;\", \"float tau = 2. * 3.1416 ;\", \"a = mod(a, tau/sides);\", \"a = abs(a - tau/sides/2.) ;\", \"p = r * vec2(cos(a), sin(a));\", \"vec4 color = texture2D(tDiffuse, p + 0.5);\", \"gl_FragColor = color;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = KaleidoShader;\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\n\nvar MirrorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"side\": { value: 1 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform int side;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 p = vUv;\", \"if (side == 0){\", \"if (p.x > 0.5) p.x = 1.0 - p.x;\", \"}else if (side == 1){\", \"if (p.x < 0.5) p.x = 1.0 - p.x;\", \"}else if (side == 2){\", \"if (p.y < 0.5) p.y = 1.0 - p.y;\", \"}else if (side == 3){\", \"if (p.y > 0.5) p.y = 1.0 - p.y;\", \"} \", \"vec4 color = texture2D(tDiffuse, p);\", \"gl_FragColor = color;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = MirrorShader;\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Normal map shader\n * - compute normals from heightmap\n */\n\nvar NormalMapShader = {\n\n\tuniforms: {\n\n\t\t\"heightMap\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2(512, 512) },\n\t\t\"scale\": { value: new THREE.Vector2(1, 1) },\n\t\t\"height\": { value: 0.05 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float height;\", \"uniform vec2 resolution;\", \"uniform sampler2D heightMap;\", \"varying vec2 vUv;\", \"void main() {\", \"float val = texture2D( heightMap, vUv ).x;\", \"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\", \"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\", \"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = NormalMapShader;\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// TODO to ES6\n\n// Author: Aleksandr Albert\n// Website: www.routter.co.tt\n\n// Description: A deep water ocean shader set\n// based on an implementation of a Tessendorf Waves\n// originally presented by David Li ( www.david.li/waves )\n\n// The general method is to apply shaders to simulation Framebuffers\n// and then sample these framebuffers when rendering the ocean mesh\n\n// The set uses 7 shaders:\n\n// -- Simulation shaders\n// [1] ocean_sim_vertex         -> Vertex shader used to set up a 2x2 simulation plane centered at (0,0)\n// [2] ocean_subtransform       -> Fragment shader used to subtransform the mesh (generates the displacement map)\n// [3] ocean_initial_spectrum   -> Fragment shader used to set intitial wave frequency at a texel coordinate\n// [4] ocean_phase              -> Fragment shader used to set wave phase at a texel coordinate\n// [5] ocean_spectrum           -> Fragment shader used to set current wave frequency at a texel coordinate\n// [6] ocean_normal             -> Fragment shader used to set face normals at a texel coordinate\n\n// -- Rendering Shader\n// [7] ocean_main               -> Vertex and Fragment shader used to create the final render\n\n\nTHREE.ShaderLib['ocean_sim_vertex'] = {\n\tvertexShader: ['varying vec2 vUV;', 'void main (void) {', 'vUV = position.xy * 0.5 + 0.5;', 'gl_Position = vec4(position, 1.0 );', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_subtransform'] = {\n\tuniforms: {\n\t\t\"u_input\": { value: null },\n\t\t\"u_transformSize\": { value: 512.0 },\n\t\t\"u_subtransformSize\": { value: 250.0 }\n\t},\n\tfragmentShader: [\n\t//GPU FFT using a Stockham formulation\n\n\t'precision highp float;', '#include <common>', 'uniform sampler2D u_input;', 'uniform float u_transformSize;', 'uniform float u_subtransformSize;', 'varying vec2 vUV;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'void main (void) {', '#ifdef HORIZONTAL', 'float index = vUV.x * u_transformSize - 0.5;', '#else', 'float index = vUV.y * u_transformSize - 0.5;', '#endif', 'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);',\n\n\t//transform two complex sequences simultaneously\n\t'#ifdef HORIZONTAL', 'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', '#else', 'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;', '#endif', 'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);', 'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));', 'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);', 'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);', 'gl_FragColor = vec4(outputA, outputB);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_initial_spectrum'] = {\n\tuniforms: {\n\t\t\"u_wind\": { value: new THREE.Vector2(10.0, 10.0) },\n\t\t\"u_resolution\": { value: 512.0 },\n\t\t\"u_size\": { value: 250.0 }\n\t},\n\tfragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'const float CM = 0.23;', 'uniform vec2 u_wind;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + pow2(k / KM)));', '}', 'float tanh (float x) {', 'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;', 'float k = length(K);', 'float l_wind = length(u_wind);', 'float Omega = 0.84;', 'float kp = G * pow2(Omega / l_wind);', 'float c = omega(k) / k;', 'float cp = omega(kp) / kp;', 'float Lpm = exp(-1.25 * pow2(kp / k));', 'float gamma = 1.7;', 'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));', 'float Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));', 'float Jp = pow(gamma, Gamma);', 'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));', 'float alphap = 0.006 * sqrt(Omega);', 'float Bl = 0.5 * alphap * cp / c * Fp;', 'float z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);', 'float uStar = 0.41 * l_wind / log(10.0 / z0);', 'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));', 'float Fm = exp(-0.25 * pow2(k / KM - 1.0));', 'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;', 'float a0 = log(2.0) / 4.0;', 'float am = 0.13 * uStar / CM;', 'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));', 'float cosPhi = dot(normalize(u_wind), normalize(K));', 'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));', 'float dk = 2.0 * PI / u_size;', 'float h = sqrt(S / 2.0) * dk;', 'if (K.x == 0.0 && K.y == 0.0) {', 'h = 0.0;', //no DC term\n\t'}', 'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_phase'] = {\n\tuniforms: {\n\t\t\"u_phases\": { value: null },\n\t\t\"u_deltaTime\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_size\": { value: null }\n\t},\n\tfragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform sampler2D u_phases;', 'uniform float u_deltaTime;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'float deltaTime = 1.0 / 60.0;', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'float deltaPhase = omega(length(waveVector)) * u_deltaTime;', 'phase = mod(phase + deltaPhase, 2.0 * PI);', 'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_spectrum'] = {\n\tuniforms: {\n\t\t\"u_size\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_choppiness\": { value: null },\n\t\t\"u_phases\": { value: null },\n\t\t\"u_initialSpectrum\": { value: null }\n\t},\n\tfragmentShader: ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform float u_size;', 'uniform float u_resolution;', 'uniform float u_choppiness;', 'uniform sampler2D u_phases;', 'uniform sampler2D u_initialSpectrum;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'vec2 multiplyByI (vec2 z) {', 'return vec2(-z[1], z[0]);', '}', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'vec2 phaseVector = vec2(cos(phase), sin(phase));', 'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;', 'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;', 'h0Star.y *= -1.0;', 'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));', 'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;', 'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;',\n\n\t//no DC term\n\t'if (waveVector.x == 0.0 && waveVector.y == 0.0) {', 'h = vec2(0.0);', 'hX = vec2(0.0);', 'hZ = vec2(0.0);', '}', 'gl_FragColor = vec4(hX + multiplyByI(h), hZ);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_normals'] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { value: null },\n\t\t\"u_resolution\": { value: null },\n\t\t\"u_size\": { value: null }\n\t},\n\tfragmentShader: ['precision highp float;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform float u_resolution;', 'uniform float u_size;', 'void main (void) {', 'float texel = 1.0 / u_resolution;', 'float texelSize = u_size / u_resolution;', 'vec3 center = texture2D(u_displacementMap, vUV).rgb;', 'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;', 'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;', 'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;', 'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;', 'vec3 topRight = cross(right, top);', 'vec3 topLeft = cross(top, left);', 'vec3 bottomLeft = cross(left, bottom);', 'vec3 bottomRight = cross(bottom, right);', 'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);', '}'].join('\\n')\n};\nTHREE.ShaderLib['ocean_main'] = {\n\tuniforms: {\n\t\t\"u_displacementMap\": { value: null },\n\t\t\"u_normalMap\": { value: null },\n\t\t\"u_geometrySize\": { value: null },\n\t\t\"u_size\": { value: null },\n\t\t\"u_projectionMatrix\": { value: null },\n\t\t\"u_viewMatrix\": { value: null },\n\t\t\"u_cameraPosition\": { value: null },\n\t\t\"u_skyColor\": { value: null },\n\t\t\"u_oceanColor\": { value: null },\n\t\t\"u_sunDirection\": { value: null },\n\t\t\"u_exposure\": { value: null }\n\t},\n\tvertexShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform mat4 u_projectionMatrix;', 'uniform mat4 u_viewMatrix;', 'uniform float u_size;', 'uniform float u_geometrySize;', 'uniform sampler2D u_displacementMap;', 'void main (void) {', 'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);', 'vPos = newPos;', 'vUV = uv;', 'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);', '}'].join('\\n'),\n\tfragmentShader: ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform sampler2D u_normalMap;', 'uniform vec3 u_cameraPosition;', 'uniform vec3 u_oceanColor;', 'uniform vec3 u_skyColor;', 'uniform vec3 u_sunDirection;', 'uniform float u_exposure;', 'vec3 hdr (vec3 color, float exposure) {', 'return 1.0 - exp(-color * exposure);', '}', 'void main (void) {', 'vec3 normal = texture2D(u_normalMap, vUV).rgb;', 'vec3 view = normalize(u_cameraPosition - vPos);', 'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);', 'vec3 sky = fresnel * u_skyColor;', 'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);', 'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;', 'vec3 color = sky + water;', 'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);', '}'].join('\\n')\n};\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\n\nvar ParallaxShader = {\n\t// Ordered from fastest to best quality.\n\tmodes: {\n\t\tnone: 'NO_PARALLAX',\n\t\tbasic: 'USE_BASIC_PARALLAX',\n\t\tsteep: 'USE_STEEP_PARALLAX',\n\t\tocclusion: 'USE_OCLUSION_PARALLAX', // a.k.a. POM\n\t\trelief: 'USE_RELIEF_PARALLAX'\n\t},\n\n\tuniforms: {\n\t\t\"bumpMap\": { value: null },\n\t\t\"map\": { value: null },\n\t\t\"parallaxScale\": { value: null },\n\t\t\"parallaxMinLayers\": { value: null },\n\t\t\"parallaxMaxLayers\": { value: null }\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"void main() {\", \"vUv = uv;\", \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\", \"vViewPosition = -mvPosition.xyz;\", \"vNormal = normalize( normalMatrix * normal );\", \"gl_Position = projectionMatrix * mvPosition;\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D bumpMap;\", \"uniform sampler2D map;\", \"uniform float parallaxScale;\", \"uniform float parallaxMinLayers;\", \"uniform float parallaxMaxLayers;\", \"varying vec2 vUv;\", \"varying vec3 vViewPosition;\", \"varying vec3 vNormal;\", \"#ifdef USE_BASIC_PARALLAX\", \"vec2 parallaxMap( in vec3 V ) {\", \"float initialHeight = texture2D( bumpMap, vUv ).r;\",\n\n\t// No Offset Limitting: messy, floating output at grazing angles.\n\t//\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n\n\t// Offset Limiting\n\t\"vec2 texCoordOffset = parallaxScale * V.xy * initialHeight;\", \"return vUv - texCoordOffset;\", \"}\", \"#else\", \"vec2 parallaxMap( in vec3 V ) {\",\n\n\t// Determine number of layers from angle between V and N\n\t\"float numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );\", \"float layerHeight = 1.0 / numLayers;\", \"float currentLayerHeight = 0.0;\",\n\t// Shift of texture coordinates for each iteration\n\t\"vec2 dtex = parallaxScale * V.xy / V.z / numLayers;\", \"vec2 currentTextureCoords = vUv;\", \"float heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\n\t// while ( heightFromTexture > currentLayerHeight )\n\t// Infinite loops are not well supported. Do a \"large\" finite\n\t// loop, but not too large, as it slows down some compilers.\n\t\"for ( int i = 0; i < 30; i += 1 ) {\", \"if ( heightFromTexture <= currentLayerHeight ) {\", \"break;\", \"}\", \"currentLayerHeight += layerHeight;\",\n\t// Shift texture coordinates along vector V\n\t\"currentTextureCoords -= dtex;\", \"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\", \"}\", \"#ifdef USE_STEEP_PARALLAX\", \"return currentTextureCoords;\", \"#elif defined( USE_RELIEF_PARALLAX )\", \"vec2 deltaTexCoord = dtex / 2.0;\", \"float deltaHeight = layerHeight / 2.0;\",\n\n\t// Return to the mid point of previous layer\n\t\"currentTextureCoords += deltaTexCoord;\", \"currentLayerHeight -= deltaHeight;\",\n\n\t// Binary search to increase precision of Steep Parallax Mapping\n\t\"const int numSearches = 5;\", \"for ( int i = 0; i < numSearches; i += 1 ) {\", \"deltaTexCoord /= 2.0;\", \"deltaHeight /= 2.0;\", \"heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;\",\n\t// Shift along or against vector V\n\t\"if( heightFromTexture > currentLayerHeight ) {\", // Below the surface\n\n\t\"currentTextureCoords -= deltaTexCoord;\", \"currentLayerHeight += deltaHeight;\", \"} else {\", // above the surface\n\n\t\"currentTextureCoords += deltaTexCoord;\", \"currentLayerHeight -= deltaHeight;\", \"}\", \"}\", \"return currentTextureCoords;\", \"#elif defined( USE_OCLUSION_PARALLAX )\", \"vec2 prevTCoords = currentTextureCoords + dtex;\",\n\n\t// Heights for linear interpolation\n\t\"float nextH = heightFromTexture - currentLayerHeight;\", \"float prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;\",\n\n\t// Proportions for linear interpolation\n\t\"float weight = nextH / ( nextH - prevH );\",\n\n\t// Interpolation of texture coordinates\n\t\"return prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );\", \"#else\", // NO_PARALLAX\n\n\t\"return vUv;\", \"#endif\", \"}\", \"#endif\", \"vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {\", \"vec2 texDx = dFdx( vUv );\", \"vec2 texDy = dFdy( vUv );\", \"vec3 vSigmaX = dFdx( surfPosition );\", \"vec3 vSigmaY = dFdy( surfPosition );\", \"vec3 vR1 = cross( vSigmaY, surfNormal );\", \"vec3 vR2 = cross( surfNormal, vSigmaX );\", \"float fDet = dot( vSigmaX, vR1 );\", \"vec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );\", \"vec3 vProjVtex;\", \"vProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;\", \"vProjVtex.z = dot( surfNormal, viewPosition );\", \"return parallaxMap( vProjVtex );\", \"}\", \"void main() {\", \"vec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );\", \"gl_FragColor = texture2D( map, mapUv );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = ParallaxShader;\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author wongbryan / http://wongbryan.github.io\n *\n * Pixelation shader\n */\n\nvar PixelShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: null },\n\t\t\"pixelSize\": { value: 1. }\n\n\t},\n\n\tvertexShader: [\"varying highp vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float pixelSize;\", \"uniform vec2 resolution;\", \"varying highp vec2 vUv;\", \"void main(){\", \"vec2 dxy = pixelSize / resolution;\", \"vec2 coord = dxy * floor( vUv / dxy );\", \"gl_FragColor = texture2D(tDiffuse, coord);\", \"}\"].join(\"\\n\")\n};\n\nexports.default = PixelShader;\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nvar RGBShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"amount\": { value: 0.005 },\n\t\t\"angle\": { value: 0.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float amount;\", \"uniform float angle;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 offset = amount * vec2( cos(angle), sin(angle));\", \"vec4 cr = texture2D(tDiffuse, vUv + offset);\", \"vec4 cga = texture2D(tDiffuse, vUv);\", \"vec4 cb = texture2D(tDiffuse, vUv - offset);\", \"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = RGBShiftShader;\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Sepia tone shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nvar SepiaShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"amount\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float amount;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 color = texture2D( tDiffuse, vUv );\", \"vec3 c = color.rgb;\", \"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\", \"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\", \"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\", \"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = SepiaShader;\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nvar SobelOperatorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec2 resolution;\", \"varying vec2 vUv;\", \"void main() {\", \"vec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\",\n\n\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\"const mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\", // x direction kernel\n\t\"const mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\", // y direction kernel\n\n\t// fetch the 3x3 neighbourhood of a fragment\n\n\t// first column\n\n\t\"float tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\", \"float tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\", \"float tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\",\n\n\t// second column\n\n\t\"float tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\", \"float tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\", \"float tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\",\n\n\t// third column\n\n\t\"float tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\", \"float tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\", \"float tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\",\n\n\t// gradient value in x direction\n\n\t\"float valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \", \"Gx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \", \"Gx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \",\n\n\t// gradient value in y direction\n\n\t\"float valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \", \"Gy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \", \"Gy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \",\n\n\t// magnitute of the total gradient\n\n\t\"float G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\", \"gl_FragColor = vec4( vec3( G ), 1 );\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = SobelOperatorShader;\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author flimshaw / http://charliehoey.com\n *\n * Technicolor Shader\n * Simulates the look of the two-strip technicolor process popular in early 20th century films.\n * More historical info here: http://www.widescreenmuseum.com/oldcolor/technicolor1.htm\n * Demo here: http://charliehoey.com/technicolor_shader/shader_test.html\n */\n\nvar TechnicolorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 tex = texture2D( tDiffuse, vec2( vUv.x, vUv.y ) );\", \"vec4 newTex = vec4(tex.r, (tex.g + tex.b) * .5, (tex.g + tex.b) * .5, 1.0);\", \"gl_FragColor = newTex;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = TechnicolorShader;\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _three = __webpack_require__(0);\n\nvar THREE = _interopRequireWildcard(_three);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nvar TriangleBlurShader = {\n\n\tuniforms: {\n\n\t\t\"texture\": { value: null },\n\t\t\"delta\": { value: new THREE.Vector2(1, 1) }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"#include <common>\", \"#define ITERATIONS 10.0\", \"uniform sampler2D texture;\", \"uniform vec2 delta;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 color = vec4( 0.0 );\", \"float total = 0.0;\",\n\n\t// randomize the lookup values to hide the fixed number of samples\n\n\t\"float offset = rand( vUv );\", \"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\", \"float percent = ( t + offset - 0.5 ) / ITERATIONS;\", \"float weight = 1.0 - abs( percent );\", \"color += texture2D( texture, vUv + delta * percent ) * weight;\", \"total += weight;\", \"}\", \"gl_FragColor = color / total;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = TriangleBlurShader;\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nvar VerticalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"v\": { value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float v;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = VerticalBlurShader;\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nvar VerticalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"v\": { value: 1.0 / 512.0 },\n\t\t\"r\": { value: 0.35 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform float v;\", \"uniform float r;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 sum = vec4( 0.0 );\", \"float vv = v * abs( r - vUv.y );\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\", \"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\", \"gl_FragColor = sum;\", \"}\"].join(\"\\n\")\n\n};\n\nexports.default = VerticalTiltShiftShader;\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Vignette shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nvar VignetteShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"offset\": { value: 1.0 },\n\t\t\"darkness\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\tfragmentShader: [\"uniform float offset;\", \"uniform float darkness;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\",\n\n\t// Eskil's vignette\n\n\t\"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\", \"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\",\n\n\t/*\n // alternative version from glfx.js\n // this one makes more \"dusty\" look (as opposed to \"burned\")\n \t\"vec4 color = texture2D( tDiffuse, vUv );\",\n \"float dist = distance( vUv, vec2( 0.5 ) );\",\n \"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\n \"gl_FragColor = color;\",\n */\n\n\t\"}\"].join(\"\\n\")\n\n};\n\nexports.default = VignetteShader;\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n */\n\nvar WaterRefractionShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\ttype: 'c',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'time': {\n\t\t\ttype: 'f',\n\t\t\tvalue: 0\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDudv': {\n\t\t\ttype: 't',\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\ttype: 'm4',\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: ['uniform mat4 textureMatrix;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'void main() {', '\tvUv = uv;', '\tvUvRefraction = textureMatrix * vec4( position, 1.0 );', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n\n\tfragmentShader: ['uniform vec3 color;', 'uniform float time;', 'uniform sampler2D tDiffuse;', 'uniform sampler2D tDudv;', 'varying vec2 vUv;', 'varying vec4 vUvRefraction;', 'float blendOverlay( float base, float blend ) {', '\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );', '}', 'vec3 blendOverlay( vec3 base, vec3 blend ) {', '\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ),blendOverlay( base.b, blend.b ) );', '}', 'void main() {', ' float waveStrength = 0.1;', ' float waveSpeed = 0.03;',\n\n\t// simple distortion (ripple) via dudv map (see https://www.youtube.com/watch?v=6B7IF6GOu7s)\n\n\t'\tvec2 distortedUv = texture2D( tDudv, vec2( vUv.x + time * waveSpeed, vUv.y ) ).rg * waveStrength;', '\tdistortedUv = vUv.xy + vec2( distortedUv.x, distortedUv.y + time * waveSpeed );', '\tvec2 distortion = ( texture2D( tDudv, distortedUv ).rg * 2.0 - 1.0 ) * waveStrength;',\n\n\t// new uv coords\n\n\t' vec4 uv = vec4( vUvRefraction );', ' uv.xy += distortion;', '\tvec4 base = texture2DProj( tDiffuse, uv );', '\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );', '}'].join('\\n')\n};\n\nexports.default = WaterRefractionShader;\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Volume = undefined;\n\nvar _Volume = __webpack_require__(10);\n\nvar _Volume2 = _interopRequireDefault(_Volume);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.Volume = _Volume2.default;\n\n/***/ })\n/******/ ])));\n\n//# sourceURL=webpack:///./node_modules/threejs-ext/dist/index.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/functions.js":
/*!**************************!*\
  !*** ./src/functions.js ***!
  \**************************/
/*! exports provided: DEFAULT_ROOT, loadTextureAsBase64, loadBlockState, loadTextureMeta, loadJsonFromPath, loadJsonFromPath_, scaleUv, trimCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_ROOT\", function() { return DEFAULT_ROOT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadTextureAsBase64\", function() { return loadTextureAsBase64; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadBlockState\", function() { return loadBlockState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadTextureMeta\", function() { return loadTextureMeta; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJsonFromPath\", function() { return loadJsonFromPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadJsonFromPath_\", function() { return loadJsonFromPath_; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleUv\", function() { return scaleUv; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"trimCanvas\", function() { return trimCanvas; });\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! debug */ \"./node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_0__);\n\r\nconst debug = debug__WEBPACK_IMPORTED_MODULE_0__(\"minerender\");\r\n\r\n/**\r\n * Default asset root\r\n * @type {string}\r\n */\r\nconst DEFAULT_ROOT = \"https://assets.mcasset.cloud/1.13\";\r\n/**\r\n * Texture cache\r\n * @type {Object.<string,string>}\r\n */\r\nconst textureCache = {};\r\n/**\r\n * Texture callbacks\r\n * @type {Object.<string,function[]>}\r\n */\r\nconst textureCallbacks = {};\r\n\r\n/**\r\n * Model cache\r\n * @type {Object.<string,string>}\r\n */\r\nconst modelCache = {};\r\n/**\r\n * Model callbacks\r\n * @type {Object.<string,function[]>}\r\n */\r\nconst modelCallbacks = {};\r\n\r\n\r\n/**\r\n * Loads a Mincraft texture an returns it as Base64\r\n *\r\n * @param {string} root Asset root, see {@link DEFAULT_ROOT}\r\n * @param {string} namespace Namespace, usually 'minecraft'\r\n * @param {string} dir Directory of the texture\r\n * @param {string} name Name of the texture\r\n * @returns {Promise<string>}\r\n */\r\nfunction loadTextureAsBase64(root, namespace, dir, name) {\r\n    return new Promise((resolve, reject) => {\r\n        loadTexture(root, namespace, dir, name, resolve, reject);\r\n    })\r\n};\r\n\r\n/**\r\n * Load a texture as base64 - shouldn't be used directly\r\n * @see loadTextureAsBase64\r\n * @ignore\r\n */\r\nfunction loadTexture(root, namespace, dir, name, resolve, reject, forceLoad) {\r\n    let path = \"/assets/\" + namespace + \"/textures\" + dir + name + \".png\";\r\n\r\n    if (textureCache.hasOwnProperty(path)) {\r\n        if (textureCache[path] === \"__invalid\") {\r\n            reject();\r\n            return;\r\n        }\r\n        resolve(textureCache[path]);\r\n        return;\r\n    }\r\n\r\n    if (!textureCallbacks.hasOwnProperty(path) || textureCallbacks[path].length === 0 || forceLoad) {\r\n        // https://gist.github.com/oliyh/db3d1a582aefe6d8fee9 / https://stackoverflow.com/questions/20035615/using-raw-image-data-from-ajax-request-for-data-uri\r\n        let xhr = new XMLHttpRequest();\r\n        xhr.open('GET', root + path, true);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.onloadend = function () {\r\n            if (xhr.status === 200) {\r\n                let arr = new Uint8Array(xhr.response || xhr.responseText);\r\n                let raw = String.fromCharCode.apply(null, arr);\r\n                let b64 = btoa(raw);\r\n                let dataURL = \"data:image/png;base64,\" + b64;\r\n\r\n                textureCache[path] = dataURL;\r\n\r\n                if (textureCallbacks.hasOwnProperty(path)) {\r\n                    while (textureCallbacks[path].length > 0) {\r\n                        let cb = textureCallbacks[path].shift(0);\r\n                        cb[0](dataURL);\r\n                    }\r\n                }\r\n            } else {\r\n                if (DEFAULT_ROOT === root) {\r\n                    textureCache[path] = \"__invalid\";\r\n\r\n                    if (textureCallbacks.hasOwnProperty(path)) {\r\n                        while (textureCallbacks[path].length > 0) {\r\n                            let cb = textureCallbacks[path].shift(0);\r\n                            cb[1]();\r\n                        }\r\n                    }\r\n                } else {\r\n                    loadTexture(DEFAULT_ROOT, namespace, dir, name, resolve, reject, true)\r\n                }\r\n            }\r\n        };\r\n        xhr.send();\r\n\r\n        // init array\r\n        if (!textureCallbacks.hasOwnProperty(path))\r\n            textureCallbacks[path] = [];\r\n    }\r\n\r\n    // add the promise callback\r\n    textureCallbacks[path].push([resolve, reject]);\r\n}\r\n\r\n\r\n/**\r\n * Loads a blockstate file and returns the contained JSON\r\n * @param {string} state Name of the blockstate\r\n * @param {string} assetRoot Asset root, see {@link DEFAULT_ROOT}\r\n * @returns {Promise<object>}\r\n */\r\nfunction loadBlockState(state, assetRoot) {\r\n    return loadJsonFromPath(assetRoot, \"/assets/minecraft/blockstates/\" + state + \".json\")\r\n};\r\n\r\nfunction loadTextureMeta(texture, assetRoot) {\r\n    return loadJsonFromPath(assetRoot, \"/assets/minecraft/textures/block/\" + texture + \".png.mcmeta\")\r\n}\r\n\r\n/**\r\n * Loads a model file and returns the contained JSON\r\n * @param {string} root Asset root, see {@link DEFAULT_ROOT}\r\n * @param {string} path Path to the model file\r\n * @returns {Promise<object>}\r\n */\r\nfunction loadJsonFromPath(root, path) {\r\n    return new Promise((resolve, reject) => {\r\n        loadJsonFromPath_(root, path, resolve, reject);\r\n    })\r\n}\r\n\r\n/**\r\n * Load a model - shouldn't used directly\r\n * @see loadJsonFromPath\r\n * @ignore\r\n */\r\nfunction loadJsonFromPath_(root, path, resolve, reject, forceLoad) {\r\n    if (modelCache.hasOwnProperty(path)) {\r\n        if (modelCache[path] === \"__invalid\") {\r\n            reject();\r\n            return;\r\n        }\r\n        resolve(Object.assign({}, modelCache[path]));\r\n        return;\r\n    }\r\n\r\n    if (!modelCallbacks.hasOwnProperty(path) || modelCallbacks[path].length === 0 || forceLoad) {\r\n        debug(root + path)\r\n        fetch(root + path, {\r\n            mode: \"cors\",\r\n            redirect: \"follow\"\r\n        })\r\n            .then(response => response.json())\r\n            .then(data => {\r\n                debug(\"json data:\", data);\r\n                modelCache[path] = data;\r\n\r\n                if (modelCallbacks.hasOwnProperty(path)) {\r\n                    while (modelCallbacks[path].length > 0) {\r\n                        let dataCopy = Object.assign({}, data);\r\n                        let cb = modelCallbacks[path].shift(0);\r\n                        cb[0](dataCopy);\r\n                    }\r\n                }\r\n            })\r\n            .catch((err) => {\r\n                console.warn(err);\r\n                if (DEFAULT_ROOT === root) {\r\n                    modelCache[path] = \"__invalid\";\r\n\r\n                    if (modelCallbacks.hasOwnProperty(path)) {\r\n                        while (modelCallbacks[path].length > 0) {\r\n                            let cb = modelCallbacks[path].shift(0);\r\n                            cb[1]();\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Try again with default root\r\n                    loadJsonFromPath_(DEFAULT_ROOT, path, resolve, reject, true);\r\n                }\r\n            });\r\n\r\n        if (!modelCallbacks.hasOwnProperty(path))\r\n            modelCallbacks[path] = [];\r\n    }\r\n\r\n    modelCallbacks[path].push([resolve, reject]);\r\n}\r\n\r\n/**\r\n * Scales UV values\r\n * @param {number} uv UV value\r\n * @param {number} size\r\n * @param {number} [scale=16]\r\n * @returns {number}\r\n */\r\nfunction scaleUv(uv, size, scale) {\r\n    if (uv === 0) return 0;\r\n    return size / (scale || 16) * uv;\r\n}\r\n\r\n\r\n// https://gist.github.com/remy/784508\r\nfunction trimCanvas(c) {\r\n    let ctx = c.getContext('2d'),\r\n        copy = document.createElement('canvas').getContext('2d'),\r\n        pixels = ctx.getImageData(0, 0, c.width, c.height),\r\n        l = pixels.data.length,\r\n        i,\r\n        bound = {\r\n            top: null,\r\n            left: null,\r\n            right: null,\r\n            bottom: null\r\n        },\r\n        x, y;\r\n\r\n    for (i = 0; i < l; i += 4) {\r\n        if (pixels.data[i + 3] !== 0) {\r\n            x = (i / 4) % c.width;\r\n            y = ~~((i / 4) / c.width);\r\n\r\n            if (bound.top === null) {\r\n                bound.top = y;\r\n            }\r\n\r\n            if (bound.left === null) {\r\n                bound.left = x;\r\n            } else if (x < bound.left) {\r\n                bound.left = x;\r\n            }\r\n\r\n            if (bound.right === null) {\r\n                bound.right = x;\r\n            } else if (bound.right < x) {\r\n                bound.right = x;\r\n            }\r\n\r\n            if (bound.bottom === null) {\r\n                bound.bottom = y;\r\n            } else if (bound.bottom < y) {\r\n                bound.bottom = y;\r\n            }\r\n        }\r\n    }\r\n\r\n    let trimHeight = bound.bottom - bound.top,\r\n        trimWidth = bound.right - bound.left,\r\n        trimmed = ctx.getImageData(bound.left, bound.top, trimWidth, trimHeight);\r\n\r\n    copy.canvas.width = trimWidth;\r\n    copy.canvas.height = trimHeight;\r\n    copy.putImageData(trimmed, 0, 0);\r\n\r\n    // open new window with trimmed image:\r\n    return copy.canvas;\r\n}\r\n\n\n//# sourceURL=webpack:///./src/functions.js?");

/***/ }),

/***/ "./src/lib/OrbitControls.js":
/*!**********************************!*\
  !*** ./src/lib/OrbitControls.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return OrbitControls; });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\n/**\r\n * @author qiao / https://github.com/qiao\r\n * @author mrdoob / http://mrdoob.com\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author erich666 / http://erichaines.com\r\n */\r\n\r\n// This set of controls performs orbiting, dollying (zooming), and panning.\r\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\r\n//\r\n//    Orbit - left mouse / touch: one finger move\r\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\r\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\r\n\r\nfunction OrbitControls( object, domElement ) {\r\n\r\n    this.object = object;\r\n\r\n    this.domElement = ( domElement !== undefined ) ? domElement : document;\r\n\r\n    // Set to false to disable this control\r\n    this.enabled = true;\r\n\r\n    // \"target\" sets the location of focus, where the object orbits around\r\n    this.target = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n    // How far you can dolly in and out ( PerspectiveCamera only )\r\n    this.minDistance = 0;\r\n    this.maxDistance = Infinity;\r\n\r\n    // How far you can zoom in and out ( OrthographicCamera only )\r\n    this.minZoom = 0;\r\n    this.maxZoom = Infinity;\r\n\r\n    // How far you can orbit vertically, upper and lower limits.\r\n    // Range is 0 to Math.PI radians.\r\n    this.minPolarAngle = 0; // radians\r\n    this.maxPolarAngle = Math.PI; // radians\r\n\r\n    // How far you can orbit horizontally, upper and lower limits.\r\n    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\r\n    this.minAzimuthAngle = - Infinity; // radians\r\n    this.maxAzimuthAngle = Infinity; // radians\r\n\r\n    // Set to true to enable damping (inertia)\r\n    // If damping is enabled, you must call controls.update() in your animation loop\r\n    this.enableDamping = false;\r\n    this.dampingFactor = 0.25;\r\n\r\n    // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\r\n    // Set to false to disable zooming\r\n    this.enableZoom = true;\r\n    this.zoomSpeed = 1.0;\r\n\r\n    // Set to false to disable rotating\r\n    this.enableRotate = true;\r\n    this.rotateSpeed = 1.0;\r\n\r\n    // Set to false to disable panning\r\n    this.enablePan = true;\r\n    this.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\r\n\r\n    // Set to true to automatically rotate around the target\r\n    // If auto-rotate is enabled, you must call controls.update() in your animation loop\r\n    this.autoRotate = false;\r\n    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\r\n\r\n    // Set to false to disable use of the keys\r\n    this.enableKeys = true;\r\n\r\n    // The four arrow keys\r\n    this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\r\n\r\n    // Mouse buttons\r\n    this.mouseButtons = { ORBIT: three__WEBPACK_IMPORTED_MODULE_0__[\"MOUSE\"].LEFT, ZOOM: three__WEBPACK_IMPORTED_MODULE_0__[\"MOUSE\"].MIDDLE, PAN: three__WEBPACK_IMPORTED_MODULE_0__[\"MOUSE\"].RIGHT };\r\n\r\n    // for reset\r\n    this.target0 = this.target.clone();\r\n    this.position0 = this.object.position.clone();\r\n    this.zoom0 = this.object.zoom;\r\n\r\n    //\r\n    // public methods\r\n    //\r\n\r\n    this.getPolarAngle = function () {\r\n\r\n        return spherical.phi;\r\n\r\n    };\r\n\r\n    this.getAzimuthalAngle = function () {\r\n\r\n        return spherical.theta;\r\n\r\n    };\r\n\r\n    this.saveState = function () {\r\n\r\n        scope.target0.copy( scope.target );\r\n        scope.position0.copy( scope.object.position );\r\n        scope.zoom0 = scope.object.zoom;\r\n\r\n    };\r\n\r\n    this.reset = function () {\r\n\r\n        scope.target.copy( scope.target0 );\r\n        scope.object.position.copy( scope.position0 );\r\n        scope.object.zoom = scope.zoom0;\r\n\r\n        scope.object.updateProjectionMatrix();\r\n        scope.dispatchEvent( changeEvent );\r\n\r\n        scope.update();\r\n\r\n        state = STATE.NONE;\r\n\r\n    };\r\n\r\n    // this method is exposed, but perhaps it would be better if we can make it private...\r\n    this.update = function () {\r\n\r\n        var offset = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        // so camera.up is the orbit axis\r\n        var quat = new three__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"]().setFromUnitVectors( object.up, new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]( 0, 1, 0 ) );\r\n        var quatInverse = quat.clone().inverse();\r\n\r\n        var lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n        var lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"]();\r\n\r\n        return function update() {\r\n\r\n            var position = scope.object.position;\r\n\r\n            offset.copy( position ).sub( scope.target );\r\n\r\n            // rotate offset to \"y-axis-is-up\" space\r\n            offset.applyQuaternion( quat );\r\n\r\n            // angle from z-axis around y-axis\r\n            spherical.setFromVector3( offset );\r\n\r\n            if ( scope.autoRotate && state === STATE.NONE ) {\r\n\r\n                rotateLeft( getAutoRotationAngle() );\r\n\r\n            }\r\n\r\n            spherical.theta += sphericalDelta.theta;\r\n            spherical.phi += sphericalDelta.phi;\r\n\r\n            // restrict theta to be between desired limits\r\n            spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\r\n\r\n            // restrict phi to be between desired limits\r\n            spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\r\n\r\n            spherical.makeSafe();\r\n\r\n\r\n            spherical.radius *= scale;\r\n\r\n            // restrict radius to be between desired limits\r\n            spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\r\n\r\n            // move target to panned location\r\n            scope.target.add( panOffset );\r\n\r\n            offset.setFromSpherical( spherical );\r\n\r\n            // rotate offset back to \"camera-up-vector-is-up\" space\r\n            offset.applyQuaternion( quatInverse );\r\n\r\n            position.copy( scope.target ).add( offset );\r\n\r\n            scope.object.lookAt( scope.target );\r\n\r\n            if ( scope.enableDamping === true ) {\r\n\r\n                sphericalDelta.theta *= ( 1 - scope.dampingFactor );\r\n                sphericalDelta.phi *= ( 1 - scope.dampingFactor );\r\n\r\n            } else {\r\n\r\n                sphericalDelta.set( 0, 0, 0 );\r\n\r\n            }\r\n\r\n            scale = 1;\r\n            panOffset.set( 0, 0, 0 );\r\n\r\n            // update condition is:\r\n            // min(camera displacement, camera rotation in radians)^2 > EPS\r\n            // using small-angle approximation cos(x/2) = 1 - x^2 / 8\r\n\r\n            if ( zoomChanged ||\r\n                lastPosition.distanceToSquared( scope.object.position ) > EPS ||\r\n                8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\r\n\r\n                scope.dispatchEvent( changeEvent );\r\n\r\n                lastPosition.copy( scope.object.position );\r\n                lastQuaternion.copy( scope.object.quaternion );\r\n                zoomChanged = false;\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n            return false;\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    this.dispose = function () {\r\n\r\n        scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\r\n        scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\r\n        scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\r\n\r\n        scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\r\n        scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\r\n        scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\r\n\r\n        document.removeEventListener( 'mousemove', onMouseMove, false );\r\n        document.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        window.removeEventListener( 'keydown', onKeyDown, false );\r\n\r\n        //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\r\n\r\n    };\r\n\r\n    //\r\n    // internals\r\n    //\r\n\r\n    var scope = this;\r\n\r\n    var changeEvent = { type: 'change' };\r\n    var startEvent = { type: 'start' };\r\n    var endEvent = { type: 'end' };\r\n\r\n    var STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\r\n\r\n    var state = STATE.NONE;\r\n\r\n    var EPS = 0.000001;\r\n\r\n    // current position in spherical coordinates\r\n    var spherical = new three__WEBPACK_IMPORTED_MODULE_0__[\"Spherical\"]();\r\n    var sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Spherical\"]();\r\n\r\n    var scale = 1;\r\n    var panOffset = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n    var zoomChanged = false;\r\n\r\n    var rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n\r\n    var panStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var panEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var panDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n\r\n    var dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n    var dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]();\r\n\r\n    function getAutoRotationAngle() {\r\n\r\n        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\r\n\r\n    }\r\n\r\n    function getZoomScale() {\r\n\r\n        return Math.pow( 0.95, scope.zoomSpeed );\r\n\r\n    }\r\n\r\n    function rotateLeft( angle ) {\r\n\r\n        sphericalDelta.theta -= angle;\r\n\r\n    }\r\n\r\n    function rotateUp( angle ) {\r\n\r\n        sphericalDelta.phi -= angle;\r\n\r\n    }\r\n\r\n    var panLeft = function () {\r\n\r\n        var v = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        return function panLeft( distance, objectMatrix ) {\r\n\r\n            v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\r\n            v.multiplyScalar( - distance );\r\n\r\n            panOffset.add( v );\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    var panUp = function () {\r\n\r\n        var v = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        return function panUp( distance, objectMatrix ) {\r\n\r\n            v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\r\n            v.multiplyScalar( distance );\r\n\r\n            panOffset.add( v );\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    // deltaX and deltaY are in pixels; right and down are positive\r\n    var pan = function () {\r\n\r\n        var offset = new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]();\r\n\r\n        return function pan( deltaX, deltaY ) {\r\n\r\n            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n            if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"] ) {\r\n\r\n                // perspective\r\n                var position = scope.object.position;\r\n                offset.copy( position ).sub( scope.target );\r\n                var targetDistance = offset.length();\r\n\r\n                // half of the fov is center to top of screen\r\n                targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\r\n\r\n                // we actually don't use screenWidth, since perspective camera is fixed to screen height\r\n                panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\r\n                panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\r\n\r\n            } else if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"] ) {\r\n\r\n                // orthographic\r\n                panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\r\n                panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\r\n\r\n            } else {\r\n\r\n                // camera neither orthographic nor perspective\r\n                console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\r\n                scope.enablePan = false;\r\n\r\n            }\r\n\r\n        };\r\n\r\n    }();\r\n\r\n    function dollyIn( dollyScale ) {\r\n\r\n        if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"] ) {\r\n\r\n            scale /= dollyScale;\r\n\r\n        } else if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"] ) {\r\n\r\n            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n\r\n        } else {\r\n\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n            scope.enableZoom = false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function dollyOut( dollyScale ) {\r\n\r\n        if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"PerspectiveCamera\"] ) {\r\n\r\n            scale *= dollyScale;\r\n\r\n        } else if ( scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__[\"OrthographicCamera\"] ) {\r\n\r\n            scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\r\n            scope.object.updateProjectionMatrix();\r\n            zoomChanged = true;\r\n\r\n        } else {\r\n\r\n            console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\r\n            scope.enableZoom = false;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //\r\n    // event callbacks - update the object state\r\n    //\r\n\r\n    function handleMouseDownRotate( event ) {\r\n\r\n        //console.log( 'handleMouseDownRotate' );\r\n\r\n        rotateStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseDownDolly( event ) {\r\n\r\n        //console.log( 'handleMouseDownDolly' );\r\n\r\n        dollyStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseDownPan( event ) {\r\n\r\n        //console.log( 'handleMouseDownPan' );\r\n\r\n        panStart.set( event.clientX, event.clientY );\r\n\r\n    }\r\n\r\n    function handleMouseMoveRotate( event ) {\r\n\r\n        //console.log( 'handleMouseMoveRotate' );\r\n\r\n        rotateEnd.set( event.clientX, event.clientY );\r\n        rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        // rotating across whole screen goes 360 degrees around\r\n        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n        rotateStart.copy( rotateEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseMoveDolly( event ) {\r\n\r\n        //console.log( 'handleMouseMoveDolly' );\r\n\r\n        dollyEnd.set( event.clientX, event.clientY );\r\n\r\n        dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n        if ( dollyDelta.y > 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        } else if ( dollyDelta.y < 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        }\r\n\r\n        dollyStart.copy( dollyEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseMovePan( event ) {\r\n\r\n        //console.log( 'handleMouseMovePan' );\r\n\r\n        panEnd.set( event.clientX, event.clientY );\r\n\r\n        panDelta.subVectors( panEnd, panStart );\r\n\r\n        pan( panDelta.x, panDelta.y );\r\n\r\n        panStart.copy( panEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleMouseUp( event ) {\r\n\r\n        // console.log( 'handleMouseUp' );\r\n\r\n    }\r\n\r\n    function handleMouseWheel( event ) {\r\n\r\n        // console.log( 'handleMouseWheel' );\r\n\r\n        if ( event.deltaY < 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        } else if ( event.deltaY > 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        }\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleKeyDown( event ) {\r\n\r\n        //console.log( 'handleKeyDown' );\r\n\r\n        switch ( event.keyCode ) {\r\n\r\n            case scope.keys.UP:\r\n                pan( 0, scope.keyPanSpeed );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.BOTTOM:\r\n                pan( 0, - scope.keyPanSpeed );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.LEFT:\r\n                pan( scope.keyPanSpeed, 0 );\r\n                scope.update();\r\n                break;\r\n\r\n            case scope.keys.RIGHT:\r\n                pan( - scope.keyPanSpeed, 0 );\r\n                scope.update();\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function handleTouchStartRotate( event ) {\r\n\r\n        //console.log( 'handleTouchStartRotate' );\r\n\r\n        rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n    }\r\n\r\n    function handleTouchStartDolly( event ) {\r\n\r\n        //console.log( 'handleTouchStartDolly' );\r\n\r\n        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        dollyStart.set( 0, distance );\r\n\r\n    }\r\n\r\n    function handleTouchStartPan( event ) {\r\n\r\n        //console.log( 'handleTouchStartPan' );\r\n\r\n        panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n    }\r\n\r\n    function handleTouchMoveRotate( event ) {\r\n\r\n        //console.log( 'handleTouchMoveRotate' );\r\n\r\n        rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n        rotateDelta.subVectors( rotateEnd, rotateStart );\r\n\r\n        var element = scope.domElement === document ? scope.domElement.body : scope.domElement;\r\n\r\n        // rotating across whole screen goes 360 degrees around\r\n        rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\r\n\r\n        // rotating up and down along whole screen attempts to go 360, but limited to 180\r\n        rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\r\n\r\n        rotateStart.copy( rotateEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchMoveDolly( event ) {\r\n\r\n        //console.log( 'handleTouchMoveDolly' );\r\n\r\n        var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\r\n        var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\r\n\r\n        var distance = Math.sqrt( dx * dx + dy * dy );\r\n\r\n        dollyEnd.set( 0, distance );\r\n\r\n        dollyDelta.subVectors( dollyEnd, dollyStart );\r\n\r\n        if ( dollyDelta.y > 0 ) {\r\n\r\n            dollyOut( getZoomScale() );\r\n\r\n        } else if ( dollyDelta.y < 0 ) {\r\n\r\n            dollyIn( getZoomScale() );\r\n\r\n        }\r\n\r\n        dollyStart.copy( dollyEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchMovePan( event ) {\r\n\r\n        //console.log( 'handleTouchMovePan' );\r\n\r\n        panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\r\n\r\n        panDelta.subVectors( panEnd, panStart );\r\n\r\n        pan( panDelta.x, panDelta.y );\r\n\r\n        panStart.copy( panEnd );\r\n\r\n        scope.update();\r\n\r\n    }\r\n\r\n    function handleTouchEnd( event ) {\r\n\r\n        //console.log( 'handleTouchEnd' );\r\n\r\n    }\r\n\r\n    //\r\n    // event handlers - FSM: listen for events and reset state\r\n    //\r\n\r\n    function onMouseDown( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        switch ( event.button ) {\r\n\r\n            case scope.mouseButtons.ORBIT:\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleMouseDownRotate( event );\r\n\r\n                state = STATE.ROTATE;\r\n\r\n                break;\r\n\r\n            case scope.mouseButtons.ZOOM:\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleMouseDownDolly( event );\r\n\r\n                state = STATE.DOLLY;\r\n\r\n                break;\r\n\r\n            case scope.mouseButtons.PAN:\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleMouseDownPan( event );\r\n\r\n                state = STATE.PAN;\r\n\r\n                break;\r\n\r\n        }\r\n\r\n        if ( state !== STATE.NONE ) {\r\n\r\n            document.addEventListener( 'mousemove', onMouseMove, false );\r\n            document.addEventListener( 'mouseup', onMouseUp, false );\r\n\r\n            scope.dispatchEvent( startEvent );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onMouseMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n        switch ( state ) {\r\n\r\n            case STATE.ROTATE:\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleMouseMoveRotate( event );\r\n\r\n                break;\r\n\r\n            case STATE.DOLLY:\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleMouseMoveDolly( event );\r\n\r\n                break;\r\n\r\n            case STATE.PAN:\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleMouseMovePan( event );\r\n\r\n                break;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onMouseUp( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        handleMouseUp( event );\r\n\r\n        document.removeEventListener( 'mousemove', onMouseMove, false );\r\n        document.removeEventListener( 'mouseup', onMouseUp, false );\r\n\r\n        scope.dispatchEvent( endEvent );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onMouseWheel( event ) {\r\n\r\n        if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        handleMouseWheel( event );\r\n\r\n        scope.dispatchEvent( startEvent ); // not sure why these are here...\r\n        scope.dispatchEvent( endEvent );\r\n\r\n    }\r\n\r\n    function onKeyDown( event ) {\r\n\r\n        if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\r\n\r\n        handleKeyDown( event );\r\n\r\n    }\r\n\r\n    function onTouchStart( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1:\t// one-fingered touch: rotate\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n\r\n                handleTouchStartRotate( event );\r\n\r\n                state = STATE.TOUCH_ROTATE;\r\n\r\n                break;\r\n\r\n            case 2:\t// two-fingered touch: dolly\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n\r\n                handleTouchStartDolly( event );\r\n\r\n                state = STATE.TOUCH_DOLLY;\r\n\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n\r\n                if ( scope.enablePan === false ) return;\r\n\r\n                handleTouchStartPan( event );\r\n\r\n                state = STATE.TOUCH_PAN;\r\n\r\n                break;\r\n\r\n            default:\r\n\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n        if ( state !== STATE.NONE ) {\r\n\r\n            scope.dispatchEvent( startEvent );\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onTouchMove( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n        event.stopPropagation();\r\n\r\n        switch ( event.touches.length ) {\r\n\r\n            case 1: // one-fingered touch: rotate\r\n\r\n                if ( scope.enableRotate === false ) return;\r\n                if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\r\n\r\n                handleTouchMoveRotate( event );\r\n\r\n                break;\r\n\r\n            case 2: // two-fingered touch: dolly\r\n\r\n                if ( scope.enableZoom === false ) return;\r\n                if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\r\n\r\n                handleTouchMoveDolly( event );\r\n\r\n                break;\r\n\r\n            case 3: // three-fingered touch: pan\r\n\r\n                if ( scope.enablePan === false ) return;\r\n                if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\r\n\r\n                handleTouchMovePan( event );\r\n\r\n                break;\r\n\r\n            default:\r\n\r\n                state = STATE.NONE;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    function onTouchEnd( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        handleTouchEnd( event );\r\n\r\n        scope.dispatchEvent( endEvent );\r\n\r\n        state = STATE.NONE;\r\n\r\n    }\r\n\r\n    function onContextMenu( event ) {\r\n\r\n        if ( scope.enabled === false ) return;\r\n\r\n        event.preventDefault();\r\n\r\n    }\r\n\r\n    //\r\n\r\n    scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\r\n\r\n    scope.domElement.addEventListener( 'mousedown', onMouseDown, false );\r\n    scope.domElement.addEventListener( 'wheel', onMouseWheel, false );\r\n\r\n    scope.domElement.addEventListener( 'touchstart', onTouchStart, false );\r\n    scope.domElement.addEventListener( 'touchend', onTouchEnd, false );\r\n    scope.domElement.addEventListener( 'touchmove', onTouchMove, false );\r\n\r\n    window.addEventListener( 'keydown', onKeyDown, false );\r\n\r\n    // force an update at start\r\n\r\n    this.update();\r\n\r\n};\r\n\r\nOrbitControls.prototype = Object.create( three__WEBPACK_IMPORTED_MODULE_0__[\"EventDispatcher\"].prototype );\r\nOrbitControls.prototype.constructor = OrbitControls;\r\n\r\nObject.defineProperties( OrbitControls.prototype, {\r\n\r\n    center: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .center has been renamed to .target' );\r\n            return this.target;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    // backward compatibility\r\n\r\n    noZoom: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n            return ! this.enableZoom;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\r\n            this.enableZoom = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noRotate: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n            return ! this.enableRotate;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\r\n            this.enableRotate = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noPan: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n            return ! this.enablePan;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\r\n            this.enablePan = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    noKeys: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n            return ! this.enableKeys;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\r\n            this.enableKeys = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    staticMoving: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n            return ! this.enableDamping;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\r\n            this.enableDamping = ! value;\r\n\r\n        }\r\n\r\n    },\r\n\r\n    dynamicDampingFactor: {\r\n\r\n        get: function () {\r\n\r\n            console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n            return this.dampingFactor;\r\n\r\n        },\r\n\r\n        set: function ( value ) {\r\n\r\n            console.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\r\n            this.dampingFactor = value;\r\n\r\n        }\r\n\r\n    }\r\n\r\n} );\n\n//# sourceURL=webpack:///./src/lib/OrbitControls.js?");

/***/ }),

/***/ "./src/renderBase.js":
/*!***************************!*\
  !*** ./src/renderBase.js ***!
  \***************************/
/*! exports provided: defaultOptions, default, deepDisposeMesh, mergeMeshes__, mergeCubeMeshes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultOptions\", function() { return defaultOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Render; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deepDisposeMesh\", function() { return deepDisposeMesh; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeMeshes__\", function() { return mergeMeshes__; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mergeCubeMeshes\", function() { return mergeCubeMeshes; });\n/* harmony import */ var _lib_OrbitControls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/OrbitControls */ \"./src/lib/OrbitControls.js\");\n/* harmony import */ var threejs_ext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! threejs-ext */ \"./node_modules/threejs-ext/dist/index.js\");\n/* harmony import */ var threejs_ext__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(threejs_ext__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @johh/three-effectcomposer */ \"./node_modules/@johh/three-effectcomposer/dist/index.js\");\n/* harmony import */ var _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var onscreen__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! onscreen */ \"./node_modules/onscreen/dist/on-screen.umd.js\");\n/* harmony import */ var onscreen__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(onscreen__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jquery */ \"jquery\");\n/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var stats_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stats.js */ \"./node_modules/stats.js/build/stats.min.js\");\n/* harmony import */ var stats_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(stats_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _functions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./functions */ \"./src/functions.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @property {boolean} showAxes                 Debugging - Show the scene's axes\r\n * @property {boolean} showOutlines             Debugging - Show bounding boxes\r\n * @property {boolean} showGrid                 Debugging - Show coordinate grid\r\n *\r\n * @property {object} controls                  Controls settings\r\n * @property {boolean} [controls.enabled=true]  Toggle controls\r\n * @property {boolean} [controls.zoom=true]     Toggle zoom\r\n * @property {boolean} [controls.rotate=true]   Toggle rotation\r\n * @property {boolean} [controls.pan=true]      Toggle panning\r\n *\r\n * @property {object} camera                    Camera settings\r\n * @property {string} [camera.type=perspective] Camera type\r\n * @property {number} camera.x                  Camera X-position\r\n * @property {number} camera.y                  Camera Y-Position\r\n * @property {number} camera.z                  Camera Z-Position\r\n * @property {number[]} camera.target           [x,y,z] array where the camera should look\r\n *\r\n * @property {number} frameRateLimit            Limit render calls to fps\r\n * @property {boolean} enableStats              Toggle stats.js info\r\n * @property {boolean} pauseHidden              Pause render elements which are not on screen\r\n */\r\nconst defaultOptions = {\r\n    showAxes: false,\r\n    showGrid: false,\r\n    autoResize: false,\r\n    controls: {\r\n        enabled: true,\r\n        zoom: true,\r\n        rotate: true,\r\n        pan: true,\r\n        keys: true\r\n    },\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 20,\r\n        y: 35,\r\n        z: 20,\r\n        target: [0, 0, 0]\r\n    },\r\n    canvas: {\r\n        width: undefined,\r\n        height: undefined\r\n    },\r\n    frameRateLimit: -1,\r\n    enableStats: false,\r\n    pauseHidden: true,\r\n    forceContext: false,\r\n    sendStats: true\r\n};\r\n\r\n/**\r\n * Base class for all Renders\r\n */\r\nclass Render {\r\n\r\n    /**\r\n     * @param {object} options The options for this renderer, see {@link defaultOptions}\r\n     * @param {object} defOptions Additional default options, provided by the individual renders\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, defOptions, element) {\r\n        /**\r\n         * DOM Element to attach the renderer to\r\n         * @type {HTMLElement}\r\n         */\r\n        this.element = element || document.body;\r\n        /**\r\n         * Combined options\r\n         * @type {{} & defaultOptions & defOptions & options}\r\n         */\r\n        this.options = Object.assign({}, defaultOptions, defOptions, options);\r\n\r\n        this.renderType = \"_Base_\";\r\n    }\r\n\r\n    /**\r\n     * @param {boolean} [trim=false] whether to trim transparent pixels\r\n     * @param {string} [mime=image/png] mime type of the image\r\n     * @returns {string} The content of the renderer's canvas as a Base64 encoded image\r\n     */\r\n    toImage(trim, mime) {\r\n        if (!mime) mime = \"image/png\";\r\n        if (this._renderer) {\r\n            if (!trim) {\r\n                return this._renderer.domElement.toDataURL(mime);\r\n            } else {\r\n                // Clone the canvas onto a 2d context, so we can trim it properly\r\n                let newCanvas = document.createElement('canvas');\r\n                let context = newCanvas.getContext('2d');\r\n\r\n                newCanvas.width = this._renderer.domElement.width;\r\n                newCanvas.height = this._renderer.domElement.height;\r\n\r\n                context.drawImage(this._renderer.domElement, 0, 0);\r\n\r\n                let trimmed = Object(_functions__WEBPACK_IMPORTED_MODULE_7__[\"trimCanvas\"])(newCanvas);\r\n                return trimmed.toDataURL(mime);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Export the current scene content in the .obj format (only geometries, no textures)\r\n     * @returns {string} the .obj file content\r\n     */\r\n    toObj() {\r\n        if (this._scene) {\r\n            let exporter = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"OBJExporter\"]();\r\n            return exporter.parse(this._scene);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Export the current scene content in the .gltf format (geometries + textures)\r\n     * @returns {Promise<any>} a promise which resolves with the .gltf file content\r\n     */\r\n    toGLTF(exportOptions) {\r\n        return new Promise((resolve, reject) => {\r\n            if (this._scene) {\r\n                let exporter = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"GLTFExporter\"]();\r\n                exporter.parse(this._scene, (gltf) => {\r\n                    resolve(gltf);\r\n                }, exportOptions)\r\n            } else {\r\n                reject();\r\n            }\r\n        })\r\n    }\r\n\r\n    toPLY(exportOptions) {\r\n        if (this._scene) {\r\n            let exporter = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"PLYExporter\"]();\r\n            return exporter.parse(this._scene, exportOptions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the scene\r\n     * @param renderCb\r\n     * @param doNotAnimate\r\n     * @protected\r\n     */\r\n    initScene(renderCb, doNotAnimate) {\r\n        let renderObj = this;\r\n\r\n        console.log(\" \");\r\n        console.log('%c       ', 'font-size: 100px; background: url(https://minerender.org/img/minerender.svg) no-repeat;');\r\n        console.log(\"MineRender/\" + (renderObj.renderType || renderObj.constructor.name) + \"/\" + \"1.4.11\");\r\n        console.log(( false ? undefined : \"DEVELOPMENT\") + \" build\");\r\n        console.log(\"Built @ \" + \"2021-02-20T09:28:50.532Z\");\r\n        console.log(\" \");\r\n\r\n        if (renderObj.options.sendStats) {\r\n            // Send stats\r\n\r\n            let iframe = false;\r\n            try {\r\n                iframe = window.self !== window.top;\r\n            } catch (e) {\r\n                return true;\r\n            }\r\n            let hostname;\r\n            try{\r\n                hostname = new URL(iframe ? document.referrer : window.location).hostname;\r\n            }catch (e) {\r\n                console.warn(\"Failed to get hostname\");\r\n            }\r\n\r\n            jquery__WEBPACK_IMPORTED_MODULE_5__[\"post\"]({\r\n                url: \"https://minerender.org/stats.php\",\r\n                data: {\r\n                    action: \"init\",\r\n                    type: renderObj.renderType,\r\n                    host: hostname,\r\n                    source: (iframe ? \"iframe\" : \"javascript\")\r\n                }\r\n            });\r\n        }\r\n\r\n        // Scene INIT\r\n        let scene = new three__WEBPACK_IMPORTED_MODULE_3__[\"Scene\"]();\r\n        renderObj._scene = scene;\r\n        let camera;\r\n        if (renderObj.options.camera.type === \"orthographic\") {\r\n            camera = new three__WEBPACK_IMPORTED_MODULE_3__[\"OrthographicCamera\"]((renderObj.options.canvas.width || window.innerWidth) / -2, (renderObj.options.canvas.width || window.innerWidth) / 2, (renderObj.options.canvas.height || window.innerHeight) / 2, (renderObj.options.canvas.height || window.innerHeight) / -2, 1, 1000);\r\n        } else {\r\n            camera = new three__WEBPACK_IMPORTED_MODULE_3__[\"PerspectiveCamera\"](75, (renderObj.options.canvas.width || window.innerWidth) / (renderObj.options.canvas.height || window.innerHeight), 5, 1000);\r\n        }\r\n        renderObj._camera = camera;\r\n\r\n        if (renderObj.options.camera.zoom) {\r\n            camera.zoom = renderObj.options.camera.zoom;\r\n        }\r\n\r\n        let renderer = new three__WEBPACK_IMPORTED_MODULE_3__[\"WebGLRenderer\"]({alpha: true, antialias: true, preserveDrawingBuffer: true});\r\n        renderObj._renderer = renderer;\r\n        renderer.setSize((renderObj.options.canvas.width || window.innerWidth), (renderObj.options.canvas.height || window.innerHeight));\r\n        renderer.setClearColor(0x000000, 0);\r\n        renderer.setPixelRatio(window.devicePixelRatio);\r\n        renderer.shadowMap.enabled = true;\r\n        renderer.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_3__[\"PCFSoftShadowMap\"];\r\n        renderObj.element.appendChild(renderObj._canvas = renderer.domElement);\r\n\r\n        let composer = new _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2___default.a(renderer);\r\n        composer.setSize((renderObj.options.canvas.width || window.innerWidth), (renderObj.options.canvas.height || window.innerHeight));\r\n        renderObj._composer = composer;\r\n        let ssaaRenderPass = new threejs_ext__WEBPACK_IMPORTED_MODULE_1__[\"SSAARenderPass\"](scene, camera);\r\n        ssaaRenderPass.unbiased = true;\r\n        composer.addPass(ssaaRenderPass);\r\n        // let renderPass = new RenderPass(scene, camera);\r\n        // renderPass.enabled = false;\r\n        // composer.addPass(renderPass);\r\n        let copyPass = new _johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__[\"ShaderPass\"](_johh_three_effectcomposer__WEBPACK_IMPORTED_MODULE_2__[\"CopyShader\"]);\r\n        copyPass.renderToScreen = true;\r\n        composer.addPass(copyPass);\r\n\r\n        if (renderObj.options.autoResize) {\r\n            renderObj._resizeListener = function () {\r\n                let width = (renderObj.element && renderObj.element !== document.body) ? renderObj.element.offsetWidth : window.innerWidth;\r\n                let height = (renderObj.element && renderObj.element !== document.body) ? renderObj.element.offsetHeight : window.innerHeight;\r\n\r\n                renderObj._resize(width, height);\r\n            };\r\n            window.addEventListener(\"resize\", renderObj._resizeListener);\r\n        }\r\n        renderObj._resize = function (width, height) {\r\n            if (renderObj.options.camera.type === \"orthographic\") {\r\n                camera.left = width / -2;\r\n                camera.right = width / 2;\r\n                camera.top = height / 2;\r\n                camera.bottom = height / -2;\r\n            } else {\r\n                camera.aspect = width / height;\r\n            }\r\n            camera.updateProjectionMatrix();\r\n\r\n            renderer.setSize(width, height);\r\n            composer.setSize(width, height);\r\n        };\r\n\r\n        // Helpers\r\n        if (renderObj.options.showAxes) {\r\n            scene.add(new three__WEBPACK_IMPORTED_MODULE_3__[\"AxesHelper\"](50));\r\n        }\r\n        if (renderObj.options.showGrid) {\r\n            scene.add(new three__WEBPACK_IMPORTED_MODULE_3__[\"GridHelper\"](100, 100));\r\n        }\r\n\r\n        let light = new three__WEBPACK_IMPORTED_MODULE_3__[\"AmbientLight\"](0xFFFFFF); // soft white light\r\n        scene.add(light);\r\n\r\n        // Init controls\r\n        let controls = new _lib_OrbitControls__WEBPACK_IMPORTED_MODULE_0__[\"default\"](camera, renderer.domElement);\r\n        renderObj._controls = controls;\r\n        controls.enableZoom = renderObj.options.controls.zoom;\r\n        controls.enableRotate = renderObj.options.controls.rotate;\r\n        controls.enablePan = renderObj.options.controls.pan;\r\n        controls.enableKeys = renderObj.options.controls.keys;\r\n        controls.target.set(renderObj.options.camera.target[0], renderObj.options.camera.target[1], renderObj.options.camera.target[2]);\r\n\r\n        // Set camera location & target\r\n        camera.position.x = renderObj.options.camera.x;\r\n        camera.position.y = renderObj.options.camera.y;\r\n        camera.position.z = renderObj.options.camera.z;\r\n        camera.lookAt(new three__WEBPACK_IMPORTED_MODULE_3__[\"Vector3\"](renderObj.options.camera.target[0], renderObj.options.camera.target[1], renderObj.options.camera.target[2]));\r\n\r\n        if (renderObj.options.enableStats) {\r\n            renderObj._stats = new stats_js__WEBPACK_IMPORTED_MODULE_6___default.a();\r\n            renderObj._stats.showPanel(0);\r\n            document.body.appendChild(renderObj._stats.dom);\r\n        }\r\n\r\n        let limitFps = false;\r\n        if (renderObj.options.frameRateLimit > 0) {\r\n            // based on https://stackoverflow.com/a/51942991/6257838\r\n            limitFps = true;\r\n            renderObj._clock = new three__WEBPACK_IMPORTED_MODULE_3__[\"Clock\"]();\r\n            renderObj._animDelta = 0;\r\n            renderObj._animInterval = 1.0 / renderObj.options.frameRateLimit;\r\n        }\r\n\r\n\r\n        // Do the render!\r\n        let animate = function () {\r\n            renderObj._animId = requestAnimationFrame(animate);\r\n\r\n            if (renderObj.options.enableStats) {\r\n                renderObj._stats.begin();\r\n            }\r\n\r\n            if (renderObj.options.pauseHidden && ((typeof document.visibilityState !== \"undefined\" && document.visibilityState !== \"visible\") || !renderObj.onScreen)) return;\r\n\r\n            if (limitFps) {\r\n                renderObj._animDelta += renderObj._clock.getDelta();\r\n                if (renderObj._animDelta <= renderObj._animInterval) return;\r\n            }\r\n\r\n            if (typeof renderCb === \"function\") {\r\n                renderCb();\r\n            }\r\n\r\n            composer.render();\r\n\r\n            if (limitFps) {\r\n                renderObj._animDelta = renderObj._animDelta % renderObj._animInterval;\r\n            }\r\n\r\n            if (renderObj.options.enableStats) {\r\n                renderObj._stats.end();\r\n            }\r\n\r\n        };\r\n        renderObj._animate = animate;\r\n\r\n        if (!doNotAnimate) {\r\n            animate();\r\n        }\r\n\r\n        renderObj.onScreen = true;// default to true, in case the checking is disabled\r\n        let id = \"minerender-canvas-\" + renderObj._scene.uuid + \"-\" + Date.now();\r\n        renderObj._canvas.id = id;\r\n        if (renderObj.options.pauseHidden) {\r\n            renderObj.onScreen = false;// set to false if the check is enabled\r\n            let os = new onscreen__WEBPACK_IMPORTED_MODULE_4___default.a();\r\n            renderObj._onScreenObserver = os;\r\n\r\n            os.on(\"enter\", \"#\" + id, (element, event) => {\r\n                renderObj.onScreen = true;\r\n                if (renderObj.options.forceContext) {\r\n                    renderObj._renderer.forceContextRestore();\r\n                }\r\n            })\r\n            os.on(\"leave\", \"#\" + id, (element, event) => {\r\n                renderObj.onScreen = false;\r\n                if (renderObj.options.forceContext) {\r\n                    renderObj._renderer.forceContextLoss();\r\n                }\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds an object to the scene & sets userData.renderType to this renderer's type\r\n     * @param toAdd object to add\r\n     */\r\n    addToScene(toAdd) {\r\n        let renderObj = this;\r\n        if (renderObj._scene && toAdd) {\r\n            toAdd.userData.renderType = renderObj.renderType;\r\n            renderObj._scene.add(toAdd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clears the scene\r\n     * @param onlySelfType whether to remove only objects whose type is equal to this renderer's type (useful for combined render)\r\n     * @param filterFn Filter function to check which children of the scene to remove\r\n     */\r\n    clearScene(onlySelfType, filterFn) {\r\n        if (onlySelfType || filterFn) {\r\n            for (let i = this._scene.children.length - 1; i >= 0; i--) {\r\n                let child = this._scene.children[i];\r\n                if (filterFn) {\r\n                    let shouldKeep = filterFn(child);\r\n                    if (shouldKeep) {\r\n                        continue;\r\n                    }\r\n                }\r\n                if (onlySelfType) {\r\n                    if (child.userData.renderType !== this.renderType) {\r\n                        continue;\r\n                    }\r\n                }\r\n                deepDisposeMesh(child, true);\r\n                this._scene.remove(child);\r\n            }\r\n        } else {\r\n            while (this._scene.children.length > 0) {\r\n                this._scene.remove(this._scene.children[0]);\r\n            }\r\n        }\r\n    };\r\n\r\n    dispose() {\r\n        cancelAnimationFrame(this._animId);\r\n        if (this._onScreenObserver) {\r\n            this._onScreenObserver.destroy();\r\n        }\r\n\r\n        this.clearScene();\r\n\r\n        this._canvas.remove();\r\n        let el = this.element;\r\n        while (el.firstChild) {\r\n            el.removeChild(el.firstChild);\r\n        }\r\n\r\n        if (this.options.autoResize) {\r\n            window.removeEventListener(\"resize\", this._resizeListener);\r\n        }\r\n\r\n        if (this._renderer) {\r\n            this._renderer.forceContextLoss();\r\n            this._renderer.dispose();\r\n            this._renderer.context = undefined;\r\n            this._renderer.domElement = undefined;\r\n        }\r\n    };\r\n\r\n}\r\n\r\n// https://stackoverflow.com/questions/27217388/use-multiple-materials-for-merged-geometries-in-three-js/44485364#44485364\r\nfunction deepDisposeMesh(obj, removeChildren) {\r\n    if (!obj) return;\r\n    if (obj.geometry && obj.geometry.dispose) obj.geometry.dispose();\r\n    if (obj.material && obj.material.dispose) obj.material.dispose();\r\n    if (obj.texture && obj.texture.dispose) obj.texture.dispose();\r\n    if (obj.children) {\r\n        let children = obj.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            deepDisposeMesh(children[i], removeChildren);\r\n        }\r\n\r\n        if (removeChildren) {\r\n            for (let i = obj.children.length - 1; i >= 0; i--) {\r\n                obj.remove(children[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction mergeMeshes__(meshes, toBufferGeometry) {\r\n    let finalGeometry,\r\n        materials = [],\r\n        mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_3__[\"Geometry\"](),\r\n        mergedMesh;\r\n\r\n    meshes.forEach(function (mesh, index) {\r\n        mesh.updateMatrix();\r\n        mesh.geometry.faces.forEach(function (face) {\r\n            face.materialIndex = 0;\r\n        });\r\n        mergedGeometry.merge(mesh.geometry, mesh.matrix, index);\r\n        materials.push(mesh.material);\r\n    });\r\n\r\n    mergedGeometry.groupsNeedUpdate = true;\r\n\r\n    if (toBufferGeometry) {\r\n        finalGeometry = new three__WEBPACK_IMPORTED_MODULE_3__[\"BufferGeometry\"]().fromGeometry(mergedGeometry);\r\n    } else {\r\n        finalGeometry = mergedGeometry;\r\n    }\r\n\r\n    mergedMesh = new three__WEBPACK_IMPORTED_MODULE_3__[\"Mesh\"](finalGeometry, materials);\r\n    mergedMesh.geometry.computeFaceNormals();\r\n    mergedMesh.geometry.computeVertexNormals();\r\n\r\n    return mergedMesh;\r\n\r\n}\r\n\r\nfunction mergeCubeMeshes(cubes, toBuffer) {\r\n    cubes = cubes.filter(c => !!c);\r\n\r\n    let mergedCubes = new three__WEBPACK_IMPORTED_MODULE_3__[\"Geometry\"]();\r\n    let mergedMaterials = [];\r\n    for (let i = 0; i < cubes.length; i++) {\r\n        let offset = i * Math.max(cubes[i].material.length, 1);\r\n        mergedCubes.merge(cubes[i].geometry, cubes[i].matrix, offset);\r\n        for (let j = 0; j < cubes[i].material.length; j++) {\r\n            mergedMaterials.push(cubes[i].material[j]);\r\n        }\r\n        // for (let j = 0; j < cubes[i].geometry.faces.length; j++) {\r\n        //     cubes[i].geometry.faces[j].materialIndex=offset-1+j;\r\n        // }\r\n\r\n        deepDisposeMesh(cubes[i], true);\r\n    }\r\n    mergedCubes.mergeVertices();\r\n    return {\r\n        geometry: toBuffer ? new three__WEBPACK_IMPORTED_MODULE_3__[\"BufferGeometry\"]().fromGeometry(mergedCubes) : mergedCubes,\r\n        materials: mergedMaterials\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./src/renderBase.js?");

/***/ }),

/***/ "./src/skin/index.js":
/*!***************************!*\
  !*** ./src/skin/index.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"three\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(three__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _texturePositions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texturePositions */ \"./src/skin/texturePositions.js\");\n/* harmony import */ var _renderBase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderBase */ \"./src/renderBase.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @see defaultOptions\r\n */\r\nlet defOptions = {\r\n    camera: {\r\n        type: \"perspective\",\r\n        x: 20,\r\n        y: 35,\r\n        z: 20,\r\n        target: [0, 18, 0]\r\n    },\r\n    makeNonTransparentOpaque: true\r\n};\r\n\r\n/**\r\n * A renderer for Minecraft player models/skins\r\n */\r\nclass SkinRender extends _renderBase__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\r\n\r\n    /**\r\n     * @param {Object} [options] The options for this renderer, see {@link defaultOptions}\r\n     * @param {HTMLElement} [element=document.body] DOM Element to attach the renderer to - defaults to document.body\r\n     * @constructor\r\n     */\r\n    constructor(options, element) {\r\n        super(options, defOptions, element);\r\n\r\n        this.renderType = \"SkinRender\";\r\n        this._animId = -1;\r\n\r\n        // bind this renderer to the element\r\n        this.element.skinRender = this;\r\n        this.attached = false;\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * Does the actual rendering\r\n     *\r\n     * @param {(string|Object)} texture The texture to render - May be a string with the playername/URL/Base64 or an Object\r\n     * @param {string} texture.url URL to the texture image\r\n     * @param {string} texture.data Base64 encoded image data of the texture\r\n     * @param {string} texture.username Player username\r\n     * @param {string} texture.uuid Player UUID\r\n     * @param {number} texture.mineskin ID of a MineSkin.org skin\r\n     * @param {boolean} [texture.slim=false] Whether the provided texture uses the slim skin format\r\n     *\r\n     * @param {string} [texture.cape=latest] Cape to render using capes.dev - Either a direct link to the cape data (api.capes.dev/get/...) OR a specific cape type\r\n     * @param {string} [texture.capeUser] Specify this to use a different user for the cape texture than the skin\r\n     * @param {string} [texture.capeUrl] URL to a cape texture\r\n     * @param {string} [texture.capeData] Base64 encoded image data of the cape texture\r\n     * @param {string} [texture.mineskin] deprecated; ID of a MineSkin.org skin with a cape\r\n     * @param {boolean} [texture.optifine=false] deprecated; Whether the provided cape texture is an optifine cape\r\n     *\r\n     * @param {function} [cb] Callback when rendering finished\r\n     */\r\n    render(texture, cb) {\r\n        let skinRender = this;\r\n\r\n        let renderStarted = false;\r\n\r\n        let imagesLoaded = (skinTexture, capeTexture) => {\r\n            renderStarted = true;\r\n            skinTexture.needsUpdate = true;\r\n            if (capeTexture) capeTexture.needsUpdate = true;\r\n\r\n            let textureVersion = -1;\r\n            if (skinTexture.image.height === 32) {\r\n                textureVersion = 0;\r\n            } else if (skinTexture.image.height === 64) {\r\n                textureVersion = 1;\r\n            } else {\r\n                console.error(\"Couldn't detect texture version. Invalid dimensions: \" + skinTexture.image.width + \"x\" + skinTexture.image.height)\r\n            }\r\n            console.log(\"Skin Texture Version: \" + textureVersion)\r\n\r\n            // To keep the pixelated texture\r\n            skinTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n            skinTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n            skinTexture.anisotropy = 0;\r\n            if (capeTexture) {\r\n                capeTexture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                capeTexture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__[\"NearestFilter\"];\r\n                capeTexture.anisotropy = 0;\r\n                capeTexture.format = three__WEBPACK_IMPORTED_MODULE_0__[\"RGBFormat\"]; // no transparency\r\n            }\r\n\r\n            if (skinTexture.image.height === 32) {\r\n                skinTexture.format = three__WEBPACK_IMPORTED_MODULE_0__[\"RGBFormat\"]; // 64x32 don't have transparency\r\n            }\r\n\r\n            if (!skinRender.attached && !skinRender._scene) {// Don't init scene if attached, since we already have an available scene\r\n                super.initScene(function () {\r\n                    skinRender.element.dispatchEvent(new CustomEvent(\"skinRender\", {detail: {playerModel: skinRender.playerModel}}));\r\n                });\r\n            } else {\r\n                console.log(\"[SkinRender] is attached - skipping scene init\");\r\n            }\r\n\r\n            console.log(\"Slim: \" + slim)\r\n            let playerModel = createPlayerModel(skinTexture, capeTexture, textureVersion, slim, texture._capeType ? texture._capeType : texture.optifine ? \"optifine\" : \"minecraft\");\r\n            skinRender.addToScene(playerModel);\r\n            // console.log(playerModel);\r\n            skinRender.playerModel = playerModel;\r\n\r\n            if (typeof cb === \"function\") cb();\r\n        }\r\n\r\n        skinRender._skinImage = new Image();\r\n        skinRender._skinImage.crossOrigin = \"anonymous\";\r\n        skinRender._capeImage = new Image();\r\n        skinRender._capeImage.crossOrigin = \"anonymous\";\r\n        let hasCape = texture.cape !== undefined || texture.capeUrl !== undefined || texture.capeData !== undefined || texture.mineskin !== undefined;\r\n        let slim = false;\r\n        let skinLoaded = false;\r\n        let capeLoaded = false;\r\n\r\n        let skinTexture = new three__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"]();\r\n        let capeTexture = new three__WEBPACK_IMPORTED_MODULE_0__[\"Texture\"]();\r\n        skinTexture.image = skinRender._skinImage;\r\n        skinRender._skinImage.onload = function () {\r\n            if (!skinRender._skinImage) return;\r\n\r\n            skinLoaded = true;\r\n            console.log(\"Skin Image Loaded\");\r\n\r\n            if (texture.slim === undefined) {\r\n                if (skinRender._skinImage.height !== 32) {\r\n\r\n                    let detectCanvas = document.createElement(\"canvas\");\r\n                    let detectCtx = detectCanvas.getContext(\"2d\");\r\n                    // detectCanvas.style.display = \"none\";\r\n                    detectCanvas.width = skinRender._skinImage.width;\r\n                    detectCanvas.height = skinRender._skinImage.height;\r\n                    detectCtx.drawImage(skinRender._skinImage, 0, 0);\r\n\r\n                    console.log(\"Slim Detection:\")\r\n\r\n                    // Check the 2 columns that should be transparent on slim skins\r\n                    let px1 = detectCtx.getImageData(46, 52, 1, 12).data;\r\n                    let px2 = detectCtx.getImageData(54, 20, 1, 12).data;\r\n                    let allTransparent = true;\r\n                    for (let i = 3; i < 12 * 4; i += 4) {\r\n                        if (px1[i] === 255) {\r\n                            allTransparent = false;\r\n                            break;\r\n                        }\r\n                        if (px2[i] === 255) {\r\n                            allTransparent = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    console.log(allTransparent)\r\n\r\n                    if (allTransparent) slim = true;\r\n                }\r\n            }\r\n\r\n            if (skinRender.options.makeNonTransparentOpaque && skinRender._skinImage.height !== 32) { // 64x32 don't have transparency\r\n                let sourceCanvas = document.createElement(\"canvas\");\r\n                let sourceContext = sourceCanvas.getContext(\"2d\");\r\n                sourceCanvas.width = skinRender._skinImage.width;\r\n                sourceCanvas.height = skinRender._skinImage.height;\r\n                // draw skin texture\r\n                sourceContext.drawImage(skinRender._skinImage, 0, 0);\r\n\r\n                // remove partial transparency\r\n                let opaqueCanvas = document.createElement(\"canvas\");\r\n                let opaqueContext = opaqueCanvas.getContext(\"2d\");\r\n                opaqueCanvas.width = skinRender._skinImage.width;\r\n                opaqueCanvas.height = skinRender._skinImage.height;\r\n\r\n                let imageData = sourceContext.getImageData(0, 0, sourceCanvas.width, sourceCanvas.height);\r\n                let pixels = imageData.data;\r\n\r\n                function removeTransparency(x, y) {\r\n                    if (x > 0 && y > 0 && x < 32 && y < 32) return true; // top left, face + right leg + half of body\r\n                    if (x > 32 && y > 16 && x < 32 + 32 && y < 16 + 16) return true;// mid right, other body half + right arm\r\n                    if (x > 16 && y > 48 && x < 16 + 32 && y < 48 + 16) return true;// bottom mid, left leg + left arm\r\n                    return false;\r\n                }\r\n\r\n                // check every pixel for transparency\r\n                for (let i = 0; i < pixels.length; i += 4) {\r\n                    let a = pixels[i + 3];\r\n                    let x = (i / 4) % sourceCanvas.width;\r\n                    let y = Math.floor((i / 4) / sourceCanvas.width);\r\n                    if (a > 178 || removeTransparency(x, y)) { // alpha over threshold OR area not supposed to have transparency at all\r\n                        pixels[i + 3] = 255; // max the alpha\r\n                    }\r\n                }\r\n\r\n                // update destination canvas\r\n                opaqueContext.putImageData(imageData, 0, 0);\r\n\r\n                console.log(opaqueCanvas.toDataURL())\r\n\r\n                skinTexture = new three__WEBPACK_IMPORTED_MODULE_0__[\"CanvasTexture\"](opaqueCanvas);\r\n            }\r\n\r\n            if (skinLoaded && (capeLoaded || !hasCape)) {\r\n                if (!renderStarted) imagesLoaded(skinTexture, capeTexture);\r\n            }\r\n        };\r\n        skinRender._skinImage.onerror = function (e) {\r\n            console.warn(\"Skin Image Error\")\r\n            console.warn(e)\r\n        }\r\n        console.log(\"Has Cape: \" + hasCape)\r\n        if (hasCape) {\r\n            capeTexture.image = skinRender._capeImage;\r\n            skinRender._capeImage.onload = function () {\r\n                if (!skinRender._capeImage) return;\r\n\r\n                capeLoaded = true;\r\n                console.log(\"Cape Image Loaded\");\r\n\r\n                if (capeLoaded && skinLoaded) {\r\n                    if (!renderStarted) imagesLoaded(skinTexture, capeTexture);\r\n                }\r\n            }\r\n            skinRender._capeImage.onerror = function (e) {\r\n                console.warn(\"Cape Image Error\")\r\n                console.warn(e);\r\n\r\n                // Continue anyway, just without the cape\r\n                capeLoaded = true;\r\n                if (skinLoaded) {\r\n                    if (!renderStarted) imagesLoaded(skinTexture);\r\n                }\r\n            }\r\n        } else {\r\n            capeTexture = null;\r\n            skinRender._capeImage = null;\r\n        }\r\n\r\n        if (typeof texture === \"string\") {\r\n            // console.log(texture)\r\n            if (texture.indexOf(\"http\") === 0) {// URL\r\n                skinRender._skinImage.src = texture\r\n            } else if (texture.length <= 16) {// Probably a Minecraft username\r\n                getJSON(\"https://minerender.org/nameToUuid.php?name=\" + texture, function (err, data) {\r\n                    if (err) return console.log(err);\r\n                    console.log(data);\r\n                    skinRender._skinImage.src = \"https://crafatar.com/skins/\" + (data.id ? data.id : texture);\r\n                });\r\n            } else if (texture.length <= 36) {// Probably player UUID\r\n                image.src = \"https://crafatar.com/skins/\" + texture + \"?overlay\";\r\n            } else {// taking a guess that it's a Base64 image\r\n                skinRender._skinImage.src = texture;\r\n            }\r\n        } else if (typeof texture === \"object\") {\r\n            if (texture.url) {\r\n                skinRender._skinImage.src = texture.url;\r\n            } else if (texture.data) {\r\n                skinRender._skinImage.src = texture.data;\r\n            } else if (texture.username) {\r\n                getJSON(\"https://minerender.org/nameToUuid.php?name=\" + texture.username, function (err, data) {\r\n                    if (err) return console.log(err);\r\n                    skinRender._skinImage.src = \"https://crafatar.com/skins/\" + (data.id ? data.id : texture.username) + \"?overlay\";\r\n                });\r\n            } else if (texture.uuid) {\r\n                skinRender._skinImage.src = \"https://crafatar.com/skins/\" + texture.uuid + \"?overlay\";\r\n            } else if (texture.mineskin) {\r\n                skinRender._skinImage.src = \"https://api.mineskin.org/render/texture/\" + texture.mineskin;\r\n            }\r\n            if (texture.cape) {\r\n                if (texture.cape.length > 36) { // Likely either a cape ID or URL\r\n                    let capeDataUrl = texture.cape.startsWith(\"http\") ? texture.cape : \"https://api.capes.dev/get/\" + texture.cape;\r\n                    getJSON(capeDataUrl, function (err, data) {\r\n                        if (err) return console.log(err);\r\n                        if (data.exists) {\r\n                            texture._capeType = data.type;\r\n                            skinRender._capeImage.src = data.imageUrls.base.full;\r\n                        }\r\n                    })\r\n                } else { // Type\r\n                    let capeLoadUrl = \"https://api.capes.dev/load/\";\r\n                    if (texture.capeUser) {// Try to find a player to use\r\n                        capeLoadUrl += texture.capeUser;\r\n                    } else if (texture.username) {\r\n                        capeLoadUrl += texture.username;\r\n                    } else if (texture.uuid) {\r\n                        capeLoadUrl += texture.uuid;\r\n                    } else {\r\n                        console.warn(\"Couldn't find a user to get a cape from\");\r\n                    }\r\n                    capeLoadUrl += \"/\" + texture.cape; // append type\r\n\r\n                    getJSON(capeLoadUrl, function (err, data) {\r\n                        if (err) return console.log(err);\r\n                        // Should be a single object of the requested type\r\n                        if (data.exists) {\r\n                            texture._capeType = data.type;\r\n                            skinRender._capeImage.src = data.imageUrls.base.full;\r\n                        }\r\n                    })\r\n                }\r\n            } else if (texture.capeUrl) {\r\n                skinRender._capeImage.src = texture.capeUrl;\r\n            } else if (texture.capeData) {\r\n                skinRender._capeImage.src = texture.capeData;\r\n            } else if (texture.mineskin) {\r\n                skinRender._capeImage.src = \"https://api.mineskin.org/render/texture/\" + texture.mineskin + \"/cape\";\r\n            }\r\n\r\n            slim = texture.slim;\r\n        } else {\r\n            throw new Error(\"Invalid texture value\")\r\n        }\r\n    };\r\n\r\n\r\n    resize(width, height) {\r\n        return this._resize(width, height);\r\n    };\r\n\r\n    reset() {\r\n        this._skinImage = null;\r\n        this._capeImage = null;\r\n\r\n        if (this._animId) {\r\n            cancelAnimationFrame(this._animId);\r\n        }\r\n        if (this._canvas) {\r\n            this._canvas.remove();\r\n        }\r\n    };\r\n\r\n    getPlayerModel() {\r\n        return this.playerModel;\r\n    };\r\n\r\n\r\n    getModelByName(name) {\r\n        return this._scene.getObjectByName(name, true);\r\n    };\r\n\r\n    toggleSkinPart(name, visible) {\r\n        this._scene.getObjectByName(name, true).visible = visible;\r\n    };\r\n\r\n\r\n}\r\n\r\nfunction createCube(texture, width, height, depth, textures, slim, name, transparent) {\r\n    let textureWidth = texture.image.width;\r\n    let textureHeight = texture.image.height;\r\n\r\n    let geometry = new three__WEBPACK_IMPORTED_MODULE_0__[\"BoxGeometry\"](width, height, depth);\r\n    let material = new three__WEBPACK_IMPORTED_MODULE_0__[\"MeshBasicMaterial\"]({\r\n        /*color: 0x00ff00,*/map: texture, transparent: transparent || false, alphaTest: 0.1, side: transparent ? three__WEBPACK_IMPORTED_MODULE_0__[\"DoubleSide\"] : three__WEBPACK_IMPORTED_MODULE_0__[\"FrontSide\"]//TODO: double sided not working properly\r\n    });\r\n\r\n    geometry.computeBoundingBox();\r\n\r\n    geometry.faceVertexUvs[0] = [];\r\n\r\n    let faceNames = [\"right\", \"left\", \"top\", \"bottom\", \"front\", \"back\"];\r\n    let faceUvs = [];\r\n    for (let i = 0; i < faceNames.length; i++) {\r\n        let face = textures[faceNames[i]];\r\n        if (faceNames[i] === \"back\") {\r\n            //     console.log(face)\r\n            // console.log(\"X: \" + (slim && face.sx ? face.sx : face.x))\r\n            // console.log(\"W: \" + (slim && face.sw ? face.sw : face.w))\r\n        }\r\n        let w = textureWidth;\r\n        let h = textureHeight;\r\n        let tx1 = ((slim && face.sx ? face.sx : face.x) / w);\r\n        let ty1 = (face.y / h);\r\n        let tx2 = (((slim && face.sx ? face.sx : face.x) + (slim && face.sw ? face.sw : face.w)) / w);\r\n        let ty2 = ((face.y + face.h) / h);\r\n\r\n        faceUvs[i] = [\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx1, ty2),\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx1, ty1),\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx2, ty1),\r\n            new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](tx2, ty2)\r\n        ];\r\n        // console.log(faceUvs[i])\r\n\r\n        let flipX = face.flipX;\r\n        let flipY = face.flipY;\r\n\r\n        let temp;\r\n        if (flipY) {\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[2];\r\n            faceUvs[i][1] = temp[3];\r\n            faceUvs[i][2] = temp[0];\r\n            faceUvs[i][3] = temp[1]\r\n        }\r\n        if (flipX) {//flip x\r\n            temp = faceUvs[i].slice(0);\r\n            faceUvs[i][0] = temp[3];\r\n            faceUvs[i][1] = temp[2];\r\n            faceUvs[i][2] = temp[1];\r\n            faceUvs[i][3] = temp[0]\r\n        }\r\n    }\r\n\r\n    let j = 0;\r\n    for (let i = 0; i < faceUvs.length; i++) {\r\n        geometry.faceVertexUvs[0][j] = [faceUvs[i][0], faceUvs[i][1], faceUvs[i][3]];\r\n        geometry.faceVertexUvs[0][j + 1] = [faceUvs[i][1], faceUvs[i][2], faceUvs[i][3]];\r\n        j += 2;\r\n    }\r\n    geometry.uvsNeedUpdate = true;\r\n\r\n    let cube = new three__WEBPACK_IMPORTED_MODULE_0__[\"Mesh\"](geometry, material);\r\n    cube.name = name;\r\n    // cube.position.set(x, y, z);\r\n    cube.castShadow = true;\r\n    cube.receiveShadow = false;\r\n\r\n    return cube;\r\n};\r\n\r\n\r\nfunction createPlayerModel(skinTexture, capeTexture, v, slim, capeType) {\r\n    console.log(\"capeType: \" + capeType);\r\n\r\n    let headGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    headGroup.name = \"headGroup\";\r\n    headGroup.position.x = 0;\r\n    headGroup.position.y = 28;\r\n    headGroup.position.z = 0;\r\n    headGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    let head = createCube(skinTexture,\r\n        8, 8, 8,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].head[v],\r\n        slim,\r\n        \"head\"\r\n    );\r\n    head.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    headGroup.add(head);\r\n    let hat = createCube(skinTexture,\r\n        8.504, 8.504, 8.504,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].hat[v],\r\n        slim,\r\n        \"hat\",\r\n        true\r\n    );\r\n    hat.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    headGroup.add(hat);\r\n\r\n    let bodyGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    bodyGroup.name = \"bodyGroup\";\r\n    bodyGroup.position.x = 0;\r\n    bodyGroup.position.y = 18;\r\n    bodyGroup.position.z = 0;\r\n    let body = createCube(skinTexture,\r\n        8, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].body[v],\r\n        slim,\r\n        \"body\"\r\n    );\r\n    bodyGroup.add(body);\r\n    if (v >= 1) {\r\n        let jacket = createCube(skinTexture,\r\n            8.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].jacket,\r\n            slim,\r\n            \"jacket\",\r\n            true\r\n        );\r\n        bodyGroup.add(jacket);\r\n    }\r\n\r\n    let leftArmGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    leftArmGroup.name = \"leftArmGroup\";\r\n    leftArmGroup.position.x = slim ? -5.5 : -6;\r\n    leftArmGroup.position.y = 18;\r\n    leftArmGroup.position.z = 0;\r\n    leftArmGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let leftArm = createCube(skinTexture,\r\n        slim ? 3 : 4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftArm[v],\r\n        slim,\r\n        \"leftArm\"\r\n    );\r\n    leftArm.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    leftArmGroup.add(leftArm);\r\n    if (v >= 1) {\r\n        let leftSleeve = createCube(skinTexture,\r\n            slim ? 3.504 : 4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftSleeve,\r\n            slim,\r\n            \"leftSleeve\",\r\n            true\r\n        );\r\n        leftSleeve.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        leftArmGroup.add(leftSleeve);\r\n    }\r\n\r\n    let rightArmGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    rightArmGroup.name = \"rightArmGroup\";\r\n    rightArmGroup.position.x = slim ? 5.5 : 6;\r\n    rightArmGroup.position.y = 18;\r\n    rightArmGroup.position.z = 0;\r\n    rightArmGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let rightArm = createCube(skinTexture,\r\n        slim ? 3 : 4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightArm[v],\r\n        slim,\r\n        \"rightArm\"\r\n    );\r\n    rightArm.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    rightArmGroup.add(rightArm);\r\n    if (v >= 1) {\r\n        let rightSleeve = createCube(skinTexture,\r\n            slim ? 3.504 : 4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightSleeve,\r\n            slim,\r\n            \"rightSleeve\",\r\n            true\r\n        );\r\n        rightSleeve.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        rightArmGroup.add(rightSleeve);\r\n    }\r\n\r\n    let leftLegGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    leftLegGroup.name = \"leftLegGroup\";\r\n    leftLegGroup.position.x = -2;\r\n    leftLegGroup.position.y = 6;\r\n    leftLegGroup.position.z = 0;\r\n    leftLegGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let leftLeg = createCube(skinTexture,\r\n        4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftLeg[v],\r\n        slim,\r\n        \"leftLeg\"\r\n    );\r\n    leftLeg.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    leftLegGroup.add(leftLeg);\r\n    if (v >= 1) {\r\n        let leftTrousers = createCube(skinTexture,\r\n            4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].leftTrousers,\r\n            slim,\r\n            \"leftTrousers\",\r\n            true\r\n        );\r\n        leftTrousers.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        leftLegGroup.add(leftTrousers);\r\n    }\r\n\r\n    let rightLegGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    rightLegGroup.name = \"rightLegGroup\";\r\n    rightLegGroup.position.x = 2;\r\n    rightLegGroup.position.y = 6;\r\n    rightLegGroup.position.z = 0;\r\n    rightLegGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 4);\r\n    let rightLeg = createCube(skinTexture,\r\n        4, 12, 4,\r\n        _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightLeg[v],\r\n        slim,\r\n        \"rightLeg\"\r\n    );\r\n    rightLeg.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n    rightLegGroup.add(rightLeg);\r\n    if (v >= 1) {\r\n        let rightTrousers = createCube(skinTexture,\r\n            4.504, 12.504, 4.504,\r\n            _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rightTrousers,\r\n            slim,\r\n            \"rightTrousers\",\r\n            true\r\n        );\r\n        rightTrousers.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -4);\r\n        rightLegGroup.add(rightTrousers);\r\n    }\r\n\r\n    let playerGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n    playerGroup.add(headGroup);\r\n    playerGroup.add(bodyGroup);\r\n    playerGroup.add(leftArmGroup);\r\n    playerGroup.add(rightArmGroup);\r\n    playerGroup.add(leftLegGroup);\r\n    playerGroup.add(rightLegGroup);\r\n\r\n    if (capeTexture) {\r\n        console.log(_texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\r\n        let capeTextureCoordinates = _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].capeRelative;\r\n        if (capeType === \"optifine\") {\r\n            capeTextureCoordinates = _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].capeOptifineRelative;\r\n        }\r\n        if (capeType === \"labymod\") {\r\n            capeTextureCoordinates = _texturePositions__WEBPACK_IMPORTED_MODULE_1__[\"default\"].capeLabymodRelative;\r\n        }\r\n        capeTextureCoordinates = JSON.parse(JSON.stringify(capeTextureCoordinates)); // bad clone to keep the below scaling from affecting everything\r\n\r\n        console.log(capeTextureCoordinates);\r\n\r\n        // Multiply coordinates by image dimensions\r\n        for (let cord in capeTextureCoordinates) {\r\n            capeTextureCoordinates[cord].x *= capeTexture.image.width;\r\n            capeTextureCoordinates[cord].w *= capeTexture.image.width;\r\n            capeTextureCoordinates[cord].y *= capeTexture.image.height;\r\n            capeTextureCoordinates[cord].h *= capeTexture.image.height;\r\n        }\r\n\r\n        console.log(capeTextureCoordinates);\r\n\r\n        let capeGroup = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n        capeGroup.name = \"capeGroup\";\r\n        capeGroup.position.x = 0;\r\n        capeGroup.position.y = 16;\r\n        capeGroup.position.z = -2.5;\r\n        capeGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), 8);\r\n        capeGroup.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1), 0.5);\r\n        let cape = createCube(capeTexture,\r\n            10, 16, 1,\r\n            capeTextureCoordinates,\r\n            false,\r\n            \"cape\");\r\n        cape.rotation.x = toRadians(10); // slight backward angle\r\n        cape.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 1, 0), -8);\r\n        cape.translateOnAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 1), -0.5);\r\n        cape.rotation.y = toRadians(180); // flip front&back to be correct\r\n        capeGroup.add(cape)\r\n\r\n        playerGroup.add(capeGroup);\r\n    }\r\n\r\n    return playerGroup;\r\n};\r\n\r\n// From https://soledadpenades.com/articles/three-js-tutorials/drawing-the-coordinate-axes/\r\nfunction buildAxes(length) {\r\n    let axes = new three__WEBPACK_IMPORTED_MODULE_0__[\"Object3D\"]();\r\n\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](length, 0, 0), 0xFF0000, false)); // +X\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](-length, 0, 0), 0xFF0000, true)); // -X\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, length, 0), 0x00FF00, false)); // +Y\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, -length, 0), 0x00FF00, true)); // -Y\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, length), 0x0000FF, false)); // +Z\r\n    axes.add(buildAxis(new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, 0), new three__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](0, 0, -length), 0x0000FF, true)); // -Z\r\n\r\n    return axes;\r\n\r\n};\r\n\r\nfunction buildAxis(src, dst, colorHex, dashed) {\r\n    let geom = new three__WEBPACK_IMPORTED_MODULE_0__[\"Geometry\"](),\r\n        mat;\r\n\r\n    if (dashed) {\r\n        mat = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineDashedMaterial\"]({linewidth: 3, color: colorHex, dashSize: 3, gapSize: 3});\r\n    } else {\r\n        mat = new three__WEBPACK_IMPORTED_MODULE_0__[\"LineBasicMaterial\"]({linewidth: 3, color: colorHex});\r\n    }\r\n\r\n    geom.vertices.push(src.clone());\r\n    geom.vertices.push(dst.clone());\r\n    geom.computeLineDistances(); // This one is SUPER important, otherwise dashed lines will appear as simple plain lines\r\n\r\n    return new three__WEBPACK_IMPORTED_MODULE_0__[\"Line\"](geom, mat, three__WEBPACK_IMPORTED_MODULE_0__[\"LinePieces\"]);\r\n};\r\n\r\nfunction toRadians(angle) {\r\n    return angle * (Math.PI / 180);\r\n}\r\n\r\nfunction getJSON(url, callback) {\r\n    let xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url, true);\r\n    xhr.responseType = 'json';\r\n    xhr.onload = function () {\r\n        let status = xhr.status;\r\n        let r = xhr.response || xhr.responseText;\r\n        if (typeof r === \"string\") {\r\n            r = JSON.parse(r);\r\n        }\r\n        if (status === 200) {\r\n            callback(null, r);\r\n        } else {\r\n            callback(xhr.statusText, r);\r\n        }\r\n    };\r\n    xhr.send();\r\n}\r\n\r\nif (typeof window !== \"undefined\")\r\n    window.SkinRender = SkinRender;\r\nif (typeof global !== \"undefined\")\r\n    global.SkinRender = SkinRender;\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (SkinRender);\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/skin/index.js?");

/***/ }),

/***/ "./src/skin/texturePositions.js":
/*!**************************************!*\
  !*** ./src/skin/texturePositions.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\r\n * Texture positions for Minecraft's player model\r\n */\r\nconst texturePositions =  {\r\n    head: [\r\n        {// 64x32\r\n            left: {\r\n                x: 0,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 8,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 16,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 24,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 8,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            bottom: {\r\n                x: 16,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 0,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 8,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 16,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 24,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 8,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            bottom: {\r\n                x: 16,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        }\r\n    ],\r\n    body: [\r\n        {// 64x32\r\n            left: {\r\n                x: 16,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 0,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            right: {\r\n                x: 28,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            back: {\r\n                x: 32,\r\n                y: 0,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 12,\r\n                w: 8,\r\n                h: 4\r\n            },\r\n            bottom: {\r\n                x: 28,\r\n                y: 12,\r\n                w: 8,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 16,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 32,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            right: {\r\n                x: 28,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 32,\r\n                y: 32,\r\n                w: 8,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 44,\r\n                w: 8,\r\n                h: 4\r\n            },\r\n            bottom: {\r\n                x: 28,\r\n                y: 44,\r\n                w: 8,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    rightArm: [\r\n        {// 64x32 - same as rightArm\r\n            left: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 32,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 36,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 39,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 43,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 36,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 40,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                sx: 39,\r\n                sw: 3,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    leftArm: [\r\n        {// 64x32 - same as leftArm\r\n            left: {\r\n                x: 40,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 40,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 44,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 47,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 52,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                sx: 51,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 44,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                sw: 3,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                sx: 47,\r\n                sw: 3,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    rightLeg: [\r\n        {// 64x32 - same as rightLeg\r\n            left: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 16,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 20,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 24,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 28,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 20,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 24,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    leftLeg: [\r\n        {// 64x32 - same as leftLeg\r\n            left: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 0,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: true\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 12,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: true,\r\n                flipY: true\r\n            }\r\n        },\r\n        {// 64x64\r\n            left: {\r\n                x: 0,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            front: {\r\n                x: 4,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            right: {\r\n                x: 8,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            back: {\r\n                x: 12,\r\n                y: 32,\r\n                w: 4,\r\n                h: 12,\r\n                flipX: false\r\n            },\r\n            top: {\r\n                x: 4,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 8,\r\n                y: 44,\r\n                w: 4,\r\n                h: 4,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n\r\n    hat: [\r\n        { // 64x32\r\n            left: {\r\n                x: 32,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            front: {\r\n                x: 40,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            back: {\r\n                x: 56,\r\n                y: 16,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 40,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 24,\r\n                w: 8,\r\n                h: 8,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        },\r\n        { // 64x64\r\n            left: {\r\n                x: 32,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            front: {\r\n                x: 40,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            right: {\r\n                x: 48,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            back: {\r\n                x: 56,\r\n                y: 48,\r\n                w: 8,\r\n                h: 8\r\n            },\r\n            top: {\r\n                x: 40,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8,\r\n                flipX: false\r\n            },\r\n            bottom: {\r\n                x: 48,\r\n                y: 56,\r\n                w: 8,\r\n                h: 8,\r\n                flipY: true,\r\n                flipX: true\r\n            }\r\n        }\r\n    ],\r\n    jacket: {\r\n        left: {\r\n            x: 16,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 20,\r\n            y: 16,\r\n            w: 8,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 28,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 32,\r\n            y: 16,\r\n            w: 8,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 20,\r\n            y: 28,\r\n            w: 8,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 28,\r\n            y: 28,\r\n            w: 8,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    rightSleeve: {\r\n        left: {\r\n            x: 48,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 52,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sw: 3\r\n        },\r\n        right: {\r\n            x: 56,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 55\r\n        },\r\n        back: {\r\n            x: 60,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 59,\r\n            sw: 3\r\n        },\r\n        top: {\r\n            x: 52,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            sw: 3\r\n        },\r\n        bottom: {\r\n            x: 56,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            sx: 55,\r\n            sw: 3,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    leftSleeve: {\r\n        left: {\r\n            x: 40,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 44,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sw: 3\r\n        },\r\n        right: {\r\n            x: 48,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 47\r\n        },\r\n        back: {\r\n            x: 52,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12,\r\n            sx: 51,\r\n            sw: 3\r\n        },\r\n        top: {\r\n            x: 44,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            sw: 3\r\n        },\r\n        bottom: {\r\n            x: 48,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            sx: 47,\r\n            sw: 3,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    rightTrousers: {\r\n        left: {\r\n            x: 0,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 4,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 8,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 0,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 4,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 8,\r\n            y: 12,\r\n            w: 4,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n    leftTrousers: {\r\n        left: {\r\n            x: 0,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        front: {\r\n            x: 4,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        right: {\r\n            x: 8,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 16,\r\n            w: 4,\r\n            h: 12\r\n        },\r\n        top: {\r\n            x: 4,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4\r\n        },\r\n        bottom: {\r\n            x: 8,\r\n            y: 28,\r\n            w: 4,\r\n            h: 4,\r\n            flipY: true,\r\n            flipX: true\r\n        }\r\n    },\r\n\r\n    cape: {\r\n        right: {\r\n            x: 0,\r\n            y: 5,\r\n            w: 1,\r\n            h: 16\r\n        },\r\n        front: {\r\n            x: 1,\r\n            y: 5,\r\n            w: 10,\r\n            h: 16\r\n        },\r\n        left: {\r\n            x: 11,\r\n            y: 5,\r\n            w: 1,\r\n            h: 16\r\n        },\r\n        back: {\r\n            x: 12,\r\n            y: 5,\r\n            w: 10,\r\n            h: 16\r\n        },\r\n        top: {\r\n            x: 1,\r\n            y: 21,\r\n            w: 10,\r\n            h: 1\r\n        },\r\n        bottom: {\r\n            x: 11,\r\n            y: 21,\r\n            w: 10,\r\n            h: 1\r\n        }\r\n    },\r\n    capeRelative: { // Cape coordinates relative to image dimensions, starting bottom-left\r\n        right: {\r\n            x: 0,\r\n            y: 15/32,\r\n            w: 1/64,\r\n            h: 16/32\r\n        },\r\n        front: {\r\n            x: 1/64,\r\n            y: 15/32,\r\n            w: 10/64,\r\n            h: 16/32\r\n        },\r\n        left: {\r\n            x: 11/64,\r\n            y: 15/32,\r\n            w: 1/64,\r\n            h: 16/32\r\n        },\r\n        back: {\r\n            x: 12/64,\r\n            y: 15/32,\r\n            w: 10/64,\r\n            h: 16/32\r\n        },\r\n        top: {\r\n            x: 1/64,\r\n            y: 31/32,\r\n            w: 10/64,\r\n            h: 1/32\r\n        },\r\n        bottom: {\r\n            x: 11/64,\r\n            y: 31/32,\r\n            w: 10/64,\r\n            h: 1/32\r\n        }\r\n    },\r\n    capeOptifineRelative: {\r\n        right: {\r\n            x: 0,\r\n            y: 10/44,\r\n            w: 2/92,\r\n            h: 32/44\r\n        },\r\n        front: {\r\n            x: 2/92,\r\n            y: 10/44,\r\n            w: 20/92,\r\n            h: 32/44\r\n        },\r\n        left: {\r\n            x: 22/92,\r\n            y: 10/44,\r\n            w: 2/92,\r\n            h: 32/44\r\n        },\r\n        back: {\r\n            x: 24/92,\r\n            y: 10/44,\r\n            w: 20/92,\r\n            h: 32/44\r\n        },\r\n        top: {\r\n            x: 2/92,\r\n            y: 42/44,\r\n            w: 20/92,\r\n            h: 2/44\r\n        },\r\n        bottom: {\r\n            x: 22/92,\r\n            y: 42/44,\r\n            w: 20/92,\r\n            h: 2/44\r\n        }\r\n    },\r\n    capeOptifine: {\r\n        right: {\r\n            x: 0,\r\n            y: 10,\r\n            w: 2,\r\n            h: 32\r\n        },\r\n        front: {\r\n            x: 2,\r\n            y: 10,\r\n            w: 20,\r\n            h: 32\r\n        },\r\n        left: {\r\n            x: 22,\r\n            y: 10,\r\n            w: 2,\r\n            h: 32\r\n        },\r\n        back: {\r\n            x: 24,\r\n            y: 10,\r\n            w: 20,\r\n            h: 32\r\n        },\r\n        top: {\r\n            x: 2,\r\n            y: 42,\r\n            w: 20,\r\n            h: 2\r\n        },\r\n        bottom: {\r\n            x: 22,\r\n            y: 42,\r\n            w: 20,\r\n            h: 2\r\n        }\r\n    },\r\n    capeLabymodRelative: {\r\n        right: {\r\n            x: 0,\r\n            y: 0,\r\n            w: 1/22,\r\n            h: 16/17\r\n        },\r\n        front: {\r\n            x: 1/22,\r\n            y: 0,\r\n            w: 10/22,\r\n            h: 16/17\r\n        },\r\n        left: {\r\n            x: 11/22,\r\n            y: 0,\r\n            w: 1/22,\r\n            h: 16/17\r\n        },\r\n        back: {\r\n            x: 12/22,\r\n            y: 0,\r\n            w: 10/22,\r\n            h: 16/17\r\n        },\r\n        top: {\r\n            x: 1/22,\r\n            y: 16/17,\r\n            w: 10/22,\r\n            h: 1/17\r\n        },\r\n        bottom: {\r\n            x: 11/22,\r\n            y: 16/17,\r\n            w: 10/22,\r\n            h: 1/17\r\n        }\r\n    },\r\n};\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (texturePositions);\r\n\n\n//# sourceURL=webpack:///./src/skin/texturePositions.js?");

/***/ }),

/***/ "jquery":
/*!*************************!*\
  !*** external "jQuery" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = jQuery;\n\n//# sourceURL=webpack:///external_%22jQuery%22?");

/***/ }),

/***/ "three":
/*!************************!*\
  !*** external "THREE" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = THREE;\n\n//# sourceURL=webpack:///external_%22THREE%22?");

/***/ })

/******/ });